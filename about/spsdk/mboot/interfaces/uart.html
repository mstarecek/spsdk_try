<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.mboot.interfaces.uart API documentation</title>
<meta name="description" content="Module for serial communication with a target device using MBoot protocol." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.mboot.interfaces.uart</code></h1>
</header>
<section id="section-intro">
<p>Module for serial communication with a target device using MBoot protocol.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2016-2018 Martin Olejar
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Module for serial communication with a target device using MBoot protocol.&#34;&#34;&#34;

import logging
import struct
from typing import List, Optional, Tuple, Union

import construct
from crccheck.crc import Crc16
from serial import Serial, SerialException
from serial.tools.list_ports import comports

from spsdk.mboot.commands import CmdPacket, CmdResponse, parse_cmd_response
from spsdk.utils.easy_enum import Enum

from .base import Interface

logger = logging.getLogger(&#34;MBOOT:UART&#34;)


def scan_uart(port: str = None, baudrate: int = 57600, timeout: int = 5000) -&gt; List[Interface]:
    &#34;&#34;&#34;Scan connected serial ports.

    Returns list of serial ports with devices that respond to PING command.
    If &#39;port&#39; is specified, only that serial port is checked
    If no devices are found, return an empty list.

    :param port: name of preferred serial port, defaults to None
    :param baudrate: speed of the UART interface, defaults to 56700
    :param timeout: timeout in milliseconds
    :return: list of interfaces responding to the PING command
    :rtype: List[spsdk.mboot.interfaces.base.Interface]
    &#34;&#34;&#34;
    if port:
        interface = _check_port(port, baudrate, timeout)
        return [interface] if interface else []
    all_ports = [_check_port(comport.device, baudrate, timeout) for comport in comports(include_links=True)]
    return list(filter(None, all_ports))


def _check_port(port: str, baudrate: int, timeout: int) -&gt; Optional[Interface]:
    &#34;&#34;&#34;Check if device on comport &#39;port&#39; responds to PING command.

    :param port: name of port to check
    :param baudrate: speed of the UART interface, defaults to 56700
    :param timeout: timeout in milliseconds
    :return: None if device doesn&#39;t respond to PING, instance of Interface if it does
    :rtype: Optional[Interface]
    &#34;&#34;&#34;
    try:
        interface = Uart(port=port, baudrate=baudrate, timeout=timeout)
        interface.open()
        interface.ping()
        interface.close()
        return interface
    except (AssertionError, SerialException) as e:
        logger.error(str(e))
        return None


def calc_crc(data: bytes) -&gt; int:
    &#34;&#34;&#34;Calculate CRC from the data.

    :param data: data to calculate CRC from
    :type data: bytes
    :return: calculated CRC
    :rtype: int
    &#34;&#34;&#34;
    return Crc16.calc(data)


def to_int(data: bytes, little_endian: bool = True) -&gt; int:
    &#34;&#34;&#34;Convert bytes into single integer.

    :param data: bytes to convert
    :type data: bytes
    :param little_endian: indicate byte ordering in data, defaults to True
    :type little_endian: bool, optional
    :return: integer
    :rtype: int
    &#34;&#34;&#34;
    byte_order = &#39;little&#39; if little_endian else &#39;big&#39;
    return int.from_bytes(data, byteorder=byte_order)

#: Version of protocol used in serial communication
PROTOCOL_VERSION = construct.Struct(
    &#39;bugfix&#39; / construct.Int8ul,
    &#39;minor&#39; / construct.Int8ul,
    &#39;major&#39; / construct.Int8ul,
    &#39;name&#39; / construct.Int8ul
)

#: Type of frame used for pig response
PING_RESPONSE = construct.Struct(
    &#39;version&#39; / PROTOCOL_VERSION,
    &#39;options&#39; / construct.Int16ul,
    &#39;crc&#39; / construct.Int16ul
)


########################################################################################################################
# UART Interface Class
########################################################################################################################
class FPType(Enum):
    &#34;&#34;&#34;Type of frames used in serial communication.&#34;&#34;&#34;

    ACK = 0xA1
    NACK = 0xA2
    ABORT = 0xA3
    CMD = 0xA4
    DATA = 0xA5
    PING = 0xA6
    PINGR = 0xA7


class Uart(Interface):
    &#34;&#34;&#34;UART interface.&#34;&#34;&#34;

    FRAME_START_BYTE = 0x5A

    @property
    def is_opened(self) -&gt; bool:
        &#34;&#34;&#34;Return True if device is open, False othervise.&#34;&#34;&#34;
        return self.device.is_open

    @property
    def need_data_split(self) -&gt; bool:
        &#34;&#34;&#34;Indicates whether device need to split data into smaller chunks.&#34;&#34;&#34;
        return True

    def __init__(self, port: str = None, baudrate: int = 57600, timeout: int = 5000) -&gt; None:
        &#34;&#34;&#34;Initialize the UART interface.

        :param port: name of the serial port, defaults to None
        :type port: str, optional
        :param baudrate: baudrate of the serial port, defaults to 57600
        :type baudrate: int, optional
        :param timeout: read/write timeout in milliseconds, defaults to 2000
        :type timeout: int, optional
        &#34;&#34;&#34;
        super().__init__()
        self.device = Serial(port=port, timeout=timeout // 1000, baudrate=baudrate)
        self.close()
        self.protocol_version = None
        self.options = None

    def open(self) -&gt; None:
        &#34;&#34;&#34;Open the UART interface.&#34;&#34;&#34;
        self.device.open()
        self.ping()

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the UART interface.&#34;&#34;&#34;
        self.device.close()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return information about the UART interface.

        :return: Description of UART interface
        :rtype: str
        &#34;&#34;&#34;
        return self.device.port

    def read(self) -&gt; Union[CmdResponse, bytes]:
        &#34;&#34;&#34;Read data from device.

        :return: read data
        :rtype: Union[spsdk.mboot.commands.CmdResponse, bytes]
        &#34;&#34;&#34;
        _, frame_type = self._read_frame_header()
        length = to_int(self._read(2))
        crc = to_int(self._read(2))
        data = self._read(length)
        self._send_ack()
        calculated_crc = self._calc_frame_crc(data, frame_type)
        assert crc == calculated_crc, &#34;Received invalid CRC&#34;
        if frame_type == FPType.CMD:
            return parse_cmd_response(data)
        return data

    def write(self, packet: Union[CmdPacket, bytes]) -&gt; None:
        &#34;&#34;&#34;Write data to the device; data might be in form of &#39;CmdPacket&#39; or bytes.

        :param packet: Packet to send
        :type packet: Union[spsdk.mboot.commands.CmdPacket, bytes]
        &#34;&#34;&#34;
        if isinstance(packet, CmdPacket):
            data = packet.to_bytes(padding=False)
            frame_type = FPType.CMD
        if isinstance(packet, (bytes, bytearray)):
            data = packet
            frame_type = FPType.DATA
        frame = self._create_frame(data, frame_type)
        self._send_frame(frame, wait_for_ack=True)

    def _read(self, length: int) -&gt; bytes:
        &#34;&#34;&#34;Read &#39;length&#39; amount for bytes from device.

        :param length: Number of bytes to read
        :type length: int
        :return: Data read from the device
        :rtype: bytes
        &#34;&#34;&#34;
        data = self.device.read(length)
        logger.debug(f&#34;&lt;{&#39; &#39;.join(f&#39;{b:02x}&#39; for b in data)}&gt;&#34;)
        return data

    def _write(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;Send data to device.

        :param data: Data to send
        :type data: bytes
        &#34;&#34;&#34;
        logger.debug(f&#34;[{&#39; &#39;.join(f&#39;{b:02x}&#39; for b in data)}]&#34;)
        self.device.reset_input_buffer()
        self.device.reset_output_buffer()
        self.device.write(data)
        self.device.flush()

    def _send_ack(self) -&gt; None:
        ack_frame = struct.pack(&#39;&lt;BB&#39;, self.FRAME_START_BYTE, FPType.ACK)
        self._send_frame(ack_frame, wait_for_ack=False)

    def _send_frame(self, frame: bytes, wait_for_ack: bool = True) -&gt; None:
        &#34;&#34;&#34;Send a frame to UART.

        :param frame: Data to send
        :type frame: bytes
        :param wait_for_ack: Wait for ACK frame from device, defaults to True
        :type wait_for_ack: bool, optional
        &#34;&#34;&#34;
        self._write(frame)
        if wait_for_ack:
            self._read_frame_header(FPType.ACK)

    def _read_frame_header(self, expected_frame_type: int = None) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Read frame header and frame type. Return them as tuple of integers.

        :param expected_frame_type: Check if the frame_type is exactly as expected
        :return: Tuple of integers representing frame header and frame type
        :raises AssertionError: Unexpected frame header or frame type (if specified)
        &#34;&#34;&#34;
        header = to_int(self._read(1))
        assert header == self.FRAME_START_BYTE, \
            f&#34;Received invalid frame header &#39;{header:#X}&#39; expected &#39;{self.FRAME_START_BYTE:#X}&#39;&#34;
        frame_type = to_int(self._read(1))
        if expected_frame_type:
            assert frame_type == expected_frame_type, \
                f&#34;received invalid ACK &#39;{frame_type:#X}&#39; expected &#39;{expected_frame_type:#X}&#39;&#34;
        return header, frame_type

    def _create_frame(self, data: bytes, frame_type: int) -&gt; bytes:
        &#34;&#34;&#34;Encapsulate data into frame.&#34;&#34;&#34;
        crc = self._calc_frame_crc(data, frame_type)
        frame = struct.pack(
            f&#39;&lt;BBHH{len(data)}B&#39;,
            self.FRAME_START_BYTE, frame_type, len(data), crc, *data)
        return frame

    def _calc_frame_crc(self, data: bytes, frame_type: int) -&gt; int:
        &#34;&#34;&#34;Calculate the CRC of a frame.

        :param data: frame data
        :type data: bytes
        :param frame_type: frame type
        :type frame_type: int
        :return: calculated CRC
        :rtype: int
        &#34;&#34;&#34;
        crc_data = struct.pack(
            f&#39;&lt;BBH{len(data)}B&#39;,
            self.FRAME_START_BYTE, frame_type, len(data), *data)
        return calc_crc(crc_data)

    def ping(self) -&gt; None:
        &#34;&#34;&#34;Ping the target device, retreive protocol version.

        :raises AssertionError: If the target device doesn&#39;t respond to ping
        &#34;&#34;&#34;
        ping = struct.pack(&#39;&lt;BB&#39;, self.FRAME_START_BYTE, FPType.PING)
        self._send_frame(ping, wait_for_ack=False)

        header, frame_type = self._read_frame_header(FPType.PINGR)

        response_data = self._read(8)
        assert response_data, f&#34;Failed to receive ping response&#34;
        response = PING_RESPONSE.parse(response_data)

        # ping response has different crc computation than the other responses
        # that&#39;s why we can&#39;t use calc_frame_crc method
        # crc data for ping excludes the last 2B of response data, which holds the CRC from device
        crc_data = struct.pack(f&#39;&lt;BB{len(response_data) -2}B&#39;, header, frame_type, *response_data[:-2])
        crc = calc_crc(crc_data)
        assert crc == response.crc, \
            f&#34;Received CRC doesn&#39;t match&#34;

        self.protocol_version = response.version
        self.options = response.options</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spsdk.mboot.interfaces.uart.calc_crc"><code class="name flex">
<span>def <span class="ident">calc_crc</span></span>(<span>data: bytes) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CRC from the data.</p>
<p>:param data: data to calculate CRC from
:type data: bytes
:return: calculated CRC
:rtype: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_crc(data: bytes) -&gt; int:
    &#34;&#34;&#34;Calculate CRC from the data.

    :param data: data to calculate CRC from
    :type data: bytes
    :return: calculated CRC
    :rtype: int
    &#34;&#34;&#34;
    return Crc16.calc(data)</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.scan_uart"><code class="name flex">
<span>def <span class="ident">scan_uart</span></span>(<span>port: str = None, baudrate: int = 57600, timeout: int = 5000) ‑> List[<a title="spsdk.mboot.interfaces.base.Interface" href="base.html#spsdk.mboot.interfaces.base.Interface">Interface</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Scan connected serial ports.</p>
<p>Returns list of serial ports with devices that respond to PING command.
If 'port' is specified, only that serial port is checked
If no devices are found, return an empty list.</p>
<p>:param port: name of preferred serial port, defaults to None
:param baudrate: speed of the UART interface, defaults to 56700
:param timeout: timeout in milliseconds
:return: list of interfaces responding to the PING command
:rtype: List[spsdk.mboot.interfaces.base.Interface]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_uart(port: str = None, baudrate: int = 57600, timeout: int = 5000) -&gt; List[Interface]:
    &#34;&#34;&#34;Scan connected serial ports.

    Returns list of serial ports with devices that respond to PING command.
    If &#39;port&#39; is specified, only that serial port is checked
    If no devices are found, return an empty list.

    :param port: name of preferred serial port, defaults to None
    :param baudrate: speed of the UART interface, defaults to 56700
    :param timeout: timeout in milliseconds
    :return: list of interfaces responding to the PING command
    :rtype: List[spsdk.mboot.interfaces.base.Interface]
    &#34;&#34;&#34;
    if port:
        interface = _check_port(port, baudrate, timeout)
        return [interface] if interface else []
    all_ports = [_check_port(comport.device, baudrate, timeout) for comport in comports(include_links=True)]
    return list(filter(None, all_ports))</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.to_int"><code class="name flex">
<span>def <span class="ident">to_int</span></span>(<span>data: bytes, little_endian: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Convert bytes into single integer.</p>
<p>:param data: bytes to convert
:type data: bytes
:param little_endian: indicate byte ordering in data, defaults to True
:type little_endian: bool, optional
:return: integer
:rtype: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_int(data: bytes, little_endian: bool = True) -&gt; int:
    &#34;&#34;&#34;Convert bytes into single integer.

    :param data: bytes to convert
    :type data: bytes
    :param little_endian: indicate byte ordering in data, defaults to True
    :type little_endian: bool, optional
    :return: integer
    :rtype: int
    &#34;&#34;&#34;
    byte_order = &#39;little&#39; if little_endian else &#39;big&#39;
    return int.from_bytes(data, byteorder=byte_order)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.mboot.interfaces.uart.FPType"><code class="flex name class">
<span>class <span class="ident">FPType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Type of frames used in serial communication.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FPType(Enum):
    &#34;&#34;&#34;Type of frames used in serial communication.&#34;&#34;&#34;

    ACK = 0xA1
    NACK = 0xA2
    ABORT = 0xA3
    CMD = 0xA4
    DATA = 0xA5
    PING = 0xA6
    PINGR = 0xA7</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.mboot.interfaces.uart.FPType.ABORT"><code class="name">var <span class="ident">ABORT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.mboot.interfaces.uart.FPType.ACK"><code class="name">var <span class="ident">ACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.mboot.interfaces.uart.FPType.CMD"><code class="name">var <span class="ident">CMD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.mboot.interfaces.uart.FPType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.mboot.interfaces.uart.FPType.NACK"><code class="name">var <span class="ident">NACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.mboot.interfaces.uart.FPType.PING"><code class="name">var <span class="ident">PING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.mboot.interfaces.uart.FPType.PINGR"><code class="name">var <span class="ident">PINGR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.mboot.interfaces.uart.Uart"><code class="flex name class">
<span>class <span class="ident">Uart</span></span>
<span>(</span><span>port: str = None, baudrate: int = 57600, timeout: int = 5000)</span>
</code></dt>
<dd>
<div class="desc"><p>UART interface.</p>
<p>Initialize the UART interface.</p>
<p>:param port: name of the serial port, defaults to None
:type port: str, optional
:param baudrate: baudrate of the serial port, defaults to 57600
:type baudrate: int, optional
:param timeout: read/write timeout in milliseconds, defaults to 2000
:type timeout: int, optional</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Uart(Interface):
    &#34;&#34;&#34;UART interface.&#34;&#34;&#34;

    FRAME_START_BYTE = 0x5A

    @property
    def is_opened(self) -&gt; bool:
        &#34;&#34;&#34;Return True if device is open, False othervise.&#34;&#34;&#34;
        return self.device.is_open

    @property
    def need_data_split(self) -&gt; bool:
        &#34;&#34;&#34;Indicates whether device need to split data into smaller chunks.&#34;&#34;&#34;
        return True

    def __init__(self, port: str = None, baudrate: int = 57600, timeout: int = 5000) -&gt; None:
        &#34;&#34;&#34;Initialize the UART interface.

        :param port: name of the serial port, defaults to None
        :type port: str, optional
        :param baudrate: baudrate of the serial port, defaults to 57600
        :type baudrate: int, optional
        :param timeout: read/write timeout in milliseconds, defaults to 2000
        :type timeout: int, optional
        &#34;&#34;&#34;
        super().__init__()
        self.device = Serial(port=port, timeout=timeout // 1000, baudrate=baudrate)
        self.close()
        self.protocol_version = None
        self.options = None

    def open(self) -&gt; None:
        &#34;&#34;&#34;Open the UART interface.&#34;&#34;&#34;
        self.device.open()
        self.ping()

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the UART interface.&#34;&#34;&#34;
        self.device.close()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return information about the UART interface.

        :return: Description of UART interface
        :rtype: str
        &#34;&#34;&#34;
        return self.device.port

    def read(self) -&gt; Union[CmdResponse, bytes]:
        &#34;&#34;&#34;Read data from device.

        :return: read data
        :rtype: Union[spsdk.mboot.commands.CmdResponse, bytes]
        &#34;&#34;&#34;
        _, frame_type = self._read_frame_header()
        length = to_int(self._read(2))
        crc = to_int(self._read(2))
        data = self._read(length)
        self._send_ack()
        calculated_crc = self._calc_frame_crc(data, frame_type)
        assert crc == calculated_crc, &#34;Received invalid CRC&#34;
        if frame_type == FPType.CMD:
            return parse_cmd_response(data)
        return data

    def write(self, packet: Union[CmdPacket, bytes]) -&gt; None:
        &#34;&#34;&#34;Write data to the device; data might be in form of &#39;CmdPacket&#39; or bytes.

        :param packet: Packet to send
        :type packet: Union[spsdk.mboot.commands.CmdPacket, bytes]
        &#34;&#34;&#34;
        if isinstance(packet, CmdPacket):
            data = packet.to_bytes(padding=False)
            frame_type = FPType.CMD
        if isinstance(packet, (bytes, bytearray)):
            data = packet
            frame_type = FPType.DATA
        frame = self._create_frame(data, frame_type)
        self._send_frame(frame, wait_for_ack=True)

    def _read(self, length: int) -&gt; bytes:
        &#34;&#34;&#34;Read &#39;length&#39; amount for bytes from device.

        :param length: Number of bytes to read
        :type length: int
        :return: Data read from the device
        :rtype: bytes
        &#34;&#34;&#34;
        data = self.device.read(length)
        logger.debug(f&#34;&lt;{&#39; &#39;.join(f&#39;{b:02x}&#39; for b in data)}&gt;&#34;)
        return data

    def _write(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;Send data to device.

        :param data: Data to send
        :type data: bytes
        &#34;&#34;&#34;
        logger.debug(f&#34;[{&#39; &#39;.join(f&#39;{b:02x}&#39; for b in data)}]&#34;)
        self.device.reset_input_buffer()
        self.device.reset_output_buffer()
        self.device.write(data)
        self.device.flush()

    def _send_ack(self) -&gt; None:
        ack_frame = struct.pack(&#39;&lt;BB&#39;, self.FRAME_START_BYTE, FPType.ACK)
        self._send_frame(ack_frame, wait_for_ack=False)

    def _send_frame(self, frame: bytes, wait_for_ack: bool = True) -&gt; None:
        &#34;&#34;&#34;Send a frame to UART.

        :param frame: Data to send
        :type frame: bytes
        :param wait_for_ack: Wait for ACK frame from device, defaults to True
        :type wait_for_ack: bool, optional
        &#34;&#34;&#34;
        self._write(frame)
        if wait_for_ack:
            self._read_frame_header(FPType.ACK)

    def _read_frame_header(self, expected_frame_type: int = None) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Read frame header and frame type. Return them as tuple of integers.

        :param expected_frame_type: Check if the frame_type is exactly as expected
        :return: Tuple of integers representing frame header and frame type
        :raises AssertionError: Unexpected frame header or frame type (if specified)
        &#34;&#34;&#34;
        header = to_int(self._read(1))
        assert header == self.FRAME_START_BYTE, \
            f&#34;Received invalid frame header &#39;{header:#X}&#39; expected &#39;{self.FRAME_START_BYTE:#X}&#39;&#34;
        frame_type = to_int(self._read(1))
        if expected_frame_type:
            assert frame_type == expected_frame_type, \
                f&#34;received invalid ACK &#39;{frame_type:#X}&#39; expected &#39;{expected_frame_type:#X}&#39;&#34;
        return header, frame_type

    def _create_frame(self, data: bytes, frame_type: int) -&gt; bytes:
        &#34;&#34;&#34;Encapsulate data into frame.&#34;&#34;&#34;
        crc = self._calc_frame_crc(data, frame_type)
        frame = struct.pack(
            f&#39;&lt;BBHH{len(data)}B&#39;,
            self.FRAME_START_BYTE, frame_type, len(data), crc, *data)
        return frame

    def _calc_frame_crc(self, data: bytes, frame_type: int) -&gt; int:
        &#34;&#34;&#34;Calculate the CRC of a frame.

        :param data: frame data
        :type data: bytes
        :param frame_type: frame type
        :type frame_type: int
        :return: calculated CRC
        :rtype: int
        &#34;&#34;&#34;
        crc_data = struct.pack(
            f&#39;&lt;BBH{len(data)}B&#39;,
            self.FRAME_START_BYTE, frame_type, len(data), *data)
        return calc_crc(crc_data)

    def ping(self) -&gt; None:
        &#34;&#34;&#34;Ping the target device, retreive protocol version.

        :raises AssertionError: If the target device doesn&#39;t respond to ping
        &#34;&#34;&#34;
        ping = struct.pack(&#39;&lt;BB&#39;, self.FRAME_START_BYTE, FPType.PING)
        self._send_frame(ping, wait_for_ack=False)

        header, frame_type = self._read_frame_header(FPType.PINGR)

        response_data = self._read(8)
        assert response_data, f&#34;Failed to receive ping response&#34;
        response = PING_RESPONSE.parse(response_data)

        # ping response has different crc computation than the other responses
        # that&#39;s why we can&#39;t use calc_frame_crc method
        # crc data for ping excludes the last 2B of response data, which holds the CRC from device
        crc_data = struct.pack(f&#39;&lt;BB{len(response_data) -2}B&#39;, header, frame_type, *response_data[:-2])
        crc = calc_crc(crc_data)
        assert crc == response.crc, \
            f&#34;Received CRC doesn&#39;t match&#34;

        self.protocol_version = response.version
        self.options = response.options</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.mboot.interfaces.base.Interface" href="base.html#spsdk.mboot.interfaces.base.Interface">Interface</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.mboot.interfaces.uart.Uart.FRAME_START_BYTE"><code class="name">var <span class="ident">FRAME_START_BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.mboot.interfaces.uart.Uart.is_opened"><code class="name">var <span class="ident">is_opened</span> : bool</code></dt>
<dd>
<div class="desc"><p>Return True if device is open, False othervise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_opened(self) -&gt; bool:
    &#34;&#34;&#34;Return True if device is open, False othervise.&#34;&#34;&#34;
    return self.device.is_open</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.mboot.interfaces.uart.Uart.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close the UART interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;Close the UART interface.&#34;&#34;&#34;
    self.device.close()</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.Uart.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return information about the UART interface.</p>
<p>:return: Description of UART interface
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return information about the UART interface.

    :return: Description of UART interface
    :rtype: str
    &#34;&#34;&#34;
    return self.device.port</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.Uart.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open the UART interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;Open the UART interface.&#34;&#34;&#34;
    self.device.open()
    self.ping()</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.Uart.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Ping the target device, retreive protocol version.</p>
<p>:raises AssertionError: If the target device doesn't respond to ping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self) -&gt; None:
    &#34;&#34;&#34;Ping the target device, retreive protocol version.

    :raises AssertionError: If the target device doesn&#39;t respond to ping
    &#34;&#34;&#34;
    ping = struct.pack(&#39;&lt;BB&#39;, self.FRAME_START_BYTE, FPType.PING)
    self._send_frame(ping, wait_for_ack=False)

    header, frame_type = self._read_frame_header(FPType.PINGR)

    response_data = self._read(8)
    assert response_data, f&#34;Failed to receive ping response&#34;
    response = PING_RESPONSE.parse(response_data)

    # ping response has different crc computation than the other responses
    # that&#39;s why we can&#39;t use calc_frame_crc method
    # crc data for ping excludes the last 2B of response data, which holds the CRC from device
    crc_data = struct.pack(f&#39;&lt;BB{len(response_data) -2}B&#39;, header, frame_type, *response_data[:-2])
    crc = calc_crc(crc_data)
    assert crc == response.crc, \
        f&#34;Received CRC doesn&#39;t match&#34;

    self.protocol_version = response.version
    self.options = response.options</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.Uart.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) ‑> Union[<a title="spsdk.mboot.commands.CmdResponse" href="../commands.html#spsdk.mboot.commands.CmdResponse">CmdResponse</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Read data from device.</p>
<p>:return: read data
:rtype: Union[spsdk.mboot.commands.CmdResponse, bytes]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; Union[CmdResponse, bytes]:
    &#34;&#34;&#34;Read data from device.

    :return: read data
    :rtype: Union[spsdk.mboot.commands.CmdResponse, bytes]
    &#34;&#34;&#34;
    _, frame_type = self._read_frame_header()
    length = to_int(self._read(2))
    crc = to_int(self._read(2))
    data = self._read(length)
    self._send_ack()
    calculated_crc = self._calc_frame_crc(data, frame_type)
    assert crc == calculated_crc, &#34;Received invalid CRC&#34;
    if frame_type == FPType.CMD:
        return parse_cmd_response(data)
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.interfaces.uart.Uart.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, packet: Union[<a title="spsdk.mboot.commands.CmdPacket" href="../commands.html#spsdk.mboot.commands.CmdPacket">CmdPacket</a>, bytes]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to the device; data might be in form of 'CmdPacket' or bytes.</p>
<p>:param packet: Packet to send
:type packet: Union[spsdk.mboot.commands.CmdPacket, bytes]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, packet: Union[CmdPacket, bytes]) -&gt; None:
    &#34;&#34;&#34;Write data to the device; data might be in form of &#39;CmdPacket&#39; or bytes.

    :param packet: Packet to send
    :type packet: Union[spsdk.mboot.commands.CmdPacket, bytes]
    &#34;&#34;&#34;
    if isinstance(packet, CmdPacket):
        data = packet.to_bytes(padding=False)
        frame_type = FPType.CMD
    if isinstance(packet, (bytes, bytearray)):
        data = packet
        frame_type = FPType.DATA
    frame = self._create_frame(data, frame_type)
    self._send_frame(frame, wait_for_ack=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.mboot.interfaces.base.Interface" href="base.html#spsdk.mboot.interfaces.base.Interface">Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.mboot.interfaces.base.Interface.need_data_split" href="base.html#spsdk.mboot.interfaces.base.Interface.need_data_split">need_data_split</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.mboot.interfaces" href="index.html">spsdk.mboot.interfaces</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spsdk.mboot.interfaces.uart.calc_crc" href="#spsdk.mboot.interfaces.uart.calc_crc">calc_crc</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.scan_uart" href="#spsdk.mboot.interfaces.uart.scan_uart">scan_uart</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.to_int" href="#spsdk.mboot.interfaces.uart.to_int">to_int</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.mboot.interfaces.uart.FPType" href="#spsdk.mboot.interfaces.uart.FPType">FPType</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.ABORT" href="#spsdk.mboot.interfaces.uart.FPType.ABORT">ABORT</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.ACK" href="#spsdk.mboot.interfaces.uart.FPType.ACK">ACK</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.CMD" href="#spsdk.mboot.interfaces.uart.FPType.CMD">CMD</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.DATA" href="#spsdk.mboot.interfaces.uart.FPType.DATA">DATA</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.NACK" href="#spsdk.mboot.interfaces.uart.FPType.NACK">NACK</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.PING" href="#spsdk.mboot.interfaces.uart.FPType.PING">PING</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.FPType.PINGR" href="#spsdk.mboot.interfaces.uart.FPType.PINGR">PINGR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.mboot.interfaces.uart.Uart" href="#spsdk.mboot.interfaces.uart.Uart">Uart</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.FRAME_START_BYTE" href="#spsdk.mboot.interfaces.uart.Uart.FRAME_START_BYTE">FRAME_START_BYTE</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.close" href="#spsdk.mboot.interfaces.uart.Uart.close">close</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.info" href="#spsdk.mboot.interfaces.uart.Uart.info">info</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.is_opened" href="#spsdk.mboot.interfaces.uart.Uart.is_opened">is_opened</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.open" href="#spsdk.mboot.interfaces.uart.Uart.open">open</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.ping" href="#spsdk.mboot.interfaces.uart.Uart.ping">ping</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.read" href="#spsdk.mboot.interfaces.uart.Uart.read">read</a></code></li>
<li><code><a title="spsdk.mboot.interfaces.uart.Uart.write" href="#spsdk.mboot.interfaces.uart.Uart.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>