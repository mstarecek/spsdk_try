<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.mboot.mcuboot API documentation</title>
<meta name="description" content="Module for comunication with the bootloader." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.mboot.mcuboot</code></h1>
</header>
<section id="section-intro">
<p>Module for comunication with the bootloader.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2016-2018 Martin Olejar
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Module for comunication with the bootloader.&#34;&#34;&#34;

import logging
import time
from types import TracebackType
from typing import Any, Dict, List, Optional, Sequence, Union, Type

from .commands import CommandTag, KeyProvOperation, KeyProvUserKeyType, CmdPacket, GenericResponse
from .error_codes import StatusCode
from .exceptions import McuBootCommandError, McuBootConnectionError, SPSDKError
from .interfaces import Interface
from .memories import ExtMemPropTags, ExtMemId
from .properties import PropertyTag, Version, parse_property_value

logger = logging.getLogger(&#39;MBOOT&#39;)


########################################################################################################################
# McuBoot Class
########################################################################################################################
class McuBoot:  # pylint: disable=too-many-public-methods
    &#34;&#34;&#34;Class for communication with the bootloader.&#34;&#34;&#34;

    @property
    def status_code(self) -&gt; StatusCode:
        &#34;&#34;&#34;:return: status code of the last operation.&#34;&#34;&#34;
        return self._status_code

    @property
    def is_opened(self) -&gt; bool:
        &#34;&#34;&#34;:return: True if the device is open.&#34;&#34;&#34;
        return self._device.is_opened

    def __init__(self, device: Interface, cmd_exception: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize the McuBoot object.

        :param device: The instance of communication interface class
        :param cmd_exception: True to throw McuBootCommandError on any error;
                False to set status code only
                Note: some operation might raise McuBootCommandError is all cases

        &#34;&#34;&#34;
        self._cmd_exception = cmd_exception
        self._status_code = StatusCode.SUCCESS
        self._device = device
        self.reopen = False

    def __enter__(self) -&gt; &#39;McuBoot&#39;:
        self.reopen = True
        self.open()
        return self

    def __exit__(self, exception_type: Type[BaseException] = None,
                 exception_value: BaseException = None, traceback: TracebackType = None) -&gt; None:
        self.close()

    def _process_cmd(self, cmd_packet: CmdPacket) -&gt; Any:
        &#34;&#34;&#34;Process Command.

        :param cmd_packet: Command Packet
        :return: commad response derived from the CmdResponse
        :raises McuBootConnectionError: Timeout Error
        :raises McuBootCommandError: Error during command execution on the target
        &#34;&#34;&#34;
        if not self._device.is_opened:
            logger.info(&#39;TX: Device not opened&#39;)
            raise McuBootConnectionError(&#39;Device not opened&#39;)

        logger.debug(f&#39;TX-PACKET: {cmd_packet.info()}&#39;)

        try:
            self._device.write(cmd_packet)
            response = self._device.read()
        except TimeoutError:
            self._status_code = StatusCode.NO_RESPONSE
            logger.debug(&#39;RX-PACKET: No Response, Timeout Error !&#39;)
            raise McuBootConnectionError(&#34;No Response from Device&#34;)

        logger.debug(f&#39;RX-PACKET: {response.info()}&#39;)
        self._status_code = response.status

        if self._cmd_exception and self._status_code != StatusCode.SUCCESS:
            raise McuBootCommandError(CommandTag.name(cmd_packet.header.tag), response.status)

        return response

    def _read_data(self, cmd_tag: int, length: int, timeout: int = 1000) -&gt; bytes:
        &#34;&#34;&#34;Read data from device.

        :param cmd_tag: Tag indicating the read command.
        :param length: Length of data to read
        :param timeout: Timeout, defaults to 1000
        :raises McuBootConnectionError: Timeout error or a problem opening the interface
        :raises McuBootCommandError: Error during command execution on the target
        :return: Data read from the device
        &#34;&#34;&#34;
        data = b&#39;&#39;

        if not self._device.is_opened:
            logger.info(&#39;RX: Device not opened&#39;)
            raise McuBootConnectionError(&#39;Device not opened&#39;)

        while True:
            try:
                response = self._device.read()
            except TimeoutError:
                self._status_code = StatusCode.NO_RESPONSE
                logger.debug(&#39;RX: No Response, Timeout Error !&#39;)
                raise McuBootConnectionError(&#34;No Response from Device&#34;)

            if isinstance(response, bytes):
                data += response

            elif isinstance(response, GenericResponse):
                logger.debug(f&#39;RX-PACKET: {response.info()}&#39;)
                self._status_code = response.status
                if response.cmd_tag == cmd_tag:
                    break

        if len(data) &lt; length or self.status_code != StatusCode.SUCCESS:
            status_info = StatusCode.get(self._status_code, f&#39;0x{self._status_code:08X}&#39;)
            logger.debug(f&#34;CMD: Received {len(data)} from {length} Bytes, {status_info}&#34;)
            if self._cmd_exception:
                raise McuBootCommandError(CommandTag.name(cmd_tag), response.status)
        else:
            logger.info(f&#34;CMD: Successfully Received {len(data)} from {length} Bytes&#34;)

        return data[:length] if len(data) &gt; length else data

    def _send_data(self, cmd_tag: int, data: List[bytes]) -&gt; bool:
        &#34;&#34;&#34;Send Data part of specific command.

        :param cmd_tag: Tag indicating the command
        :param data: List of data chunks to send
        :raises McuBootConnectionError: Timeout error
        :raises McuBootCommandError: Error during command execution on the target
        :return: True if the operation is successfull
        &#34;&#34;&#34;
        if not self._device.is_opened:
            logger.info(&#39;TX: Device Disconnected&#39;)
            raise McuBootConnectionError(&#39;Device Disconnected !&#39;)

        try:
            for data_chunk in data:
                self._device.write(data_chunk)
            response = self._device.read()
        except TimeoutError:
            self._status_code = StatusCode.NO_RESPONSE
            logger.debug(&#39;RX: No Response, Timeout Error !&#39;)
            raise McuBootConnectionError(&#34;No Response from Device&#34;)
        except SPSDKError:
            response = self._device.read()

        logger.debug(f&#39;RX-PACKET: {response.info()}&#39;)
        self._status_code = response.status
        if response.status != StatusCode.SUCCESS:
            status_info = StatusCode.get(self._status_code, f&#39;0x{self._status_code:08X}&#39;)
            logger.debug(f&#34;CMD: Send Error, {status_info}&#34;)
            if self._cmd_exception:
                raise McuBootCommandError(CommandTag.name(cmd_tag), response.status)
            return False

        logger.info(f&#34;CMD: Successfully Send {sum(len(chunk) for chunk in data)} Bytes&#34;)
        return True

    def _split_data(self, data: bytes) -&gt; List[bytes]:
        &#34;&#34;&#34;Split data to send if necessary.

        :param data: Data to send
        :return: List of data splices
        &#34;&#34;&#34;
        if not self._device.need_data_split:
            return [data]
        packet_size_property = self.get_property(prop_tag=PropertyTag.MAX_PACKET_SIZE)
        assert packet_size_property, &#34;Unable to get MAX PACKET SIZE&#34;
        max_packet_size = packet_size_property[0]
        return [
            data[i:i + max_packet_size] for i in range(0, len(data), max_packet_size)
        ]

    def open(self) -&gt; None:
        &#34;&#34;&#34;Connect to the device.&#34;&#34;&#34;
        if not self._device.is_opened:
            logger.info(f&#34;Connect: {self._device.info()}&#34;)
            self._device.open()

    def close(self) -&gt; None:
        &#34;&#34;&#34;Disconnect from the device.&#34;&#34;&#34;
        self._device.close()

    def get_property_list(self) -&gt; list:
        &#34;&#34;&#34;Get a list of available properties.

        :return: List of available properties.
        :raises McuBootCommandError: Failure to read properties list
        &#34;&#34;&#34;
        property_list: List[Any] = []
        for tag in PropertyTag.tags():
            try:
                values = self.get_property(tag)
            except McuBootCommandError:
                continue

            if values:
                property_list.append(parse_property_value(tag, values))

        self._status_code = StatusCode.SUCCESS
        if not property_list:
            self._status_code = StatusCode.FAIL
            if self._cmd_exception:
                raise McuBootCommandError(&#39;GetPropertyList&#39;, self.status_code)

        return property_list

    def _get_internal_flash(self) -&gt; dict:
        &#34;&#34;&#34;Get information about the internal flash.

        - key: index
        - value: dictionary
            - key: &#39;address&#39; / &#39;size&#39; / &#39;sector_size&#39;
            - value: number??
        :return: info about internal flash for memory map
        &#34;&#34;&#34;
        index = 0
        mdata: dict = {}
        start_address = 0
        while True:
            try:
                values = self.get_property(PropertyTag.FLASH_START_ADDRESS, index)
                if not values:
                    break
                if index == 0:
                    start_address = values[0]
                elif start_address == values[0]:
                    break
                mdata[index] = {}
                mdata[index][&#39;address&#39;] = values[0]
                values = self.get_property(PropertyTag.FLASH_SIZE, index)
                if not values:
                    break
                mdata[index][&#39;size&#39;] = values[0]
                values = self.get_property(PropertyTag.FLASH_SECTOR_SIZE, index)
                if not values:
                    break
                mdata[index][&#39;sector_size&#39;] = values[0]
                index += 1
            except McuBootCommandError:
                break

        return mdata

    def _get_internal_ram(self) -&gt; dict:
        &#34;&#34;&#34;Get information about the internal RAM.

        - key: index
        - value: dictionary
            - key: &#39;address&#39; / &#39;size&#39;
            - value: number??
        :return: info about internal RAM
        &#34;&#34;&#34;
        index = 0
        mdata: Dict[int, Dict[str, int]] = {}
        start_address = 0
        while True:
            try:
                values = self.get_property(PropertyTag.RAM_START_ADDRESS, index)
                if not values:
                    break
                if index == 0:
                    start_address = values[0]
                elif start_address == values[0]:
                    break
                mdata[index] = {}
                mdata[index][&#39;address&#39;] = values[0]
                values = self.get_property(PropertyTag.RAM_SIZE, index)
                if not values:
                    break
                mdata[index][&#39;size&#39;] = values[0]
                index += 1
            except McuBootCommandError:
                break

        return mdata

    def _get_ext_memories(self) -&gt; list:
        &#34;&#34;&#34;Get information about the external memories.

        List contains dictionary with info about memory:
        - mem_id
        - mem_name
        - address (optional)
        - size (optional)
        - page_size (optional)
        - sector_size (optional)
        - block_size (optional)
        :return: list of external memories supported by the device
        &#34;&#34;&#34;
        ext_mem_list: List[Dict[str, Union[int, str]]] = []
        ext_mem_ids: Sequence[int] = ExtMemId.tags()
        try:
            values = self.get_property(PropertyTag.CURRENT_VERSION)
        except McuBootCommandError:
            values = None

        if not values and self._status_code == StatusCode.UNKNOWN_PROPERTY:
            self._status_code = StatusCode.SUCCESS
            return ext_mem_list

        assert values

        if Version(values[0]) &lt;= Version(&#34;2.0.0&#34;):
            # old versions mboot support only Quad SPI memory
            ext_mem_ids = [ExtMemId.QUAD_SPI0]

        for mem_id in ext_mem_ids:
            mem_attrs: Dict[str, Union[int, str]] = {}

            try:
                values = self.get_property(PropertyTag.EXTERNAL_MEMORY_ATTRIBUTES, mem_id)
            except McuBootCommandError:
                values = None

            if not values:
                if self._status_code == StatusCode.UNKNOWN_PROPERTY:
                    # No external memories are supported by current device.
                    break

                if self._status_code == StatusCode.INVALID_ARGUMENT:
                    # Current memory type is not supported by the device, skip to next external memory.
                    continue

                if self._status_code == StatusCode.QSPI_NOT_CONFIGURED:
                    # QSPI0 is not supported, skip to next external memory.
                    continue

                if self._status_code == StatusCode.MEMORY_NOT_CONFIGURED:
                    # Un-configured external memory, skip to next external memory.
                    continue

                assert self._status_code != StatusCode.SUCCESS  # Other Error
                break

            # memory ID and name
            mem_attrs[&#39;mem_id&#39;] = mem_id
            mem_attrs[&#39;mem_name&#39;] = ExtMemId.name(mem_id)
            # parse memory attributes
            if values[0] &amp; ExtMemPropTags.START_ADDRESS:
                mem_attrs[&#39;address&#39;] = values[1]
            if values[0] &amp; ExtMemPropTags.SIZE_IN_KBYTES:
                mem_attrs[&#39;size&#39;] = values[2] * 1024
            if values[0] &amp; ExtMemPropTags.PAGE_SIZE:
                mem_attrs[&#39;page_size&#39;] = values[3]
            if values[0] &amp; ExtMemPropTags.SECTOR_SIZE:
                mem_attrs[&#39;sector_size&#39;] = values[4]
            if values[0] &amp; ExtMemPropTags.BLOCK_SIZE:
                mem_attrs[&#39;block_size&#39;] = values[5]
            # store attributes
            ext_mem_list.append(mem_attrs)

        return ext_mem_list

    def get_memory_list(self) -&gt; dict:
        &#34;&#34;&#34;Get list of embedded memories.

        :return: dict, with the following keys: internal_flash (optional) - dictionary,
                internal_ram (optional) - dictionary, external_mems (optional) - list
        :raises McuBootCommandError: Error reading the memory list
        &#34;&#34;&#34;
        memory_list: Dict[str, Any] = {}
        # Internal FLASH
        mdata = self._get_internal_flash()
        if mdata:
            memory_list[&#39;internal_flash&#39;] = mdata

        # Internal RAM
        mdata = self._get_internal_ram()
        if mdata:
            memory_list[&#39;internal_ram&#39;] = mdata

        # External Memories
        ext_mem_list = self._get_ext_memories()
        if ext_mem_list:
            memory_list[&#39;external_mems&#39;] = ext_mem_list

        self._status_code = StatusCode.SUCCESS
        if not memory_list:
            self._status_code = StatusCode.FAIL
            if self._cmd_exception:
                raise McuBootCommandError(&#39;GetMemoryList&#39;, self.status_code)

        return memory_list

    def flash_erase_all(self, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Erase complete flash memory without recovering flash security section.

        :param mem_id: Memory ID
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashEraseAll(mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_ALL, 0, mem_id)
        response = self._process_cmd(cmd_packet)
        assert isinstance(cmd_packet, GenericResponse)
        return response.status == StatusCode.SUCCESS

    def flash_erase_region(self, address: int, length: int, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Erase specified range of flash.

        :param address: Start address
        :param length: Count of bytes
        :param mem_id: Memory ID
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashEraseRegion(address=0x{address:08X}, length={length}, mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_REGION, 0, address, length, mem_id)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def read_memory(self, address: int, length: int, mem_id: int = 0) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Read data from MCU memory.

        :param address: Start address
        :param length: Count of bytes
        :param mem_id: Memory ID
        :return: Data read from the memory; None in case of a failure
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ReadMemory(address=0x{address:08X}, length={length}, mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.READ_MEMORY, 0, address, length, mem_id)
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.READ_MEMORY, cmd_response.length)
        return None

    def write_memory(self, address: int, data: bytes, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Write data into MCU memory.

        :param address: Start address
        :param data: List of bytes
        :param mem_id: Memory ID, see ExtMemId; additionally use `0` for internal memory
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: WriteMemory(address=0x{address:08X}, length={len(data)}, mem_id={mem_id})&#34;)
        data_chunks = self._split_data(data=data)
        cmd_packet = CmdPacket(CommandTag.WRITE_MEMORY, 0, address, len(data), mem_id)
        if self._process_cmd(cmd_packet).status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.WRITE_MEMORY, data_chunks)
        return False

    def fill_memory(self, address: int, length: int, pattern: int = 0xFFFFFFFF) -&gt; bool:
        &#34;&#34;&#34;Fill MCU memory with specified pattern.

        :param address: Start address (must be word aligned)
        :param length: Count of words (must be word aligned)
        :param pattern: Count of wrote bytes
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FillMemory(address=0x{address:08X}, length={length}, pattern=0x{pattern:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.FILL_MEMORY, 0, address, length, pattern)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def flash_security_disable(self, backdoor_key: bytes) -&gt; bool:
        &#34;&#34;&#34;Disable flash security by using of backdoor key.

        :param backdoor_key: The key value as array of 8 bytes
        :return: False in case of any problem; True otherwise
        :raises ValueError: If the backdoor_key is not 8 bytes long
        &#34;&#34;&#34;
        if len(backdoor_key) != 8:
            raise ValueError(&#39;Backdoor key must by 8 bytes long&#39;)
        logger.info(f&#34;CMD: FlashSecurityDisable(backdoor_key={backdoor_key!r})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_SECURITY_DISABLE, 0, data=backdoor_key)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def get_property(self, prop_tag: PropertyTag, index: int = 0) -&gt; Optional[List[int]]:
        &#34;&#34;&#34;Get specified property value.

        :param prop_tag: Property TAG (see Properties Enum)
        :param index: External memory ID or internal memory region index (depends on property type)
        :return: list integers representing the property; None in case no response from device
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: GetProperty({PropertyTag.name(prop_tag)!r}, index={index!r})&#34;)
        cmd_packet = CmdPacket(CommandTag.GET_PROPERTY, 0, prop_tag, index)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.values if cmd_response.status == StatusCode.SUCCESS else None

    def set_property(self, prop_tag: PropertyTag, value: int) -&gt; bool:
        &#34;&#34;&#34;Set value of specified property.

        :param  prop_tag: Property TAG (see Property enumerator)
        :param  value: The value of selected property
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: SetProperty({PropertyTag.name(prop_tag)}, value=0x{value:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.SET_PROPERTY, 0, prop_tag, value)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.status == StatusCode.SUCCESS

    def receive_sb_file(self, data: bytes) -&gt; bool:
        &#34;&#34;&#34;Receive SB file.

        :param  data: SB file data
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ReceiveSBfile(data_length={len(data)})&#34;)
        data_chunks = self._split_data(data=data)
        cmd_packet = CmdPacket(CommandTag.RECEIVE_SB_FILE, 1, len(data))
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.RECEIVE_SB_FILE, data_chunks)
        return False

    def execute(self, address: int, argument: int, sp: int) -&gt; bool:    # pylint: disable=invalid-name
        &#34;&#34;&#34;Execute program on a given address using the stack pointer.

        :param address: Jump address (must be word aligned)
        :param argument: Function arguments address
        :param sp: Stack pointer address
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: Execute(address=0x{address:08X}, argument=0x{argument:08X}, SP=0x{sp:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.EXECUTE, 0, address, argument, sp)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def call(self, address: int, argument: int) -&gt; bool:
        &#34;&#34;&#34;Fill MCU memory with specified pattern.

        :param address: Call address (must be word aligned)
        :param argument: Function arguments address
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: Call(address=0x{address:08X}, argument=0x{argument:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.CALL, 0, address, argument)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def reset(self, timeout: int = 2000, reopen: bool = True) -&gt; bool:
        &#34;&#34;&#34;Reset MCU and reconnect if enabled.

        :param timeout: The maximal waiting time in [ms] for reopen connection
        :param reopen: True for reopen connection after HW reset else False
        :return: False in case of any problem; True otherwise
        :raise ValueError: if reopen is not supported
        :raise McuBootConnectionError: Failure to reopen the device
        &#34;&#34;&#34;
        logger.info(&#39;CMD: Reset MCU&#39;)
        cmd_packet = CmdPacket(CommandTag.RESET, 0)
        ret_val = False
        if self._process_cmd(cmd_packet).status == StatusCode.SUCCESS:
            self._device.close()
            ret_val = True
            if reopen:
                if not self.reopen:
                    raise ValueError(&#39;reopen is not supported&#39;)
                time.sleep(timeout / 1000)
                try:
                    self._device.open()
                except SPSDKError:
                    ret_val = False
                    if self._cmd_exception:
                        raise McuBootConnectionError(&#39;reopen failed&#39;)
        return ret_val

    def flash_erase_all_unsecure(self) -&gt; bool:
        &#34;&#34;&#34;Erase complete flash memory and recover flash security section.

        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(&#39;CMD: FlashEraseAllUnsecure&#39;)
        cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_ALL_UNSECURE, 0)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def efuse_read_once(self, index: int) -&gt; Optional[int]:
        &#34;&#34;&#34;Read from MCU flash program once region.

        :param index: Start index
        :return: read value (32-bit int); None if operation failed
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashReadOnce(index={index})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_READ_ONCE, 0, index, 4)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.values[0] if cmd_response.status == StatusCode.SUCCESS else None

    def efuse_program_once(self, index: int, value: int) -&gt; bool:
        &#34;&#34;&#34;Write into MCU once program region (OCOTP).

        :param index: Start index
        :param value: Int value (4 bytes long)
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashProgramOnce(index={index}, value=0x{value:X})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_PROGRAM_ONCE, 0, index, 4, value)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def flash_read_once(self, index: int, count: int = 4) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Read from MCU flash program once region (max 8 bytes).

        :param index: Start index
        :param count: Count of bytes
        :return: Data read; None in case of an failure
        &#34;&#34;&#34;
        assert count in (4, 8)
        logger.info(f&#34;CMD: FlashReadOnce(index={index}, bytes={count})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_READ_ONCE, 0, index, count)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.data if cmd_response.status == StatusCode.SUCCESS else None

    def flash_program_once(self, index: int, data: bytes) -&gt; bool:
        &#34;&#34;&#34;Write into MCU flash program once region (max 8 bytes).

        :param index: Start index
        :param data: Input data aligned to 4 or 8 bytes
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        assert len(data) in (4, 8)
        logger.info(f&#34;CMD: FlashProgramOnce(index={index!r}, data={data!r})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_PROGRAM_ONCE, 0, index, len(data), data=data)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def flash_read_resource(self, address: int, length: int, option: int = 1) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Read resource of flash module.

        :param address: Start address
        :param length: Number of bytes
        :param option:
        :return: Data from the resource; None in case of an failure
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashReadResource(address=0x{address:08X}, length={length}, option={option})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_READ_RESOURCE, 0, address, length, option)
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.FLASH_READ_RESOURCE, cmd_response.length)
        return None

    def configure_memory(self, address: int, mem_id: ExtMemId) -&gt; bool:
        &#34;&#34;&#34;Configure memory.

        :param address: The address in memory where are locating configuration data
        :param mem_id: External memory ID
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ConfigureMemory({ExtMemId.name(mem_id)}, address=0x{address:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.CONFIGURE_MEMORY, 0, mem_id, address)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def reliable_update(self, address: int) -&gt; bool:
        &#34;&#34;&#34;Reliable Update.

        :param address: Address where new the firmware is stored
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ReliableUpdate(address=0x{address:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.RELIABLE_UPDATE, 0, address)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def generate_key_blob(self, dek_data: bytes, count: int = 72) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Generate Key Blob.

        :param dek_data: Data Encryption Key as bytes
        :param count: Key blob count (default: 72 - AES128bit)
        :return: Key blob; None in case of an failure
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: GenerateKeyBlob(dek_len={len(dek_data)}, count={count})&#34;)
        data_chunks = self._split_data(data=dek_data)
        cmd_response = self._process_cmd(CmdPacket(CommandTag.GENERATE_KEY_BLOB, 1, 0, len(dek_data), 0))
        if cmd_response.status != StatusCode.SUCCESS:
            return None
        if not self._send_data(CommandTag.GENERATE_KEY_BLOB, data_chunks):
            return None
        cmd_response = self._process_cmd(CmdPacket(CommandTag.GENERATE_KEY_BLOB, 0, 0, count, 1))
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.GENERATE_KEY_BLOB, cmd_response.length)
        return None

    def kp_enroll(self) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Enroll Command (start PUF).

        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(&#34;CMD: [KeyProvisioning] Enroll&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.ENROLL)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_set_intrinsic_key(self, key_type: int, key_size: int) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Generate Intrinsic Key.

        :param key_type: Type of the key
        :param key_size: Size of the key
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] SetIntrinsicKey(type={key_type}, key_size={key_size})&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.SET_INTRINSIC_KEY, key_type, key_size)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_write_nonvolatile(self, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Write the key to a nonvolatile memory.

        :param mem_id: The memory ID (default: 0)
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] WriteNonVolatileMemory(mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.WRITE_NON_VOLATILE, mem_id)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_read_nonvolatile(self, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Load the key from a nonvolatile memory to bootloader.

        :param mem_id: The memory ID (default: 0)
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] ReadNonVolatileMemory(mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.READ_NON_VOLATILE, mem_id)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_set_user_key(self, key_type: KeyProvUserKeyType, key_data: bytes) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Send the user key specified by &lt;key_type&gt; to bootloader.

        :param key_type: type of the user key, see enumeration for details
        :param key_data: binary content of the user key
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] SetUserKey(key_type={KeyProvUserKeyType.name(key_type)}, &#34;
                    f&#34;key_len={len(key_data)})&#34;)
        data_chunks = self._split_data(data=key_data)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 1, KeyProvOperation.SET_USER_KEY, key_type, len(key_data))
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.KEY_PROVISIONING, data_chunks)
        return False

    def kp_write_key_store(self, key_data: bytes) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Write key data into key store area.

        :param key_data: key store binary content to be written to processor
        :return: result of the operation; True means success
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] WriteKeyStore(key_len={len(key_data)})&#34;)
        data_chunks = self._split_data(data=key_data)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 1, KeyProvOperation.WRITE_KEY_STORE, 0, len(key_data))
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.KEY_PROVISIONING, data_chunks)
        return False

    def kp_read_key_store(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Key provisioning: Read key data from key store area.&#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] ReadKeyStore&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.READ_KEY_STORE)
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.KEY_PROVISIONING, cmd_response.length)
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.mboot.mcuboot.McuBoot"><code class="flex name class">
<span>class <span class="ident">McuBoot</span></span>
<span>(</span><span>device: <a title="spsdk.mboot.interfaces.base.Interface" href="interfaces/base.html#spsdk.mboot.interfaces.base.Interface">Interface</a>, cmd_exception: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for communication with the bootloader.</p>
<p>Initialize the McuBoot object.</p>
<p>:param device: The instance of communication interface class
:param cmd_exception: True to throw McuBootCommandError on any error;
False to set status code only
Note: some operation might raise McuBootCommandError is all cases</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class McuBoot:  # pylint: disable=too-many-public-methods
    &#34;&#34;&#34;Class for communication with the bootloader.&#34;&#34;&#34;

    @property
    def status_code(self) -&gt; StatusCode:
        &#34;&#34;&#34;:return: status code of the last operation.&#34;&#34;&#34;
        return self._status_code

    @property
    def is_opened(self) -&gt; bool:
        &#34;&#34;&#34;:return: True if the device is open.&#34;&#34;&#34;
        return self._device.is_opened

    def __init__(self, device: Interface, cmd_exception: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize the McuBoot object.

        :param device: The instance of communication interface class
        :param cmd_exception: True to throw McuBootCommandError on any error;
                False to set status code only
                Note: some operation might raise McuBootCommandError is all cases

        &#34;&#34;&#34;
        self._cmd_exception = cmd_exception
        self._status_code = StatusCode.SUCCESS
        self._device = device
        self.reopen = False

    def __enter__(self) -&gt; &#39;McuBoot&#39;:
        self.reopen = True
        self.open()
        return self

    def __exit__(self, exception_type: Type[BaseException] = None,
                 exception_value: BaseException = None, traceback: TracebackType = None) -&gt; None:
        self.close()

    def _process_cmd(self, cmd_packet: CmdPacket) -&gt; Any:
        &#34;&#34;&#34;Process Command.

        :param cmd_packet: Command Packet
        :return: commad response derived from the CmdResponse
        :raises McuBootConnectionError: Timeout Error
        :raises McuBootCommandError: Error during command execution on the target
        &#34;&#34;&#34;
        if not self._device.is_opened:
            logger.info(&#39;TX: Device not opened&#39;)
            raise McuBootConnectionError(&#39;Device not opened&#39;)

        logger.debug(f&#39;TX-PACKET: {cmd_packet.info()}&#39;)

        try:
            self._device.write(cmd_packet)
            response = self._device.read()
        except TimeoutError:
            self._status_code = StatusCode.NO_RESPONSE
            logger.debug(&#39;RX-PACKET: No Response, Timeout Error !&#39;)
            raise McuBootConnectionError(&#34;No Response from Device&#34;)

        logger.debug(f&#39;RX-PACKET: {response.info()}&#39;)
        self._status_code = response.status

        if self._cmd_exception and self._status_code != StatusCode.SUCCESS:
            raise McuBootCommandError(CommandTag.name(cmd_packet.header.tag), response.status)

        return response

    def _read_data(self, cmd_tag: int, length: int, timeout: int = 1000) -&gt; bytes:
        &#34;&#34;&#34;Read data from device.

        :param cmd_tag: Tag indicating the read command.
        :param length: Length of data to read
        :param timeout: Timeout, defaults to 1000
        :raises McuBootConnectionError: Timeout error or a problem opening the interface
        :raises McuBootCommandError: Error during command execution on the target
        :return: Data read from the device
        &#34;&#34;&#34;
        data = b&#39;&#39;

        if not self._device.is_opened:
            logger.info(&#39;RX: Device not opened&#39;)
            raise McuBootConnectionError(&#39;Device not opened&#39;)

        while True:
            try:
                response = self._device.read()
            except TimeoutError:
                self._status_code = StatusCode.NO_RESPONSE
                logger.debug(&#39;RX: No Response, Timeout Error !&#39;)
                raise McuBootConnectionError(&#34;No Response from Device&#34;)

            if isinstance(response, bytes):
                data += response

            elif isinstance(response, GenericResponse):
                logger.debug(f&#39;RX-PACKET: {response.info()}&#39;)
                self._status_code = response.status
                if response.cmd_tag == cmd_tag:
                    break

        if len(data) &lt; length or self.status_code != StatusCode.SUCCESS:
            status_info = StatusCode.get(self._status_code, f&#39;0x{self._status_code:08X}&#39;)
            logger.debug(f&#34;CMD: Received {len(data)} from {length} Bytes, {status_info}&#34;)
            if self._cmd_exception:
                raise McuBootCommandError(CommandTag.name(cmd_tag), response.status)
        else:
            logger.info(f&#34;CMD: Successfully Received {len(data)} from {length} Bytes&#34;)

        return data[:length] if len(data) &gt; length else data

    def _send_data(self, cmd_tag: int, data: List[bytes]) -&gt; bool:
        &#34;&#34;&#34;Send Data part of specific command.

        :param cmd_tag: Tag indicating the command
        :param data: List of data chunks to send
        :raises McuBootConnectionError: Timeout error
        :raises McuBootCommandError: Error during command execution on the target
        :return: True if the operation is successfull
        &#34;&#34;&#34;
        if not self._device.is_opened:
            logger.info(&#39;TX: Device Disconnected&#39;)
            raise McuBootConnectionError(&#39;Device Disconnected !&#39;)

        try:
            for data_chunk in data:
                self._device.write(data_chunk)
            response = self._device.read()
        except TimeoutError:
            self._status_code = StatusCode.NO_RESPONSE
            logger.debug(&#39;RX: No Response, Timeout Error !&#39;)
            raise McuBootConnectionError(&#34;No Response from Device&#34;)
        except SPSDKError:
            response = self._device.read()

        logger.debug(f&#39;RX-PACKET: {response.info()}&#39;)
        self._status_code = response.status
        if response.status != StatusCode.SUCCESS:
            status_info = StatusCode.get(self._status_code, f&#39;0x{self._status_code:08X}&#39;)
            logger.debug(f&#34;CMD: Send Error, {status_info}&#34;)
            if self._cmd_exception:
                raise McuBootCommandError(CommandTag.name(cmd_tag), response.status)
            return False

        logger.info(f&#34;CMD: Successfully Send {sum(len(chunk) for chunk in data)} Bytes&#34;)
        return True

    def _split_data(self, data: bytes) -&gt; List[bytes]:
        &#34;&#34;&#34;Split data to send if necessary.

        :param data: Data to send
        :return: List of data splices
        &#34;&#34;&#34;
        if not self._device.need_data_split:
            return [data]
        packet_size_property = self.get_property(prop_tag=PropertyTag.MAX_PACKET_SIZE)
        assert packet_size_property, &#34;Unable to get MAX PACKET SIZE&#34;
        max_packet_size = packet_size_property[0]
        return [
            data[i:i + max_packet_size] for i in range(0, len(data), max_packet_size)
        ]

    def open(self) -&gt; None:
        &#34;&#34;&#34;Connect to the device.&#34;&#34;&#34;
        if not self._device.is_opened:
            logger.info(f&#34;Connect: {self._device.info()}&#34;)
            self._device.open()

    def close(self) -&gt; None:
        &#34;&#34;&#34;Disconnect from the device.&#34;&#34;&#34;
        self._device.close()

    def get_property_list(self) -&gt; list:
        &#34;&#34;&#34;Get a list of available properties.

        :return: List of available properties.
        :raises McuBootCommandError: Failure to read properties list
        &#34;&#34;&#34;
        property_list: List[Any] = []
        for tag in PropertyTag.tags():
            try:
                values = self.get_property(tag)
            except McuBootCommandError:
                continue

            if values:
                property_list.append(parse_property_value(tag, values))

        self._status_code = StatusCode.SUCCESS
        if not property_list:
            self._status_code = StatusCode.FAIL
            if self._cmd_exception:
                raise McuBootCommandError(&#39;GetPropertyList&#39;, self.status_code)

        return property_list

    def _get_internal_flash(self) -&gt; dict:
        &#34;&#34;&#34;Get information about the internal flash.

        - key: index
        - value: dictionary
            - key: &#39;address&#39; / &#39;size&#39; / &#39;sector_size&#39;
            - value: number??
        :return: info about internal flash for memory map
        &#34;&#34;&#34;
        index = 0
        mdata: dict = {}
        start_address = 0
        while True:
            try:
                values = self.get_property(PropertyTag.FLASH_START_ADDRESS, index)
                if not values:
                    break
                if index == 0:
                    start_address = values[0]
                elif start_address == values[0]:
                    break
                mdata[index] = {}
                mdata[index][&#39;address&#39;] = values[0]
                values = self.get_property(PropertyTag.FLASH_SIZE, index)
                if not values:
                    break
                mdata[index][&#39;size&#39;] = values[0]
                values = self.get_property(PropertyTag.FLASH_SECTOR_SIZE, index)
                if not values:
                    break
                mdata[index][&#39;sector_size&#39;] = values[0]
                index += 1
            except McuBootCommandError:
                break

        return mdata

    def _get_internal_ram(self) -&gt; dict:
        &#34;&#34;&#34;Get information about the internal RAM.

        - key: index
        - value: dictionary
            - key: &#39;address&#39; / &#39;size&#39;
            - value: number??
        :return: info about internal RAM
        &#34;&#34;&#34;
        index = 0
        mdata: Dict[int, Dict[str, int]] = {}
        start_address = 0
        while True:
            try:
                values = self.get_property(PropertyTag.RAM_START_ADDRESS, index)
                if not values:
                    break
                if index == 0:
                    start_address = values[0]
                elif start_address == values[0]:
                    break
                mdata[index] = {}
                mdata[index][&#39;address&#39;] = values[0]
                values = self.get_property(PropertyTag.RAM_SIZE, index)
                if not values:
                    break
                mdata[index][&#39;size&#39;] = values[0]
                index += 1
            except McuBootCommandError:
                break

        return mdata

    def _get_ext_memories(self) -&gt; list:
        &#34;&#34;&#34;Get information about the external memories.

        List contains dictionary with info about memory:
        - mem_id
        - mem_name
        - address (optional)
        - size (optional)
        - page_size (optional)
        - sector_size (optional)
        - block_size (optional)
        :return: list of external memories supported by the device
        &#34;&#34;&#34;
        ext_mem_list: List[Dict[str, Union[int, str]]] = []
        ext_mem_ids: Sequence[int] = ExtMemId.tags()
        try:
            values = self.get_property(PropertyTag.CURRENT_VERSION)
        except McuBootCommandError:
            values = None

        if not values and self._status_code == StatusCode.UNKNOWN_PROPERTY:
            self._status_code = StatusCode.SUCCESS
            return ext_mem_list

        assert values

        if Version(values[0]) &lt;= Version(&#34;2.0.0&#34;):
            # old versions mboot support only Quad SPI memory
            ext_mem_ids = [ExtMemId.QUAD_SPI0]

        for mem_id in ext_mem_ids:
            mem_attrs: Dict[str, Union[int, str]] = {}

            try:
                values = self.get_property(PropertyTag.EXTERNAL_MEMORY_ATTRIBUTES, mem_id)
            except McuBootCommandError:
                values = None

            if not values:
                if self._status_code == StatusCode.UNKNOWN_PROPERTY:
                    # No external memories are supported by current device.
                    break

                if self._status_code == StatusCode.INVALID_ARGUMENT:
                    # Current memory type is not supported by the device, skip to next external memory.
                    continue

                if self._status_code == StatusCode.QSPI_NOT_CONFIGURED:
                    # QSPI0 is not supported, skip to next external memory.
                    continue

                if self._status_code == StatusCode.MEMORY_NOT_CONFIGURED:
                    # Un-configured external memory, skip to next external memory.
                    continue

                assert self._status_code != StatusCode.SUCCESS  # Other Error
                break

            # memory ID and name
            mem_attrs[&#39;mem_id&#39;] = mem_id
            mem_attrs[&#39;mem_name&#39;] = ExtMemId.name(mem_id)
            # parse memory attributes
            if values[0] &amp; ExtMemPropTags.START_ADDRESS:
                mem_attrs[&#39;address&#39;] = values[1]
            if values[0] &amp; ExtMemPropTags.SIZE_IN_KBYTES:
                mem_attrs[&#39;size&#39;] = values[2] * 1024
            if values[0] &amp; ExtMemPropTags.PAGE_SIZE:
                mem_attrs[&#39;page_size&#39;] = values[3]
            if values[0] &amp; ExtMemPropTags.SECTOR_SIZE:
                mem_attrs[&#39;sector_size&#39;] = values[4]
            if values[0] &amp; ExtMemPropTags.BLOCK_SIZE:
                mem_attrs[&#39;block_size&#39;] = values[5]
            # store attributes
            ext_mem_list.append(mem_attrs)

        return ext_mem_list

    def get_memory_list(self) -&gt; dict:
        &#34;&#34;&#34;Get list of embedded memories.

        :return: dict, with the following keys: internal_flash (optional) - dictionary,
                internal_ram (optional) - dictionary, external_mems (optional) - list
        :raises McuBootCommandError: Error reading the memory list
        &#34;&#34;&#34;
        memory_list: Dict[str, Any] = {}
        # Internal FLASH
        mdata = self._get_internal_flash()
        if mdata:
            memory_list[&#39;internal_flash&#39;] = mdata

        # Internal RAM
        mdata = self._get_internal_ram()
        if mdata:
            memory_list[&#39;internal_ram&#39;] = mdata

        # External Memories
        ext_mem_list = self._get_ext_memories()
        if ext_mem_list:
            memory_list[&#39;external_mems&#39;] = ext_mem_list

        self._status_code = StatusCode.SUCCESS
        if not memory_list:
            self._status_code = StatusCode.FAIL
            if self._cmd_exception:
                raise McuBootCommandError(&#39;GetMemoryList&#39;, self.status_code)

        return memory_list

    def flash_erase_all(self, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Erase complete flash memory without recovering flash security section.

        :param mem_id: Memory ID
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashEraseAll(mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_ALL, 0, mem_id)
        response = self._process_cmd(cmd_packet)
        assert isinstance(cmd_packet, GenericResponse)
        return response.status == StatusCode.SUCCESS

    def flash_erase_region(self, address: int, length: int, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Erase specified range of flash.

        :param address: Start address
        :param length: Count of bytes
        :param mem_id: Memory ID
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashEraseRegion(address=0x{address:08X}, length={length}, mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_REGION, 0, address, length, mem_id)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def read_memory(self, address: int, length: int, mem_id: int = 0) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Read data from MCU memory.

        :param address: Start address
        :param length: Count of bytes
        :param mem_id: Memory ID
        :return: Data read from the memory; None in case of a failure
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ReadMemory(address=0x{address:08X}, length={length}, mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.READ_MEMORY, 0, address, length, mem_id)
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.READ_MEMORY, cmd_response.length)
        return None

    def write_memory(self, address: int, data: bytes, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Write data into MCU memory.

        :param address: Start address
        :param data: List of bytes
        :param mem_id: Memory ID, see ExtMemId; additionally use `0` for internal memory
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: WriteMemory(address=0x{address:08X}, length={len(data)}, mem_id={mem_id})&#34;)
        data_chunks = self._split_data(data=data)
        cmd_packet = CmdPacket(CommandTag.WRITE_MEMORY, 0, address, len(data), mem_id)
        if self._process_cmd(cmd_packet).status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.WRITE_MEMORY, data_chunks)
        return False

    def fill_memory(self, address: int, length: int, pattern: int = 0xFFFFFFFF) -&gt; bool:
        &#34;&#34;&#34;Fill MCU memory with specified pattern.

        :param address: Start address (must be word aligned)
        :param length: Count of words (must be word aligned)
        :param pattern: Count of wrote bytes
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FillMemory(address=0x{address:08X}, length={length}, pattern=0x{pattern:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.FILL_MEMORY, 0, address, length, pattern)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def flash_security_disable(self, backdoor_key: bytes) -&gt; bool:
        &#34;&#34;&#34;Disable flash security by using of backdoor key.

        :param backdoor_key: The key value as array of 8 bytes
        :return: False in case of any problem; True otherwise
        :raises ValueError: If the backdoor_key is not 8 bytes long
        &#34;&#34;&#34;
        if len(backdoor_key) != 8:
            raise ValueError(&#39;Backdoor key must by 8 bytes long&#39;)
        logger.info(f&#34;CMD: FlashSecurityDisable(backdoor_key={backdoor_key!r})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_SECURITY_DISABLE, 0, data=backdoor_key)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def get_property(self, prop_tag: PropertyTag, index: int = 0) -&gt; Optional[List[int]]:
        &#34;&#34;&#34;Get specified property value.

        :param prop_tag: Property TAG (see Properties Enum)
        :param index: External memory ID or internal memory region index (depends on property type)
        :return: list integers representing the property; None in case no response from device
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: GetProperty({PropertyTag.name(prop_tag)!r}, index={index!r})&#34;)
        cmd_packet = CmdPacket(CommandTag.GET_PROPERTY, 0, prop_tag, index)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.values if cmd_response.status == StatusCode.SUCCESS else None

    def set_property(self, prop_tag: PropertyTag, value: int) -&gt; bool:
        &#34;&#34;&#34;Set value of specified property.

        :param  prop_tag: Property TAG (see Property enumerator)
        :param  value: The value of selected property
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: SetProperty({PropertyTag.name(prop_tag)}, value=0x{value:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.SET_PROPERTY, 0, prop_tag, value)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.status == StatusCode.SUCCESS

    def receive_sb_file(self, data: bytes) -&gt; bool:
        &#34;&#34;&#34;Receive SB file.

        :param  data: SB file data
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ReceiveSBfile(data_length={len(data)})&#34;)
        data_chunks = self._split_data(data=data)
        cmd_packet = CmdPacket(CommandTag.RECEIVE_SB_FILE, 1, len(data))
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.RECEIVE_SB_FILE, data_chunks)
        return False

    def execute(self, address: int, argument: int, sp: int) -&gt; bool:    # pylint: disable=invalid-name
        &#34;&#34;&#34;Execute program on a given address using the stack pointer.

        :param address: Jump address (must be word aligned)
        :param argument: Function arguments address
        :param sp: Stack pointer address
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: Execute(address=0x{address:08X}, argument=0x{argument:08X}, SP=0x{sp:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.EXECUTE, 0, address, argument, sp)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def call(self, address: int, argument: int) -&gt; bool:
        &#34;&#34;&#34;Fill MCU memory with specified pattern.

        :param address: Call address (must be word aligned)
        :param argument: Function arguments address
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: Call(address=0x{address:08X}, argument=0x{argument:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.CALL, 0, address, argument)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def reset(self, timeout: int = 2000, reopen: bool = True) -&gt; bool:
        &#34;&#34;&#34;Reset MCU and reconnect if enabled.

        :param timeout: The maximal waiting time in [ms] for reopen connection
        :param reopen: True for reopen connection after HW reset else False
        :return: False in case of any problem; True otherwise
        :raise ValueError: if reopen is not supported
        :raise McuBootConnectionError: Failure to reopen the device
        &#34;&#34;&#34;
        logger.info(&#39;CMD: Reset MCU&#39;)
        cmd_packet = CmdPacket(CommandTag.RESET, 0)
        ret_val = False
        if self._process_cmd(cmd_packet).status == StatusCode.SUCCESS:
            self._device.close()
            ret_val = True
            if reopen:
                if not self.reopen:
                    raise ValueError(&#39;reopen is not supported&#39;)
                time.sleep(timeout / 1000)
                try:
                    self._device.open()
                except SPSDKError:
                    ret_val = False
                    if self._cmd_exception:
                        raise McuBootConnectionError(&#39;reopen failed&#39;)
        return ret_val

    def flash_erase_all_unsecure(self) -&gt; bool:
        &#34;&#34;&#34;Erase complete flash memory and recover flash security section.

        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(&#39;CMD: FlashEraseAllUnsecure&#39;)
        cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_ALL_UNSECURE, 0)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def efuse_read_once(self, index: int) -&gt; Optional[int]:
        &#34;&#34;&#34;Read from MCU flash program once region.

        :param index: Start index
        :return: read value (32-bit int); None if operation failed
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashReadOnce(index={index})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_READ_ONCE, 0, index, 4)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.values[0] if cmd_response.status == StatusCode.SUCCESS else None

    def efuse_program_once(self, index: int, value: int) -&gt; bool:
        &#34;&#34;&#34;Write into MCU once program region (OCOTP).

        :param index: Start index
        :param value: Int value (4 bytes long)
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashProgramOnce(index={index}, value=0x{value:X})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_PROGRAM_ONCE, 0, index, 4, value)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def flash_read_once(self, index: int, count: int = 4) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Read from MCU flash program once region (max 8 bytes).

        :param index: Start index
        :param count: Count of bytes
        :return: Data read; None in case of an failure
        &#34;&#34;&#34;
        assert count in (4, 8)
        logger.info(f&#34;CMD: FlashReadOnce(index={index}, bytes={count})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_READ_ONCE, 0, index, count)
        cmd_response = self._process_cmd(cmd_packet)
        return cmd_response.data if cmd_response.status == StatusCode.SUCCESS else None

    def flash_program_once(self, index: int, data: bytes) -&gt; bool:
        &#34;&#34;&#34;Write into MCU flash program once region (max 8 bytes).

        :param index: Start index
        :param data: Input data aligned to 4 or 8 bytes
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        assert len(data) in (4, 8)
        logger.info(f&#34;CMD: FlashProgramOnce(index={index!r}, data={data!r})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_PROGRAM_ONCE, 0, index, len(data), data=data)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def flash_read_resource(self, address: int, length: int, option: int = 1) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Read resource of flash module.

        :param address: Start address
        :param length: Number of bytes
        :param option:
        :return: Data from the resource; None in case of an failure
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: FlashReadResource(address=0x{address:08X}, length={length}, option={option})&#34;)
        cmd_packet = CmdPacket(CommandTag.FLASH_READ_RESOURCE, 0, address, length, option)
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.FLASH_READ_RESOURCE, cmd_response.length)
        return None

    def configure_memory(self, address: int, mem_id: ExtMemId) -&gt; bool:
        &#34;&#34;&#34;Configure memory.

        :param address: The address in memory where are locating configuration data
        :param mem_id: External memory ID
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ConfigureMemory({ExtMemId.name(mem_id)}, address=0x{address:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.CONFIGURE_MEMORY, 0, mem_id, address)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def reliable_update(self, address: int) -&gt; bool:
        &#34;&#34;&#34;Reliable Update.

        :param address: Address where new the firmware is stored
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: ReliableUpdate(address=0x{address:08X})&#34;)
        cmd_packet = CmdPacket(CommandTag.RELIABLE_UPDATE, 0, address)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def generate_key_blob(self, dek_data: bytes, count: int = 72) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Generate Key Blob.

        :param dek_data: Data Encryption Key as bytes
        :param count: Key blob count (default: 72 - AES128bit)
        :return: Key blob; None in case of an failure
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: GenerateKeyBlob(dek_len={len(dek_data)}, count={count})&#34;)
        data_chunks = self._split_data(data=dek_data)
        cmd_response = self._process_cmd(CmdPacket(CommandTag.GENERATE_KEY_BLOB, 1, 0, len(dek_data), 0))
        if cmd_response.status != StatusCode.SUCCESS:
            return None
        if not self._send_data(CommandTag.GENERATE_KEY_BLOB, data_chunks):
            return None
        cmd_response = self._process_cmd(CmdPacket(CommandTag.GENERATE_KEY_BLOB, 0, 0, count, 1))
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.GENERATE_KEY_BLOB, cmd_response.length)
        return None

    def kp_enroll(self) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Enroll Command (start PUF).

        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(&#34;CMD: [KeyProvisioning] Enroll&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.ENROLL)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_set_intrinsic_key(self, key_type: int, key_size: int) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Generate Intrinsic Key.

        :param key_type: Type of the key
        :param key_size: Size of the key
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] SetIntrinsicKey(type={key_type}, key_size={key_size})&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.SET_INTRINSIC_KEY, key_type, key_size)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_write_nonvolatile(self, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Write the key to a nonvolatile memory.

        :param mem_id: The memory ID (default: 0)
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] WriteNonVolatileMemory(mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.WRITE_NON_VOLATILE, mem_id)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_read_nonvolatile(self, mem_id: int = 0) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Load the key from a nonvolatile memory to bootloader.

        :param mem_id: The memory ID (default: 0)
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] ReadNonVolatileMemory(mem_id={mem_id})&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.READ_NON_VOLATILE, mem_id)
        return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS

    def kp_set_user_key(self, key_type: KeyProvUserKeyType, key_data: bytes) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Send the user key specified by &lt;key_type&gt; to bootloader.

        :param key_type: type of the user key, see enumeration for details
        :param key_data: binary content of the user key
        :return: False in case of any problem; True otherwise
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] SetUserKey(key_type={KeyProvUserKeyType.name(key_type)}, &#34;
                    f&#34;key_len={len(key_data)})&#34;)
        data_chunks = self._split_data(data=key_data)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 1, KeyProvOperation.SET_USER_KEY, key_type, len(key_data))
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.KEY_PROVISIONING, data_chunks)
        return False

    def kp_write_key_store(self, key_data: bytes) -&gt; bool:
        &#34;&#34;&#34;Key provisioning: Write key data into key store area.

        :param key_data: key store binary content to be written to processor
        :return: result of the operation; True means success
        &#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] WriteKeyStore(key_len={len(key_data)})&#34;)
        data_chunks = self._split_data(data=key_data)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 1, KeyProvOperation.WRITE_KEY_STORE, 0, len(key_data))
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._send_data(CommandTag.KEY_PROVISIONING, data_chunks)
        return False

    def kp_read_key_store(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Key provisioning: Read key data from key store area.&#34;&#34;&#34;
        logger.info(f&#34;CMD: [KeyProvisioning] ReadKeyStore&#34;)
        cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.READ_KEY_STORE)
        cmd_response = self._process_cmd(cmd_packet)
        if cmd_response.status == StatusCode.SUCCESS:
            return self._read_data(CommandTag.KEY_PROVISIONING, cmd_response.length)
        return None</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.mboot.mcuboot.McuBoot.is_opened"><code class="name">var <span class="ident">is_opened</span> : bool</code></dt>
<dd>
<div class="desc"><p>:return: True if the device is open.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_opened(self) -&gt; bool:
    &#34;&#34;&#34;:return: True if the device is open.&#34;&#34;&#34;
    return self._device.is_opened</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.status_code"><code class="name">var <span class="ident">status_code</span> : <a title="spsdk.mboot.error_codes.StatusCode" href="error_codes.html#spsdk.mboot.error_codes.StatusCode">StatusCode</a></code></dt>
<dd>
<div class="desc"><p>:return: status code of the last operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status_code(self) -&gt; StatusCode:
    &#34;&#34;&#34;:return: status code of the last operation.&#34;&#34;&#34;
    return self._status_code</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.mboot.mcuboot.McuBoot.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, address: int, argument: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Fill MCU memory with specified pattern.</p>
<p>:param address: Call address (must be word aligned)
:param argument: Function arguments address
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, address: int, argument: int) -&gt; bool:
    &#34;&#34;&#34;Fill MCU memory with specified pattern.

    :param address: Call address (must be word aligned)
    :param argument: Function arguments address
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: Call(address=0x{address:08X}, argument=0x{argument:08X})&#34;)
    cmd_packet = CmdPacket(CommandTag.CALL, 0, address, argument)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;Disconnect from the device.&#34;&#34;&#34;
    self._device.close()</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.configure_memory"><code class="name flex">
<span>def <span class="ident">configure_memory</span></span>(<span>self, address: int, mem_id: <a title="spsdk.mboot.memories.ExtMemId" href="memories.html#spsdk.mboot.memories.ExtMemId">ExtMemId</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Configure memory.</p>
<p>:param address: The address in memory where are locating configuration data
:param mem_id: External memory ID
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_memory(self, address: int, mem_id: ExtMemId) -&gt; bool:
    &#34;&#34;&#34;Configure memory.

    :param address: The address in memory where are locating configuration data
    :param mem_id: External memory ID
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: ConfigureMemory({ExtMemId.name(mem_id)}, address=0x{address:08X})&#34;)
    cmd_packet = CmdPacket(CommandTag.CONFIGURE_MEMORY, 0, mem_id, address)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.efuse_program_once"><code class="name flex">
<span>def <span class="ident">efuse_program_once</span></span>(<span>self, index: int, value: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Write into MCU once program region (OCOTP).</p>
<p>:param index: Start index
:param value: Int value (4 bytes long)
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efuse_program_once(self, index: int, value: int) -&gt; bool:
    &#34;&#34;&#34;Write into MCU once program region (OCOTP).

    :param index: Start index
    :param value: Int value (4 bytes long)
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: FlashProgramOnce(index={index}, value=0x{value:X})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_PROGRAM_ONCE, 0, index, 4, value)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.efuse_read_once"><code class="name flex">
<span>def <span class="ident">efuse_read_once</span></span>(<span>self, index: int) ‑> Union[int, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Read from MCU flash program once region.</p>
<p>:param index: Start index
:return: read value (32-bit int); None if operation failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efuse_read_once(self, index: int) -&gt; Optional[int]:
    &#34;&#34;&#34;Read from MCU flash program once region.

    :param index: Start index
    :return: read value (32-bit int); None if operation failed
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: FlashReadOnce(index={index})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_READ_ONCE, 0, index, 4)
    cmd_response = self._process_cmd(cmd_packet)
    return cmd_response.values[0] if cmd_response.status == StatusCode.SUCCESS else None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, address: int, argument: int, sp: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute program on a given address using the stack pointer.</p>
<p>:param address: Jump address (must be word aligned)
:param argument: Function arguments address
:param sp: Stack pointer address
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, address: int, argument: int, sp: int) -&gt; bool:    # pylint: disable=invalid-name
    &#34;&#34;&#34;Execute program on a given address using the stack pointer.

    :param address: Jump address (must be word aligned)
    :param argument: Function arguments address
    :param sp: Stack pointer address
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: Execute(address=0x{address:08X}, argument=0x{argument:08X}, SP=0x{sp:08X})&#34;)
    cmd_packet = CmdPacket(CommandTag.EXECUTE, 0, address, argument, sp)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.fill_memory"><code class="name flex">
<span>def <span class="ident">fill_memory</span></span>(<span>self, address: int, length: int, pattern: int = 4294967295) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Fill MCU memory with specified pattern.</p>
<p>:param address: Start address (must be word aligned)
:param length: Count of words (must be word aligned)
:param pattern: Count of wrote bytes
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_memory(self, address: int, length: int, pattern: int = 0xFFFFFFFF) -&gt; bool:
    &#34;&#34;&#34;Fill MCU memory with specified pattern.

    :param address: Start address (must be word aligned)
    :param length: Count of words (must be word aligned)
    :param pattern: Count of wrote bytes
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: FillMemory(address=0x{address:08X}, length={length}, pattern=0x{pattern:08X})&#34;)
    cmd_packet = CmdPacket(CommandTag.FILL_MEMORY, 0, address, length, pattern)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_erase_all"><code class="name flex">
<span>def <span class="ident">flash_erase_all</span></span>(<span>self, mem_id: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Erase complete flash memory without recovering flash security section.</p>
<p>:param mem_id: Memory ID
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_erase_all(self, mem_id: int = 0) -&gt; bool:
    &#34;&#34;&#34;Erase complete flash memory without recovering flash security section.

    :param mem_id: Memory ID
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: FlashEraseAll(mem_id={mem_id})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_ALL, 0, mem_id)
    response = self._process_cmd(cmd_packet)
    assert isinstance(cmd_packet, GenericResponse)
    return response.status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_erase_all_unsecure"><code class="name flex">
<span>def <span class="ident">flash_erase_all_unsecure</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Erase complete flash memory and recover flash security section.</p>
<p>:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_erase_all_unsecure(self) -&gt; bool:
    &#34;&#34;&#34;Erase complete flash memory and recover flash security section.

    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(&#39;CMD: FlashEraseAllUnsecure&#39;)
    cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_ALL_UNSECURE, 0)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_erase_region"><code class="name flex">
<span>def <span class="ident">flash_erase_region</span></span>(<span>self, address: int, length: int, mem_id: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Erase specified range of flash.</p>
<p>:param address: Start address
:param length: Count of bytes
:param mem_id: Memory ID
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_erase_region(self, address: int, length: int, mem_id: int = 0) -&gt; bool:
    &#34;&#34;&#34;Erase specified range of flash.

    :param address: Start address
    :param length: Count of bytes
    :param mem_id: Memory ID
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: FlashEraseRegion(address=0x{address:08X}, length={length}, mem_id={mem_id})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_ERASE_REGION, 0, address, length, mem_id)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_program_once"><code class="name flex">
<span>def <span class="ident">flash_program_once</span></span>(<span>self, index: int, data: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Write into MCU flash program once region (max 8 bytes).</p>
<p>:param index: Start index
:param data: Input data aligned to 4 or 8 bytes
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_program_once(self, index: int, data: bytes) -&gt; bool:
    &#34;&#34;&#34;Write into MCU flash program once region (max 8 bytes).

    :param index: Start index
    :param data: Input data aligned to 4 or 8 bytes
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    assert len(data) in (4, 8)
    logger.info(f&#34;CMD: FlashProgramOnce(index={index!r}, data={data!r})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_PROGRAM_ONCE, 0, index, len(data), data=data)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_read_once"><code class="name flex">
<span>def <span class="ident">flash_read_once</span></span>(<span>self, index: int, count: int = 4) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Read from MCU flash program once region (max 8 bytes).</p>
<p>:param index: Start index
:param count: Count of bytes
:return: Data read; None in case of an failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_read_once(self, index: int, count: int = 4) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Read from MCU flash program once region (max 8 bytes).

    :param index: Start index
    :param count: Count of bytes
    :return: Data read; None in case of an failure
    &#34;&#34;&#34;
    assert count in (4, 8)
    logger.info(f&#34;CMD: FlashReadOnce(index={index}, bytes={count})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_READ_ONCE, 0, index, count)
    cmd_response = self._process_cmd(cmd_packet)
    return cmd_response.data if cmd_response.status == StatusCode.SUCCESS else None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_read_resource"><code class="name flex">
<span>def <span class="ident">flash_read_resource</span></span>(<span>self, address: int, length: int, option: int = 1) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Read resource of flash module.</p>
<p>:param address: Start address
:param length: Number of bytes
:param option:
:return: Data from the resource; None in case of an failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_read_resource(self, address: int, length: int, option: int = 1) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Read resource of flash module.

    :param address: Start address
    :param length: Number of bytes
    :param option:
    :return: Data from the resource; None in case of an failure
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: FlashReadResource(address=0x{address:08X}, length={length}, option={option})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_READ_RESOURCE, 0, address, length, option)
    cmd_response = self._process_cmd(cmd_packet)
    if cmd_response.status == StatusCode.SUCCESS:
        return self._read_data(CommandTag.FLASH_READ_RESOURCE, cmd_response.length)
    return None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.flash_security_disable"><code class="name flex">
<span>def <span class="ident">flash_security_disable</span></span>(<span>self, backdoor_key: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Disable flash security by using of backdoor key.</p>
<p>:param backdoor_key: The key value as array of 8 bytes
:return: False in case of any problem; True otherwise
:raises ValueError: If the backdoor_key is not 8 bytes long</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash_security_disable(self, backdoor_key: bytes) -&gt; bool:
    &#34;&#34;&#34;Disable flash security by using of backdoor key.

    :param backdoor_key: The key value as array of 8 bytes
    :return: False in case of any problem; True otherwise
    :raises ValueError: If the backdoor_key is not 8 bytes long
    &#34;&#34;&#34;
    if len(backdoor_key) != 8:
        raise ValueError(&#39;Backdoor key must by 8 bytes long&#39;)
    logger.info(f&#34;CMD: FlashSecurityDisable(backdoor_key={backdoor_key!r})&#34;)
    cmd_packet = CmdPacket(CommandTag.FLASH_SECURITY_DISABLE, 0, data=backdoor_key)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.generate_key_blob"><code class="name flex">
<span>def <span class="ident">generate_key_blob</span></span>(<span>self, dek_data: bytes, count: int = 72) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Key Blob.</p>
<p>:param dek_data: Data Encryption Key as bytes
:param count: Key blob count (default: 72 - AES128bit)
:return: Key blob; None in case of an failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_key_blob(self, dek_data: bytes, count: int = 72) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Generate Key Blob.

    :param dek_data: Data Encryption Key as bytes
    :param count: Key blob count (default: 72 - AES128bit)
    :return: Key blob; None in case of an failure
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: GenerateKeyBlob(dek_len={len(dek_data)}, count={count})&#34;)
    data_chunks = self._split_data(data=dek_data)
    cmd_response = self._process_cmd(CmdPacket(CommandTag.GENERATE_KEY_BLOB, 1, 0, len(dek_data), 0))
    if cmd_response.status != StatusCode.SUCCESS:
        return None
    if not self._send_data(CommandTag.GENERATE_KEY_BLOB, data_chunks):
        return None
    cmd_response = self._process_cmd(CmdPacket(CommandTag.GENERATE_KEY_BLOB, 0, 0, count, 1))
    if cmd_response.status == StatusCode.SUCCESS:
        return self._read_data(CommandTag.GENERATE_KEY_BLOB, cmd_response.length)
    return None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.get_memory_list"><code class="name flex">
<span>def <span class="ident">get_memory_list</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of embedded memories.</p>
<p>:return: dict, with the following keys: internal_flash (optional) - dictionary,
internal_ram (optional) - dictionary, external_mems (optional) - list
:raises McuBootCommandError: Error reading the memory list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_memory_list(self) -&gt; dict:
    &#34;&#34;&#34;Get list of embedded memories.

    :return: dict, with the following keys: internal_flash (optional) - dictionary,
            internal_ram (optional) - dictionary, external_mems (optional) - list
    :raises McuBootCommandError: Error reading the memory list
    &#34;&#34;&#34;
    memory_list: Dict[str, Any] = {}
    # Internal FLASH
    mdata = self._get_internal_flash()
    if mdata:
        memory_list[&#39;internal_flash&#39;] = mdata

    # Internal RAM
    mdata = self._get_internal_ram()
    if mdata:
        memory_list[&#39;internal_ram&#39;] = mdata

    # External Memories
    ext_mem_list = self._get_ext_memories()
    if ext_mem_list:
        memory_list[&#39;external_mems&#39;] = ext_mem_list

    self._status_code = StatusCode.SUCCESS
    if not memory_list:
        self._status_code = StatusCode.FAIL
        if self._cmd_exception:
            raise McuBootCommandError(&#39;GetMemoryList&#39;, self.status_code)

    return memory_list</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.get_property"><code class="name flex">
<span>def <span class="ident">get_property</span></span>(<span>self, prop_tag: <a title="spsdk.mboot.properties.PropertyTag" href="properties.html#spsdk.mboot.properties.PropertyTag">PropertyTag</a>, index: int = 0) ‑> Union[List[int], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get specified property value.</p>
<p>:param prop_tag: Property TAG (see Properties Enum)
:param index: External memory ID or internal memory region index (depends on property type)
:return: list integers representing the property; None in case no response from device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_property(self, prop_tag: PropertyTag, index: int = 0) -&gt; Optional[List[int]]:
    &#34;&#34;&#34;Get specified property value.

    :param prop_tag: Property TAG (see Properties Enum)
    :param index: External memory ID or internal memory region index (depends on property type)
    :return: list integers representing the property; None in case no response from device
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: GetProperty({PropertyTag.name(prop_tag)!r}, index={index!r})&#34;)
    cmd_packet = CmdPacket(CommandTag.GET_PROPERTY, 0, prop_tag, index)
    cmd_response = self._process_cmd(cmd_packet)
    return cmd_response.values if cmd_response.status == StatusCode.SUCCESS else None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.get_property_list"><code class="name flex">
<span>def <span class="ident">get_property_list</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of available properties.</p>
<p>:return: List of available properties.
:raises McuBootCommandError: Failure to read properties list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_property_list(self) -&gt; list:
    &#34;&#34;&#34;Get a list of available properties.

    :return: List of available properties.
    :raises McuBootCommandError: Failure to read properties list
    &#34;&#34;&#34;
    property_list: List[Any] = []
    for tag in PropertyTag.tags():
        try:
            values = self.get_property(tag)
        except McuBootCommandError:
            continue

        if values:
            property_list.append(parse_property_value(tag, values))

    self._status_code = StatusCode.SUCCESS
    if not property_list:
        self._status_code = StatusCode.FAIL
        if self._cmd_exception:
            raise McuBootCommandError(&#39;GetPropertyList&#39;, self.status_code)

    return property_list</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_enroll"><code class="name flex">
<span>def <span class="ident">kp_enroll</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Enroll Command (start PUF).</p>
<p>:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_enroll(self) -&gt; bool:
    &#34;&#34;&#34;Key provisioning: Enroll Command (start PUF).

    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(&#34;CMD: [KeyProvisioning] Enroll&#34;)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.ENROLL)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_read_key_store"><code class="name flex">
<span>def <span class="ident">kp_read_key_store</span></span>(<span>self) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Read key data from key store area.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_read_key_store(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Key provisioning: Read key data from key store area.&#34;&#34;&#34;
    logger.info(f&#34;CMD: [KeyProvisioning] ReadKeyStore&#34;)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.READ_KEY_STORE)
    cmd_response = self._process_cmd(cmd_packet)
    if cmd_response.status == StatusCode.SUCCESS:
        return self._read_data(CommandTag.KEY_PROVISIONING, cmd_response.length)
    return None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_read_nonvolatile"><code class="name flex">
<span>def <span class="ident">kp_read_nonvolatile</span></span>(<span>self, mem_id: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Load the key from a nonvolatile memory to bootloader.</p>
<p>:param mem_id: The memory ID (default: 0)
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_read_nonvolatile(self, mem_id: int = 0) -&gt; bool:
    &#34;&#34;&#34;Key provisioning: Load the key from a nonvolatile memory to bootloader.

    :param mem_id: The memory ID (default: 0)
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: [KeyProvisioning] ReadNonVolatileMemory(mem_id={mem_id})&#34;)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.READ_NON_VOLATILE, mem_id)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_set_intrinsic_key"><code class="name flex">
<span>def <span class="ident">kp_set_intrinsic_key</span></span>(<span>self, key_type: int, key_size: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Generate Intrinsic Key.</p>
<p>:param key_type: Type of the key
:param key_size: Size of the key
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_set_intrinsic_key(self, key_type: int, key_size: int) -&gt; bool:
    &#34;&#34;&#34;Key provisioning: Generate Intrinsic Key.

    :param key_type: Type of the key
    :param key_size: Size of the key
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: [KeyProvisioning] SetIntrinsicKey(type={key_type}, key_size={key_size})&#34;)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.SET_INTRINSIC_KEY, key_type, key_size)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_set_user_key"><code class="name flex">
<span>def <span class="ident">kp_set_user_key</span></span>(<span>self, key_type: <a title="spsdk.mboot.commands.KeyProvUserKeyType" href="commands.html#spsdk.mboot.commands.KeyProvUserKeyType">KeyProvUserKeyType</a>, key_data: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Send the user key specified by <key_type> to bootloader.</p>
<p>:param key_type: type of the user key, see enumeration for details
:param key_data: binary content of the user key
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_set_user_key(self, key_type: KeyProvUserKeyType, key_data: bytes) -&gt; bool:
    &#34;&#34;&#34;Key provisioning: Send the user key specified by &lt;key_type&gt; to bootloader.

    :param key_type: type of the user key, see enumeration for details
    :param key_data: binary content of the user key
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: [KeyProvisioning] SetUserKey(key_type={KeyProvUserKeyType.name(key_type)}, &#34;
                f&#34;key_len={len(key_data)})&#34;)
    data_chunks = self._split_data(data=key_data)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 1, KeyProvOperation.SET_USER_KEY, key_type, len(key_data))
    cmd_response = self._process_cmd(cmd_packet)
    if cmd_response.status == StatusCode.SUCCESS:
        return self._send_data(CommandTag.KEY_PROVISIONING, data_chunks)
    return False</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_write_key_store"><code class="name flex">
<span>def <span class="ident">kp_write_key_store</span></span>(<span>self, key_data: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Write key data into key store area.</p>
<p>:param key_data: key store binary content to be written to processor
:return: result of the operation; True means success</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_write_key_store(self, key_data: bytes) -&gt; bool:
    &#34;&#34;&#34;Key provisioning: Write key data into key store area.

    :param key_data: key store binary content to be written to processor
    :return: result of the operation; True means success
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: [KeyProvisioning] WriteKeyStore(key_len={len(key_data)})&#34;)
    data_chunks = self._split_data(data=key_data)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 1, KeyProvOperation.WRITE_KEY_STORE, 0, len(key_data))
    cmd_response = self._process_cmd(cmd_packet)
    if cmd_response.status == StatusCode.SUCCESS:
        return self._send_data(CommandTag.KEY_PROVISIONING, data_chunks)
    return False</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.kp_write_nonvolatile"><code class="name flex">
<span>def <span class="ident">kp_write_nonvolatile</span></span>(<span>self, mem_id: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Key provisioning: Write the key to a nonvolatile memory.</p>
<p>:param mem_id: The memory ID (default: 0)
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kp_write_nonvolatile(self, mem_id: int = 0) -&gt; bool:
    &#34;&#34;&#34;Key provisioning: Write the key to a nonvolatile memory.

    :param mem_id: The memory ID (default: 0)
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: [KeyProvisioning] WriteNonVolatileMemory(mem_id={mem_id})&#34;)
    cmd_packet = CmdPacket(CommandTag.KEY_PROVISIONING, 0, KeyProvOperation.WRITE_NON_VOLATILE, mem_id)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;Connect to the device.&#34;&#34;&#34;
    if not self._device.is_opened:
        logger.info(f&#34;Connect: {self._device.info()}&#34;)
        self._device.open()</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.read_memory"><code class="name flex">
<span>def <span class="ident">read_memory</span></span>(<span>self, address: int, length: int, mem_id: int = 0) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Read data from MCU memory.</p>
<p>:param address: Start address
:param length: Count of bytes
:param mem_id: Memory ID
:return: Data read from the memory; None in case of a failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_memory(self, address: int, length: int, mem_id: int = 0) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Read data from MCU memory.

    :param address: Start address
    :param length: Count of bytes
    :param mem_id: Memory ID
    :return: Data read from the memory; None in case of a failure
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: ReadMemory(address=0x{address:08X}, length={length}, mem_id={mem_id})&#34;)
    cmd_packet = CmdPacket(CommandTag.READ_MEMORY, 0, address, length, mem_id)
    cmd_response = self._process_cmd(cmd_packet)
    if cmd_response.status == StatusCode.SUCCESS:
        return self._read_data(CommandTag.READ_MEMORY, cmd_response.length)
    return None</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.receive_sb_file"><code class="name flex">
<span>def <span class="ident">receive_sb_file</span></span>(<span>self, data: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Receive SB file.</p>
<p>:param
data: SB file data
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive_sb_file(self, data: bytes) -&gt; bool:
    &#34;&#34;&#34;Receive SB file.

    :param  data: SB file data
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: ReceiveSBfile(data_length={len(data)})&#34;)
    data_chunks = self._split_data(data=data)
    cmd_packet = CmdPacket(CommandTag.RECEIVE_SB_FILE, 1, len(data))
    cmd_response = self._process_cmd(cmd_packet)
    if cmd_response.status == StatusCode.SUCCESS:
        return self._send_data(CommandTag.RECEIVE_SB_FILE, data_chunks)
    return False</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.reliable_update"><code class="name flex">
<span>def <span class="ident">reliable_update</span></span>(<span>self, address: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Reliable Update.</p>
<p>:param address: Address where new the firmware is stored
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reliable_update(self, address: int) -&gt; bool:
    &#34;&#34;&#34;Reliable Update.

    :param address: Address where new the firmware is stored
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: ReliableUpdate(address=0x{address:08X})&#34;)
    cmd_packet = CmdPacket(CommandTag.RELIABLE_UPDATE, 0, address)
    return self._process_cmd(cmd_packet).status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, timeout: int = 2000, reopen: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Reset MCU and reconnect if enabled.</p>
<p>:param timeout: The maximal waiting time in [ms] for reopen connection
:param reopen: True for reopen connection after HW reset else False
:return: False in case of any problem; True otherwise
:raise ValueError: if reopen is not supported
:raise McuBootConnectionError: Failure to reopen the device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, timeout: int = 2000, reopen: bool = True) -&gt; bool:
    &#34;&#34;&#34;Reset MCU and reconnect if enabled.

    :param timeout: The maximal waiting time in [ms] for reopen connection
    :param reopen: True for reopen connection after HW reset else False
    :return: False in case of any problem; True otherwise
    :raise ValueError: if reopen is not supported
    :raise McuBootConnectionError: Failure to reopen the device
    &#34;&#34;&#34;
    logger.info(&#39;CMD: Reset MCU&#39;)
    cmd_packet = CmdPacket(CommandTag.RESET, 0)
    ret_val = False
    if self._process_cmd(cmd_packet).status == StatusCode.SUCCESS:
        self._device.close()
        ret_val = True
        if reopen:
            if not self.reopen:
                raise ValueError(&#39;reopen is not supported&#39;)
            time.sleep(timeout / 1000)
            try:
                self._device.open()
            except SPSDKError:
                ret_val = False
                if self._cmd_exception:
                    raise McuBootConnectionError(&#39;reopen failed&#39;)
    return ret_val</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.set_property"><code class="name flex">
<span>def <span class="ident">set_property</span></span>(<span>self, prop_tag: <a title="spsdk.mboot.properties.PropertyTag" href="properties.html#spsdk.mboot.properties.PropertyTag">PropertyTag</a>, value: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Set value of specified property.</p>
<p>:param
prop_tag: Property TAG (see Property enumerator)
:param
value: The value of selected property
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_property(self, prop_tag: PropertyTag, value: int) -&gt; bool:
    &#34;&#34;&#34;Set value of specified property.

    :param  prop_tag: Property TAG (see Property enumerator)
    :param  value: The value of selected property
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: SetProperty({PropertyTag.name(prop_tag)}, value=0x{value:08X})&#34;)
    cmd_packet = CmdPacket(CommandTag.SET_PROPERTY, 0, prop_tag, value)
    cmd_response = self._process_cmd(cmd_packet)
    return cmd_response.status == StatusCode.SUCCESS</code></pre>
</details>
</dd>
<dt id="spsdk.mboot.mcuboot.McuBoot.write_memory"><code class="name flex">
<span>def <span class="ident">write_memory</span></span>(<span>self, address: int, data: bytes, mem_id: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Write data into MCU memory.</p>
<p>:param address: Start address
:param data: List of bytes
:param mem_id: Memory ID, see ExtMemId; additionally use <code>0</code> for internal memory
:return: False in case of any problem; True otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_memory(self, address: int, data: bytes, mem_id: int = 0) -&gt; bool:
    &#34;&#34;&#34;Write data into MCU memory.

    :param address: Start address
    :param data: List of bytes
    :param mem_id: Memory ID, see ExtMemId; additionally use `0` for internal memory
    :return: False in case of any problem; True otherwise
    &#34;&#34;&#34;
    logger.info(f&#34;CMD: WriteMemory(address=0x{address:08X}, length={len(data)}, mem_id={mem_id})&#34;)
    data_chunks = self._split_data(data=data)
    cmd_packet = CmdPacket(CommandTag.WRITE_MEMORY, 0, address, len(data), mem_id)
    if self._process_cmd(cmd_packet).status == StatusCode.SUCCESS:
        return self._send_data(CommandTag.WRITE_MEMORY, data_chunks)
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.mboot" href="index.html">spsdk.mboot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.mboot.mcuboot.McuBoot" href="#spsdk.mboot.mcuboot.McuBoot">McuBoot</a></code></h4>
<ul class="">
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.call" href="#spsdk.mboot.mcuboot.McuBoot.call">call</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.close" href="#spsdk.mboot.mcuboot.McuBoot.close">close</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.configure_memory" href="#spsdk.mboot.mcuboot.McuBoot.configure_memory">configure_memory</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.efuse_program_once" href="#spsdk.mboot.mcuboot.McuBoot.efuse_program_once">efuse_program_once</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.efuse_read_once" href="#spsdk.mboot.mcuboot.McuBoot.efuse_read_once">efuse_read_once</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.execute" href="#spsdk.mboot.mcuboot.McuBoot.execute">execute</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.fill_memory" href="#spsdk.mboot.mcuboot.McuBoot.fill_memory">fill_memory</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_erase_all" href="#spsdk.mboot.mcuboot.McuBoot.flash_erase_all">flash_erase_all</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_erase_all_unsecure" href="#spsdk.mboot.mcuboot.McuBoot.flash_erase_all_unsecure">flash_erase_all_unsecure</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_erase_region" href="#spsdk.mboot.mcuboot.McuBoot.flash_erase_region">flash_erase_region</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_program_once" href="#spsdk.mboot.mcuboot.McuBoot.flash_program_once">flash_program_once</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_read_once" href="#spsdk.mboot.mcuboot.McuBoot.flash_read_once">flash_read_once</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_read_resource" href="#spsdk.mboot.mcuboot.McuBoot.flash_read_resource">flash_read_resource</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.flash_security_disable" href="#spsdk.mboot.mcuboot.McuBoot.flash_security_disable">flash_security_disable</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.generate_key_blob" href="#spsdk.mboot.mcuboot.McuBoot.generate_key_blob">generate_key_blob</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.get_memory_list" href="#spsdk.mboot.mcuboot.McuBoot.get_memory_list">get_memory_list</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.get_property" href="#spsdk.mboot.mcuboot.McuBoot.get_property">get_property</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.get_property_list" href="#spsdk.mboot.mcuboot.McuBoot.get_property_list">get_property_list</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.is_opened" href="#spsdk.mboot.mcuboot.McuBoot.is_opened">is_opened</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_enroll" href="#spsdk.mboot.mcuboot.McuBoot.kp_enroll">kp_enroll</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_read_key_store" href="#spsdk.mboot.mcuboot.McuBoot.kp_read_key_store">kp_read_key_store</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_read_nonvolatile" href="#spsdk.mboot.mcuboot.McuBoot.kp_read_nonvolatile">kp_read_nonvolatile</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_set_intrinsic_key" href="#spsdk.mboot.mcuboot.McuBoot.kp_set_intrinsic_key">kp_set_intrinsic_key</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_set_user_key" href="#spsdk.mboot.mcuboot.McuBoot.kp_set_user_key">kp_set_user_key</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_write_key_store" href="#spsdk.mboot.mcuboot.McuBoot.kp_write_key_store">kp_write_key_store</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.kp_write_nonvolatile" href="#spsdk.mboot.mcuboot.McuBoot.kp_write_nonvolatile">kp_write_nonvolatile</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.open" href="#spsdk.mboot.mcuboot.McuBoot.open">open</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.read_memory" href="#spsdk.mboot.mcuboot.McuBoot.read_memory">read_memory</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.receive_sb_file" href="#spsdk.mboot.mcuboot.McuBoot.receive_sb_file">receive_sb_file</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.reliable_update" href="#spsdk.mboot.mcuboot.McuBoot.reliable_update">reliable_update</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.reset" href="#spsdk.mboot.mcuboot.McuBoot.reset">reset</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.set_property" href="#spsdk.mboot.mcuboot.McuBoot.set_property">set_property</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.status_code" href="#spsdk.mboot.mcuboot.McuBoot.status_code">status_code</a></code></li>
<li><code><a title="spsdk.mboot.mcuboot.McuBoot.write_memory" href="#spsdk.mboot.mcuboot.McuBoot.write_memory">write_memory</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>