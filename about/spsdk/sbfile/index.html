<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.sbfile API documentation</title>
<meta name="description" content="Module implementing SBFile." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.sbfile</code></h1>
</header>
<section id="section-intro">
<p>Module implementing SBFile.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Module implementing SBFile.&#34;&#34;&#34;

from spsdk.mboot import ExtMemId
from spsdk.utils.crypto import crypto_backend, Certificate
from .commands import CmdNop, CmdErase, CmdLoad, CmdFill, CmdJump, CmdCall, CmdReset, CmdMemEnable, CmdProg, \
    CmdKeyStoreBackup, CmdKeyStoreRestore
from .commands import VersionCheckType, CmdVersionCheck
from .images import BootImageV20, BootImageV21, SBV2xAdvancedParams
from .misc import BcdVersion3
from .sb1.headers import SecureBootFlagsV1
from .sb1.images import SecureBootV1
from .sb1.sections import BootSectionV1
from .sections import BootSectionV2, CertSectionV2, CertBlockV2

__all__ = [
    # images
    &#39;BootImageV20&#39;,
    &#39;BootImageV21&#39;,
    # sections
    &#39;BootSectionV2&#39;,
    &#39;CertSectionV2&#39;,
    &#39;CertBlockV2&#39;,
    # commands
    &#39;CmdNop&#39;,
    &#39;CmdErase&#39;,
    &#39;CmdLoad&#39;,
    &#39;CmdFill&#39;,
    &#39;CmdJump&#39;,
    &#39;CmdCall&#39;,
    &#39;CmdReset&#39;,
    &#39;CmdMemEnable&#39;,
    &#39;CmdProg&#39;,
    &#39;CmdVersionCheck&#39;,
    &#39;CmdKeyStoreBackup&#39;,
    &#39;CmdKeyStoreRestore&#39;,
    # other types and enums
    &#39;SBV2xAdvancedParams&#39;,
    &#39;BcdVersion3&#39;,
    &#39;Certificate&#39;,
    &#39;VersionCheckType&#39;,
    &#39;ExtMemId&#39;,
    # functions
    &#39;crypto_backend&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="spsdk.sbfile.commands" href="commands.html">spsdk.sbfile.commands</a></code></dt>
<dd>
<div class="desc"><p>Commands used by SBFile module.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.headers" href="headers.html">spsdk.sbfile.headers</a></code></dt>
<dd>
<div class="desc"><p>Image header.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.images" href="images.html">spsdk.sbfile.images</a></code></dt>
<dd>
<div class="desc"><p>Boot Image V2.0, V2.1.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.misc" href="misc.html">spsdk.sbfile.misc</a></code></dt>
<dd>
<div class="desc"><p>Miscellaneous functions in SBFile module.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.sb1" href="sb1/index.html">spsdk.sbfile.sb1</a></code></dt>
<dd>
<div class="desc"><p>Module implementing SBFile version 1.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.sections" href="sections.html">spsdk.sbfile.sections</a></code></dt>
<dd>
<div class="desc"><p>Sections within SBfile.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spsdk.sbfile.crypto_backend"><code class="name flex">
<span>def <span class="ident">crypto_backend</span></span>(<span>) ‑> <a title="spsdk.utils.crypto.abstract.BackendClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BackendClass">BackendClass</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return default crypto backend instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crypto_backend() -&gt; BackendClass:
    &#34;&#34;&#34;Return default crypto backend instance.&#34;&#34;&#34;
    return openssl_backend</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.sbfile.BcdVersion3"><code class="flex name class">
<span>class <span class="ident">BcdVersion3</span></span>
<span>(</span><span>major: int = 1, minor: int = 0, service: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Version in format #.#.#, where # is BCD number (1-4 digits).</p>
<p>Initialize BcdVersion3.</p>
<p>:param major: number in BCD format, 1-4 decimal digits
:param minor: number in BCD format, 1-4 decimal digits
:param service: number in BCD format, 1-4 decimal digits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BcdVersion3:
    &#34;&#34;&#34;Version in format #.#.#, where # is BCD number (1-4 digits).&#34;&#34;&#34;

    # default value
    DEFAULT = &#39;999.999.999&#39;

    @staticmethod
    def _check_number(num: int) -&gt; bool:
        &#34;&#34;&#34;Check given number is a valid version number.

        :param num: to be checked
        :return: True if number format is valid
        :raise ValueError: if number format is not valid
        &#34;&#34;&#34;
        if not 0 &lt;= num &lt;= 0x9999:
            raise ValueError(&#39;Invalid number range&#39;)
        for index in range(4):
            if (num &gt;&gt; 4 * index) &amp; 0xF &gt; 0x9:
                raise ValueError(&#39;Invalid number, contains digit &gt; 9&#39;)
        return True

    @staticmethod
    def _num_from_str(text: str) -&gt; int:
        &#34;&#34;&#34;Converts BCD number from text to int.

        :param text: given string to be converted to a version number
        :return: version number
        :raise ValueError: if format is not valid
        &#34;&#34;&#34;
        assert 0 &lt;= len(text) &lt;= 4
        result = int(text, 16)
        BcdVersion3._check_number(result)
        return result

    @staticmethod
    def from_str(text: str) -&gt; &#39;BcdVersion3&#39;:
        &#34;&#34;&#34;Convert string to BcdVersion instance.

        :param text: version in format #.#.#, where # is 1-4 decimal digits
        :return: BcdVersion3 instance
        :raise: ValueError: if format is not valid
        &#34;&#34;&#34;
        parts = text.split(&#39;.&#39;)
        assert len(parts) == 3
        major = BcdVersion3._num_from_str(parts[0])
        minor = BcdVersion3._num_from_str(parts[1])
        service = BcdVersion3._num_from_str(parts[2])
        return BcdVersion3(major, minor, service)

    @staticmethod
    def to_version(input_version: BcdVersion3Format) -&gt; &#39;BcdVersion3&#39;:
        &#34;&#34;&#34;Convert different input formats into BcdVersion3 instance.

        :param input_version: either directly BcdVersion3 or string
        :raise ValueError: raises when the format is unsupported
        :return: BcdVersion3 instance
        &#34;&#34;&#34;
        if isinstance(input_version, BcdVersion3):
            return input_version
        if isinstance(input_version, str):
            return BcdVersion3.from_str(input_version)
        raise ValueError(&#39;unsupported format&#39;)

    def __init__(self, major: int = 1, minor: int = 0, service: int = 0):
        &#34;&#34;&#34;Initialize BcdVersion3.

        :param major: number in BCD format, 1-4 decimal digits
        :param minor: number in BCD format, 1-4 decimal digits
        :param service: number in BCD format, 1-4 decimal digits
        &#34;&#34;&#34;
        assert all([BcdVersion3._check_number(major), BcdVersion3._check_number(minor),
                    BcdVersion3._check_number(service)])
        self.major = major
        self.minor = minor
        self.service = service

    def __str__(self) -&gt; str:
        return f&#39;{self.major:X}.{self.minor:X}.{self.service:X}&#39;

    def __repr__(self) -&gt; str:
        return self.__class__.__name__ + &#39;: &#39; + self.__str__()

    def __eq__(self, other: Any) -&gt; bool:
        return (isinstance(other, BcdVersion3) and
                (self.major == other.major) and
                (self.minor == other.minor) and
                (self.service == other.service))

    @property
    def nums(self) -&gt; Sequence[int]:
        &#34;&#34;&#34;Return array of version numbers: [major, minor, service].&#34;&#34;&#34;
        return [self.major, self.minor, self.service]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.BcdVersion3.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.BcdVersion3.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>text: str) ‑> <a title="spsdk.sbfile.misc.BcdVersion3" href="misc.html#spsdk.sbfile.misc.BcdVersion3">BcdVersion3</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert string to BcdVersion instance.</p>
<p>:param text: version in format #.#.#, where # is 1-4 decimal digits
:return: BcdVersion3 instance
:raise: ValueError: if format is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_str(text: str) -&gt; &#39;BcdVersion3&#39;:
    &#34;&#34;&#34;Convert string to BcdVersion instance.

    :param text: version in format #.#.#, where # is 1-4 decimal digits
    :return: BcdVersion3 instance
    :raise: ValueError: if format is not valid
    &#34;&#34;&#34;
    parts = text.split(&#39;.&#39;)
    assert len(parts) == 3
    major = BcdVersion3._num_from_str(parts[0])
    minor = BcdVersion3._num_from_str(parts[1])
    service = BcdVersion3._num_from_str(parts[2])
    return BcdVersion3(major, minor, service)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BcdVersion3.to_version"><code class="name flex">
<span>def <span class="ident">to_version</span></span>(<span>input_version: Union[ForwardRef('<a title="spsdk.sbfile.BcdVersion3" href="#spsdk.sbfile.BcdVersion3">BcdVersion3</a>'), str]) ‑> <a title="spsdk.sbfile.misc.BcdVersion3" href="misc.html#spsdk.sbfile.misc.BcdVersion3">BcdVersion3</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert different input formats into BcdVersion3 instance.</p>
<p>:param input_version: either directly BcdVersion3 or string
:raise ValueError: raises when the format is unsupported
:return: BcdVersion3 instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_version(input_version: BcdVersion3Format) -&gt; &#39;BcdVersion3&#39;:
    &#34;&#34;&#34;Convert different input formats into BcdVersion3 instance.

    :param input_version: either directly BcdVersion3 or string
    :raise ValueError: raises when the format is unsupported
    :return: BcdVersion3 instance
    &#34;&#34;&#34;
    if isinstance(input_version, BcdVersion3):
        return input_version
    if isinstance(input_version, str):
        return BcdVersion3.from_str(input_version)
    raise ValueError(&#39;unsupported format&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.BcdVersion3.nums"><code class="name">var <span class="ident">nums</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Return array of version numbers: [major, minor, service].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nums(self) -&gt; Sequence[int]:
    &#34;&#34;&#34;Return array of version numbers: [major, minor, service].&#34;&#34;&#34;
    return [self.major, self.minor, self.service]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.BootImageV20"><code class="flex name class">
<span>class <span class="ident">BootImageV20</span></span>
<span>(</span><span>signed: bool, kek: bytes, *sections: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>, product_version: str = '1.0.0', component_version: str = '1.0.0', build_number: int = 0, advanced_params: <a title="spsdk.sbfile.images.SBV2xAdvancedParams" href="images.html#spsdk.sbfile.images.SBV2xAdvancedParams">SBV2xAdvancedParams</a> = &lt;spsdk.sbfile.images.SBV2xAdvancedParams object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Image V2.0 class.</p>
<p>Initialize Secure Boot Image V2.0.</p>
<p>:param signed: True if image is signed, False otherwise
:param kek: key for wrapping DEK and MAC keys
:param product_version: The product version (default: 1.0.0)
:param component_version: The component version (default: 1.0.0)
:param build_number: The build number value (default: 0)
:param advanced_params: Advanced parameters for encryption of the SB file, use for tests only
:param sections: Boot sections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImageV20(BaseClass):
    &#34;&#34;&#34;Boot Image V2.0 class.&#34;&#34;&#34;
    # Image specific data
    # size of the MAC key
    HEADER_MAC_SIZE = 32
    # AES encrypted DEK and MAC, including padding
    DEK_MAC_SIZE = 32 + 32 + 16

    KEY_BLOB_SIZE = 80

    def __init__(self, signed: bool, kek: bytes, *sections: BootSectionV2,
                 product_version: str = &#39;1.0.0&#39;, component_version: str = &#39;1.0.0&#39;,
                 build_number: int = 0, advanced_params: SBV2xAdvancedParams = SBV2xAdvancedParams()) -&gt; None:
        &#34;&#34;&#34;Initialize Secure Boot Image V2.0.

        :param signed: True if image is signed, False otherwise
        :param kek: key for wrapping DEK and MAC keys
        :param product_version: The product version (default: 1.0.0)
        :param component_version: The component version (default: 1.0.0)
        :param build_number: The build number value (default: 0)
        :param advanced_params: Advanced parameters for encryption of the SB file, use for tests only
        :param sections: Boot sections
        &#34;&#34;&#34;
        self._kek = kek
        # Set Flags value
        self._signed = signed
        self._private_key_pem_data: Optional[bytes] = None
        flags = 0x08 if self.signed else 0x04
        # Set private attributes
        self._dek: bytes = advanced_params.dek
        self._mac: bytes = advanced_params.mac
        assert len(self._dek) == self.HEADER_MAC_SIZE and len(self._mac) == self.HEADER_MAC_SIZE
        self._header = ImageHeaderV2(version=&#39;2.0&#39;, product_version=product_version,
                                     component_version=component_version, build_number=build_number, flags=flags,
                                     nonce=advanced_params.nonce, timestamp=advanced_params.timestamp)
        self._cert_section: Optional[CertSectionV2] = None
        self._boot_sections: List[BootSectionV2] = []
        # Generate nonce
        if self._header.nonce is None:
            nonce = bytearray(crypto_backend().random_bytes(16))
            # clear nonce bit at offsets 31 and 63
            nonce[9] &amp;= 0x7F
            nonce[13] &amp;= 0x7F
            self._header.nonce = bytes(nonce)
        # Sections
        for section in sections:
            self.add_boot_section(section)

    @property
    def header(self) -&gt; ImageHeaderV2:
        &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
        return self._header

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
        return self._mac

    @property
    def kek(self) -&gt; bytes:
        &#34;&#34;&#34;Return key for wrapping DEK and MAC keys.&#34;&#34;&#34;
        return self._kek

    @property
    def private_key_pem_data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Return private key data for signed images, decrypted in PEM format.&#34;&#34;&#34;
        return self._private_key_pem_data

    @private_key_pem_data.setter
    def private_key_pem_data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter to be used for signed images.

        :param: key for signing the image; decrypted binary data in PEM format
        &#34;&#34;&#34;
        self._private_key_pem_data = value

    @property
    def signed(self) -&gt; bool:
        &#34;&#34;&#34;Check whether sb is signed + encrypted or only encrypted.&#34;&#34;&#34;
        return self._signed

    @property
    def cert_block(self) -&gt; Optional[CertBlockV2]:
        &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
        cert_sect = self._cert_section
        if cert_sect is None:
            return None

        return cert_sect.cert_block

    @cert_block.setter
    def cert_block(self, value: Optional[CertBlockV2]) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: block to be assigned; None to remove previously assigned block
        &#34;&#34;&#34;
        if value is not None:
            assert self.signed, &#34;Certificate block cannot be used unless SB file is signed&#34;
        self._cert_section = CertSectionV2(value) if value else None

    @property
    def cert_header_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    @property
    def raw_size_without_signature(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size without signature, used to calculate image blocks.&#34;&#34;&#34;
        # Header, HMAC and KeyBlob
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        # Certificates Section
        if self.signed:
            size += self.DEK_MAC_SIZE
            cert_block = self.cert_block
            assert cert_block
            size += cert_block.raw_size
        # Boot Sections
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size.&#34;&#34;&#34;
        size = self.raw_size_without_signature

        if self.signed:
            cert_block = self.cert_block
            assert cert_block
            size += cert_block.signature_size

        return size

    def __str__(self) -&gt; str:
        return self.info()

    def __len__(self) -&gt; int:
        return len(self._boot_sections)

    def __getitem__(self, key: int) -&gt; BootSectionV2:
        return self._boot_sections[key]

    def __setitem__(self, key: int, value: BootSectionV2) -&gt; None:
        self._boot_sections[key] = value

    def __iter__(self) -&gt; Iterator[BootSectionV2]:
        return self._boot_sections.__iter__()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update boot image.&#34;&#34;&#34;
        if self._boot_sections:
            self._header.first_boot_section_id = self._boot_sections[0].uid
            # calculate first boot tag block
            data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            if self._cert_section is not None:
                data_size += self._cert_section.raw_size
            self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
        # ...
        self._header.flags = 0x08 if self.signed else 0x04
        self._header.image_blocks = calc_cypher_block_count(self.raw_size_without_signature)
        self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
        self._header.max_section_mac_count = 0
        if self.signed:
            self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            self._header.offset_to_certificate_block += CmdHeader.SIZE + CertSectionV2.HMAC_SIZE * 2
            self._header.max_section_mac_count = 1
        for boot_sect in self._boot_sections:
            boot_sect.is_last = True  # this is unified with elftosb
            self._header.max_section_mac_count += boot_sect.hmac_count
        # Update certificates block header
        cert_blk = self.cert_block
        if cert_blk is not None:
            cert_blk.header.build_number = self._header.build_number
            cert_blk.header.image_length = self.cert_header_size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        self.update()
        nfo = &#34;\n&#34;
        nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._header.info()
        if self._cert_section is not None:
            nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
            nfo += self._cert_section.info()
        nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
        for index, section in enumerate(self._boot_sections):
            nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
            nfo += section.info()
        return nfo

    def add_boot_section(self, section: BootSectionV2) -&gt; None:
        &#34;&#34;&#34;Add new Boot section into image.

        :param section: Boot section
        :raise TypeError: raised when section is not instance of BootSectionV2 class
        :raise ValueError: raise when boot section has duplicate UID
        &#34;&#34;&#34;
        if not isinstance(section, BootSectionV2):
            raise TypeError()
        duplicate_uid = find_first(self._boot_sections, lambda bs: bs.uid == section.uid)
        if duplicate_uid is not None:
            raise ValueError(f&#39;Boot section with duplicate UID: {str(section.uid)}&#39;)
        self._boot_sections.append(section)

    def export(self, padding: Optional[bytes] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize image object.

        :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
        :return: exported bytes
        :raise ValueError: raised when there are no boot sections or is not signed or private keys are missing
        &#34;&#34;&#34;
        assert len(self.dek) == 32 and len(self.mac) == 32
        # validate params
        if not self._boot_sections:
            raise ValueError(&#39;No boot section&#39;)
        if self.signed and (self._cert_section is None):
            raise ValueError(&#34;Certificate section is required for signed images&#34;)
        # update internals
        self.update()
        # Add Image Header data
        data = self._header.export(padding=padding)
        # Add Image Header HMAC data
        data += crypto_backend().hmac(self.mac, data)
        # Add DEK and MAC keys
        data += crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
        # Add Padding
        data += padding if padding else crypto_backend().random_bytes(8)
        # Add Certificates data
        assert self._header.nonce
        counter = Counter(self._header.nonce)
        counter.increment(calc_cypher_block_count(len(data)))
        if self._cert_section is not None:
            cert_sect_bin = self._cert_section.export(dek=self.dek, mac=self.mac, counter=counter)
            counter.increment(calc_cypher_block_count(len(cert_sect_bin)))
            data += cert_sect_bin
        # Add Boot Sections data
        for sect in self._boot_sections:
            data += sect.export(dek=self.dek, mac=self.mac, counter=counter)
        # Add Signature data
        if self.signed:
            private_key_pem_data = self.private_key_pem_data
            if private_key_pem_data is None:
                raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
            certificate_block = self.cert_block
            assert (certificate_block is not None) and certificate_block.verify_private_key(private_key_pem_data)
            data += crypto_backend().rsa_sign(private_key_pem_data, data)
        assert len(data) == self.raw_size
        return data

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes()) -&gt; &#39;BootImageV20&#39;:
        &#34;&#34;&#34;Parse image from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param kek: The Key for unwrapping DEK and MAC keys (required)
        :return: parsed image object
        :raise Exception: raised when header is in wrong format
        :raise Exception: raised when there is invalid header version
        :raise Exception: raised when signature is incorrect
        &#34;&#34;&#34;
        assert kek, &#39;kek cannot be empty&#39;
        index = offset
        header_raw_data = data[index: index + ImageHeaderV2.SIZE]
        index += ImageHeaderV2.SIZE
        header_mac_data = data[index: index + cls.HEADER_MAC_SIZE]
        index += cls.HEADER_MAC_SIZE
        key_blob = data[index: index + cls.KEY_BLOB_SIZE]
        index += cls.KEY_BLOB_SIZE
        key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
        dek = key_blob_unwrap[:32]
        mac = key_blob_unwrap[32:]
        header_mac_data_calc = crypto_backend().hmac(mac, header_raw_data)
        if header_mac_data != header_mac_data_calc:
            raise Exception()
        # Parse Header
        header = ImageHeaderV2.parse(header_raw_data)
        if header.version != &#39;2.0&#39;:
            raise Exception(f&#39;Invalid Header Version: {header.version} instead 2.0&#39;)
        image_size = header.image_blocks * 16
        # Initialize counter
        assert header.nonce
        counter = Counter(header.nonce)
        counter.increment(calc_cypher_block_count(index - offset))
        # ...
        signed = header.flags == 0x08
        adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
        obj = cls(signed,
                  kek=kek,
                  product_version=str(header.product_version),
                  component_version=str(header.component_version),
                  build_number=header.build_number,
                  advanced_params=adv_params)
        # Parse Certificate section
        if header.flags == 0x08:
            cert_sect = CertSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
            obj._cert_section = cert_sect
            index += cert_sect.raw_size
            # Check Signature
            if not cert_sect.cert_block.verify_data(data[offset + image_size:],
                                                    data[offset: offset + image_size]):
                raise Exception()
        # Parse Boot Sections
        while index &lt; (image_size + offset):
            boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
            obj.add_boot_section(boot_section)
            index += boot_section.raw_size
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV20.DEK_MAC_SIZE"><code class="name">var <span class="ident">DEK_MAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.BootImageV20.HEADER_MAC_SIZE"><code class="name">var <span class="ident">HEADER_MAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.BootImageV20.KEY_BLOB_SIZE"><code class="name">var <span class="ident">KEY_BLOB_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV20.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, kek: bytes = b'') ‑> <a title="spsdk.sbfile.images.BootImageV20" href="images.html#spsdk.sbfile.images.BootImageV20">BootImageV20</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from bytes.</p>
<p>:param data: Raw data of parsed image
:param offset: The offset of input data
:param kek: The Key for unwrapping DEK and MAC keys (required)
:return: parsed image object
:raise Exception: raised when header is in wrong format
:raise Exception: raised when there is invalid header version
:raise Exception: raised when signature is incorrect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes()) -&gt; &#39;BootImageV20&#39;:
    &#34;&#34;&#34;Parse image from bytes.

    :param data: Raw data of parsed image
    :param offset: The offset of input data
    :param kek: The Key for unwrapping DEK and MAC keys (required)
    :return: parsed image object
    :raise Exception: raised when header is in wrong format
    :raise Exception: raised when there is invalid header version
    :raise Exception: raised when signature is incorrect
    &#34;&#34;&#34;
    assert kek, &#39;kek cannot be empty&#39;
    index = offset
    header_raw_data = data[index: index + ImageHeaderV2.SIZE]
    index += ImageHeaderV2.SIZE
    header_mac_data = data[index: index + cls.HEADER_MAC_SIZE]
    index += cls.HEADER_MAC_SIZE
    key_blob = data[index: index + cls.KEY_BLOB_SIZE]
    index += cls.KEY_BLOB_SIZE
    key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
    dek = key_blob_unwrap[:32]
    mac = key_blob_unwrap[32:]
    header_mac_data_calc = crypto_backend().hmac(mac, header_raw_data)
    if header_mac_data != header_mac_data_calc:
        raise Exception()
    # Parse Header
    header = ImageHeaderV2.parse(header_raw_data)
    if header.version != &#39;2.0&#39;:
        raise Exception(f&#39;Invalid Header Version: {header.version} instead 2.0&#39;)
    image_size = header.image_blocks * 16
    # Initialize counter
    assert header.nonce
    counter = Counter(header.nonce)
    counter.increment(calc_cypher_block_count(index - offset))
    # ...
    signed = header.flags == 0x08
    adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
    obj = cls(signed,
              kek=kek,
              product_version=str(header.product_version),
              component_version=str(header.component_version),
              build_number=header.build_number,
              advanced_params=adv_params)
    # Parse Certificate section
    if header.flags == 0x08:
        cert_sect = CertSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
        obj._cert_section = cert_sect
        index += cert_sect.raw_size
        # Check Signature
        if not cert_sect.cert_block.verify_data(data[offset + image_size:],
                                                data[offset: offset + image_size]):
            raise Exception()
    # Parse Boot Sections
    while index &lt; (image_size + offset):
        boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
        obj.add_boot_section(boot_section)
        index += boot_section.raw_size
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV20.cert_block"><code class="name">var <span class="ident">cert_block</span> : Union[<a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return certificate block; None if SB file not signed or block not assigned yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_block(self) -&gt; Optional[CertBlockV2]:
    &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
    cert_sect = self._cert_section
    if cert_sect is None:
        return None

    return cert_sect.cert_block</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.cert_header_size"><code class="name">var <span class="ident">cert_header_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size (not aligned) for certificate header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_header_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
    for boot_section in self._boot_sections:
        size += boot_section.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.dek"><code class="name">var <span class="ident">dek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Data encryption key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek(self) -&gt; bytes:
    &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
    return self._dek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.sbfile.headers.ImageHeaderV2" href="headers.html#spsdk.sbfile.headers.ImageHeaderV2">ImageHeaderV2</a></code></dt>
<dd>
<div class="desc"><p>Return image header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; ImageHeaderV2:
    &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.kek"><code class="name">var <span class="ident">kek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return key for wrapping DEK and MAC keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kek(self) -&gt; bytes:
    &#34;&#34;&#34;Return key for wrapping DEK and MAC keys.&#34;&#34;&#34;
    return self._kek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Message authentication code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.private_key_pem_data"><code class="name">var <span class="ident">private_key_pem_data</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return private key data for signed images, decrypted in PEM format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def private_key_pem_data(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Return private key data for signed images, decrypted in PEM format.&#34;&#34;&#34;
    return self._private_key_pem_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size.&#34;&#34;&#34;
    size = self.raw_size_without_signature

    if self.signed:
        cert_block = self.cert_block
        assert cert_block
        size += cert_block.signature_size

    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.raw_size_without_signature"><code class="name">var <span class="ident">raw_size_without_signature</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size without signature, used to calculate image blocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size_without_signature(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size without signature, used to calculate image blocks.&#34;&#34;&#34;
    # Header, HMAC and KeyBlob
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
    # Certificates Section
    if self.signed:
        size += self.DEK_MAC_SIZE
        cert_block = self.cert_block
        assert cert_block
        size += cert_block.raw_size
    # Boot Sections
    for boot_section in self._boot_sections:
        size += boot_section.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.signed"><code class="name">var <span class="ident">signed</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check whether sb is signed + encrypted or only encrypted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signed(self) -&gt; bool:
    &#34;&#34;&#34;Check whether sb is signed + encrypted or only encrypted.&#34;&#34;&#34;
    return self._signed</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV20.add_boot_section"><code class="name flex">
<span>def <span class="ident">add_boot_section</span></span>(<span>self, section: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add new Boot section into image.</p>
<p>:param section: Boot section
:raise TypeError: raised when section is not instance of BootSectionV2 class
:raise ValueError: raise when boot section has duplicate UID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_boot_section(self, section: BootSectionV2) -&gt; None:
    &#34;&#34;&#34;Add new Boot section into image.

    :param section: Boot section
    :raise TypeError: raised when section is not instance of BootSectionV2 class
    :raise ValueError: raise when boot section has duplicate UID
    &#34;&#34;&#34;
    if not isinstance(section, BootSectionV2):
        raise TypeError()
    duplicate_uid = find_first(self._boot_sections, lambda bs: bs.uid == section.uid)
    if duplicate_uid is not None:
        raise ValueError(f&#39;Boot section with duplicate UID: {str(section.uid)}&#39;)
    self._boot_sections.append(section)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, padding: Union[bytes, NoneType] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize image object.</p>
<p>:param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
:return: exported bytes
:raise ValueError: raised when there are no boot sections or is not signed or private keys are missing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, padding: Optional[bytes] = None) -&gt; bytes:
    &#34;&#34;&#34;Serialize image object.

    :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
    :return: exported bytes
    :raise ValueError: raised when there are no boot sections or is not signed or private keys are missing
    &#34;&#34;&#34;
    assert len(self.dek) == 32 and len(self.mac) == 32
    # validate params
    if not self._boot_sections:
        raise ValueError(&#39;No boot section&#39;)
    if self.signed and (self._cert_section is None):
        raise ValueError(&#34;Certificate section is required for signed images&#34;)
    # update internals
    self.update()
    # Add Image Header data
    data = self._header.export(padding=padding)
    # Add Image Header HMAC data
    data += crypto_backend().hmac(self.mac, data)
    # Add DEK and MAC keys
    data += crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
    # Add Padding
    data += padding if padding else crypto_backend().random_bytes(8)
    # Add Certificates data
    assert self._header.nonce
    counter = Counter(self._header.nonce)
    counter.increment(calc_cypher_block_count(len(data)))
    if self._cert_section is not None:
        cert_sect_bin = self._cert_section.export(dek=self.dek, mac=self.mac, counter=counter)
        counter.increment(calc_cypher_block_count(len(cert_sect_bin)))
        data += cert_sect_bin
    # Add Boot Sections data
    for sect in self._boot_sections:
        data += sect.export(dek=self.dek, mac=self.mac, counter=counter)
    # Add Signature data
    if self.signed:
        private_key_pem_data = self.private_key_pem_data
        if private_key_pem_data is None:
            raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
        certificate_block = self.cert_block
        assert (certificate_block is not None) and certificate_block.verify_private_key(private_key_pem_data)
        data += crypto_backend().rsa_sign(private_key_pem_data, data)
    assert len(data) == self.raw_size
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
    self.update()
    nfo = &#34;\n&#34;
    nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
    nfo += self._header.info()
    if self._cert_section is not None:
        nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._cert_section.info()
    nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
    for index, section in enumerate(self._boot_sections):
        nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
        nfo += section.info()
    return nfo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV20.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update boot image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Update boot image.&#34;&#34;&#34;
    if self._boot_sections:
        self._header.first_boot_section_id = self._boot_sections[0].uid
        # calculate first boot tag block
        data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        if self._cert_section is not None:
            data_size += self._cert_section.raw_size
        self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
    # ...
    self._header.flags = 0x08 if self.signed else 0x04
    self._header.image_blocks = calc_cypher_block_count(self.raw_size_without_signature)
    self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
    self._header.max_section_mac_count = 0
    if self.signed:
        self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        self._header.offset_to_certificate_block += CmdHeader.SIZE + CertSectionV2.HMAC_SIZE * 2
        self._header.max_section_mac_count = 1
    for boot_sect in self._boot_sections:
        boot_sect.is_last = True  # this is unified with elftosb
        self._header.max_section_mac_count += boot_sect.hmac_count
    # Update certificates block header
    cert_blk = self.cert_block
    if cert_blk is not None:
        cert_blk.header.build_number = self._header.build_number
        cert_blk.header.image_length = self.cert_header_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.BootImageV21"><code class="flex name class">
<span>class <span class="ident">BootImageV21</span></span>
<span>(</span><span>kek: bytes, *sections: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>, product_version: str = '1.0.0', component_version: str = '1.0.0', build_number: int = 0, advanced_params: <a title="spsdk.sbfile.images.SBV2xAdvancedParams" href="images.html#spsdk.sbfile.images.SBV2xAdvancedParams">SBV2xAdvancedParams</a> = &lt;spsdk.sbfile.images.SBV2xAdvancedParams object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Image V2.1 class.</p>
<p>Initialize Secure Boot Image V2.1.</p>
<p>:param kek: key to wrap DEC and MAC keys</p>
<p>:param product_version: The product version (default: 1.0.0)
:param component_version: The component version (default: 1.0.0)
:param build_number: The build number value (default: 0)</p>
<p>:param advanced_params: optional advanced parameters for encryption; it is recommended to use default value
:param sections: Boot sections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImageV21(BaseClass):
    &#34;&#34;&#34;Boot Image V2.1 class.&#34;&#34;&#34;
    # Image specific data
    HEADER_MAC_SIZE = 32
    KEY_BLOB_SIZE = 80

    def __init__(self, kek: bytes, *sections: BootSectionV2,
                 product_version: str = &#39;1.0.0&#39;, component_version: str = &#39;1.0.0&#39;,
                 build_number: int = 0, advanced_params: SBV2xAdvancedParams = SBV2xAdvancedParams()) -&gt; None:
        &#34;&#34;&#34;Initialize Secure Boot Image V2.1.

        :param kek: key to wrap DEC and MAC keys

        :param product_version: The product version (default: 1.0.0)
        :param component_version: The component version (default: 1.0.0)
        :param build_number: The build number value (default: 0)

        :param advanced_params: optional advanced parameters for encryption; it is recommended to use default value
        :param sections: Boot sections
        &#34;&#34;&#34;
        self._kek = kek
        self._private_key_pem_data: Optional[bytes] = None  # this should be assigned for export, not needed for parsing
        self._dek = advanced_params.dek
        self._mac = advanced_params.mac
        self._header = ImageHeaderV2(version=&#39;2.1&#39;, product_version=product_version,
                                     component_version=component_version, build_number=build_number, flags=0x08,
                                     nonce=advanced_params.nonce, timestamp=advanced_params.timestamp)
        self._cert_block: Optional[CertBlockV2] = None
        self._boot_sections: List[BootSectionV2] = []
        # ...
        for section in sections:
            self.add_boot_section(section)

    @property
    def header(self) -&gt; ImageHeaderV2:
        &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
        return self._header

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
        return self._mac

    @property
    def kek(self) -&gt; bytes:
        &#34;&#34;&#34;Return key to wrap DEC and MAC keys.&#34;&#34;&#34;
        return self._kek

    @property
    def private_key_pem_data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Return binary data of private key for signing; decrypted binary data in PEM format.

        None if not assigned yet or image not signed.
        &#34;&#34;&#34;
        return self._private_key_pem_data

    @private_key_pem_data.setter
    def private_key_pem_data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param: key for signing the image; decrypted binary data in PEM format
        &#34;&#34;&#34;
        self._private_key_pem_data = value

    @property
    def cert_block(self) -&gt; Optional[CertBlockV2]:
        &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
        return self._cert_block

    @cert_block.setter
    def cert_block(self, value: CertBlockV2) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: block to be assigned; None to remove previously assigned block
        &#34;&#34;&#34;
        assert isinstance(value, CertBlockV2)
        self._cert_block = value

    @property
    def signed(self) -&gt; bool:
        &#34;&#34;&#34;Return flag whether SB file is signed.&#34;&#34;&#34;
        return True  # SB2.1 is always signed

    @property
    def cert_header_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
        size += self.KEY_BLOB_SIZE
        # Certificates Section
        cert_blk = self.cert_block
        if cert_blk:
            size += cert_blk.raw_size
        return size

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned).&#34;&#34;&#34;
        # Header, HMAC and KeyBlob
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
        size += self.KEY_BLOB_SIZE
        # Certificates Section
        cert_blk = self.cert_block
        if cert_blk:
            size += cert_blk.raw_size
            assert self.signed
            size += cert_blk.signature_size
        # Boot Sections
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    def __str__(self) -&gt; str:
        return self.info()

    def __len__(self) -&gt; int:
        return len(self._boot_sections)

    def __getitem__(self, key: int) -&gt; BootSectionV2:
        return self._boot_sections[key]

    def __setitem__(self, key: int, value: BootSectionV2) -&gt; None:
        self._boot_sections[key] = value

    def __iter__(self) -&gt; Iterator[BootSectionV2]:
        return self._boot_sections.__iter__()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update BootImageV21.&#34;&#34;&#34;
        if self._boot_sections:
            self._header.first_boot_section_id = self._boot_sections[0].uid
            # calculate first boot tag block
            data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            cert_blk = self.cert_block
            if cert_blk is not None:
                data_size += cert_blk.raw_size
                assert self.signed
                data_size += cert_blk.signature_size
            self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
        # ...
        self._header.image_blocks = calc_cypher_block_count(self.raw_size)
        self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
        self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        # Get HMAC count
        self._header.max_section_mac_count = 0
        for boot_sect in self._boot_sections:
            boot_sect.is_last = True  # unified with elftosb
            self._header.max_section_mac_count += boot_sect.hmac_count
        # Update certificates block header
        cert_clk = self.cert_block
        if cert_clk is not None:
            cert_clk.header.build_number = self._header.build_number
            cert_clk.header.image_length = self.cert_header_size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        self.update()
        nfo = &#34;\n&#34;
        nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._header.info()
        if self.cert_block is not None:
            nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
            nfo += self.cert_block.info()
        nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
        for index, section in enumerate(self._boot_sections):
            nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
            nfo += section.info()
        return nfo

    def add_boot_section(self, section: BootSectionV2) -&gt; None:
        &#34;&#34;&#34;Add new Boot section into image.

        :param section: Boot section to be added
        :raise TypeError: raised when section is not instance of BootSectionV2 class
        &#34;&#34;&#34;
        if not isinstance(section, BootSectionV2):
            raise TypeError()
        self._boot_sections.append(section)

    # pylint: disable=too-many-locals
    def export(self, padding: Optional[bytes] = None,
               dbg_info: Optional[List[str]] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize image object.

        :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
        :param dbg_info: optional list, where debug info is exported in text form
        :return: exported bytes
        :raise ValueError: raised when there is no boot section to be added
        :raise ValueError: raise when certificate is not assigned
        :raise ValueError: raise when private key is not assigned
        &#34;&#34;&#34;
        # validate params
        if not self._boot_sections:
            raise ValueError(&#34;At least one Boot Section must be added&#34;)
        if self.cert_block is None:
            raise ValueError(&#39;Certificate is not assigned&#39;)
        if self.private_key_pem_data is None:
            raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
        # Update internals
        if dbg_info is not None:
            dbg_info.append(&#39;[sb_file]&#39;)
        bs_dbg_info: Optional[List[str]] = list() if dbg_info else None
        self.update()
        # Export Boot Sections
        bs_data = bytes()
        # TODO: implement helper method for get key size in bytes. Now is working only with internal backend
        bs_offset = (ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE + self.cert_block.raw_size +
                     self.cert_block.signature_size)
        assert self._header.nonce
        counter = Counter(self._header.nonce, calc_cypher_block_count(bs_offset))
        for sect in self._boot_sections:
            bs_data += sect.export(dek=self.dek, mac=self.mac, counter=counter, dbg_info=bs_dbg_info)
        # Export Header
        signed_data = self._header.export(padding=padding)
        if dbg_info:
            dbg_info.append(&#39;[header]&#39;)
            dbg_info.append(signed_data.hex())
        #  Add HMAC data
        first_bs_hmac_count = self._boot_sections[0].hmac_count
        hmac_data = bs_data[CmdHeader.SIZE: CmdHeader.SIZE + (first_bs_hmac_count * 32) + 32]
        hmac = crypto_backend().hmac(self.mac, hmac_data)
        signed_data += hmac
        if dbg_info:
            dbg_info.append(&#39;[hmac]&#39;)
            dbg_info.append(hmac.hex())
        # Add KeyBlob data
        key_blob = crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
        key_blob += b&#39;\00&#39; * (self.KEY_BLOB_SIZE - len(key_blob))
        signed_data += key_blob
        if dbg_info:
            dbg_info.append(&#39;[key_blob]&#39;)
            dbg_info.append(key_blob.hex())
        # Add Certificates data
        signed_data += self.cert_block.export()
        if dbg_info:
            dbg_info.append(&#39;[cert_block]&#39;)
            dbg_info.append(self.cert_block.export().hex())
        # Add Signature data
        assert self.cert_block.verify_private_key(self.private_key_pem_data)  # verify private key matches certificate
        signature = crypto_backend().rsa_sign(self.private_key_pem_data, signed_data)
        if dbg_info:
            dbg_info.append(&#39;[signature]&#39;)
            dbg_info.append(signature.hex())
            dbg_info.append(&#39;[boot_sections]&#39;)
            assert bs_dbg_info
            dbg_info.extend(bs_dbg_info)
        return signed_data + signature + bs_data

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes(),
              plain_sections: bool = False) -&gt; &#39;BootImageV21&#39;:
        &#34;&#34;&#34;Parse image from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param kek: The Key for unwrapping DEK and MAC keys (required)
        :param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
        :return: BootImageV21 parsed object
        :raise Exception: raised when header is in incorrect format
        :raise Exception: raised when signature is incorrect
        &#34;&#34;&#34;
        assert kek, &#39;kek cannot be empty&#39;
        index = offset
        header_raw_data = data[index: index + ImageHeaderV2.SIZE]
        index += ImageHeaderV2.SIZE
        # TODO not used right now: hmac_data = data[index: index + cls.HEADER_MAC_SIZE]
        index += cls.HEADER_MAC_SIZE
        key_blob = data[index: index + cls.KEY_BLOB_SIZE]
        index += cls.KEY_BLOB_SIZE
        key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
        dek = key_blob_unwrap[:32]
        mac = key_blob_unwrap[32:]
        # Parse Header
        header = ImageHeaderV2.parse(header_raw_data)
        if header.offset_to_certificate_block != (index - offset):
            raise Exception()
        # Parse Certificate Block
        cert_block = CertBlockV2.parse(data, index)
        index += cert_block.raw_size
        # Verify Signature
        if not cert_block.verify_data(data[index: index + cert_block.signature_size], data[offset: index]):
            raise Exception()
        index += cert_block.signature_size
        # Check first Boot Section HMAC
        # TODO: not implemented yet
        # hmac_data_calc = crypto_backend().hmac(mac, data[index + CmdHeader.SIZE: index + CmdHeader.SIZE + ((2) * 32)])
        # if hmac_data != hmac_data_calc:
        #    raise Exception()
        assert header.nonce
        counter = Counter(header.nonce)
        counter.increment(calc_cypher_block_count(index - offset))
        boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter, plain_sect=plain_sections)
        adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
        obj = cls(kek=kek,
                  product_version=str(header.product_version),
                  component_version=str(header.component_version),
                  build_number=header.build_number,
                  advanced_params=adv_params)
        obj.cert_block = cert_block
        obj.add_boot_section(boot_section)
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV21.HEADER_MAC_SIZE"><code class="name">var <span class="ident">HEADER_MAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.BootImageV21.KEY_BLOB_SIZE"><code class="name">var <span class="ident">KEY_BLOB_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV21.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, kek: bytes = b'', plain_sections: bool = False) ‑> <a title="spsdk.sbfile.images.BootImageV21" href="images.html#spsdk.sbfile.images.BootImageV21">BootImageV21</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from bytes.</p>
<p>:param data: Raw data of parsed image
:param offset: The offset of input data
:param kek: The Key for unwrapping DEK and MAC keys (required)
:param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
:return: BootImageV21 parsed object
:raise Exception: raised when header is in incorrect format
:raise Exception: raised when signature is incorrect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes(),
          plain_sections: bool = False) -&gt; &#39;BootImageV21&#39;:
    &#34;&#34;&#34;Parse image from bytes.

    :param data: Raw data of parsed image
    :param offset: The offset of input data
    :param kek: The Key for unwrapping DEK and MAC keys (required)
    :param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
    :return: BootImageV21 parsed object
    :raise Exception: raised when header is in incorrect format
    :raise Exception: raised when signature is incorrect
    &#34;&#34;&#34;
    assert kek, &#39;kek cannot be empty&#39;
    index = offset
    header_raw_data = data[index: index + ImageHeaderV2.SIZE]
    index += ImageHeaderV2.SIZE
    # TODO not used right now: hmac_data = data[index: index + cls.HEADER_MAC_SIZE]
    index += cls.HEADER_MAC_SIZE
    key_blob = data[index: index + cls.KEY_BLOB_SIZE]
    index += cls.KEY_BLOB_SIZE
    key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
    dek = key_blob_unwrap[:32]
    mac = key_blob_unwrap[32:]
    # Parse Header
    header = ImageHeaderV2.parse(header_raw_data)
    if header.offset_to_certificate_block != (index - offset):
        raise Exception()
    # Parse Certificate Block
    cert_block = CertBlockV2.parse(data, index)
    index += cert_block.raw_size
    # Verify Signature
    if not cert_block.verify_data(data[index: index + cert_block.signature_size], data[offset: index]):
        raise Exception()
    index += cert_block.signature_size
    # Check first Boot Section HMAC
    # TODO: not implemented yet
    # hmac_data_calc = crypto_backend().hmac(mac, data[index + CmdHeader.SIZE: index + CmdHeader.SIZE + ((2) * 32)])
    # if hmac_data != hmac_data_calc:
    #    raise Exception()
    assert header.nonce
    counter = Counter(header.nonce)
    counter.increment(calc_cypher_block_count(index - offset))
    boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter, plain_sect=plain_sections)
    adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
    obj = cls(kek=kek,
              product_version=str(header.product_version),
              component_version=str(header.component_version),
              build_number=header.build_number,
              advanced_params=adv_params)
    obj.cert_block = cert_block
    obj.add_boot_section(boot_section)
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV21.cert_block"><code class="name">var <span class="ident">cert_block</span> : Union[<a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return certificate block; None if SB file not signed or block not assigned yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_block(self) -&gt; Optional[CertBlockV2]:
    &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
    return self._cert_block</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.cert_header_size"><code class="name">var <span class="ident">cert_header_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size (not aligned) for certificate header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_header_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
    size += self.KEY_BLOB_SIZE
    # Certificates Section
    cert_blk = self.cert_block
    if cert_blk:
        size += cert_blk.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.dek"><code class="name">var <span class="ident">dek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Data encryption key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek(self) -&gt; bytes:
    &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
    return self._dek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.sbfile.headers.ImageHeaderV2" href="headers.html#spsdk.sbfile.headers.ImageHeaderV2">ImageHeaderV2</a></code></dt>
<dd>
<div class="desc"><p>Return image header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; ImageHeaderV2:
    &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.kek"><code class="name">var <span class="ident">kek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return key to wrap DEC and MAC keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kek(self) -&gt; bytes:
    &#34;&#34;&#34;Return key to wrap DEC and MAC keys.&#34;&#34;&#34;
    return self._kek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Message authentication code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.private_key_pem_data"><code class="name">var <span class="ident">private_key_pem_data</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return binary data of private key for signing; decrypted binary data in PEM format.</p>
<p>None if not assigned yet or image not signed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def private_key_pem_data(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Return binary data of private key for signing; decrypted binary data in PEM format.

    None if not assigned yet or image not signed.
    &#34;&#34;&#34;
    return self._private_key_pem_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size (not aligned).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size (not aligned).&#34;&#34;&#34;
    # Header, HMAC and KeyBlob
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
    size += self.KEY_BLOB_SIZE
    # Certificates Section
    cert_blk = self.cert_block
    if cert_blk:
        size += cert_blk.raw_size
        assert self.signed
        size += cert_blk.signature_size
    # Boot Sections
    for boot_section in self._boot_sections:
        size += boot_section.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.signed"><code class="name">var <span class="ident">signed</span> : bool</code></dt>
<dd>
<div class="desc"><p>Return flag whether SB file is signed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signed(self) -&gt; bool:
    &#34;&#34;&#34;Return flag whether SB file is signed.&#34;&#34;&#34;
    return True  # SB2.1 is always signed</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.BootImageV21.add_boot_section"><code class="name flex">
<span>def <span class="ident">add_boot_section</span></span>(<span>self, section: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add new Boot section into image.</p>
<p>:param section: Boot section to be added
:raise TypeError: raised when section is not instance of BootSectionV2 class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_boot_section(self, section: BootSectionV2) -&gt; None:
    &#34;&#34;&#34;Add new Boot section into image.

    :param section: Boot section to be added
    :raise TypeError: raised when section is not instance of BootSectionV2 class
    &#34;&#34;&#34;
    if not isinstance(section, BootSectionV2):
        raise TypeError()
    self._boot_sections.append(section)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, padding: Union[bytes, NoneType] = None, dbg_info: Union[List[str], NoneType] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize image object.</p>
<p>:param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
:param dbg_info: optional list, where debug info is exported in text form
:return: exported bytes
:raise ValueError: raised when there is no boot section to be added
:raise ValueError: raise when certificate is not assigned
:raise ValueError: raise when private key is not assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, padding: Optional[bytes] = None,
           dbg_info: Optional[List[str]] = None) -&gt; bytes:
    &#34;&#34;&#34;Serialize image object.

    :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
    :param dbg_info: optional list, where debug info is exported in text form
    :return: exported bytes
    :raise ValueError: raised when there is no boot section to be added
    :raise ValueError: raise when certificate is not assigned
    :raise ValueError: raise when private key is not assigned
    &#34;&#34;&#34;
    # validate params
    if not self._boot_sections:
        raise ValueError(&#34;At least one Boot Section must be added&#34;)
    if self.cert_block is None:
        raise ValueError(&#39;Certificate is not assigned&#39;)
    if self.private_key_pem_data is None:
        raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
    # Update internals
    if dbg_info is not None:
        dbg_info.append(&#39;[sb_file]&#39;)
    bs_dbg_info: Optional[List[str]] = list() if dbg_info else None
    self.update()
    # Export Boot Sections
    bs_data = bytes()
    # TODO: implement helper method for get key size in bytes. Now is working only with internal backend
    bs_offset = (ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE + self.cert_block.raw_size +
                 self.cert_block.signature_size)
    assert self._header.nonce
    counter = Counter(self._header.nonce, calc_cypher_block_count(bs_offset))
    for sect in self._boot_sections:
        bs_data += sect.export(dek=self.dek, mac=self.mac, counter=counter, dbg_info=bs_dbg_info)
    # Export Header
    signed_data = self._header.export(padding=padding)
    if dbg_info:
        dbg_info.append(&#39;[header]&#39;)
        dbg_info.append(signed_data.hex())
    #  Add HMAC data
    first_bs_hmac_count = self._boot_sections[0].hmac_count
    hmac_data = bs_data[CmdHeader.SIZE: CmdHeader.SIZE + (first_bs_hmac_count * 32) + 32]
    hmac = crypto_backend().hmac(self.mac, hmac_data)
    signed_data += hmac
    if dbg_info:
        dbg_info.append(&#39;[hmac]&#39;)
        dbg_info.append(hmac.hex())
    # Add KeyBlob data
    key_blob = crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
    key_blob += b&#39;\00&#39; * (self.KEY_BLOB_SIZE - len(key_blob))
    signed_data += key_blob
    if dbg_info:
        dbg_info.append(&#39;[key_blob]&#39;)
        dbg_info.append(key_blob.hex())
    # Add Certificates data
    signed_data += self.cert_block.export()
    if dbg_info:
        dbg_info.append(&#39;[cert_block]&#39;)
        dbg_info.append(self.cert_block.export().hex())
    # Add Signature data
    assert self.cert_block.verify_private_key(self.private_key_pem_data)  # verify private key matches certificate
    signature = crypto_backend().rsa_sign(self.private_key_pem_data, signed_data)
    if dbg_info:
        dbg_info.append(&#39;[signature]&#39;)
        dbg_info.append(signature.hex())
        dbg_info.append(&#39;[boot_sections]&#39;)
        assert bs_dbg_info
        dbg_info.extend(bs_dbg_info)
    return signed_data + signature + bs_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
    self.update()
    nfo = &#34;\n&#34;
    nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
    nfo += self._header.info()
    if self.cert_block is not None:
        nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self.cert_block.info()
    nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
    for index, section in enumerate(self._boot_sections):
        nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
        nfo += section.info()
    return nfo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootImageV21.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update BootImageV21.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Update BootImageV21.&#34;&#34;&#34;
    if self._boot_sections:
        self._header.first_boot_section_id = self._boot_sections[0].uid
        # calculate first boot tag block
        data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        cert_blk = self.cert_block
        if cert_blk is not None:
            data_size += cert_blk.raw_size
            assert self.signed
            data_size += cert_blk.signature_size
        self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
    # ...
    self._header.image_blocks = calc_cypher_block_count(self.raw_size)
    self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
    self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
    # Get HMAC count
    self._header.max_section_mac_count = 0
    for boot_sect in self._boot_sections:
        boot_sect.is_last = True  # unified with elftosb
        self._header.max_section_mac_count += boot_sect.hmac_count
    # Update certificates block header
    cert_clk = self.cert_block
    if cert_clk is not None:
        cert_clk.header.build_number = self._header.build_number
        cert_clk.header.image_length = self.cert_header_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.BootSectionV2"><code class="flex name class">
<span>class <span class="ident">BootSectionV2</span></span>
<span>(</span><span>uid: int, *commands: <a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a>, hmac_count: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Section V2.</p>
<p>Initialize BootSectionV2.</p>
<p>:param uid: section unique identification
:param commands: List of commands
:param hmac_count: The number of HMAC entries</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootSectionV2(BaseClass):
    &#34;&#34;&#34;Boot Section V2.&#34;&#34;&#34;
    HMAC_SIZE = 32

    @property
    def uid(self) -&gt; int:
        &#34;&#34;&#34;Boot Section UID.&#34;&#34;&#34;
        return self._header.address

    @uid.setter
    def uid(self, value: int) -&gt; None:
        self._header.address = value

    @property
    def is_last(self) -&gt; bool:
        &#34;&#34;&#34;Check whether the section is the last one.&#34;&#34;&#34;
        return self._header.flags &amp; EnumSectionFlag.LAST_SECT != 0

    @is_last.setter
    def is_last(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._header.flags = EnumSectionFlag.BOOTABLE
        if value:
            self._header.flags |= EnumSectionFlag.LAST_SECT

    @property
    def hmac_count(self) -&gt; int:
        &#34;&#34;&#34;Number of HMACs.&#34;&#34;&#34;
        raw_size = 0
        hmac_count = 0
        for cmd in self._commands:
            raw_size += cmd.raw_size
        if raw_size &gt; 0:
            block_count = (raw_size + 15) // 16
            hmac_count = self._hmac_count if block_count &gt;= self._hmac_count else block_count
        return hmac_count

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Raw size of section.&#34;&#34;&#34;
        size = CmdHeader.SIZE + self.HMAC_SIZE
        size += self.hmac_count * self.HMAC_SIZE
        for cmd in self._commands:
            size += cmd.raw_size
        if size % 16:
            size += 16 - (size % 16)
        return size

    def __init__(self, uid: int, *commands: CmdBaseClass, hmac_count: int = 1) -&gt; None:
        &#34;&#34;&#34;Initialize BootSectionV2.

        :param uid: section unique identification
        :param commands: List of commands
        :param hmac_count: The number of HMAC entries
        &#34;&#34;&#34;
        self._header = CmdHeader(EnumCmdTag.TAG, EnumSectionFlag.BOOTABLE)
        self._commands: List[CmdBaseClass] = []
        self._hmac_count = hmac_count
        for cmd in commands:
            self.append(cmd)
        # Initialize HMAC count
        if not isinstance(self._hmac_count, int) or self._hmac_count == 0:
            self._hmac_count = 1
        # section UID
        self.uid = uid

    def __str__(self) -&gt; str:
        pass

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBaseClass:
        return self._commands[key]

    def __setitem__(self, key: int, value: CmdBaseClass) -&gt; None:
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator[CmdBaseClass]:
        return self._commands.__iter__()

    def append(self, cmd: CmdBaseClass) -&gt; None:
        &#34;&#34;&#34;Add command to section.&#34;&#34;&#34;
        assert isinstance(cmd, CmdBaseClass)
        self._commands.append(cmd)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Get object info.&#34;&#34;&#34;
        nfo = &#34;&#34;
        for index, cmd in enumerate(self._commands):
            nfo += f&#34; {index}) {cmd.info()}\n&#34;
        return nfo

    # pylint: disable=too-many-locals
    def export(self, dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None,
               dbg_info: Optional[List[str]] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize Boot Section object.

        :param dek: The DEK value in bytes (required)
        :param mac: The MAC value in bytes (required)
        :param counter: The counter object (required)
        :param dbg_info: Optional[List[str]] optional list to export debug information about content in text format
        :return: exported bytes
        :raise Exception: raised when dek, mac, counter have invalid format
        &#34;&#34;&#34;
        cmd_dbg_info: Optional[List[str]] = None
        if dbg_info is not None:
            dbg_info.append(&#39;[bootable_section]&#39;)
            cmd_dbg_info = list()
            cmd_dbg_info.append(&#39;[commands]&#39;)
        if not isinstance(dek, bytes):
            raise Exception()
        if not isinstance(mac, bytes):
            raise Exception()
        if not isinstance(counter, Counter):
            raise Exception()
        # Export commands
        commands_data = b&#39;&#39;
        for cmd in self._commands:
            cmd_data = cmd.export()
            commands_data += cmd_data
            if cmd_dbg_info is not None:
                cmd_dbg_info.append(f&#39;[command:{type(cmd).__name__}]&#39;)
                cmd_dbg_info.append(cmd_data.hex())
        if len(commands_data) % 16:
            commands_data += b&#39;\x00&#39; * (16 - (len(commands_data) % 16))
        # Encrypt header
        self._header.data = self.hmac_count
        self._header.count = len(commands_data) // 16
        encrypted_header = crypto_backend().aes_ctr_encrypt(dek, self._header.export(), counter.value)
        hmac_data = crypto_backend().hmac(mac, encrypted_header)
        counter.increment(1 + (self.hmac_count + 1) * 2)
        if dbg_info:
            dbg_info.append(&#39;[header]&#39;)
            dbg_info.append(self._header.export().hex())
            dbg_info.append(&#39;[encrypted_header]&#39;)
            dbg_info.append(encrypted_header.hex())
            dbg_info.append(&#39;[hmac]&#39;)
            dbg_info.append(hmac_data.hex())
            if cmd_dbg_info:
                dbg_info.extend(cmd_dbg_info)
        # Encrypt commands
        encrypted_commands = b&#39;&#39;
        for index in range(0, len(commands_data), 16):
            encrypted_block = crypto_backend().aes_ctr_encrypt(dek, commands_data[index: index + 16], counter.value)
            encrypted_commands += encrypted_block
            counter.increment()
        # Calculate HMAC of commands
        index = 0
        hmac_count = self._header.data
        block_size = (self._header.count // hmac_count) * 16
        while hmac_count &gt; 0:
            enc_block = encrypted_commands[index:] if hmac_count == 1 else encrypted_commands[index: index + block_size]
            hmac_data += crypto_backend().hmac(mac, enc_block)
            hmac_count -= 1
            index += len(enc_block)
        return encrypted_header + hmac_data + encrypted_commands

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, plain_sect: bool = False,
              dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None) -&gt; &#39;BootSectionV2&#39;:
        &#34;&#34;&#34;Parse Boot Section from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param plain_sect: If the sections are not encrypted; It is used for debugging only, not supported by ROM code
        :param dek: The DEK value in bytes (required)
        :param mac: The MAC value in bytes (required)
        :param counter: The counter object (required)
        :return: exported bytes
        :raise Exception: raised when dek, mac, counter have invalid format
        &#34;&#34;&#34;
        if not isinstance(dek, bytes):
            raise Exception()
        if not isinstance(mac, bytes):
            raise Exception()
        if not isinstance(counter, Counter):
            raise Exception()
        # Get Header specific data
        header_encrypted = data[offset: offset + CmdHeader.SIZE]
        header_hmac_data = data[offset + CmdHeader.SIZE: offset + CmdHeader.SIZE + cls.HMAC_SIZE]
        offset += CmdHeader.SIZE + cls.HMAC_SIZE
        # Check header HMAC
        if header_hmac_data != crypto_backend().hmac(mac, header_encrypted):
            raise Exception()
        # Decrypt header
        header_decrypted = crypto_backend().aes_ctr_decrypt(dek, header_encrypted, counter.value)
        counter.increment()
        # Parse header
        header = CmdHeader.parse(header_decrypted)
        counter.increment((header.data + 1) * 2)
        # Get HMAC data
        hmac_data = data[offset: offset + (cls.HMAC_SIZE * header.data)]
        offset += cls.HMAC_SIZE * header.data
        encrypted_commands = data[offset: offset + (header.count * 16)]
        # Check HMAC
        hmac_index = 0
        hmac_count = header.data
        block_size = (header.count // hmac_count) * 16
        section_size = header.count * 16
        while hmac_count &gt; 0:
            if hmac_count == 1:
                block_size = section_size
            hmac_block = crypto_backend().hmac(mac, data[offset: offset + block_size])
            if hmac_block != hmac_data[hmac_index: hmac_index + cls.HMAC_SIZE]:
                raise Exception()
            hmac_count -= 1
            hmac_index += cls.HMAC_SIZE
            section_size -= block_size
            offset += block_size
        # Decrypt commands
        decrypted_commands = b&#39;&#39;
        for hmac_index in range(0, len(encrypted_commands), 16):
            encr_block = encrypted_commands[hmac_index: hmac_index + 16]
            decrypted_block = encr_block if plain_sect else crypto_backend().aes_ctr_decrypt(dek, encr_block,
                                                                                             counter.value)
            decrypted_commands += decrypted_block
            counter.increment()
        # ...
        cmd_offset = 0
        obj = cls(header.address, hmac_count=header.data)
        while cmd_offset &lt; len(decrypted_commands):
            cmd_obj = parse_command(decrypted_commands, cmd_offset)
            cmd_offset += cmd_obj.raw_size
            obj.append(cmd_obj)
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.BootSectionV2.HMAC_SIZE"><code class="name">var <span class="ident">HMAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.BootSectionV2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, plain_sect: bool = False, dek: bytes = b'', mac: bytes = b'', counter: Union[<a title="spsdk.utils.crypto.common.Counter" href="../utils/crypto/common.html#spsdk.utils.crypto.common.Counter">Counter</a>, NoneType] = None) ‑> <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse Boot Section from bytes.</p>
<p>:param data: Raw data of parsed image
:param offset: The offset of input data
:param plain_sect: If the sections are not encrypted; It is used for debugging only, not supported by ROM code
:param dek: The DEK value in bytes (required)
:param mac: The MAC value in bytes (required)
:param counter: The counter object (required)
:return: exported bytes
:raise Exception: raised when dek, mac, counter have invalid format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, plain_sect: bool = False,
          dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None) -&gt; &#39;BootSectionV2&#39;:
    &#34;&#34;&#34;Parse Boot Section from bytes.

    :param data: Raw data of parsed image
    :param offset: The offset of input data
    :param plain_sect: If the sections are not encrypted; It is used for debugging only, not supported by ROM code
    :param dek: The DEK value in bytes (required)
    :param mac: The MAC value in bytes (required)
    :param counter: The counter object (required)
    :return: exported bytes
    :raise Exception: raised when dek, mac, counter have invalid format
    &#34;&#34;&#34;
    if not isinstance(dek, bytes):
        raise Exception()
    if not isinstance(mac, bytes):
        raise Exception()
    if not isinstance(counter, Counter):
        raise Exception()
    # Get Header specific data
    header_encrypted = data[offset: offset + CmdHeader.SIZE]
    header_hmac_data = data[offset + CmdHeader.SIZE: offset + CmdHeader.SIZE + cls.HMAC_SIZE]
    offset += CmdHeader.SIZE + cls.HMAC_SIZE
    # Check header HMAC
    if header_hmac_data != crypto_backend().hmac(mac, header_encrypted):
        raise Exception()
    # Decrypt header
    header_decrypted = crypto_backend().aes_ctr_decrypt(dek, header_encrypted, counter.value)
    counter.increment()
    # Parse header
    header = CmdHeader.parse(header_decrypted)
    counter.increment((header.data + 1) * 2)
    # Get HMAC data
    hmac_data = data[offset: offset + (cls.HMAC_SIZE * header.data)]
    offset += cls.HMAC_SIZE * header.data
    encrypted_commands = data[offset: offset + (header.count * 16)]
    # Check HMAC
    hmac_index = 0
    hmac_count = header.data
    block_size = (header.count // hmac_count) * 16
    section_size = header.count * 16
    while hmac_count &gt; 0:
        if hmac_count == 1:
            block_size = section_size
        hmac_block = crypto_backend().hmac(mac, data[offset: offset + block_size])
        if hmac_block != hmac_data[hmac_index: hmac_index + cls.HMAC_SIZE]:
            raise Exception()
        hmac_count -= 1
        hmac_index += cls.HMAC_SIZE
        section_size -= block_size
        offset += block_size
    # Decrypt commands
    decrypted_commands = b&#39;&#39;
    for hmac_index in range(0, len(encrypted_commands), 16):
        encr_block = encrypted_commands[hmac_index: hmac_index + 16]
        decrypted_block = encr_block if plain_sect else crypto_backend().aes_ctr_decrypt(dek, encr_block,
                                                                                         counter.value)
        decrypted_commands += decrypted_block
        counter.increment()
    # ...
    cmd_offset = 0
    obj = cls(header.address, hmac_count=header.data)
    while cmd_offset &lt; len(decrypted_commands):
        cmd_obj = parse_command(decrypted_commands, cmd_offset)
        cmd_offset += cmd_obj.raw_size
        obj.append(cmd_obj)
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.BootSectionV2.hmac_count"><code class="name">var <span class="ident">hmac_count</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of HMACs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hmac_count(self) -&gt; int:
    &#34;&#34;&#34;Number of HMACs.&#34;&#34;&#34;
    raw_size = 0
    hmac_count = 0
    for cmd in self._commands:
        raw_size += cmd.raw_size
    if raw_size &gt; 0:
        block_count = (raw_size + 15) // 16
        hmac_count = self._hmac_count if block_count &gt;= self._hmac_count else block_count
    return hmac_count</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootSectionV2.is_last"><code class="name">var <span class="ident">is_last</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check whether the section is the last one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_last(self) -&gt; bool:
    &#34;&#34;&#34;Check whether the section is the last one.&#34;&#34;&#34;
    return self._header.flags &amp; EnumSectionFlag.LAST_SECT != 0</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootSectionV2.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Raw size of section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Raw size of section.&#34;&#34;&#34;
    size = CmdHeader.SIZE + self.HMAC_SIZE
    size += self.hmac_count * self.HMAC_SIZE
    for cmd in self._commands:
        size += cmd.raw_size
    if size % 16:
        size += 16 - (size % 16)
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootSectionV2.uid"><code class="name">var <span class="ident">uid</span> : int</code></dt>
<dd>
<div class="desc"><p>Boot Section UID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uid(self) -&gt; int:
    &#34;&#34;&#34;Boot Section UID.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.BootSectionV2.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cmd: <a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add command to section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, cmd: CmdBaseClass) -&gt; None:
    &#34;&#34;&#34;Add command to section.&#34;&#34;&#34;
    assert isinstance(cmd, CmdBaseClass)
    self._commands.append(cmd)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootSectionV2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dek: bytes = b'', mac: bytes = b'', counter: Union[<a title="spsdk.utils.crypto.common.Counter" href="../utils/crypto/common.html#spsdk.utils.crypto.common.Counter">Counter</a>, NoneType] = None, dbg_info: Union[List[str], NoneType] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize Boot Section object.</p>
<p>:param dek: The DEK value in bytes (required)
:param mac: The MAC value in bytes (required)
:param counter: The counter object (required)
:param dbg_info: Optional[List[str]] optional list to export debug information about content in text format
:return: exported bytes
:raise Exception: raised when dek, mac, counter have invalid format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None,
           dbg_info: Optional[List[str]] = None) -&gt; bytes:
    &#34;&#34;&#34;Serialize Boot Section object.

    :param dek: The DEK value in bytes (required)
    :param mac: The MAC value in bytes (required)
    :param counter: The counter object (required)
    :param dbg_info: Optional[List[str]] optional list to export debug information about content in text format
    :return: exported bytes
    :raise Exception: raised when dek, mac, counter have invalid format
    &#34;&#34;&#34;
    cmd_dbg_info: Optional[List[str]] = None
    if dbg_info is not None:
        dbg_info.append(&#39;[bootable_section]&#39;)
        cmd_dbg_info = list()
        cmd_dbg_info.append(&#39;[commands]&#39;)
    if not isinstance(dek, bytes):
        raise Exception()
    if not isinstance(mac, bytes):
        raise Exception()
    if not isinstance(counter, Counter):
        raise Exception()
    # Export commands
    commands_data = b&#39;&#39;
    for cmd in self._commands:
        cmd_data = cmd.export()
        commands_data += cmd_data
        if cmd_dbg_info is not None:
            cmd_dbg_info.append(f&#39;[command:{type(cmd).__name__}]&#39;)
            cmd_dbg_info.append(cmd_data.hex())
    if len(commands_data) % 16:
        commands_data += b&#39;\x00&#39; * (16 - (len(commands_data) % 16))
    # Encrypt header
    self._header.data = self.hmac_count
    self._header.count = len(commands_data) // 16
    encrypted_header = crypto_backend().aes_ctr_encrypt(dek, self._header.export(), counter.value)
    hmac_data = crypto_backend().hmac(mac, encrypted_header)
    counter.increment(1 + (self.hmac_count + 1) * 2)
    if dbg_info:
        dbg_info.append(&#39;[header]&#39;)
        dbg_info.append(self._header.export().hex())
        dbg_info.append(&#39;[encrypted_header]&#39;)
        dbg_info.append(encrypted_header.hex())
        dbg_info.append(&#39;[hmac]&#39;)
        dbg_info.append(hmac_data.hex())
        if cmd_dbg_info:
            dbg_info.extend(cmd_dbg_info)
    # Encrypt commands
    encrypted_commands = b&#39;&#39;
    for index in range(0, len(commands_data), 16):
        encrypted_block = crypto_backend().aes_ctr_encrypt(dek, commands_data[index: index + 16], counter.value)
        encrypted_commands += encrypted_block
        counter.increment()
    # Calculate HMAC of commands
    index = 0
    hmac_count = self._header.data
    block_size = (self._header.count // hmac_count) * 16
    while hmac_count &gt; 0:
        enc_block = encrypted_commands[index:] if hmac_count == 1 else encrypted_commands[index: index + block_size]
        hmac_data += crypto_backend().hmac(mac, enc_block)
        hmac_count -= 1
        index += len(enc_block)
    return encrypted_header + hmac_data + encrypted_commands</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.BootSectionV2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get object info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Get object info.&#34;&#34;&#34;
    nfo = &#34;&#34;
    for index, cmd in enumerate(self._commands):
        nfo += f&#34; {index}) {cmd.info()}\n&#34;
    return nfo</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.CertBlockV2"><code class="flex name class">
<span>class <span class="ident">CertBlockV2</span></span>
<span>(</span><span>version: str = '1.0', flags: int = 0, build_number: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate block.</p>
<p>Shared for SB file and for MasterBootImage</p>
<p>Constructor.</p>
<p>:param version: of the certificate in format n.n
:param flags: Flags for the Certificate Block Header
:param build_number: of the certificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertBlockV2(BaseClass):
    &#34;&#34;&#34;Certificate block.

    Shared for SB file and for MasterBootImage
    &#34;&#34;&#34;

    # size of the hash in bytes (single item in RKH table)
    RKH_SIZE = 32
    # number of hashes in RKH table (number of table entries)
    RKHT_SIZE = 4

    # default size alignment
    DEFAULT_ALIGNMENT = 16

    @property
    def header(self) -&gt; CertBlockHeader:
        &#34;&#34;&#34;Certificate block header.&#34;&#34;&#34;
        return self._header

    @property
    def rkh(self) -&gt; List[bytes]:
        &#34;&#34;&#34;List of root keys hashes (SHA-256), each hash as 32 bytes.&#34;&#34;&#34;
        return self._root_key_hashes

    @property
    def rkht(self) -&gt; bytes:
        &#34;&#34;&#34;32-byte hash (SHA-256) of SHA-256 hashes of up to four root public keys.&#34;&#34;&#34;
        data = bytes()
        for rkh in self._root_key_hashes:
            data += rkh
        assert len(data) == self.RKH_SIZE * self.RKHT_SIZE
        return internal_backend.hash(data)

    @property
    def rkht_fuses(self) -&gt; List[int]:
        &#34;&#34;&#34;List of RKHT fuses, ordered from highest bit to lowest.

        Note: Returned values are in format that should be passed for blhost
        &#34;&#34;&#34;
        result = list()
        rkht = self.rkht
        while rkht:
            fuse = int.from_bytes(rkht[:4], byteorder=&#39;little&#39;)
            result.append(fuse)
            rkht = rkht[4:]
        return result

    @property
    def certificates(self) -&gt; List[Certificate]:
        &#34;&#34;&#34;List of certificates in header.

        First certificate is root certificate and followed by optional chain certificates
        &#34;&#34;&#34;
        return self._cert

    @property
    def signature_size(self) -&gt; int:
        &#34;&#34;&#34;Size of the signature in bytes.&#34;&#34;&#34;
        return len(self.certificates[0].signature)  # The certificate is self signed, return size of its signature

    @property
    def rkh_index(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Index of the hash that matches the certificate; None if does not match.&#34;&#34;&#34;
        if self._cert:
            rkh = self._cert[0].public_key_hash
            for index, value in enumerate(self._root_key_hashes):
                if rkh == value:
                    return index
        return None

    @property
    def alignment(self) -&gt; int:
        &#34;&#34;&#34;Alignment of the binary output, by default it is DEFAULT_ALIGNMENT but can be customized.&#34;&#34;&#34;
        return self._alignment

    @alignment.setter
    def alignment(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new alignment
        &#34;&#34;&#34;
        assert value &gt; 0
        self._alignment = value

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Aligned size of the certificate block.&#34;&#34;&#34;
        size = CertBlockHeader.SIZE
        size += self._header.cert_table_length
        size += self.RKH_SIZE * self.RKHT_SIZE
        return misc.align(size, self.alignment)

    @property
    def image_length(self) -&gt; int:
        &#34;&#34;&#34;Image length in bytes.&#34;&#34;&#34;
        return self._header.image_length

    @image_length.setter
    def image_length(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new image length
        &#34;&#34;&#34;
        assert value &gt; 0
        self._header.image_length = value

    def __init__(self, version: str = &#39;1.0&#39;, flags: int = 0, build_number: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param version: of the certificate in format n.n
        :param flags: Flags for the Certificate Block Header
        :param build_number: of the certificate
        &#34;&#34;&#34;
        self._header = CertBlockHeader(version, flags, build_number)
        self._root_key_hashes = [b&#39;\x00&#39; * self.RKH_SIZE for _ in range(self.RKHT_SIZE)]
        self._cert: List[Certificate] = []
        self._alignment = self.DEFAULT_ALIGNMENT

    def __str__(self) -&gt; str:
        return str(self._header)

    def __len__(self) -&gt; int:
        return len(self._cert)

    def set_root_key_hash(self, index: int, key_hash: Union[bytes, bytearray, Certificate]) -&gt; None:
        &#34;&#34;&#34;Add Root Key Hash into RKH at specified index.

        Note: Multiple root public keys are supported to allow for key revocation.

        :param index: The index of Root Key Hash in the table
        :param key_hash: The Root Key Hash value (32 bytes, SHA-256);
                        or Certificate where the hash can be created from public key
        &#34;&#34;&#34;
        if isinstance(key_hash, Certificate):
            key_hash = key_hash.public_key_hash
        assert isinstance(key_hash, (bytes, bytearray))
        assert 0 &lt;= index &lt; self.RKHT_SIZE
        assert len(key_hash) == self.RKH_SIZE
        self._root_key_hashes[index] = bytes(key_hash)

    def add_certificate(self, cert: Union[bytes, Certificate]) -&gt; None:
        &#34;&#34;&#34;Add certificate.

        First call adds root certificate. Additional calls add chain certificates.

        :param cert: The certificate itself in DER format
        :raise ValueError: if certificate cannot be added
        &#34;&#34;&#34;
        if isinstance(cert, bytes):
            cert_obj = Certificate(cert)
        elif isinstance(cert, Certificate):
            cert_obj = cert
        else:
            raise ValueError(&#39;Invalid parameter type (cert)&#39;)
        if cert_obj.version != &#39;v3&#39;:
            raise ValueError(&#39;Expected certificate v3 but received: &#39; + cert_obj.version)
        if self._cert:  # chain certificate?
            last_cert = self._cert[-1]  # verify that it is signed by parent key
            if not cert_obj.verify(last_cert.public_key_modulus, last_cert.public_key_exponent):
                raise ValueError(&#39;Chain certificate cannot be verified using parent public key&#39;)
        else:  # root certificate
            if cert_obj.self_signed == &#34;no&#34;:
                raise ValueError(&#34;Root certificate must be self-signed&#34;)
        self._cert.append(cert_obj)
        self._header.cert_count += 1
        self._header.cert_table_length += cert_obj.raw_size + 4

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about certificate block.&#34;&#34;&#34;
        nfo = self.header.info()
        nfo += &#34; Public Root Keys Hash e.g. RKH (SHA256):\n&#34;
        rkh_index = self.rkh_index
        for index, root_key in enumerate(self._root_key_hashes):
            nfo += f&#34;  {index}) {root_key.hex().upper()} {&#39;&lt;- Used&#39; if index == rkh_index else &#39;&#39;}\n&#34;
        rkht = self.rkht
        nfo += f&#34; RKHT (SHA256): {rkht.hex().upper()}\n&#34;
        for index, fuse in enumerate(self.rkht_fuses):
            bit_ofs = (len(rkht) - 4 * index) * 8
            nfo += f&#34;  - RKHT fuse [{bit_ofs:03}:{bit_ofs - 31:03}]: {fuse:08X}\n&#34;
        for index, cert in enumerate(self._cert):
            nfo += &#34; Root Certificate:\n&#34; if index == 0 else f&#34; Certificate {index}:\n&#34;
            nfo += cert.info()
        return nfo

    def verify_data(self, signature: bytes, data: bytes) -&gt; bool:
        &#34;&#34;&#34;Signature verification.

        :param signature: to be verified
        :param data: that has been signed
        :return: True if the data signature can be confirmed using the certificate; False otherwise
        &#34;&#34;&#34;
        cert = self._cert[-1]
        return crypto_backend().rsa_verify(cert.public_key_modulus, cert.public_key_exponent, signature, data)

    def verify_private_key(self, private_key_pem_data: bytes) -&gt; bool:
        &#34;&#34;&#34;Verify that given private key matches the public certificate.

        :param private_key_pem_data: to be tested; decrypted binary data in PEM format
        :return: True if yes; False otherwise
        &#34;&#34;&#34;
        signature = crypto_backend().rsa_sign(private_key_pem_data, bytes())
        cert = self.certificates[-1]  # last certificate
        return crypto_backend().rsa_verify(cert.public_key_modulus, cert.public_key_exponent, signature, bytes())

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Serialize Certificate Block V2 object.&#34;&#34;&#34;
        # At least one certificate must be used
        if not self._cert:
            raise ValueError(&#34;At least one certificate must be used&#34;)
        # The hast of root key certificate must be in RKHT
        if self.rkh_index is None:
            raise ValueError(&#34;The HASH of used Root Key must be in RKHT&#34;)
        # CA: Using a single certificate is allowed. In this case, the sole certificate must be self-signed and must not
        # be a CA. If multiple certificates are used, the root must be self-signed and all but the last must be CAs.
        if self._cert[-1].ca:
            raise ValueError(&#34;The last chain certificate must not be CA&#34;)
        if not all(cert.ca for cert in self._cert[:-1]):
            raise ValueError(&#34;All certificates except the last chain certificate must be CA&#34;)
        # Export
        data = self.header.export()
        for cert in self._cert:
            data += pack(&#39;&lt;I&#39;, cert.raw_size)
            data += cert.export()
        for key in self._root_key_hashes:
            data += bytes(key)
        data = misc.align_block(data, self.alignment)
        assert len(data) == self.raw_size
        return data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CertBlockV2&#39;:
        &#34;&#34;&#34;Deserialize CertBlockV2 from binary file.

        :param data: Binary data
        :param offset: Offset within the data, where the Certificate block begins, defaults to 0
        :return: Certificate Block instance
        :raises Exception: Length of the data doesn&#39;t match Certificate Block length
        &#34;&#34;&#34;
        header = CertBlockHeader.parse(data, offset)
        offset += CertBlockHeader.SIZE
        if (len(data) - offset) &lt; (header.cert_table_length + (cls.RKHT_SIZE * cls.RKH_SIZE)):
            raise Exception()
        obj = cls(version=header.version, flags=header.flags, build_number=header.build_number)
        for i in range(header.cert_count):
            cert_len = unpack_from(&#39;&lt;I&#39;, data, offset)[0]
            offset += 4
            cert_obj = Certificate(data[offset: offset + cert_len])
            obj.add_certificate(cert_obj)
            offset += cert_len
        for i in range(cls.RKHT_SIZE):
            obj.set_root_key_hash(i, data[offset: offset + cls.RKH_SIZE])
            offset += cls.RKH_SIZE
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.CertBlockV2.DEFAULT_ALIGNMENT"><code class="name">var <span class="ident">DEFAULT_ALIGNMENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.RKHT_SIZE"><code class="name">var <span class="ident">RKHT_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.RKH_SIZE"><code class="name">var <span class="ident">RKH_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CertBlockV2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize CertBlockV2 from binary file.</p>
<p>:param data: Binary data
:param offset: Offset within the data, where the Certificate block begins, defaults to 0
:return: Certificate Block instance
:raises Exception: Length of the data doesn't match Certificate Block length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CertBlockV2&#39;:
    &#34;&#34;&#34;Deserialize CertBlockV2 from binary file.

    :param data: Binary data
    :param offset: Offset within the data, where the Certificate block begins, defaults to 0
    :return: Certificate Block instance
    :raises Exception: Length of the data doesn&#39;t match Certificate Block length
    &#34;&#34;&#34;
    header = CertBlockHeader.parse(data, offset)
    offset += CertBlockHeader.SIZE
    if (len(data) - offset) &lt; (header.cert_table_length + (cls.RKHT_SIZE * cls.RKH_SIZE)):
        raise Exception()
    obj = cls(version=header.version, flags=header.flags, build_number=header.build_number)
    for i in range(header.cert_count):
        cert_len = unpack_from(&#39;&lt;I&#39;, data, offset)[0]
        offset += 4
        cert_obj = Certificate(data[offset: offset + cert_len])
        obj.add_certificate(cert_obj)
        offset += cert_len
    for i in range(cls.RKHT_SIZE):
        obj.set_root_key_hash(i, data[offset: offset + cls.RKH_SIZE])
        offset += cls.RKH_SIZE
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CertBlockV2.alignment"><code class="name">var <span class="ident">alignment</span> : int</code></dt>
<dd>
<div class="desc"><p>Alignment of the binary output, by default it is DEFAULT_ALIGNMENT but can be customized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def alignment(self) -&gt; int:
    &#34;&#34;&#34;Alignment of the binary output, by default it is DEFAULT_ALIGNMENT but can be customized.&#34;&#34;&#34;
    return self._alignment</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.certificates"><code class="name">var <span class="ident">certificates</span> : List[<a title="spsdk.utils.crypto.certificate.Certificate" href="../utils/crypto/certificate.html#spsdk.utils.crypto.certificate.Certificate">Certificate</a>]</code></dt>
<dd>
<div class="desc"><p>List of certificates in header.</p>
<p>First certificate is root certificate and followed by optional chain certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def certificates(self) -&gt; List[Certificate]:
    &#34;&#34;&#34;List of certificates in header.

    First certificate is root certificate and followed by optional chain certificates
    &#34;&#34;&#34;
    return self._cert</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.utils.crypto.cert_blocks.CertBlockHeader" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockHeader">CertBlockHeader</a></code></dt>
<dd>
<div class="desc"><p>Certificate block header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; CertBlockHeader:
    &#34;&#34;&#34;Certificate block header.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.image_length"><code class="name">var <span class="ident">image_length</span> : int</code></dt>
<dd>
<div class="desc"><p>Image length in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_length(self) -&gt; int:
    &#34;&#34;&#34;Image length in bytes.&#34;&#34;&#34;
    return self._header.image_length</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Aligned size of the certificate block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Aligned size of the certificate block.&#34;&#34;&#34;
    size = CertBlockHeader.SIZE
    size += self._header.cert_table_length
    size += self.RKH_SIZE * self.RKHT_SIZE
    return misc.align(size, self.alignment)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.rkh"><code class="name">var <span class="ident">rkh</span> : List[bytes]</code></dt>
<dd>
<div class="desc"><p>List of root keys hashes (SHA-256), each hash as 32 bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rkh(self) -&gt; List[bytes]:
    &#34;&#34;&#34;List of root keys hashes (SHA-256), each hash as 32 bytes.&#34;&#34;&#34;
    return self._root_key_hashes</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.rkh_index"><code class="name">var <span class="ident">rkh_index</span> : Union[int, NoneType]</code></dt>
<dd>
<div class="desc"><p>Index of the hash that matches the certificate; None if does not match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rkh_index(self) -&gt; Optional[int]:
    &#34;&#34;&#34;Index of the hash that matches the certificate; None if does not match.&#34;&#34;&#34;
    if self._cert:
        rkh = self._cert[0].public_key_hash
        for index, value in enumerate(self._root_key_hashes):
            if rkh == value:
                return index
    return None</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.rkht"><code class="name">var <span class="ident">rkht</span> : bytes</code></dt>
<dd>
<div class="desc"><p>32-byte hash (SHA-256) of SHA-256 hashes of up to four root public keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rkht(self) -&gt; bytes:
    &#34;&#34;&#34;32-byte hash (SHA-256) of SHA-256 hashes of up to four root public keys.&#34;&#34;&#34;
    data = bytes()
    for rkh in self._root_key_hashes:
        data += rkh
    assert len(data) == self.RKH_SIZE * self.RKHT_SIZE
    return internal_backend.hash(data)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.rkht_fuses"><code class="name">var <span class="ident">rkht_fuses</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>List of RKHT fuses, ordered from highest bit to lowest.</p>
<p>Note: Returned values are in format that should be passed for blhost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rkht_fuses(self) -&gt; List[int]:
    &#34;&#34;&#34;List of RKHT fuses, ordered from highest bit to lowest.

    Note: Returned values are in format that should be passed for blhost
    &#34;&#34;&#34;
    result = list()
    rkht = self.rkht
    while rkht:
        fuse = int.from_bytes(rkht[:4], byteorder=&#39;little&#39;)
        result.append(fuse)
        rkht = rkht[4:]
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.signature_size"><code class="name">var <span class="ident">signature_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the signature in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signature_size(self) -&gt; int:
    &#34;&#34;&#34;Size of the signature in bytes.&#34;&#34;&#34;
    return len(self.certificates[0].signature)  # The certificate is self signed, return size of its signature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.CertBlockV2.add_certificate"><code class="name flex">
<span>def <span class="ident">add_certificate</span></span>(<span>self, cert: Union[bytes, <a title="spsdk.utils.crypto.certificate.Certificate" href="../utils/crypto/certificate.html#spsdk.utils.crypto.certificate.Certificate">Certificate</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add certificate.</p>
<p>First call adds root certificate. Additional calls add chain certificates.</p>
<p>:param cert: The certificate itself in DER format
:raise ValueError: if certificate cannot be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_certificate(self, cert: Union[bytes, Certificate]) -&gt; None:
    &#34;&#34;&#34;Add certificate.

    First call adds root certificate. Additional calls add chain certificates.

    :param cert: The certificate itself in DER format
    :raise ValueError: if certificate cannot be added
    &#34;&#34;&#34;
    if isinstance(cert, bytes):
        cert_obj = Certificate(cert)
    elif isinstance(cert, Certificate):
        cert_obj = cert
    else:
        raise ValueError(&#39;Invalid parameter type (cert)&#39;)
    if cert_obj.version != &#39;v3&#39;:
        raise ValueError(&#39;Expected certificate v3 but received: &#39; + cert_obj.version)
    if self._cert:  # chain certificate?
        last_cert = self._cert[-1]  # verify that it is signed by parent key
        if not cert_obj.verify(last_cert.public_key_modulus, last_cert.public_key_exponent):
            raise ValueError(&#39;Chain certificate cannot be verified using parent public key&#39;)
    else:  # root certificate
        if cert_obj.self_signed == &#34;no&#34;:
            raise ValueError(&#34;Root certificate must be self-signed&#34;)
    self._cert.append(cert_obj)
    self._header.cert_count += 1
    self._header.cert_table_length += cert_obj.raw_size + 4</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize Certificate Block V2 object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Serialize Certificate Block V2 object.&#34;&#34;&#34;
    # At least one certificate must be used
    if not self._cert:
        raise ValueError(&#34;At least one certificate must be used&#34;)
    # The hast of root key certificate must be in RKHT
    if self.rkh_index is None:
        raise ValueError(&#34;The HASH of used Root Key must be in RKHT&#34;)
    # CA: Using a single certificate is allowed. In this case, the sole certificate must be self-signed and must not
    # be a CA. If multiple certificates are used, the root must be self-signed and all but the last must be CAs.
    if self._cert[-1].ca:
        raise ValueError(&#34;The last chain certificate must not be CA&#34;)
    if not all(cert.ca for cert in self._cert[:-1]):
        raise ValueError(&#34;All certificates except the last chain certificate must be CA&#34;)
    # Export
    data = self.header.export()
    for cert in self._cert:
        data += pack(&#39;&lt;I&#39;, cert.raw_size)
        data += cert.export()
    for key in self._root_key_hashes:
        data += bytes(key)
    data = misc.align_block(data, self.alignment)
    assert len(data) == self.raw_size
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text info about certificate block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text info about certificate block.&#34;&#34;&#34;
    nfo = self.header.info()
    nfo += &#34; Public Root Keys Hash e.g. RKH (SHA256):\n&#34;
    rkh_index = self.rkh_index
    for index, root_key in enumerate(self._root_key_hashes):
        nfo += f&#34;  {index}) {root_key.hex().upper()} {&#39;&lt;- Used&#39; if index == rkh_index else &#39;&#39;}\n&#34;
    rkht = self.rkht
    nfo += f&#34; RKHT (SHA256): {rkht.hex().upper()}\n&#34;
    for index, fuse in enumerate(self.rkht_fuses):
        bit_ofs = (len(rkht) - 4 * index) * 8
        nfo += f&#34;  - RKHT fuse [{bit_ofs:03}:{bit_ofs - 31:03}]: {fuse:08X}\n&#34;
    for index, cert in enumerate(self._cert):
        nfo += &#34; Root Certificate:\n&#34; if index == 0 else f&#34; Certificate {index}:\n&#34;
        nfo += cert.info()
    return nfo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.set_root_key_hash"><code class="name flex">
<span>def <span class="ident">set_root_key_hash</span></span>(<span>self, index: int, key_hash: Union[bytes, bytearray, <a title="spsdk.utils.crypto.certificate.Certificate" href="../utils/crypto/certificate.html#spsdk.utils.crypto.certificate.Certificate">Certificate</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add Root Key Hash into RKH at specified index.</p>
<p>Note: Multiple root public keys are supported to allow for key revocation.</p>
<p>:param index: The index of Root Key Hash in the table
:param key_hash: The Root Key Hash value (32 bytes, SHA-256);
or Certificate where the hash can be created from public key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_root_key_hash(self, index: int, key_hash: Union[bytes, bytearray, Certificate]) -&gt; None:
    &#34;&#34;&#34;Add Root Key Hash into RKH at specified index.

    Note: Multiple root public keys are supported to allow for key revocation.

    :param index: The index of Root Key Hash in the table
    :param key_hash: The Root Key Hash value (32 bytes, SHA-256);
                    or Certificate where the hash can be created from public key
    &#34;&#34;&#34;
    if isinstance(key_hash, Certificate):
        key_hash = key_hash.public_key_hash
    assert isinstance(key_hash, (bytes, bytearray))
    assert 0 &lt;= index &lt; self.RKHT_SIZE
    assert len(key_hash) == self.RKH_SIZE
    self._root_key_hashes[index] = bytes(key_hash)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.verify_data"><code class="name flex">
<span>def <span class="ident">verify_data</span></span>(<span>self, signature: bytes, data: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Signature verification.</p>
<p>:param signature: to be verified
:param data: that has been signed
:return: True if the data signature can be confirmed using the certificate; False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_data(self, signature: bytes, data: bytes) -&gt; bool:
    &#34;&#34;&#34;Signature verification.

    :param signature: to be verified
    :param data: that has been signed
    :return: True if the data signature can be confirmed using the certificate; False otherwise
    &#34;&#34;&#34;
    cert = self._cert[-1]
    return crypto_backend().rsa_verify(cert.public_key_modulus, cert.public_key_exponent, signature, data)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertBlockV2.verify_private_key"><code class="name flex">
<span>def <span class="ident">verify_private_key</span></span>(<span>self, private_key_pem_data: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify that given private key matches the public certificate.</p>
<p>:param private_key_pem_data: to be tested; decrypted binary data in PEM format
:return: True if yes; False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_private_key(self, private_key_pem_data: bytes) -&gt; bool:
    &#34;&#34;&#34;Verify that given private key matches the public certificate.

    :param private_key_pem_data: to be tested; decrypted binary data in PEM format
    :return: True if yes; False otherwise
    &#34;&#34;&#34;
    signature = crypto_backend().rsa_sign(private_key_pem_data, bytes())
    cert = self.certificates[-1]  # last certificate
    return crypto_backend().rsa_verify(cert.public_key_modulus, cert.public_key_exponent, signature, bytes())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.CertSectionV2"><code class="flex name class">
<span>class <span class="ident">CertSectionV2</span></span>
<span>(</span><span>cert_block: <a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate Section V2 class.</p>
<p>Initialize CertBlockV2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertSectionV2(BaseClass):
    &#34;&#34;&#34;Certificate Section V2 class.&#34;&#34;&#34;
    HMAC_SIZE = 32
    SECT_MARK = unpack_from(&#39;&lt;L&#39;, b&#39;sign&#39;)[0]

    @property
    def cert_block(self) -&gt; CertBlockV2:
        &#34;&#34;&#34;Return certification block.&#34;&#34;&#34;
        return self._cert_block

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Calculate raw size of section.&#34;&#34;&#34;
        # Section header size
        size = CmdHeader.SIZE
        # Header HMAC 32 bytes + Certificate block HMAC 32 bytes
        size += self.HMAC_SIZE * 2
        # Certificate block size in bytes
        size += self.cert_block.raw_size
        return size

    def __init__(self, cert_block: CertBlockV2):
        &#34;&#34;&#34;Initialize CertBlockV2.&#34;&#34;&#34;
        assert isinstance(cert_block, CertBlockV2)
        self._header = CmdHeader(EnumCmdTag.TAG, EnumSectionFlag.CLEARTEXT | EnumSectionFlag.LAST_SECT)
        self._header.address = self.SECT_MARK
        self._header.count = cert_block.raw_size // 16
        self._header.data = 1
        self._cert_block = cert_block

    def __str__(self) -&gt; str:
        return f&#34;CertSectionV2: Length={self._header.count * 16}&#34;

    def info(self) -&gt; str:
        &#34;&#34;&#34;Get object info.&#34;&#34;&#34;
        return self.cert_block.info()

    def export(self, dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize Certificate Section object.

        :param dek: The DEK value in bytes (required)
        :param mac: The MAC value in bytes (required)
        :param counter: The counter object (required)
        :return: exported bytes
        :raise Exception: raised when dek, mac, counter have invalid format
        &#34;&#34;&#34;
        if not isinstance(dek, bytes):
            raise Exception()
        if not isinstance(mac, bytes):
            raise Exception()
        if not isinstance(counter, Counter):
            raise Exception()
        # Prepare Header data
        header_data = self._header.export()
        header_encrypted = crypto_backend().aes_ctr_encrypt(dek, header_data, counter.value)
        # counter.increment()
        # Prepare Certificate Block data
        body_data = self.cert_block.export()
        # Prepare HMAC data
        hmac_data = crypto_backend().hmac(mac, header_encrypted)
        hmac_data += crypto_backend().hmac(mac, body_data)
        result = header_encrypted + hmac_data + body_data
        assert len(result) == self.raw_size
        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0,
              dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None) -&gt; &#39;CertSectionV2&#39;:
        &#34;&#34;&#34;Parse Certificate Section from bytes array.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param dek: The DEK value in bytes (required)
        :param mac: The MAC value in bytes (required)
        :param counter: The counter object (required)
        :return: parsed cert section v2 object
        :raise AttributeError: raised when dek, mac, counter are not valid
        :raise Exception: raised when there is invalid header HMAC, TAG, FLAGS, Mark
        :raise Exception: raised when there is invalid certificate block HMAC
        &#34;&#34;&#34;
        if not isinstance(dek, bytes):
            raise AttributeError()
        if not isinstance(mac, bytes):
            raise AttributeError()
        if not isinstance(counter, Counter):
            raise AttributeError()
        index = offset
        header_encrypted = data[index: index + CmdHeader.SIZE]
        index += CmdHeader.SIZE
        header_hmac = data[index: index + cls.HMAC_SIZE]
        index += cls.HMAC_SIZE
        cert_block_hmac = data[index: index + cls.HMAC_SIZE]
        index += cls.HMAC_SIZE
        if header_hmac != crypto_backend().hmac(mac, header_encrypted):
            raise Exception(&#34;Invalid Header HMAC&#34;)
        header_encrypted = crypto_backend().aes_ctr_decrypt(dek, header_encrypted, counter.value)
        header = CmdHeader.parse(header_encrypted)
        if header.tag != EnumCmdTag.TAG:
            raise Exception(f&#34;Invalid Header TAG: 0x{header.tag:02X}&#34;)
        if header.flags != (EnumSectionFlag.CLEARTEXT | EnumSectionFlag.LAST_SECT):
            raise Exception(f&#34;Invalid Header FLAGS: 0x{header.flags:02X}&#34;)
        if header.address != cls.SECT_MARK:
            raise Exception(f&#34;Invalid Section Mark: 0x{header.address:08X}&#34;)
        # Parse Certificate Block
        cert_block = CertBlockV2.parse(data, index)
        if cert_block_hmac != crypto_backend().hmac(mac, data[index: index + cert_block.raw_size]):
            raise Exception(&#34;Invalid Certificate Block HMAC&#34;)
        index += cert_block.raw_size
        cert_section_obj = cls(cert_block)
        counter.increment(calc_cypher_block_count(index - offset))
        return cert_section_obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.CertSectionV2.HMAC_SIZE"><code class="name">var <span class="ident">HMAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.CertSectionV2.SECT_MARK"><code class="name">var <span class="ident">SECT_MARK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CertSectionV2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, dek: bytes = b'', mac: bytes = b'', counter: Union[<a title="spsdk.utils.crypto.common.Counter" href="../utils/crypto/common.html#spsdk.utils.crypto.common.Counter">Counter</a>, NoneType] = None) ‑> <a title="spsdk.sbfile.sections.CertSectionV2" href="sections.html#spsdk.sbfile.sections.CertSectionV2">CertSectionV2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse Certificate Section from bytes array.</p>
<p>:param data: Raw data of parsed image
:param offset: The offset of input data
:param dek: The DEK value in bytes (required)
:param mac: The MAC value in bytes (required)
:param counter: The counter object (required)
:return: parsed cert section v2 object
:raise AttributeError: raised when dek, mac, counter are not valid
:raise Exception: raised when there is invalid header HMAC, TAG, FLAGS, Mark
:raise Exception: raised when there is invalid certificate block HMAC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0,
          dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None) -&gt; &#39;CertSectionV2&#39;:
    &#34;&#34;&#34;Parse Certificate Section from bytes array.

    :param data: Raw data of parsed image
    :param offset: The offset of input data
    :param dek: The DEK value in bytes (required)
    :param mac: The MAC value in bytes (required)
    :param counter: The counter object (required)
    :return: parsed cert section v2 object
    :raise AttributeError: raised when dek, mac, counter are not valid
    :raise Exception: raised when there is invalid header HMAC, TAG, FLAGS, Mark
    :raise Exception: raised when there is invalid certificate block HMAC
    &#34;&#34;&#34;
    if not isinstance(dek, bytes):
        raise AttributeError()
    if not isinstance(mac, bytes):
        raise AttributeError()
    if not isinstance(counter, Counter):
        raise AttributeError()
    index = offset
    header_encrypted = data[index: index + CmdHeader.SIZE]
    index += CmdHeader.SIZE
    header_hmac = data[index: index + cls.HMAC_SIZE]
    index += cls.HMAC_SIZE
    cert_block_hmac = data[index: index + cls.HMAC_SIZE]
    index += cls.HMAC_SIZE
    if header_hmac != crypto_backend().hmac(mac, header_encrypted):
        raise Exception(&#34;Invalid Header HMAC&#34;)
    header_encrypted = crypto_backend().aes_ctr_decrypt(dek, header_encrypted, counter.value)
    header = CmdHeader.parse(header_encrypted)
    if header.tag != EnumCmdTag.TAG:
        raise Exception(f&#34;Invalid Header TAG: 0x{header.tag:02X}&#34;)
    if header.flags != (EnumSectionFlag.CLEARTEXT | EnumSectionFlag.LAST_SECT):
        raise Exception(f&#34;Invalid Header FLAGS: 0x{header.flags:02X}&#34;)
    if header.address != cls.SECT_MARK:
        raise Exception(f&#34;Invalid Section Mark: 0x{header.address:08X}&#34;)
    # Parse Certificate Block
    cert_block = CertBlockV2.parse(data, index)
    if cert_block_hmac != crypto_backend().hmac(mac, data[index: index + cert_block.raw_size]):
        raise Exception(&#34;Invalid Certificate Block HMAC&#34;)
    index += cert_block.raw_size
    cert_section_obj = cls(cert_block)
    counter.increment(calc_cypher_block_count(index - offset))
    return cert_section_obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CertSectionV2.cert_block"><code class="name">var <span class="ident">cert_block</span> : <a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a></code></dt>
<dd>
<div class="desc"><p>Return certification block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_block(self) -&gt; CertBlockV2:
    &#34;&#34;&#34;Return certification block.&#34;&#34;&#34;
    return self._cert_block</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertSectionV2.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Calculate raw size of section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Calculate raw size of section.&#34;&#34;&#34;
    # Section header size
    size = CmdHeader.SIZE
    # Header HMAC 32 bytes + Certificate block HMAC 32 bytes
    size += self.HMAC_SIZE * 2
    # Certificate block size in bytes
    size += self.cert_block.raw_size
    return size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.CertSectionV2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dek: bytes = b'', mac: bytes = b'', counter: Union[<a title="spsdk.utils.crypto.common.Counter" href="../utils/crypto/common.html#spsdk.utils.crypto.common.Counter">Counter</a>, NoneType] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize Certificate Section object.</p>
<p>:param dek: The DEK value in bytes (required)
:param mac: The MAC value in bytes (required)
:param counter: The counter object (required)
:return: exported bytes
:raise Exception: raised when dek, mac, counter have invalid format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dek: bytes = b&#39;&#39;, mac: bytes = b&#39;&#39;, counter: Optional[Counter] = None) -&gt; bytes:
    &#34;&#34;&#34;Serialize Certificate Section object.

    :param dek: The DEK value in bytes (required)
    :param mac: The MAC value in bytes (required)
    :param counter: The counter object (required)
    :return: exported bytes
    :raise Exception: raised when dek, mac, counter have invalid format
    &#34;&#34;&#34;
    if not isinstance(dek, bytes):
        raise Exception()
    if not isinstance(mac, bytes):
        raise Exception()
    if not isinstance(counter, Counter):
        raise Exception()
    # Prepare Header data
    header_data = self._header.export()
    header_encrypted = crypto_backend().aes_ctr_encrypt(dek, header_data, counter.value)
    # counter.increment()
    # Prepare Certificate Block data
    body_data = self.cert_block.export()
    # Prepare HMAC data
    hmac_data = crypto_backend().hmac(mac, header_encrypted)
    hmac_data += crypto_backend().hmac(mac, body_data)
    result = header_encrypted + hmac_data + body_data
    assert len(result) == self.raw_size
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CertSectionV2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get object info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Get object info.&#34;&#34;&#34;
    return self.cert_block.info()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.Certificate"><code class="flex name class">
<span>class <span class="ident">Certificate</span></span>
<span>(</span><span>certificate: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Internally used representation of a Certificate.</p>
<p>Initialize the Certificate object.</p>
<p>:param certificate: Certificate bytes (read from file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Certificate:
    &#34;&#34;&#34;Internally used representation of a Certificate.&#34;&#34;&#34;

    @property
    def version(self) -&gt; str:
        &#34;&#34;&#34;Version of the Certificate.&#34;&#34;&#34;
        return self._cert.native[&#39;tbs_certificate&#39;][&#39;version&#39;]

    @property
    def ca(self) -&gt; bool:   # pylint: disable=invalid-name
        &#34;&#34;&#34;Certification Authority flag.&#34;&#34;&#34;
        return self._cert.ca

    @property
    def self_signed(self) -&gt; str:
        &#34;&#34;&#34;Indication whether the Certificate is self-signed.

        A unicode string of &#34;no&#34; or &#34;maybe&#34;. The &#34;maybe&#34; result will
        be returned if the certificate issuer and subject are the same.
        If a key identifier and authority key identifier are present,
        they will need to match otherwise &#34;no&#34; will be returned.

        To verify is a certificate is truly self-signed, the signature
        will need to be verified. See the certvalidator package for
        one possible solution.
        &#34;&#34;&#34;
        return self._cert.self_signed

    @property
    def self_issued(self) -&gt; bool:
        &#34;&#34;&#34;Is the Certificate self-issued (subject and issuer are the same).&#34;&#34;&#34;
        return self._cert.self_issued

    @property
    def serial_number(self) -&gt; int:
        &#34;&#34;&#34;Serial number of the Certificate.&#34;&#34;&#34;
        return self._cert.serial_number

    @property
    def hash_algo(self) -&gt; str:
        &#34;&#34;&#34;HASH algorithm used in the Certificate.&#34;&#34;&#34;
        return self._cert.hash_algo

    @property
    def public_key_modulus(self) -&gt; int:
        &#34;&#34;&#34;Modulus of the public key of the certificate.&#34;&#34;&#34;
        return self._cert.public_key.native[&#39;public_key&#39;][&#39;modulus&#39;]

    @property
    def public_key_exponent(self) -&gt; int:
        &#34;&#34;&#34;Exponent of the public key of the certificate.&#34;&#34;&#34;
        return self._cert.public_key.native[&#39;public_key&#39;][&#39;public_exponent&#39;]

    @property
    def public_key_hash(self) -&gt; bytes:
        &#34;&#34;&#34;32 bytes hash (SHA-256) of public key (modulus and exponent).&#34;&#34;&#34;
        modulus = self._cert.public_key.native[&#39;public_key&#39;][&#39;modulus&#39;]
        exponent = self._cert.public_key.native[&#39;public_key&#39;][&#39;public_exponent&#39;]
        modulus_len = (modulus.bit_length() + 7) // 8
        exponent_len = (exponent.bit_length() + 7) // 8
        return crypto_backend().hash(modulus.to_bytes(modulus_len, &#34;big&#34;) + exponent.to_bytes(exponent_len, &#34;big&#34;))

    @property
    def public_key_usage(self) -&gt; Set[str]:
        &#34;&#34;&#34;Usage of the Certificate.&#34;&#34;&#34;
        return self._cert.key_usage_value.native

    @property
    def signature_algo(self) -&gt; str:
        &#34;&#34;&#34;Certificate signature algorithm.&#34;&#34;&#34;
        return self._cert.signature_algo

    @property
    def signature(self) -&gt; bytes:
        &#34;&#34;&#34;Certificate signature.&#34;&#34;&#34;
        return self._cert.signature

    @property
    def max_path_length(self) -&gt; int:
        &#34;&#34;&#34;Maximum length of derived Certificate chain.&#34;&#34;&#34;
        if not self.ca:
            return 0
        return self._cert.basic_constraints_value[&#39;path_len_constraint&#39;].native

    @property
    def issuer(self) -&gt; Dict[str, str]:
        &#34;&#34;&#34;Certificate issuer.&#34;&#34;&#34;
        return self._cert.issuer.native

    @property
    def not_valid_before(self) -&gt; datetime:
        &#34;&#34;&#34;Begging of the Certificate valid period.&#34;&#34;&#34;
        return self._cert.not_valid_before

    @property
    def not_valid_after(self) -&gt; datetime:
        &#34;&#34;&#34;End of the Certificate valid period.&#34;&#34;&#34;
        return self._cert.not_valid_after

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Size of the Certificate data (aligned to 4 bytes).&#34;&#34;&#34;
        size = len(self._data)
        if size % 4:
            size += 4 - (size % 4)
        return size

    def __init__(self, certificate: bytes) -&gt; None:
        &#34;&#34;&#34;Initialize the Certificate object.

        :param certificate: Certificate bytes (read from file)
        &#34;&#34;&#34;
        self._cert = x509.Certificate.load(certificate)
        self._data = certificate

    def _get_issuer_info(self, key: str, format_str: str) -&gt; str:
        &#34;&#34;&#34;Return selected issuer info in specified format.

        :param key: of the info to be returned
        :param format_str: formatting string, e.g. &#34;Value: {}\n&#34;
        :return: formatted info; empty string if the info is not available (as most of the info are optional)
        &#34;&#34;&#34;
        value = self.issuer.get(key, None)
        if not value:
            return &#39;&#39;

        return format_str.format(value)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text information about the Certificate.&#34;&#34;&#34;
        not_valid_before = self.not_valid_before.strftime(&#34;%d.%m.%Y (%H:%M:%S)&#34;)
        not_valid_after = self.not_valid_after.strftime(&#34;%d.%m.%Y (%H:%M:%S)&#34;)
        nfo = &#34;&#34;
        nfo += f&#34;  Certification Authority:    {&#39;YES&#39; if self.ca else &#39;NO&#39;}\n&#34;
        if self.ca:
            nfo += f&#34;  Max Path Length:            {self.max_path_length}\n&#34;
        nfo += f&#34;  Serial Number:              {hex(self.serial_number)}\n&#34;
        nfo += f&#34;  Validity Range:             {not_valid_before} - {not_valid_after}\n&#34;
        nfo += f&#34;  Signature Algorithm:        {self.signature_algo}\n&#34;
        nfo += f&#34;  Self Issued:                {&#39;YES&#39; if self.self_issued else &#39;NO&#39;}\n&#34;
        nfo += self._get_issuer_info(&#39;country_name&#39;, &#34;  Issuer Country Name:        {}\n&#34;)
        nfo += self._get_issuer_info(&#39;state_or_province_name&#39;, &#34;  Issuer State/Province Name: {}\n&#34;)
        nfo += self._get_issuer_info(&#39;locality_name&#39;, &#34;  Issuer Locality Name:       {}\n&#34;)
        nfo += self._get_issuer_info(&#39;organization_name&#39;, &#34;  Issuer Organization Name:   {}\n&#34;)
        nfo += self._get_issuer_info(&#39;organizational_unit_name&#39;, &#34;  Issuer Organ. Unit Name:    {}\n&#34;)
        nfo += self._get_issuer_info(&#39;common_name&#39;, &#34;  Issuer Common Name:         {}\n&#34;)
        nfo += self._get_issuer_info(&#39;email_address&#39;, &#34;  Issuer Email Address:       {}\n&#34;)
        return nfo

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Serialized Certificate data.&#34;&#34;&#34;
        raw_data = self._data
        if len(raw_data) % 4:
            raw_data += b&#39;\x00&#39; * (4 - (len(raw_data) % 4))
        return raw_data

    def verify(self, public_key_modulus: int, public_key_exponent: int) -&gt; bool:
        &#34;&#34;&#34;Use given public key to verify the certificate is signed.

        :param public_key_modulus: modulus of the public key to be verified
        :param public_key_exponent: exponent of the public key to be verified
        :return: True if verification pass; False otherwise
        &#34;&#34;&#34;
        public_key = internal_backend.rsa_public_key(public_key_modulus, public_key_exponent)
        key_object = load_public_key(public_key.export_key())
        try:
            rsa_pkcs1v15_verify(key_object, self._cert[&#39;signature_value&#39;].native, self._cert[&#39;tbs_certificate&#39;].dump(),
                                self.hash_algo)
        except SignatureError:
            return False
        return True</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.Certificate.ca"><code class="name">var <span class="ident">ca</span> : bool</code></dt>
<dd>
<div class="desc"><p>Certification Authority flag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ca(self) -&gt; bool:   # pylint: disable=invalid-name
    &#34;&#34;&#34;Certification Authority flag.&#34;&#34;&#34;
    return self._cert.ca</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.hash_algo"><code class="name">var <span class="ident">hash_algo</span> : str</code></dt>
<dd>
<div class="desc"><p>HASH algorithm used in the Certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hash_algo(self) -&gt; str:
    &#34;&#34;&#34;HASH algorithm used in the Certificate.&#34;&#34;&#34;
    return self._cert.hash_algo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.issuer"><code class="name">var <span class="ident">issuer</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Certificate issuer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def issuer(self) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Certificate issuer.&#34;&#34;&#34;
    return self._cert.issuer.native</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.max_path_length"><code class="name">var <span class="ident">max_path_length</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum length of derived Certificate chain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_path_length(self) -&gt; int:
    &#34;&#34;&#34;Maximum length of derived Certificate chain.&#34;&#34;&#34;
    if not self.ca:
        return 0
    return self._cert.basic_constraints_value[&#39;path_len_constraint&#39;].native</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.not_valid_after"><code class="name">var <span class="ident">not_valid_after</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>End of the Certificate valid period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def not_valid_after(self) -&gt; datetime:
    &#34;&#34;&#34;End of the Certificate valid period.&#34;&#34;&#34;
    return self._cert.not_valid_after</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.not_valid_before"><code class="name">var <span class="ident">not_valid_before</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Begging of the Certificate valid period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def not_valid_before(self) -&gt; datetime:
    &#34;&#34;&#34;Begging of the Certificate valid period.&#34;&#34;&#34;
    return self._cert.not_valid_before</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.public_key_exponent"><code class="name">var <span class="ident">public_key_exponent</span> : int</code></dt>
<dd>
<div class="desc"><p>Exponent of the public key of the certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def public_key_exponent(self) -&gt; int:
    &#34;&#34;&#34;Exponent of the public key of the certificate.&#34;&#34;&#34;
    return self._cert.public_key.native[&#39;public_key&#39;][&#39;public_exponent&#39;]</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.public_key_hash"><code class="name">var <span class="ident">public_key_hash</span> : bytes</code></dt>
<dd>
<div class="desc"><p>32 bytes hash (SHA-256) of public key (modulus and exponent).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def public_key_hash(self) -&gt; bytes:
    &#34;&#34;&#34;32 bytes hash (SHA-256) of public key (modulus and exponent).&#34;&#34;&#34;
    modulus = self._cert.public_key.native[&#39;public_key&#39;][&#39;modulus&#39;]
    exponent = self._cert.public_key.native[&#39;public_key&#39;][&#39;public_exponent&#39;]
    modulus_len = (modulus.bit_length() + 7) // 8
    exponent_len = (exponent.bit_length() + 7) // 8
    return crypto_backend().hash(modulus.to_bytes(modulus_len, &#34;big&#34;) + exponent.to_bytes(exponent_len, &#34;big&#34;))</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.public_key_modulus"><code class="name">var <span class="ident">public_key_modulus</span> : int</code></dt>
<dd>
<div class="desc"><p>Modulus of the public key of the certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def public_key_modulus(self) -&gt; int:
    &#34;&#34;&#34;Modulus of the public key of the certificate.&#34;&#34;&#34;
    return self._cert.public_key.native[&#39;public_key&#39;][&#39;modulus&#39;]</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.public_key_usage"><code class="name">var <span class="ident">public_key_usage</span> : Set[str]</code></dt>
<dd>
<div class="desc"><p>Usage of the Certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def public_key_usage(self) -&gt; Set[str]:
    &#34;&#34;&#34;Usage of the Certificate.&#34;&#34;&#34;
    return self._cert.key_usage_value.native</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the Certificate data (aligned to 4 bytes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Size of the Certificate data (aligned to 4 bytes).&#34;&#34;&#34;
    size = len(self._data)
    if size % 4:
        size += 4 - (size % 4)
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.self_issued"><code class="name">var <span class="ident">self_issued</span> : bool</code></dt>
<dd>
<div class="desc"><p>Is the Certificate self-issued (subject and issuer are the same).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def self_issued(self) -&gt; bool:
    &#34;&#34;&#34;Is the Certificate self-issued (subject and issuer are the same).&#34;&#34;&#34;
    return self._cert.self_issued</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.self_signed"><code class="name">var <span class="ident">self_signed</span> : str</code></dt>
<dd>
<div class="desc"><p>Indication whether the Certificate is self-signed.</p>
<p>A unicode string of "no" or "maybe". The "maybe" result will
be returned if the certificate issuer and subject are the same.
If a key identifier and authority key identifier are present,
they will need to match otherwise "no" will be returned.</p>
<p>To verify is a certificate is truly self-signed, the signature
will need to be verified. See the certvalidator package for
one possible solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def self_signed(self) -&gt; str:
    &#34;&#34;&#34;Indication whether the Certificate is self-signed.

    A unicode string of &#34;no&#34; or &#34;maybe&#34;. The &#34;maybe&#34; result will
    be returned if the certificate issuer and subject are the same.
    If a key identifier and authority key identifier are present,
    they will need to match otherwise &#34;no&#34; will be returned.

    To verify is a certificate is truly self-signed, the signature
    will need to be verified. See the certvalidator package for
    one possible solution.
    &#34;&#34;&#34;
    return self._cert.self_signed</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.serial_number"><code class="name">var <span class="ident">serial_number</span> : int</code></dt>
<dd>
<div class="desc"><p>Serial number of the Certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def serial_number(self) -&gt; int:
    &#34;&#34;&#34;Serial number of the Certificate.&#34;&#34;&#34;
    return self._cert.serial_number</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.signature"><code class="name">var <span class="ident">signature</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Certificate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signature(self) -&gt; bytes:
    &#34;&#34;&#34;Certificate signature.&#34;&#34;&#34;
    return self._cert.signature</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.signature_algo"><code class="name">var <span class="ident">signature_algo</span> : str</code></dt>
<dd>
<div class="desc"><p>Certificate signature algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signature_algo(self) -&gt; str:
    &#34;&#34;&#34;Certificate signature algorithm.&#34;&#34;&#34;
    return self._cert.signature_algo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.version"><code class="name">var <span class="ident">version</span> : str</code></dt>
<dd>
<div class="desc"><p>Version of the Certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; str:
    &#34;&#34;&#34;Version of the Certificate.&#34;&#34;&#34;
    return self._cert.native[&#39;tbs_certificate&#39;][&#39;version&#39;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.Certificate.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialized Certificate data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Serialized Certificate data.&#34;&#34;&#34;
    raw_data = self._data
    if len(raw_data) % 4:
        raw_data += b&#39;\x00&#39; * (4 - (len(raw_data) % 4))
    return raw_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text information about the Certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text information about the Certificate.&#34;&#34;&#34;
    not_valid_before = self.not_valid_before.strftime(&#34;%d.%m.%Y (%H:%M:%S)&#34;)
    not_valid_after = self.not_valid_after.strftime(&#34;%d.%m.%Y (%H:%M:%S)&#34;)
    nfo = &#34;&#34;
    nfo += f&#34;  Certification Authority:    {&#39;YES&#39; if self.ca else &#39;NO&#39;}\n&#34;
    if self.ca:
        nfo += f&#34;  Max Path Length:            {self.max_path_length}\n&#34;
    nfo += f&#34;  Serial Number:              {hex(self.serial_number)}\n&#34;
    nfo += f&#34;  Validity Range:             {not_valid_before} - {not_valid_after}\n&#34;
    nfo += f&#34;  Signature Algorithm:        {self.signature_algo}\n&#34;
    nfo += f&#34;  Self Issued:                {&#39;YES&#39; if self.self_issued else &#39;NO&#39;}\n&#34;
    nfo += self._get_issuer_info(&#39;country_name&#39;, &#34;  Issuer Country Name:        {}\n&#34;)
    nfo += self._get_issuer_info(&#39;state_or_province_name&#39;, &#34;  Issuer State/Province Name: {}\n&#34;)
    nfo += self._get_issuer_info(&#39;locality_name&#39;, &#34;  Issuer Locality Name:       {}\n&#34;)
    nfo += self._get_issuer_info(&#39;organization_name&#39;, &#34;  Issuer Organization Name:   {}\n&#34;)
    nfo += self._get_issuer_info(&#39;organizational_unit_name&#39;, &#34;  Issuer Organ. Unit Name:    {}\n&#34;)
    nfo += self._get_issuer_info(&#39;common_name&#39;, &#34;  Issuer Common Name:         {}\n&#34;)
    nfo += self._get_issuer_info(&#39;email_address&#39;, &#34;  Issuer Email Address:       {}\n&#34;)
    return nfo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.Certificate.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, public_key_modulus: int, public_key_exponent: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Use given public key to verify the certificate is signed.</p>
<p>:param public_key_modulus: modulus of the public key to be verified
:param public_key_exponent: exponent of the public key to be verified
:return: True if verification pass; False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify(self, public_key_modulus: int, public_key_exponent: int) -&gt; bool:
    &#34;&#34;&#34;Use given public key to verify the certificate is signed.

    :param public_key_modulus: modulus of the public key to be verified
    :param public_key_exponent: exponent of the public key to be verified
    :return: True if verification pass; False otherwise
    &#34;&#34;&#34;
    public_key = internal_backend.rsa_public_key(public_key_modulus, public_key_exponent)
    key_object = load_public_key(public_key.export_key())
    try:
        rsa_pkcs1v15_verify(key_object, self._cert[&#39;signature_value&#39;].native, self._cert[&#39;tbs_certificate&#39;].dump(),
                            self.hash_algo)
    except SignatureError:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.CmdCall"><code class="flex name class">
<span>class <span class="ident">CmdCall</span></span>
<span>(</span><span>address: int = 0, argument: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Call.</p>
<p>The call statement is used for inserting a bootloader command that executes a function
from one of the files that are loaded into the memory.</p>
<p>Initialize Command Call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdCall(CmdBaseClass):
    &#34;&#34;&#34;Command Call.

    The call statement is used for inserting a bootloader command that executes a function
    from one of the files that are loaded into the memory.
    &#34;&#34;&#34;

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s address.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def argument(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
        return self._header.data

    @argument.setter
    def argument(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s argument.&#34;&#34;&#34;
        self._header.data = value

    def __init__(self, address: int = 0, argument: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize Command Call.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.CALL)
        self.address = address
        self.argument = argument

    def __str__(self) -&gt; str:
        return f&#34;CALL: Address=0x{self.address:08X}, Argument=0x{self.argument:08X}&#34;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCall&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Call object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.CALL
        return cls(header.address, header.data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdCall.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdCall" href="commands.html#spsdk.sbfile.commands.CmdCall">CmdCall</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Call object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCall&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Call object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.CALL
    return cls(header.address, header.data)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdCall.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdCall.argument"><code class="name">var <span class="ident">argument</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def argument(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
    return self._header.data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdErase"><code class="flex name class">
<span>class <span class="ident">CmdErase</span></span>
<span>(</span><span>address: int = 0, length: int = 0, flags: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Erase class.</p>
<p>Initialize Command Erase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdErase(CmdBaseClass):
    &#34;&#34;&#34;Command Erase class.&#34;&#34;&#34;
    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s address.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s count.&#34;&#34;&#34;
        return self._header.count

    @length.setter
    def length(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s count.&#34;&#34;&#34;
        self._header.count = value

    @property
    def flags(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s flag.&#34;&#34;&#34;
        return self._header.flags

    @flags.setter
    def flags(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s flag.&#34;&#34;&#34;
        self._header.flags = value

    def __init__(self, address: int = 0, length: int = 0, flags: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize Command Erase.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.ERASE)
        self.address = address
        self.length = length
        self.flags = flags

    def __str__(self) -&gt; str:
        return f&#34;ERASE: Address=0x{self.address:08X}, Length={self.length}, Flags=0x{self.flags:08X}&#34;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdErase&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Erase object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.ERASE
        return cls(header.address, header.count, header.flags)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdErase.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdErase" href="commands.html#spsdk.sbfile.commands.CmdErase">CmdErase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Erase object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdErase&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Erase object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.ERASE
    return cls(header.address, header.count, header.flags)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdErase.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdErase.flags"><code class="name">var <span class="ident">flags</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's flag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s flag.&#34;&#34;&#34;
    return self._header.flags</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdErase.length"><code class="name">var <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s count.&#34;&#34;&#34;
    return self._header.count</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdFill"><code class="flex name class">
<span>class <span class="ident">CmdFill</span></span>
<span>(</span><span>address: int, pattern: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Fill class.</p>
<p>Initialize Command Fill.</p>
<p>:param address: to write data
:param pattern: data to be written
:raise ValueError: raised when size is not aligned to 4 bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdFill(CmdBaseClass):
    &#34;&#34;&#34;Command Fill class.&#34;&#34;&#34;
    PADDING_VALUE = 0x00

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return address of the command Fill.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set address for the command Fill.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Calculate raw size of header.&#34;&#34;&#34;
        size = CmdHeader.SIZE
        size += len(self._pattern) - 4
        if size % CmdHeader.SIZE:
            size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
        return size

    def __init__(self, address: int, pattern: bytes) -&gt; None:
        &#34;&#34;&#34;Initialize Command Fill.

        :param address: to write data
        :param pattern: data to be written
        :raise ValueError: raised when size is not aligned to 4 bytes
        &#34;&#34;&#34;
        super().__init__(EnumCmdTag.FILL)
        assert isinstance(pattern, (bytes, bytearray))
        if len(pattern) &lt; 4:
            raise ValueError(&#39;pattern must be at least 4 bytes long&#39;)
        if len(pattern) % 4:
            raise ValueError(&#39;pattern size must be aligned to 4 bytes&#39;)
        self.address = address
        self._pattern = bytes(pattern)
        # update header
        self._header.data = unpack_from(&#34;&lt;L&#34;, self._pattern)[0]
        self._header.count = len(self._pattern)

    @property
    def pattern(self) -&gt; bytes:
        &#34;&#34;&#34;Return binary data to fill.&#34;&#34;&#34;
        return self._pattern

    def __str__(self) -&gt; str:
        return f&#34;FILL: Address=0x{self.address:08X}, Pattern=&#34; + &#34; &#34;.join(f&#39;{byte:02X}&#39; for byte in self._pattern)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Return command in binary form (serialization).&#34;&#34;&#34;
        # export cmd
        data = super().export(dbg_info)
        # export additional data
        if len(self._pattern) &gt; 4:
            data += bytes(self._pattern[4:])
            dbg_info.append_binary_data(&#39;pattern&#39;, self._pattern[4:])
        data = SecBootBlckSize.align_block_fill_random(data)
        return data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdFill&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Fill object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.FILL
        # The last 4 bytes of header are part of pattern value
        offset += CmdHeader.SIZE - 4
        return cls(header.address, data[offset: offset + header.count])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdFill.PADDING_VALUE"><code class="name">var <span class="ident">PADDING_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdFill.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdFill" href="commands.html#spsdk.sbfile.commands.CmdFill">CmdFill</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Fill object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdFill&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Fill object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.FILL
    # The last 4 bytes of header are part of pattern value
    offset += CmdHeader.SIZE - 4
    return cls(header.address, data[offset: offset + header.count])</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdFill.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return address of the command Fill.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return address of the command Fill.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdFill.pattern"><code class="name">var <span class="ident">pattern</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return binary data to fill.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pattern(self) -&gt; bytes:
    &#34;&#34;&#34;Return binary data to fill.&#34;&#34;&#34;
    return self._pattern</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdFill.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Calculate raw size of header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Calculate raw size of header.&#34;&#34;&#34;
    size = CmdHeader.SIZE
    size += len(self._pattern) - 4
    if size % CmdHeader.SIZE:
        size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
    return size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdFill.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Return command in binary form (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Return command in binary form (serialization).&#34;&#34;&#34;
    # export cmd
    data = super().export(dbg_info)
    # export additional data
    if len(self._pattern) &gt; 4:
        data += bytes(self._pattern[4:])
        dbg_info.append_binary_data(&#39;pattern&#39;, self._pattern[4:])
    data = SecBootBlckSize.align_block_fill_random(data)
    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdJump"><code class="flex name class">
<span>class <span class="ident">CmdJump</span></span>
<span>(</span><span>address: int = 0, argument: int = 0, spreg: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Jump class.</p>
<p>Initialize Command Jump.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdJump(CmdBaseClass):
    &#34;&#34;&#34;Command Jump class.&#34;&#34;&#34;
    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return address of the command Jump.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set address of the command Jump.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def argument(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
        return self._header.data

    @argument.setter
    def argument(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s argument.&#34;&#34;&#34;
        assert 0x00 &lt;= value &lt;= 0xFF
        self._header.data = value

    @property
    def spreg(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Return command&#39;s Stack Pointer.&#34;&#34;&#34;
        if self._header.flags == 1:
            return self._header.count

        return None

    @spreg.setter
    def spreg(self, value: Optional[int]) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s Stack Pointer.&#34;&#34;&#34;
        if value is None:
            self._header.flags = 0
            self._header.count = 0
        else:
            self._header.flags = 1
            self._header.count = value

    def __init__(self, address: int = 0, argument: int = 0, spreg: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize Command Jump.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.JUMP)
        self.address = address
        self.argument = argument
        self.spreg = spreg

    def __str__(self) -&gt; str:
        nfo = f&#34;JUMP: Address=0x{self.address:08X}, Argument=0x{self.argument:08X}&#34;
        if self.spreg is not None:
            nfo += f&#34;, SP=0x{self.spreg:08X}&#34;
        return nfo

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdJump&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Jump object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.JUMP
        return cls(header.address, header.data, header.count if header.flags else None)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdJump.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdJump" href="commands.html#spsdk.sbfile.commands.CmdJump">CmdJump</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Jump object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdJump&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Jump object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.JUMP
    return cls(header.address, header.data, header.count if header.flags else None)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdJump.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return address of the command Jump.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return address of the command Jump.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdJump.argument"><code class="name">var <span class="ident">argument</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def argument(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
    return self._header.data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdJump.spreg"><code class="name">var <span class="ident">spreg</span> : Union[int, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return command's Stack Pointer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spreg(self) -&gt; Optional[int]:
    &#34;&#34;&#34;Return command&#39;s Stack Pointer.&#34;&#34;&#34;
    if self._header.flags == 1:
        return self._header.count

    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdKeyStoreBackup"><code class="flex name class">
<span>class <span class="ident">CmdKeyStoreBackup</span></span>
<span>(</span><span>address: int, controller_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to backup keystore from non-volatile memory.</p>
<p>Initialize CmdKeyStoreBackupRestore.</p>
<p>:param address: where to backup key-store or source for restoring key-store
:param controller_id: ID of the memory to backup key-store or source memory to load key-store back</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdKeyStoreBackup(CmdKeyStoreBackupRestore):
    &#34;&#34;&#34;Command to backup keystore from non-volatile memory.&#34;&#34;&#34;

    @classmethod
    def cmd_id(cls) -&gt; EnumCmdTag:
        &#34;&#34;&#34;Return command ID for backup operation.&#34;&#34;&#34;
        return EnumCmdTag.WR_KEYSTORE_FROM_NV</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore">CmdKeyStoreBackupRestore</a></li>
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdKeyStoreBackup.cmd_id"><code class="name flex">
<span>def <span class="ident">cmd_id</span></span>(<span>) ‑> <a title="spsdk.sbfile.commands.EnumCmdTag" href="commands.html#spsdk.sbfile.commands.EnumCmdTag">EnumCmdTag</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return command ID for backup operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cmd_id(cls) -&gt; EnumCmdTag:
    &#34;&#34;&#34;Return command ID for backup operation.&#34;&#34;&#34;
    return EnumCmdTag.WR_KEYSTORE_FROM_NV</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore">CmdKeyStoreBackupRestore</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.address" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.controller_id" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore.controller_id">controller_id</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.parse" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdKeyStoreRestore"><code class="flex name class">
<span>class <span class="ident">CmdKeyStoreRestore</span></span>
<span>(</span><span>address: int, controller_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to restore keystore into non-volatile memory.</p>
<p>Initialize CmdKeyStoreBackupRestore.</p>
<p>:param address: where to backup key-store or source for restoring key-store
:param controller_id: ID of the memory to backup key-store or source memory to load key-store back</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdKeyStoreRestore(CmdKeyStoreBackupRestore):
    &#34;&#34;&#34;Command to restore keystore into non-volatile memory.&#34;&#34;&#34;

    @classmethod
    def cmd_id(cls) -&gt; EnumCmdTag:
        &#34;&#34;&#34;Return command ID for restore operation.&#34;&#34;&#34;
        return EnumCmdTag.WR_KEYSTORE_TO_NV</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore">CmdKeyStoreBackupRestore</a></li>
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdKeyStoreRestore.cmd_id"><code class="name flex">
<span>def <span class="ident">cmd_id</span></span>(<span>) ‑> <a title="spsdk.sbfile.commands.EnumCmdTag" href="commands.html#spsdk.sbfile.commands.EnumCmdTag">EnumCmdTag</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return command ID for restore operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cmd_id(cls) -&gt; EnumCmdTag:
    &#34;&#34;&#34;Return command ID for restore operation.&#34;&#34;&#34;
    return EnumCmdTag.WR_KEYSTORE_TO_NV</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore">CmdKeyStoreBackupRestore</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.address" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.controller_id" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore.controller_id">controller_id</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.parse" href="commands.html#spsdk.sbfile.commands.CmdKeyStoreBackupRestore.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdKeyStoreBackupRestore.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdLoad"><code class="flex name class">
<span>class <span class="ident">CmdLoad</span></span>
<span>(</span><span>address: int, data: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Load. The load statement is used to store data into the memory.</p>
<p>Initialize CMD Load.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdLoad(CmdBaseClass):
    &#34;&#34;&#34;Command Load. The load statement is used to store data into the memory.&#34;&#34;&#34;

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return address in target processor to load data.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: address in target processor to load data
        &#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return aligned size of the command including header and data.&#34;&#34;&#34;
        size = CmdHeader.SIZE + len(self.data)
        if size % CmdHeader.SIZE:
            size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
        return size

    def __init__(self, address: int, data: bytes) -&gt; None:
        &#34;&#34;&#34;Initialize CMD Load.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.LOAD)
        assert isinstance(data, (bytes, bytearray))
        self.address = address
        self.data = bytes(data)

    def __str__(self) -&gt; str:
        return f&#34;LOAD: Address=0x{self.address:08X}, DataLen={len(self.data)}&#34;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export command as binary.&#34;&#34;&#34;
        self._update_data()
        result = super().export(dbg_info)
        dbg_info.append_binary_section(&#39;load-data&#39;, self.data)
        return result + self.data

    def _update_data(self) -&gt; None:
        &#34;&#34;&#34;Update command data.&#34;&#34;&#34;
        # padding data
        self.data = SecBootBlckSize.align_block_fill_random(self.data)
        # update header
        self._header.count = len(self.data)
        self._header.data = Crc32Mpeg2.calc(self.data, 0xFFFFFFFF)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdLoad&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: CMD Load object
        :raise ValueError: raised when there is invalid CRC
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.LOAD
        offset += CmdHeader.SIZE
        header_count = SecBootBlckSize.align(header.count)
        cmd_data = data[offset: offset + header_count]
        if header.data != Crc32Mpeg2.calc(cmd_data, 0xFFFFFFFF):
            raise ValueError(&#39;Invalid CRC in the command header&#39;)
        obj = CmdLoad(header.address, cmd_data)
        obj.header.data = header.data
        obj.header.flags = header.flags
        obj._update_data()
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdLoad.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdLoad" href="commands.html#spsdk.sbfile.commands.CmdLoad">CmdLoad</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: CMD Load object
:raise ValueError: raised when there is invalid CRC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdLoad&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: CMD Load object
    :raise ValueError: raised when there is invalid CRC
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.LOAD
    offset += CmdHeader.SIZE
    header_count = SecBootBlckSize.align(header.count)
    cmd_data = data[offset: offset + header_count]
    if header.data != Crc32Mpeg2.calc(cmd_data, 0xFFFFFFFF):
        raise ValueError(&#39;Invalid CRC in the command header&#39;)
    obj = CmdLoad(header.address, cmd_data)
    obj.header.data = header.data
    obj.header.flags = header.flags
    obj._update_data()
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdLoad.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return address in target processor to load data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return address in target processor to load data.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdLoad.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return aligned size of the command including header and data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Return aligned size of the command including header and data.&#34;&#34;&#34;
    size = CmdHeader.SIZE + len(self.data)
    if size % CmdHeader.SIZE:
        size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
    return size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdLoad.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export command as binary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export command as binary.&#34;&#34;&#34;
    self._update_data()
    result = super().export(dbg_info)
    dbg_info.append_binary_section(&#39;load-data&#39;, self.data)
    return result + self.data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdMemEnable"><code class="flex name class">
<span>class <span class="ident">CmdMemEnable</span></span>
<span>(</span><span>address: int, size: int, mem_type: <a title="spsdk.mboot.memories.ExtMemId" href="../mboot/memories.html#spsdk.mboot.memories.ExtMemId">ExtMemId</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to configure certain memory.</p>
<p>Initialize CmdMemEnable.</p>
<p>:param address: source address with configuration data for memory initialization
:param size: size of configuration data used for memory initialization
:param mem_type: identification of external memory type, see enum for details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdMemEnable(CmdBaseClass):
    &#34;&#34;&#34;Command to configure certain memory.&#34;&#34;&#34;
    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s address.&#34;&#34;&#34;
        self._header.address = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s size.&#34;&#34;&#34;
        return self._header.count

    @size.setter
    def size(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s size.&#34;&#34;&#34;
        self._header.count = value

    @property
    def mem_type(self) -&gt; ExtMemId:
        &#34;&#34;&#34;Return memory to be enabled.&#34;&#34;&#34;
        return ExtMemId.from_int(swap16(self._header.flags))

    @mem_type.setter
    def mem_type(self, value: ExtMemId) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: memory to be enabled
        &#34;&#34;&#34;
        self._header.flags = swap16(value)

    def __init__(self, address: int, size: int, mem_type: ExtMemId):
        &#34;&#34;&#34;Initialize CmdMemEnable.

        :param address: source address with configuration data for memory initialization
        :param size: size of configuration data used for memory initialization
        :param mem_type: identification of external memory type, see enum for details
        &#34;&#34;&#34;
        super().__init__(EnumCmdTag.MEM_ENABLE)
        self.address = address
        self.mem_type = mem_type
        self.size = size

    def __str__(self) -&gt; str:
        return f&#34;MEM-ENABLE: Address=0x{self.address:08X}, Size={self.size}, MemType=0x{self.mem_type:08X}&#34;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdMemEnable&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Memory Enable object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.MEM_ENABLE
        return cls(header.address, header.count, ExtMemId.from_int(swap16(header.flags)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdMemEnable.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdMemEnable" href="commands.html#spsdk.sbfile.commands.CmdMemEnable">CmdMemEnable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Memory Enable object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdMemEnable&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Memory Enable object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.MEM_ENABLE
    return cls(header.address, header.count, ExtMemId.from_int(swap16(header.flags)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdMemEnable.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdMemEnable.mem_type"><code class="name">var <span class="ident">mem_type</span> : <a title="spsdk.mboot.memories.ExtMemId" href="../mboot/memories.html#spsdk.mboot.memories.ExtMemId">ExtMemId</a></code></dt>
<dd>
<div class="desc"><p>Return memory to be enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mem_type(self) -&gt; ExtMemId:
    &#34;&#34;&#34;Return memory to be enabled.&#34;&#34;&#34;
    return ExtMemId.from_int(swap16(self._header.flags))</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdMemEnable.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s size.&#34;&#34;&#34;
    return self._header.count</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdNop"><code class="flex name class">
<span>class <span class="ident">CmdNop</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command NOP class.</p>
<p>Initialize Command Nop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdNop(CmdBaseClass):
    &#34;&#34;&#34;Command NOP class.&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Command Nop.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.NOP)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: CMD Nop object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.NOP
        return cls()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdNop.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdNop" href="commands.html#spsdk.sbfile.commands.CmdNop">CmdNop</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: CMD Nop object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: CMD Nop object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.NOP
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdProg"><code class="flex name class">
<span>class <span class="ident">CmdProg</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command Program class.</p>
<p>Initialize Cmd Program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdProg(CmdBaseClass):
    &#34;&#34;&#34;Command Program class.&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Cmd Program.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.PROG)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdProg&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: parsed command object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.PROG
        return cls()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdProg.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdProg" href="commands.html#spsdk.sbfile.commands.CmdProg">CmdProg</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: parsed command object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdProg&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: parsed command object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.PROG
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdReset"><code class="flex name class">
<span>class <span class="ident">CmdReset</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command Reset class.</p>
<p>Initialize Command Reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdReset(CmdBaseClass):
    &#34;&#34;&#34;Command Reset class.&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Command Reset.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.RESET)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdReset&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Cmd Reset object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.RESET
        return cls()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdReset.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdReset" href="commands.html#spsdk.sbfile.commands.CmdReset">CmdReset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Cmd Reset object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdReset&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Cmd Reset object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.RESET
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.CmdVersionCheck"><code class="flex name class">
<span>class <span class="ident">CmdVersionCheck</span></span>
<span>(</span><span>ver_type: <a title="spsdk.sbfile.commands.VersionCheckType" href="commands.html#spsdk.sbfile.commands.VersionCheckType">VersionCheckType</a>, version: int)</span>
</code></dt>
<dd>
<div class="desc"><p>FW Version Check command class.</p>
<p>Validates version of secure or non-secure firmware.
The command fails if version is &lt; expected.</p>
<p>Initialize CmdVersionCheck.</p>
<p>:param ver_type: version check type, see <code><a title="spsdk.sbfile.VersionCheckType" href="#spsdk.sbfile.VersionCheckType">VersionCheckType</a></code> enum
:param version: to be checked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdVersionCheck(CmdBaseClass):
    &#34;&#34;&#34;FW Version Check command class.

    Validates version of secure or non-secure firmware.
    The command fails if version is &lt; expected.
    &#34;&#34;&#34;

    def __init__(self, ver_type: VersionCheckType, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize CmdVersionCheck.

        :param ver_type: version check type, see `VersionCheckType` enum
        :param version: to be checked
        &#34;&#34;&#34;
        super().__init__(EnumCmdTag.FW_VERSION_CHECK)
        assert ver_type in VersionCheckType.tags()
        self.header.address = ver_type
        self.header.count = version

    @property
    def type(self) -&gt; VersionCheckType:
        &#34;&#34;&#34;Return type of the check version, see VersionCheckType enumeration.&#34;&#34;&#34;
        return VersionCheckType.from_int(self.header.address)

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Return minimal version expected.&#34;&#34;&#34;
        return self.header.count

    def __str__(self) -&gt; str:
        return super().__str__() + f&#39; type={VersionCheckType.name(self.type)}, version={str(self.version)}&#39;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdVersionCheck&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: parsed command object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.FW_VERSION_CHECK
        ver_type = VersionCheckType.from_int(header.address)
        version = header.count
        return CmdVersionCheck(ver_type, version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.CmdVersionCheck.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdVersionCheck" href="commands.html#spsdk.sbfile.commands.CmdVersionCheck">CmdVersionCheck</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: parsed command object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdVersionCheck&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: parsed command object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.FW_VERSION_CHECK
    ver_type = VersionCheckType.from_int(header.address)
    version = header.count
    return CmdVersionCheck(ver_type, version)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.CmdVersionCheck.type"><code class="name">var <span class="ident">type</span> : <a title="spsdk.sbfile.commands.VersionCheckType" href="commands.html#spsdk.sbfile.commands.VersionCheckType">VersionCheckType</a></code></dt>
<dd>
<div class="desc"><p>Return type of the check version, see VersionCheckType enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; VersionCheckType:
    &#34;&#34;&#34;Return type of the check version, see VersionCheckType enumeration.&#34;&#34;&#34;
    return VersionCheckType.from_int(self.header.address)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.CmdVersionCheck.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Return minimal version expected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Return minimal version expected.&#34;&#34;&#34;
    return self.header.count</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.ExtMemId"><code class="flex name class">
<span>class <span class="ident">ExtMemId</span></span>
</code></dt>
<dd>
<div class="desc"><p>McuBoot External Memory Property Tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtMemId(Enum):
    &#34;&#34;&#34;McuBoot External Memory Property Tags.&#34;&#34;&#34;

    QUAD_SPI0 = (1, &#39;QSPI&#39;, &#39;Quad SPI Memory 0&#39;)
    IFR0 = (4, &#39;Nonvolatile information register 0 (only used by SB loader)&#39;)
    SEMC_NOR = (8, &#39;SEMC-NOR&#39;, &#39;SEMC NOR Memory&#39;)
    FLEX_SPI_NOR = (9, &#39;FLEX-SPI-NOR&#39;, &#39;Flex SPI NOR Memory&#39;)
    SPIFI_NOR = (10, &#39;SPIFI-NOR&#39;, &#39;SPIFI NOR Memory&#39;)
    FLASH_EXEC_ONLY = (16, &#39;FLASH-EXEC&#39;, &#39;Execute-Only region on internal Flash&#39;)
    SEMC_NAND = (256, &#39;SEMC-NAND&#39;, &#39;SEMC NAND Memory&#39;)
    SPI_NAND = (257, &#39;SPI-NAND&#39;, &#39;SPI NAND Memory&#39;)
    SPI_NOR_EEPROM = (272, &#39;SPI-MEM&#39;, &#39;SPI NOR/EEPROM Memory&#39;)
    I2C_NOR_EEPROM = (273, &#39;I2C-MEM&#39;, &#39;I2C NOR/EEPROM Memory&#39;)
    SD_CARD = (288, &#39;SD&#39;, &#39;eSD/SD/SDHC/SDXC Memory Card&#39;)
    MMC_CARD = (289, &#39;MMC&#39;, &#39;MMC/eMMC Memory Card&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.ExtMemId.FLASH_EXEC_ONLY"><code class="name">var <span class="ident">FLASH_EXEC_ONLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.FLEX_SPI_NOR"><code class="name">var <span class="ident">FLEX_SPI_NOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.I2C_NOR_EEPROM"><code class="name">var <span class="ident">I2C_NOR_EEPROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.IFR0"><code class="name">var <span class="ident">IFR0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.MMC_CARD"><code class="name">var <span class="ident">MMC_CARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.QUAD_SPI0"><code class="name">var <span class="ident">QUAD_SPI0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.SD_CARD"><code class="name">var <span class="ident">SD_CARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.SEMC_NAND"><code class="name">var <span class="ident">SEMC_NAND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.SEMC_NOR"><code class="name">var <span class="ident">SEMC_NOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.SPIFI_NOR"><code class="name">var <span class="ident">SPIFI_NOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.SPI_NAND"><code class="name">var <span class="ident">SPI_NAND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.ExtMemId.SPI_NOR_EEPROM"><code class="name">var <span class="ident">SPI_NOR_EEPROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.SBV2xAdvancedParams"><code class="flex name class">
<span>class <span class="ident">SBV2xAdvancedParams</span></span>
<span>(</span><span>dek: Union[bytes, NoneType] = None, mac: Union[bytes, NoneType] = None, nonce: Union[bytes, NoneType] = None, timestamp: Union[datetime.datetime, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The class holds advanced parameters for the SB file encryption.</p>
<p>These parameters are used for the tests; for production, use can use default values (random keys + current time)</p>
<p>Initialize SBV2xAdvancedParams.</p>
<p>:param dek: DEK key
:param mac: MAC key
:param nonce: nonce
:param timestamp: fixed timestamp for the header; use None to use current date/time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SBV2xAdvancedParams:
    &#34;&#34;&#34;The class holds advanced parameters for the SB file encryption.

    These parameters are used for the tests; for production, use can use default values (random keys + current time)
    &#34;&#34;&#34;

    @staticmethod
    def _create_nonce() -&gt; bytes:
        &#34;&#34;&#34;Return random nonce.&#34;&#34;&#34;
        nonce = bytearray(crypto_backend().random_bytes(16))
        # clear nonce bit at offsets 31 and 63
        nonce[9] &amp;= 0x7F
        nonce[13] &amp;= 0x7F
        return bytes(nonce)

    def __init__(self, dek: Optional[bytes] = None, mac: Optional[bytes] = None, nonce: Optional[bytes] = None,
                 timestamp: Optional[datetime] = None):
        &#34;&#34;&#34;Initialize SBV2xAdvancedParams.

        :param dek: DEK key
        :param mac: MAC key
        :param nonce: nonce
        :param timestamp: fixed timestamp for the header; use None to use current date/time
        &#34;&#34;&#34;
        self._dek: bytes = dek if dek else crypto_backend().random_bytes(32)
        self._mac: bytes = mac if mac else crypto_backend().random_bytes(32)
        self._nonce: bytes = nonce if nonce else SBV2xAdvancedParams._create_nonce()
        if timestamp is None:
            timestamp = datetime.now()
        self._timestamp = datetime.fromtimestamp(int(timestamp.timestamp()))
        assert len(self._dek) == 32 and len(self._mac) == 32
        assert len(self._nonce) == 16

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Return DEK key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Return MAC key.&#34;&#34;&#34;
        return self._mac

    @property
    def nonce(self) -&gt; bytes:
        &#34;&#34;&#34;Return NONCE.&#34;&#34;&#34;
        return self._nonce

    @property
    def timestamp(self) -&gt; datetime:
        &#34;&#34;&#34;Return timestamp.&#34;&#34;&#34;
        return self._timestamp</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.SBV2xAdvancedParams.dek"><code class="name">var <span class="ident">dek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return DEK key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek(self) -&gt; bytes:
    &#34;&#34;&#34;Return DEK key.&#34;&#34;&#34;
    return self._dek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.SBV2xAdvancedParams.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return MAC key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;Return MAC key.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.SBV2xAdvancedParams.nonce"><code class="name">var <span class="ident">nonce</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return NONCE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nonce(self) -&gt; bytes:
    &#34;&#34;&#34;Return NONCE.&#34;&#34;&#34;
    return self._nonce</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.SBV2xAdvancedParams.timestamp"><code class="name">var <span class="ident">timestamp</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Return timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timestamp(self) -&gt; datetime:
    &#34;&#34;&#34;Return timestamp.&#34;&#34;&#34;
    return self._timestamp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.VersionCheckType"><code class="flex name class">
<span>class <span class="ident">VersionCheckType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Select type of the version check: either secure or non-secure firmware to be checked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VersionCheckType(Enum):
    &#34;&#34;&#34;Select type of the version check: either secure or non-secure firmware to be checked.&#34;&#34;&#34;
    SECURE_VERSION = 0
    NON_SECURE_VERSION = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.VersionCheckType.NON_SECURE_VERSION"><code class="name">var <span class="ident">NON_SECURE_VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.VersionCheckType.SECURE_VERSION"><code class="name">var <span class="ident">SECURE_VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk" href="../index.html">spsdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="spsdk.sbfile.commands" href="commands.html">spsdk.sbfile.commands</a></code></li>
<li><code><a title="spsdk.sbfile.headers" href="headers.html">spsdk.sbfile.headers</a></code></li>
<li><code><a title="spsdk.sbfile.images" href="images.html">spsdk.sbfile.images</a></code></li>
<li><code><a title="spsdk.sbfile.misc" href="misc.html">spsdk.sbfile.misc</a></code></li>
<li><code><a title="spsdk.sbfile.sb1" href="sb1/index.html">spsdk.sbfile.sb1</a></code></li>
<li><code><a title="spsdk.sbfile.sections" href="sections.html">spsdk.sbfile.sections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spsdk.sbfile.crypto_backend" href="#spsdk.sbfile.crypto_backend">crypto_backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.sbfile.BcdVersion3" href="#spsdk.sbfile.BcdVersion3">BcdVersion3</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.BcdVersion3.DEFAULT" href="#spsdk.sbfile.BcdVersion3.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="spsdk.sbfile.BcdVersion3.from_str" href="#spsdk.sbfile.BcdVersion3.from_str">from_str</a></code></li>
<li><code><a title="spsdk.sbfile.BcdVersion3.nums" href="#spsdk.sbfile.BcdVersion3.nums">nums</a></code></li>
<li><code><a title="spsdk.sbfile.BcdVersion3.to_version" href="#spsdk.sbfile.BcdVersion3.to_version">to_version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.BootImageV20" href="#spsdk.sbfile.BootImageV20">BootImageV20</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.BootImageV20.DEK_MAC_SIZE" href="#spsdk.sbfile.BootImageV20.DEK_MAC_SIZE">DEK_MAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.HEADER_MAC_SIZE" href="#spsdk.sbfile.BootImageV20.HEADER_MAC_SIZE">HEADER_MAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.KEY_BLOB_SIZE" href="#spsdk.sbfile.BootImageV20.KEY_BLOB_SIZE">KEY_BLOB_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.add_boot_section" href="#spsdk.sbfile.BootImageV20.add_boot_section">add_boot_section</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.cert_block" href="#spsdk.sbfile.BootImageV20.cert_block">cert_block</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.cert_header_size" href="#spsdk.sbfile.BootImageV20.cert_header_size">cert_header_size</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.dek" href="#spsdk.sbfile.BootImageV20.dek">dek</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.export" href="#spsdk.sbfile.BootImageV20.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.header" href="#spsdk.sbfile.BootImageV20.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.info" href="#spsdk.sbfile.BootImageV20.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.kek" href="#spsdk.sbfile.BootImageV20.kek">kek</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.mac" href="#spsdk.sbfile.BootImageV20.mac">mac</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.parse" href="#spsdk.sbfile.BootImageV20.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.private_key_pem_data" href="#spsdk.sbfile.BootImageV20.private_key_pem_data">private_key_pem_data</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.raw_size" href="#spsdk.sbfile.BootImageV20.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.raw_size_without_signature" href="#spsdk.sbfile.BootImageV20.raw_size_without_signature">raw_size_without_signature</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.signed" href="#spsdk.sbfile.BootImageV20.signed">signed</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV20.update" href="#spsdk.sbfile.BootImageV20.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.BootImageV21" href="#spsdk.sbfile.BootImageV21">BootImageV21</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.BootImageV21.HEADER_MAC_SIZE" href="#spsdk.sbfile.BootImageV21.HEADER_MAC_SIZE">HEADER_MAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.KEY_BLOB_SIZE" href="#spsdk.sbfile.BootImageV21.KEY_BLOB_SIZE">KEY_BLOB_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.add_boot_section" href="#spsdk.sbfile.BootImageV21.add_boot_section">add_boot_section</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.cert_block" href="#spsdk.sbfile.BootImageV21.cert_block">cert_block</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.cert_header_size" href="#spsdk.sbfile.BootImageV21.cert_header_size">cert_header_size</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.dek" href="#spsdk.sbfile.BootImageV21.dek">dek</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.export" href="#spsdk.sbfile.BootImageV21.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.header" href="#spsdk.sbfile.BootImageV21.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.info" href="#spsdk.sbfile.BootImageV21.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.kek" href="#spsdk.sbfile.BootImageV21.kek">kek</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.mac" href="#spsdk.sbfile.BootImageV21.mac">mac</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.parse" href="#spsdk.sbfile.BootImageV21.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.private_key_pem_data" href="#spsdk.sbfile.BootImageV21.private_key_pem_data">private_key_pem_data</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.raw_size" href="#spsdk.sbfile.BootImageV21.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.signed" href="#spsdk.sbfile.BootImageV21.signed">signed</a></code></li>
<li><code><a title="spsdk.sbfile.BootImageV21.update" href="#spsdk.sbfile.BootImageV21.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.BootSectionV2" href="#spsdk.sbfile.BootSectionV2">BootSectionV2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.BootSectionV2.HMAC_SIZE" href="#spsdk.sbfile.BootSectionV2.HMAC_SIZE">HMAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.append" href="#spsdk.sbfile.BootSectionV2.append">append</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.export" href="#spsdk.sbfile.BootSectionV2.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.hmac_count" href="#spsdk.sbfile.BootSectionV2.hmac_count">hmac_count</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.info" href="#spsdk.sbfile.BootSectionV2.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.is_last" href="#spsdk.sbfile.BootSectionV2.is_last">is_last</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.parse" href="#spsdk.sbfile.BootSectionV2.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.raw_size" href="#spsdk.sbfile.BootSectionV2.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.BootSectionV2.uid" href="#spsdk.sbfile.BootSectionV2.uid">uid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CertBlockV2" href="#spsdk.sbfile.CertBlockV2">CertBlockV2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.CertBlockV2.DEFAULT_ALIGNMENT" href="#spsdk.sbfile.CertBlockV2.DEFAULT_ALIGNMENT">DEFAULT_ALIGNMENT</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.RKHT_SIZE" href="#spsdk.sbfile.CertBlockV2.RKHT_SIZE">RKHT_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.RKH_SIZE" href="#spsdk.sbfile.CertBlockV2.RKH_SIZE">RKH_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.add_certificate" href="#spsdk.sbfile.CertBlockV2.add_certificate">add_certificate</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.alignment" href="#spsdk.sbfile.CertBlockV2.alignment">alignment</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.certificates" href="#spsdk.sbfile.CertBlockV2.certificates">certificates</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.export" href="#spsdk.sbfile.CertBlockV2.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.header" href="#spsdk.sbfile.CertBlockV2.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.image_length" href="#spsdk.sbfile.CertBlockV2.image_length">image_length</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.info" href="#spsdk.sbfile.CertBlockV2.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.parse" href="#spsdk.sbfile.CertBlockV2.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.raw_size" href="#spsdk.sbfile.CertBlockV2.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.rkh" href="#spsdk.sbfile.CertBlockV2.rkh">rkh</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.rkh_index" href="#spsdk.sbfile.CertBlockV2.rkh_index">rkh_index</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.rkht" href="#spsdk.sbfile.CertBlockV2.rkht">rkht</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.rkht_fuses" href="#spsdk.sbfile.CertBlockV2.rkht_fuses">rkht_fuses</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.set_root_key_hash" href="#spsdk.sbfile.CertBlockV2.set_root_key_hash">set_root_key_hash</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.signature_size" href="#spsdk.sbfile.CertBlockV2.signature_size">signature_size</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.verify_data" href="#spsdk.sbfile.CertBlockV2.verify_data">verify_data</a></code></li>
<li><code><a title="spsdk.sbfile.CertBlockV2.verify_private_key" href="#spsdk.sbfile.CertBlockV2.verify_private_key">verify_private_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CertSectionV2" href="#spsdk.sbfile.CertSectionV2">CertSectionV2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.CertSectionV2.HMAC_SIZE" href="#spsdk.sbfile.CertSectionV2.HMAC_SIZE">HMAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.CertSectionV2.SECT_MARK" href="#spsdk.sbfile.CertSectionV2.SECT_MARK">SECT_MARK</a></code></li>
<li><code><a title="spsdk.sbfile.CertSectionV2.cert_block" href="#spsdk.sbfile.CertSectionV2.cert_block">cert_block</a></code></li>
<li><code><a title="spsdk.sbfile.CertSectionV2.export" href="#spsdk.sbfile.CertSectionV2.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.CertSectionV2.info" href="#spsdk.sbfile.CertSectionV2.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.CertSectionV2.parse" href="#spsdk.sbfile.CertSectionV2.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CertSectionV2.raw_size" href="#spsdk.sbfile.CertSectionV2.raw_size">raw_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.Certificate" href="#spsdk.sbfile.Certificate">Certificate</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.Certificate.ca" href="#spsdk.sbfile.Certificate.ca">ca</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.export" href="#spsdk.sbfile.Certificate.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.hash_algo" href="#spsdk.sbfile.Certificate.hash_algo">hash_algo</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.info" href="#spsdk.sbfile.Certificate.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.issuer" href="#spsdk.sbfile.Certificate.issuer">issuer</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.max_path_length" href="#spsdk.sbfile.Certificate.max_path_length">max_path_length</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.not_valid_after" href="#spsdk.sbfile.Certificate.not_valid_after">not_valid_after</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.not_valid_before" href="#spsdk.sbfile.Certificate.not_valid_before">not_valid_before</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.public_key_exponent" href="#spsdk.sbfile.Certificate.public_key_exponent">public_key_exponent</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.public_key_hash" href="#spsdk.sbfile.Certificate.public_key_hash">public_key_hash</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.public_key_modulus" href="#spsdk.sbfile.Certificate.public_key_modulus">public_key_modulus</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.public_key_usage" href="#spsdk.sbfile.Certificate.public_key_usage">public_key_usage</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.raw_size" href="#spsdk.sbfile.Certificate.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.self_issued" href="#spsdk.sbfile.Certificate.self_issued">self_issued</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.self_signed" href="#spsdk.sbfile.Certificate.self_signed">self_signed</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.serial_number" href="#spsdk.sbfile.Certificate.serial_number">serial_number</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.signature" href="#spsdk.sbfile.Certificate.signature">signature</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.signature_algo" href="#spsdk.sbfile.Certificate.signature_algo">signature_algo</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.verify" href="#spsdk.sbfile.Certificate.verify">verify</a></code></li>
<li><code><a title="spsdk.sbfile.Certificate.version" href="#spsdk.sbfile.Certificate.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdCall" href="#spsdk.sbfile.CmdCall">CmdCall</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdCall.address" href="#spsdk.sbfile.CmdCall.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.CmdCall.argument" href="#spsdk.sbfile.CmdCall.argument">argument</a></code></li>
<li><code><a title="spsdk.sbfile.CmdCall.parse" href="#spsdk.sbfile.CmdCall.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdErase" href="#spsdk.sbfile.CmdErase">CmdErase</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdErase.address" href="#spsdk.sbfile.CmdErase.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.CmdErase.flags" href="#spsdk.sbfile.CmdErase.flags">flags</a></code></li>
<li><code><a title="spsdk.sbfile.CmdErase.length" href="#spsdk.sbfile.CmdErase.length">length</a></code></li>
<li><code><a title="spsdk.sbfile.CmdErase.parse" href="#spsdk.sbfile.CmdErase.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdFill" href="#spsdk.sbfile.CmdFill">CmdFill</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.CmdFill.PADDING_VALUE" href="#spsdk.sbfile.CmdFill.PADDING_VALUE">PADDING_VALUE</a></code></li>
<li><code><a title="spsdk.sbfile.CmdFill.address" href="#spsdk.sbfile.CmdFill.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.CmdFill.export" href="#spsdk.sbfile.CmdFill.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.CmdFill.parse" href="#spsdk.sbfile.CmdFill.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CmdFill.pattern" href="#spsdk.sbfile.CmdFill.pattern">pattern</a></code></li>
<li><code><a title="spsdk.sbfile.CmdFill.raw_size" href="#spsdk.sbfile.CmdFill.raw_size">raw_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdJump" href="#spsdk.sbfile.CmdJump">CmdJump</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdJump.address" href="#spsdk.sbfile.CmdJump.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.CmdJump.argument" href="#spsdk.sbfile.CmdJump.argument">argument</a></code></li>
<li><code><a title="spsdk.sbfile.CmdJump.parse" href="#spsdk.sbfile.CmdJump.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CmdJump.spreg" href="#spsdk.sbfile.CmdJump.spreg">spreg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdKeyStoreBackup" href="#spsdk.sbfile.CmdKeyStoreBackup">CmdKeyStoreBackup</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdKeyStoreBackup.cmd_id" href="#spsdk.sbfile.CmdKeyStoreBackup.cmd_id">cmd_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdKeyStoreRestore" href="#spsdk.sbfile.CmdKeyStoreRestore">CmdKeyStoreRestore</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdKeyStoreRestore.cmd_id" href="#spsdk.sbfile.CmdKeyStoreRestore.cmd_id">cmd_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdLoad" href="#spsdk.sbfile.CmdLoad">CmdLoad</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdLoad.address" href="#spsdk.sbfile.CmdLoad.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.CmdLoad.export" href="#spsdk.sbfile.CmdLoad.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.CmdLoad.parse" href="#spsdk.sbfile.CmdLoad.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CmdLoad.raw_size" href="#spsdk.sbfile.CmdLoad.raw_size">raw_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdMemEnable" href="#spsdk.sbfile.CmdMemEnable">CmdMemEnable</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdMemEnable.address" href="#spsdk.sbfile.CmdMemEnable.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.CmdMemEnable.mem_type" href="#spsdk.sbfile.CmdMemEnable.mem_type">mem_type</a></code></li>
<li><code><a title="spsdk.sbfile.CmdMemEnable.parse" href="#spsdk.sbfile.CmdMemEnable.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CmdMemEnable.size" href="#spsdk.sbfile.CmdMemEnable.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdNop" href="#spsdk.sbfile.CmdNop">CmdNop</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdNop.parse" href="#spsdk.sbfile.CmdNop.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdProg" href="#spsdk.sbfile.CmdProg">CmdProg</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdProg.parse" href="#spsdk.sbfile.CmdProg.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdReset" href="#spsdk.sbfile.CmdReset">CmdReset</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdReset.parse" href="#spsdk.sbfile.CmdReset.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.CmdVersionCheck" href="#spsdk.sbfile.CmdVersionCheck">CmdVersionCheck</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.CmdVersionCheck.parse" href="#spsdk.sbfile.CmdVersionCheck.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.CmdVersionCheck.type" href="#spsdk.sbfile.CmdVersionCheck.type">type</a></code></li>
<li><code><a title="spsdk.sbfile.CmdVersionCheck.version" href="#spsdk.sbfile.CmdVersionCheck.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.ExtMemId" href="#spsdk.sbfile.ExtMemId">ExtMemId</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.ExtMemId.FLASH_EXEC_ONLY" href="#spsdk.sbfile.ExtMemId.FLASH_EXEC_ONLY">FLASH_EXEC_ONLY</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.FLEX_SPI_NOR" href="#spsdk.sbfile.ExtMemId.FLEX_SPI_NOR">FLEX_SPI_NOR</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.I2C_NOR_EEPROM" href="#spsdk.sbfile.ExtMemId.I2C_NOR_EEPROM">I2C_NOR_EEPROM</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.IFR0" href="#spsdk.sbfile.ExtMemId.IFR0">IFR0</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.MMC_CARD" href="#spsdk.sbfile.ExtMemId.MMC_CARD">MMC_CARD</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.QUAD_SPI0" href="#spsdk.sbfile.ExtMemId.QUAD_SPI0">QUAD_SPI0</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.SD_CARD" href="#spsdk.sbfile.ExtMemId.SD_CARD">SD_CARD</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.SEMC_NAND" href="#spsdk.sbfile.ExtMemId.SEMC_NAND">SEMC_NAND</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.SEMC_NOR" href="#spsdk.sbfile.ExtMemId.SEMC_NOR">SEMC_NOR</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.SPIFI_NOR" href="#spsdk.sbfile.ExtMemId.SPIFI_NOR">SPIFI_NOR</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.SPI_NAND" href="#spsdk.sbfile.ExtMemId.SPI_NAND">SPI_NAND</a></code></li>
<li><code><a title="spsdk.sbfile.ExtMemId.SPI_NOR_EEPROM" href="#spsdk.sbfile.ExtMemId.SPI_NOR_EEPROM">SPI_NOR_EEPROM</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.SBV2xAdvancedParams" href="#spsdk.sbfile.SBV2xAdvancedParams">SBV2xAdvancedParams</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.SBV2xAdvancedParams.dek" href="#spsdk.sbfile.SBV2xAdvancedParams.dek">dek</a></code></li>
<li><code><a title="spsdk.sbfile.SBV2xAdvancedParams.mac" href="#spsdk.sbfile.SBV2xAdvancedParams.mac">mac</a></code></li>
<li><code><a title="spsdk.sbfile.SBV2xAdvancedParams.nonce" href="#spsdk.sbfile.SBV2xAdvancedParams.nonce">nonce</a></code></li>
<li><code><a title="spsdk.sbfile.SBV2xAdvancedParams.timestamp" href="#spsdk.sbfile.SBV2xAdvancedParams.timestamp">timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.VersionCheckType" href="#spsdk.sbfile.VersionCheckType">VersionCheckType</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.VersionCheckType.NON_SECURE_VERSION" href="#spsdk.sbfile.VersionCheckType.NON_SECURE_VERSION">NON_SECURE_VERSION</a></code></li>
<li><code><a title="spsdk.sbfile.VersionCheckType.SECURE_VERSION" href="#spsdk.sbfile.VersionCheckType.SECURE_VERSION">SECURE_VERSION</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>