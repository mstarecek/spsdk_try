<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.sbfile.images API documentation</title>
<meta name="description" content="Boot Image V2.0, V2.1." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.sbfile.images</code></h1>
</header>
<section id="section-intro">
<p>Boot Image V2.0, V2.1.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Boot Image V2.0, V2.1.&#34;&#34;&#34;

from datetime import datetime
from typing import Iterator, Optional, List

from spsdk.utils.crypto import CertBlockV2, Counter, crypto_backend
from spsdk.utils.crypto.abstract import BaseClass
from spsdk.utils.crypto.common import calc_cypher_block_count
from spsdk.utils.misc import find_first
from .commands import CmdHeader
from .headers import ImageHeaderV2
from .sections import BootSectionV2, CertSectionV2


class SBV2xAdvancedParams:
    &#34;&#34;&#34;The class holds advanced parameters for the SB file encryption.

    These parameters are used for the tests; for production, use can use default values (random keys + current time)
    &#34;&#34;&#34;

    @staticmethod
    def _create_nonce() -&gt; bytes:
        &#34;&#34;&#34;Return random nonce.&#34;&#34;&#34;
        nonce = bytearray(crypto_backend().random_bytes(16))
        # clear nonce bit at offsets 31 and 63
        nonce[9] &amp;= 0x7F
        nonce[13] &amp;= 0x7F
        return bytes(nonce)

    def __init__(self, dek: Optional[bytes] = None, mac: Optional[bytes] = None, nonce: Optional[bytes] = None,
                 timestamp: Optional[datetime] = None):
        &#34;&#34;&#34;Initialize SBV2xAdvancedParams.

        :param dek: DEK key
        :param mac: MAC key
        :param nonce: nonce
        :param timestamp: fixed timestamp for the header; use None to use current date/time
        &#34;&#34;&#34;
        self._dek: bytes = dek if dek else crypto_backend().random_bytes(32)
        self._mac: bytes = mac if mac else crypto_backend().random_bytes(32)
        self._nonce: bytes = nonce if nonce else SBV2xAdvancedParams._create_nonce()
        if timestamp is None:
            timestamp = datetime.now()
        self._timestamp = datetime.fromtimestamp(int(timestamp.timestamp()))
        assert len(self._dek) == 32 and len(self._mac) == 32
        assert len(self._nonce) == 16

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Return DEK key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Return MAC key.&#34;&#34;&#34;
        return self._mac

    @property
    def nonce(self) -&gt; bytes:
        &#34;&#34;&#34;Return NONCE.&#34;&#34;&#34;
        return self._nonce

    @property
    def timestamp(self) -&gt; datetime:
        &#34;&#34;&#34;Return timestamp.&#34;&#34;&#34;
        return self._timestamp


########################################################################################################################
# Secure Boot Image Class (Version 2.0)
########################################################################################################################
class BootImageV20(BaseClass):
    &#34;&#34;&#34;Boot Image V2.0 class.&#34;&#34;&#34;
    # Image specific data
    # size of the MAC key
    HEADER_MAC_SIZE = 32
    # AES encrypted DEK and MAC, including padding
    DEK_MAC_SIZE = 32 + 32 + 16

    KEY_BLOB_SIZE = 80

    def __init__(self, signed: bool, kek: bytes, *sections: BootSectionV2,
                 product_version: str = &#39;1.0.0&#39;, component_version: str = &#39;1.0.0&#39;,
                 build_number: int = 0, advanced_params: SBV2xAdvancedParams = SBV2xAdvancedParams()) -&gt; None:
        &#34;&#34;&#34;Initialize Secure Boot Image V2.0.

        :param signed: True if image is signed, False otherwise
        :param kek: key for wrapping DEK and MAC keys
        :param product_version: The product version (default: 1.0.0)
        :param component_version: The component version (default: 1.0.0)
        :param build_number: The build number value (default: 0)
        :param advanced_params: Advanced parameters for encryption of the SB file, use for tests only
        :param sections: Boot sections
        &#34;&#34;&#34;
        self._kek = kek
        # Set Flags value
        self._signed = signed
        self._private_key_pem_data: Optional[bytes] = None
        flags = 0x08 if self.signed else 0x04
        # Set private attributes
        self._dek: bytes = advanced_params.dek
        self._mac: bytes = advanced_params.mac
        assert len(self._dek) == self.HEADER_MAC_SIZE and len(self._mac) == self.HEADER_MAC_SIZE
        self._header = ImageHeaderV2(version=&#39;2.0&#39;, product_version=product_version,
                                     component_version=component_version, build_number=build_number, flags=flags,
                                     nonce=advanced_params.nonce, timestamp=advanced_params.timestamp)
        self._cert_section: Optional[CertSectionV2] = None
        self._boot_sections: List[BootSectionV2] = []
        # Generate nonce
        if self._header.nonce is None:
            nonce = bytearray(crypto_backend().random_bytes(16))
            # clear nonce bit at offsets 31 and 63
            nonce[9] &amp;= 0x7F
            nonce[13] &amp;= 0x7F
            self._header.nonce = bytes(nonce)
        # Sections
        for section in sections:
            self.add_boot_section(section)

    @property
    def header(self) -&gt; ImageHeaderV2:
        &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
        return self._header

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
        return self._mac

    @property
    def kek(self) -&gt; bytes:
        &#34;&#34;&#34;Return key for wrapping DEK and MAC keys.&#34;&#34;&#34;
        return self._kek

    @property
    def private_key_pem_data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Return private key data for signed images, decrypted in PEM format.&#34;&#34;&#34;
        return self._private_key_pem_data

    @private_key_pem_data.setter
    def private_key_pem_data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter to be used for signed images.

        :param: key for signing the image; decrypted binary data in PEM format
        &#34;&#34;&#34;
        self._private_key_pem_data = value

    @property
    def signed(self) -&gt; bool:
        &#34;&#34;&#34;Check whether sb is signed + encrypted or only encrypted.&#34;&#34;&#34;
        return self._signed

    @property
    def cert_block(self) -&gt; Optional[CertBlockV2]:
        &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
        cert_sect = self._cert_section
        if cert_sect is None:
            return None

        return cert_sect.cert_block

    @cert_block.setter
    def cert_block(self, value: Optional[CertBlockV2]) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: block to be assigned; None to remove previously assigned block
        &#34;&#34;&#34;
        if value is not None:
            assert self.signed, &#34;Certificate block cannot be used unless SB file is signed&#34;
        self._cert_section = CertSectionV2(value) if value else None

    @property
    def cert_header_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    @property
    def raw_size_without_signature(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size without signature, used to calculate image blocks.&#34;&#34;&#34;
        # Header, HMAC and KeyBlob
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        # Certificates Section
        if self.signed:
            size += self.DEK_MAC_SIZE
            cert_block = self.cert_block
            assert cert_block
            size += cert_block.raw_size
        # Boot Sections
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size.&#34;&#34;&#34;
        size = self.raw_size_without_signature

        if self.signed:
            cert_block = self.cert_block
            assert cert_block
            size += cert_block.signature_size

        return size

    def __str__(self) -&gt; str:
        return self.info()

    def __len__(self) -&gt; int:
        return len(self._boot_sections)

    def __getitem__(self, key: int) -&gt; BootSectionV2:
        return self._boot_sections[key]

    def __setitem__(self, key: int, value: BootSectionV2) -&gt; None:
        self._boot_sections[key] = value

    def __iter__(self) -&gt; Iterator[BootSectionV2]:
        return self._boot_sections.__iter__()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update boot image.&#34;&#34;&#34;
        if self._boot_sections:
            self._header.first_boot_section_id = self._boot_sections[0].uid
            # calculate first boot tag block
            data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            if self._cert_section is not None:
                data_size += self._cert_section.raw_size
            self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
        # ...
        self._header.flags = 0x08 if self.signed else 0x04
        self._header.image_blocks = calc_cypher_block_count(self.raw_size_without_signature)
        self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
        self._header.max_section_mac_count = 0
        if self.signed:
            self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            self._header.offset_to_certificate_block += CmdHeader.SIZE + CertSectionV2.HMAC_SIZE * 2
            self._header.max_section_mac_count = 1
        for boot_sect in self._boot_sections:
            boot_sect.is_last = True  # this is unified with elftosb
            self._header.max_section_mac_count += boot_sect.hmac_count
        # Update certificates block header
        cert_blk = self.cert_block
        if cert_blk is not None:
            cert_blk.header.build_number = self._header.build_number
            cert_blk.header.image_length = self.cert_header_size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        self.update()
        nfo = &#34;\n&#34;
        nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._header.info()
        if self._cert_section is not None:
            nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
            nfo += self._cert_section.info()
        nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
        for index, section in enumerate(self._boot_sections):
            nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
            nfo += section.info()
        return nfo

    def add_boot_section(self, section: BootSectionV2) -&gt; None:
        &#34;&#34;&#34;Add new Boot section into image.

        :param section: Boot section
        :raise TypeError: raised when section is not instance of BootSectionV2 class
        :raise ValueError: raise when boot section has duplicate UID
        &#34;&#34;&#34;
        if not isinstance(section, BootSectionV2):
            raise TypeError()
        duplicate_uid = find_first(self._boot_sections, lambda bs: bs.uid == section.uid)
        if duplicate_uid is not None:
            raise ValueError(f&#39;Boot section with duplicate UID: {str(section.uid)}&#39;)
        self._boot_sections.append(section)

    def export(self, padding: Optional[bytes] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize image object.

        :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
        :return: exported bytes
        :raise ValueError: raised when there are no boot sections or is not signed or private keys are missing
        &#34;&#34;&#34;
        assert len(self.dek) == 32 and len(self.mac) == 32
        # validate params
        if not self._boot_sections:
            raise ValueError(&#39;No boot section&#39;)
        if self.signed and (self._cert_section is None):
            raise ValueError(&#34;Certificate section is required for signed images&#34;)
        # update internals
        self.update()
        # Add Image Header data
        data = self._header.export(padding=padding)
        # Add Image Header HMAC data
        data += crypto_backend().hmac(self.mac, data)
        # Add DEK and MAC keys
        data += crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
        # Add Padding
        data += padding if padding else crypto_backend().random_bytes(8)
        # Add Certificates data
        assert self._header.nonce
        counter = Counter(self._header.nonce)
        counter.increment(calc_cypher_block_count(len(data)))
        if self._cert_section is not None:
            cert_sect_bin = self._cert_section.export(dek=self.dek, mac=self.mac, counter=counter)
            counter.increment(calc_cypher_block_count(len(cert_sect_bin)))
            data += cert_sect_bin
        # Add Boot Sections data
        for sect in self._boot_sections:
            data += sect.export(dek=self.dek, mac=self.mac, counter=counter)
        # Add Signature data
        if self.signed:
            private_key_pem_data = self.private_key_pem_data
            if private_key_pem_data is None:
                raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
            certificate_block = self.cert_block
            assert (certificate_block is not None) and certificate_block.verify_private_key(private_key_pem_data)
            data += crypto_backend().rsa_sign(private_key_pem_data, data)
        assert len(data) == self.raw_size
        return data

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes()) -&gt; &#39;BootImageV20&#39;:
        &#34;&#34;&#34;Parse image from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param kek: The Key for unwrapping DEK and MAC keys (required)
        :return: parsed image object
        :raise Exception: raised when header is in wrong format
        :raise Exception: raised when there is invalid header version
        :raise Exception: raised when signature is incorrect
        &#34;&#34;&#34;
        assert kek, &#39;kek cannot be empty&#39;
        index = offset
        header_raw_data = data[index: index + ImageHeaderV2.SIZE]
        index += ImageHeaderV2.SIZE
        header_mac_data = data[index: index + cls.HEADER_MAC_SIZE]
        index += cls.HEADER_MAC_SIZE
        key_blob = data[index: index + cls.KEY_BLOB_SIZE]
        index += cls.KEY_BLOB_SIZE
        key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
        dek = key_blob_unwrap[:32]
        mac = key_blob_unwrap[32:]
        header_mac_data_calc = crypto_backend().hmac(mac, header_raw_data)
        if header_mac_data != header_mac_data_calc:
            raise Exception()
        # Parse Header
        header = ImageHeaderV2.parse(header_raw_data)
        if header.version != &#39;2.0&#39;:
            raise Exception(f&#39;Invalid Header Version: {header.version} instead 2.0&#39;)
        image_size = header.image_blocks * 16
        # Initialize counter
        assert header.nonce
        counter = Counter(header.nonce)
        counter.increment(calc_cypher_block_count(index - offset))
        # ...
        signed = header.flags == 0x08
        adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
        obj = cls(signed,
                  kek=kek,
                  product_version=str(header.product_version),
                  component_version=str(header.component_version),
                  build_number=header.build_number,
                  advanced_params=adv_params)
        # Parse Certificate section
        if header.flags == 0x08:
            cert_sect = CertSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
            obj._cert_section = cert_sect
            index += cert_sect.raw_size
            # Check Signature
            if not cert_sect.cert_block.verify_data(data[offset + image_size:],
                                                    data[offset: offset + image_size]):
                raise Exception()
        # Parse Boot Sections
        while index &lt; (image_size + offset):
            boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
            obj.add_boot_section(boot_section)
            index += boot_section.raw_size
        return obj


########################################################################################################################
# Secure Boot Image Class (Version 2.1)
########################################################################################################################
class BootImageV21(BaseClass):
    &#34;&#34;&#34;Boot Image V2.1 class.&#34;&#34;&#34;
    # Image specific data
    HEADER_MAC_SIZE = 32
    KEY_BLOB_SIZE = 80

    def __init__(self, kek: bytes, *sections: BootSectionV2,
                 product_version: str = &#39;1.0.0&#39;, component_version: str = &#39;1.0.0&#39;,
                 build_number: int = 0, advanced_params: SBV2xAdvancedParams = SBV2xAdvancedParams()) -&gt; None:
        &#34;&#34;&#34;Initialize Secure Boot Image V2.1.

        :param kek: key to wrap DEC and MAC keys

        :param product_version: The product version (default: 1.0.0)
        :param component_version: The component version (default: 1.0.0)
        :param build_number: The build number value (default: 0)

        :param advanced_params: optional advanced parameters for encryption; it is recommended to use default value
        :param sections: Boot sections
        &#34;&#34;&#34;
        self._kek = kek
        self._private_key_pem_data: Optional[bytes] = None  # this should be assigned for export, not needed for parsing
        self._dek = advanced_params.dek
        self._mac = advanced_params.mac
        self._header = ImageHeaderV2(version=&#39;2.1&#39;, product_version=product_version,
                                     component_version=component_version, build_number=build_number, flags=0x08,
                                     nonce=advanced_params.nonce, timestamp=advanced_params.timestamp)
        self._cert_block: Optional[CertBlockV2] = None
        self._boot_sections: List[BootSectionV2] = []
        # ...
        for section in sections:
            self.add_boot_section(section)

    @property
    def header(self) -&gt; ImageHeaderV2:
        &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
        return self._header

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
        return self._mac

    @property
    def kek(self) -&gt; bytes:
        &#34;&#34;&#34;Return key to wrap DEC and MAC keys.&#34;&#34;&#34;
        return self._kek

    @property
    def private_key_pem_data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Return binary data of private key for signing; decrypted binary data in PEM format.

        None if not assigned yet or image not signed.
        &#34;&#34;&#34;
        return self._private_key_pem_data

    @private_key_pem_data.setter
    def private_key_pem_data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param: key for signing the image; decrypted binary data in PEM format
        &#34;&#34;&#34;
        self._private_key_pem_data = value

    @property
    def cert_block(self) -&gt; Optional[CertBlockV2]:
        &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
        return self._cert_block

    @cert_block.setter
    def cert_block(self, value: CertBlockV2) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: block to be assigned; None to remove previously assigned block
        &#34;&#34;&#34;
        assert isinstance(value, CertBlockV2)
        self._cert_block = value

    @property
    def signed(self) -&gt; bool:
        &#34;&#34;&#34;Return flag whether SB file is signed.&#34;&#34;&#34;
        return True  # SB2.1 is always signed

    @property
    def cert_header_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
        size += self.KEY_BLOB_SIZE
        # Certificates Section
        cert_blk = self.cert_block
        if cert_blk:
            size += cert_blk.raw_size
        return size

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned).&#34;&#34;&#34;
        # Header, HMAC and KeyBlob
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
        size += self.KEY_BLOB_SIZE
        # Certificates Section
        cert_blk = self.cert_block
        if cert_blk:
            size += cert_blk.raw_size
            assert self.signed
            size += cert_blk.signature_size
        # Boot Sections
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    def __str__(self) -&gt; str:
        return self.info()

    def __len__(self) -&gt; int:
        return len(self._boot_sections)

    def __getitem__(self, key: int) -&gt; BootSectionV2:
        return self._boot_sections[key]

    def __setitem__(self, key: int, value: BootSectionV2) -&gt; None:
        self._boot_sections[key] = value

    def __iter__(self) -&gt; Iterator[BootSectionV2]:
        return self._boot_sections.__iter__()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update BootImageV21.&#34;&#34;&#34;
        if self._boot_sections:
            self._header.first_boot_section_id = self._boot_sections[0].uid
            # calculate first boot tag block
            data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            cert_blk = self.cert_block
            if cert_blk is not None:
                data_size += cert_blk.raw_size
                assert self.signed
                data_size += cert_blk.signature_size
            self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
        # ...
        self._header.image_blocks = calc_cypher_block_count(self.raw_size)
        self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
        self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        # Get HMAC count
        self._header.max_section_mac_count = 0
        for boot_sect in self._boot_sections:
            boot_sect.is_last = True  # unified with elftosb
            self._header.max_section_mac_count += boot_sect.hmac_count
        # Update certificates block header
        cert_clk = self.cert_block
        if cert_clk is not None:
            cert_clk.header.build_number = self._header.build_number
            cert_clk.header.image_length = self.cert_header_size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        self.update()
        nfo = &#34;\n&#34;
        nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._header.info()
        if self.cert_block is not None:
            nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
            nfo += self.cert_block.info()
        nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
        for index, section in enumerate(self._boot_sections):
            nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
            nfo += section.info()
        return nfo

    def add_boot_section(self, section: BootSectionV2) -&gt; None:
        &#34;&#34;&#34;Add new Boot section into image.

        :param section: Boot section to be added
        :raise TypeError: raised when section is not instance of BootSectionV2 class
        &#34;&#34;&#34;
        if not isinstance(section, BootSectionV2):
            raise TypeError()
        self._boot_sections.append(section)

    # pylint: disable=too-many-locals
    def export(self, padding: Optional[bytes] = None,
               dbg_info: Optional[List[str]] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize image object.

        :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
        :param dbg_info: optional list, where debug info is exported in text form
        :return: exported bytes
        :raise ValueError: raised when there is no boot section to be added
        :raise ValueError: raise when certificate is not assigned
        :raise ValueError: raise when private key is not assigned
        &#34;&#34;&#34;
        # validate params
        if not self._boot_sections:
            raise ValueError(&#34;At least one Boot Section must be added&#34;)
        if self.cert_block is None:
            raise ValueError(&#39;Certificate is not assigned&#39;)
        if self.private_key_pem_data is None:
            raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
        # Update internals
        if dbg_info is not None:
            dbg_info.append(&#39;[sb_file]&#39;)
        bs_dbg_info: Optional[List[str]] = list() if dbg_info else None
        self.update()
        # Export Boot Sections
        bs_data = bytes()
        # TODO: implement helper method for get key size in bytes. Now is working only with internal backend
        bs_offset = (ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE + self.cert_block.raw_size +
                     self.cert_block.signature_size)
        assert self._header.nonce
        counter = Counter(self._header.nonce, calc_cypher_block_count(bs_offset))
        for sect in self._boot_sections:
            bs_data += sect.export(dek=self.dek, mac=self.mac, counter=counter, dbg_info=bs_dbg_info)
        # Export Header
        signed_data = self._header.export(padding=padding)
        if dbg_info:
            dbg_info.append(&#39;[header]&#39;)
            dbg_info.append(signed_data.hex())
        #  Add HMAC data
        first_bs_hmac_count = self._boot_sections[0].hmac_count
        hmac_data = bs_data[CmdHeader.SIZE: CmdHeader.SIZE + (first_bs_hmac_count * 32) + 32]
        hmac = crypto_backend().hmac(self.mac, hmac_data)
        signed_data += hmac
        if dbg_info:
            dbg_info.append(&#39;[hmac]&#39;)
            dbg_info.append(hmac.hex())
        # Add KeyBlob data
        key_blob = crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
        key_blob += b&#39;\00&#39; * (self.KEY_BLOB_SIZE - len(key_blob))
        signed_data += key_blob
        if dbg_info:
            dbg_info.append(&#39;[key_blob]&#39;)
            dbg_info.append(key_blob.hex())
        # Add Certificates data
        signed_data += self.cert_block.export()
        if dbg_info:
            dbg_info.append(&#39;[cert_block]&#39;)
            dbg_info.append(self.cert_block.export().hex())
        # Add Signature data
        assert self.cert_block.verify_private_key(self.private_key_pem_data)  # verify private key matches certificate
        signature = crypto_backend().rsa_sign(self.private_key_pem_data, signed_data)
        if dbg_info:
            dbg_info.append(&#39;[signature]&#39;)
            dbg_info.append(signature.hex())
            dbg_info.append(&#39;[boot_sections]&#39;)
            assert bs_dbg_info
            dbg_info.extend(bs_dbg_info)
        return signed_data + signature + bs_data

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes(),
              plain_sections: bool = False) -&gt; &#39;BootImageV21&#39;:
        &#34;&#34;&#34;Parse image from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param kek: The Key for unwrapping DEK and MAC keys (required)
        :param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
        :return: BootImageV21 parsed object
        :raise Exception: raised when header is in incorrect format
        :raise Exception: raised when signature is incorrect
        &#34;&#34;&#34;
        assert kek, &#39;kek cannot be empty&#39;
        index = offset
        header_raw_data = data[index: index + ImageHeaderV2.SIZE]
        index += ImageHeaderV2.SIZE
        # TODO not used right now: hmac_data = data[index: index + cls.HEADER_MAC_SIZE]
        index += cls.HEADER_MAC_SIZE
        key_blob = data[index: index + cls.KEY_BLOB_SIZE]
        index += cls.KEY_BLOB_SIZE
        key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
        dek = key_blob_unwrap[:32]
        mac = key_blob_unwrap[32:]
        # Parse Header
        header = ImageHeaderV2.parse(header_raw_data)
        if header.offset_to_certificate_block != (index - offset):
            raise Exception()
        # Parse Certificate Block
        cert_block = CertBlockV2.parse(data, index)
        index += cert_block.raw_size
        # Verify Signature
        if not cert_block.verify_data(data[index: index + cert_block.signature_size], data[offset: index]):
            raise Exception()
        index += cert_block.signature_size
        # Check first Boot Section HMAC
        # TODO: not implemented yet
        # hmac_data_calc = crypto_backend().hmac(mac, data[index + CmdHeader.SIZE: index + CmdHeader.SIZE + ((2) * 32)])
        # if hmac_data != hmac_data_calc:
        #    raise Exception()
        assert header.nonce
        counter = Counter(header.nonce)
        counter.increment(calc_cypher_block_count(index - offset))
        boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter, plain_sect=plain_sections)
        adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
        obj = cls(kek=kek,
                  product_version=str(header.product_version),
                  component_version=str(header.component_version),
                  build_number=header.build_number,
                  advanced_params=adv_params)
        obj.cert_block = cert_block
        obj.add_boot_section(boot_section)
        return obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.sbfile.images.BootImageV20"><code class="flex name class">
<span>class <span class="ident">BootImageV20</span></span>
<span>(</span><span>signed: bool, kek: bytes, *sections: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>, product_version: str = '1.0.0', component_version: str = '1.0.0', build_number: int = 0, advanced_params: <a title="spsdk.sbfile.images.SBV2xAdvancedParams" href="#spsdk.sbfile.images.SBV2xAdvancedParams">SBV2xAdvancedParams</a> = &lt;spsdk.sbfile.images.SBV2xAdvancedParams object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Image V2.0 class.</p>
<p>Initialize Secure Boot Image V2.0.</p>
<p>:param signed: True if image is signed, False otherwise
:param kek: key for wrapping DEK and MAC keys
:param product_version: The product version (default: 1.0.0)
:param component_version: The component version (default: 1.0.0)
:param build_number: The build number value (default: 0)
:param advanced_params: Advanced parameters for encryption of the SB file, use for tests only
:param sections: Boot sections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImageV20(BaseClass):
    &#34;&#34;&#34;Boot Image V2.0 class.&#34;&#34;&#34;
    # Image specific data
    # size of the MAC key
    HEADER_MAC_SIZE = 32
    # AES encrypted DEK and MAC, including padding
    DEK_MAC_SIZE = 32 + 32 + 16

    KEY_BLOB_SIZE = 80

    def __init__(self, signed: bool, kek: bytes, *sections: BootSectionV2,
                 product_version: str = &#39;1.0.0&#39;, component_version: str = &#39;1.0.0&#39;,
                 build_number: int = 0, advanced_params: SBV2xAdvancedParams = SBV2xAdvancedParams()) -&gt; None:
        &#34;&#34;&#34;Initialize Secure Boot Image V2.0.

        :param signed: True if image is signed, False otherwise
        :param kek: key for wrapping DEK and MAC keys
        :param product_version: The product version (default: 1.0.0)
        :param component_version: The component version (default: 1.0.0)
        :param build_number: The build number value (default: 0)
        :param advanced_params: Advanced parameters for encryption of the SB file, use for tests only
        :param sections: Boot sections
        &#34;&#34;&#34;
        self._kek = kek
        # Set Flags value
        self._signed = signed
        self._private_key_pem_data: Optional[bytes] = None
        flags = 0x08 if self.signed else 0x04
        # Set private attributes
        self._dek: bytes = advanced_params.dek
        self._mac: bytes = advanced_params.mac
        assert len(self._dek) == self.HEADER_MAC_SIZE and len(self._mac) == self.HEADER_MAC_SIZE
        self._header = ImageHeaderV2(version=&#39;2.0&#39;, product_version=product_version,
                                     component_version=component_version, build_number=build_number, flags=flags,
                                     nonce=advanced_params.nonce, timestamp=advanced_params.timestamp)
        self._cert_section: Optional[CertSectionV2] = None
        self._boot_sections: List[BootSectionV2] = []
        # Generate nonce
        if self._header.nonce is None:
            nonce = bytearray(crypto_backend().random_bytes(16))
            # clear nonce bit at offsets 31 and 63
            nonce[9] &amp;= 0x7F
            nonce[13] &amp;= 0x7F
            self._header.nonce = bytes(nonce)
        # Sections
        for section in sections:
            self.add_boot_section(section)

    @property
    def header(self) -&gt; ImageHeaderV2:
        &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
        return self._header

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
        return self._mac

    @property
    def kek(self) -&gt; bytes:
        &#34;&#34;&#34;Return key for wrapping DEK and MAC keys.&#34;&#34;&#34;
        return self._kek

    @property
    def private_key_pem_data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Return private key data for signed images, decrypted in PEM format.&#34;&#34;&#34;
        return self._private_key_pem_data

    @private_key_pem_data.setter
    def private_key_pem_data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter to be used for signed images.

        :param: key for signing the image; decrypted binary data in PEM format
        &#34;&#34;&#34;
        self._private_key_pem_data = value

    @property
    def signed(self) -&gt; bool:
        &#34;&#34;&#34;Check whether sb is signed + encrypted or only encrypted.&#34;&#34;&#34;
        return self._signed

    @property
    def cert_block(self) -&gt; Optional[CertBlockV2]:
        &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
        cert_sect = self._cert_section
        if cert_sect is None:
            return None

        return cert_sect.cert_block

    @cert_block.setter
    def cert_block(self, value: Optional[CertBlockV2]) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: block to be assigned; None to remove previously assigned block
        &#34;&#34;&#34;
        if value is not None:
            assert self.signed, &#34;Certificate block cannot be used unless SB file is signed&#34;
        self._cert_section = CertSectionV2(value) if value else None

    @property
    def cert_header_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    @property
    def raw_size_without_signature(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size without signature, used to calculate image blocks.&#34;&#34;&#34;
        # Header, HMAC and KeyBlob
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        # Certificates Section
        if self.signed:
            size += self.DEK_MAC_SIZE
            cert_block = self.cert_block
            assert cert_block
            size += cert_block.raw_size
        # Boot Sections
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size.&#34;&#34;&#34;
        size = self.raw_size_without_signature

        if self.signed:
            cert_block = self.cert_block
            assert cert_block
            size += cert_block.signature_size

        return size

    def __str__(self) -&gt; str:
        return self.info()

    def __len__(self) -&gt; int:
        return len(self._boot_sections)

    def __getitem__(self, key: int) -&gt; BootSectionV2:
        return self._boot_sections[key]

    def __setitem__(self, key: int, value: BootSectionV2) -&gt; None:
        self._boot_sections[key] = value

    def __iter__(self) -&gt; Iterator[BootSectionV2]:
        return self._boot_sections.__iter__()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update boot image.&#34;&#34;&#34;
        if self._boot_sections:
            self._header.first_boot_section_id = self._boot_sections[0].uid
            # calculate first boot tag block
            data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            if self._cert_section is not None:
                data_size += self._cert_section.raw_size
            self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
        # ...
        self._header.flags = 0x08 if self.signed else 0x04
        self._header.image_blocks = calc_cypher_block_count(self.raw_size_without_signature)
        self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
        self._header.max_section_mac_count = 0
        if self.signed:
            self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            self._header.offset_to_certificate_block += CmdHeader.SIZE + CertSectionV2.HMAC_SIZE * 2
            self._header.max_section_mac_count = 1
        for boot_sect in self._boot_sections:
            boot_sect.is_last = True  # this is unified with elftosb
            self._header.max_section_mac_count += boot_sect.hmac_count
        # Update certificates block header
        cert_blk = self.cert_block
        if cert_blk is not None:
            cert_blk.header.build_number = self._header.build_number
            cert_blk.header.image_length = self.cert_header_size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        self.update()
        nfo = &#34;\n&#34;
        nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._header.info()
        if self._cert_section is not None:
            nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
            nfo += self._cert_section.info()
        nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
        for index, section in enumerate(self._boot_sections):
            nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
            nfo += section.info()
        return nfo

    def add_boot_section(self, section: BootSectionV2) -&gt; None:
        &#34;&#34;&#34;Add new Boot section into image.

        :param section: Boot section
        :raise TypeError: raised when section is not instance of BootSectionV2 class
        :raise ValueError: raise when boot section has duplicate UID
        &#34;&#34;&#34;
        if not isinstance(section, BootSectionV2):
            raise TypeError()
        duplicate_uid = find_first(self._boot_sections, lambda bs: bs.uid == section.uid)
        if duplicate_uid is not None:
            raise ValueError(f&#39;Boot section with duplicate UID: {str(section.uid)}&#39;)
        self._boot_sections.append(section)

    def export(self, padding: Optional[bytes] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize image object.

        :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
        :return: exported bytes
        :raise ValueError: raised when there are no boot sections or is not signed or private keys are missing
        &#34;&#34;&#34;
        assert len(self.dek) == 32 and len(self.mac) == 32
        # validate params
        if not self._boot_sections:
            raise ValueError(&#39;No boot section&#39;)
        if self.signed and (self._cert_section is None):
            raise ValueError(&#34;Certificate section is required for signed images&#34;)
        # update internals
        self.update()
        # Add Image Header data
        data = self._header.export(padding=padding)
        # Add Image Header HMAC data
        data += crypto_backend().hmac(self.mac, data)
        # Add DEK and MAC keys
        data += crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
        # Add Padding
        data += padding if padding else crypto_backend().random_bytes(8)
        # Add Certificates data
        assert self._header.nonce
        counter = Counter(self._header.nonce)
        counter.increment(calc_cypher_block_count(len(data)))
        if self._cert_section is not None:
            cert_sect_bin = self._cert_section.export(dek=self.dek, mac=self.mac, counter=counter)
            counter.increment(calc_cypher_block_count(len(cert_sect_bin)))
            data += cert_sect_bin
        # Add Boot Sections data
        for sect in self._boot_sections:
            data += sect.export(dek=self.dek, mac=self.mac, counter=counter)
        # Add Signature data
        if self.signed:
            private_key_pem_data = self.private_key_pem_data
            if private_key_pem_data is None:
                raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
            certificate_block = self.cert_block
            assert (certificate_block is not None) and certificate_block.verify_private_key(private_key_pem_data)
            data += crypto_backend().rsa_sign(private_key_pem_data, data)
        assert len(data) == self.raw_size
        return data

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes()) -&gt; &#39;BootImageV20&#39;:
        &#34;&#34;&#34;Parse image from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param kek: The Key for unwrapping DEK and MAC keys (required)
        :return: parsed image object
        :raise Exception: raised when header is in wrong format
        :raise Exception: raised when there is invalid header version
        :raise Exception: raised when signature is incorrect
        &#34;&#34;&#34;
        assert kek, &#39;kek cannot be empty&#39;
        index = offset
        header_raw_data = data[index: index + ImageHeaderV2.SIZE]
        index += ImageHeaderV2.SIZE
        header_mac_data = data[index: index + cls.HEADER_MAC_SIZE]
        index += cls.HEADER_MAC_SIZE
        key_blob = data[index: index + cls.KEY_BLOB_SIZE]
        index += cls.KEY_BLOB_SIZE
        key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
        dek = key_blob_unwrap[:32]
        mac = key_blob_unwrap[32:]
        header_mac_data_calc = crypto_backend().hmac(mac, header_raw_data)
        if header_mac_data != header_mac_data_calc:
            raise Exception()
        # Parse Header
        header = ImageHeaderV2.parse(header_raw_data)
        if header.version != &#39;2.0&#39;:
            raise Exception(f&#39;Invalid Header Version: {header.version} instead 2.0&#39;)
        image_size = header.image_blocks * 16
        # Initialize counter
        assert header.nonce
        counter = Counter(header.nonce)
        counter.increment(calc_cypher_block_count(index - offset))
        # ...
        signed = header.flags == 0x08
        adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
        obj = cls(signed,
                  kek=kek,
                  product_version=str(header.product_version),
                  component_version=str(header.component_version),
                  build_number=header.build_number,
                  advanced_params=adv_params)
        # Parse Certificate section
        if header.flags == 0x08:
            cert_sect = CertSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
            obj._cert_section = cert_sect
            index += cert_sect.raw_size
            # Check Signature
            if not cert_sect.cert_block.verify_data(data[offset + image_size:],
                                                    data[offset: offset + image_size]):
                raise Exception()
        # Parse Boot Sections
        while index &lt; (image_size + offset):
            boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
            obj.add_boot_section(boot_section)
            index += boot_section.raw_size
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV20.DEK_MAC_SIZE"><code class="name">var <span class="ident">DEK_MAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.HEADER_MAC_SIZE"><code class="name">var <span class="ident">HEADER_MAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.KEY_BLOB_SIZE"><code class="name">var <span class="ident">KEY_BLOB_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV20.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, kek: bytes = b'') ‑> <a title="spsdk.sbfile.images.BootImageV20" href="#spsdk.sbfile.images.BootImageV20">BootImageV20</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from bytes.</p>
<p>:param data: Raw data of parsed image
:param offset: The offset of input data
:param kek: The Key for unwrapping DEK and MAC keys (required)
:return: parsed image object
:raise Exception: raised when header is in wrong format
:raise Exception: raised when there is invalid header version
:raise Exception: raised when signature is incorrect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes()) -&gt; &#39;BootImageV20&#39;:
    &#34;&#34;&#34;Parse image from bytes.

    :param data: Raw data of parsed image
    :param offset: The offset of input data
    :param kek: The Key for unwrapping DEK and MAC keys (required)
    :return: parsed image object
    :raise Exception: raised when header is in wrong format
    :raise Exception: raised when there is invalid header version
    :raise Exception: raised when signature is incorrect
    &#34;&#34;&#34;
    assert kek, &#39;kek cannot be empty&#39;
    index = offset
    header_raw_data = data[index: index + ImageHeaderV2.SIZE]
    index += ImageHeaderV2.SIZE
    header_mac_data = data[index: index + cls.HEADER_MAC_SIZE]
    index += cls.HEADER_MAC_SIZE
    key_blob = data[index: index + cls.KEY_BLOB_SIZE]
    index += cls.KEY_BLOB_SIZE
    key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
    dek = key_blob_unwrap[:32]
    mac = key_blob_unwrap[32:]
    header_mac_data_calc = crypto_backend().hmac(mac, header_raw_data)
    if header_mac_data != header_mac_data_calc:
        raise Exception()
    # Parse Header
    header = ImageHeaderV2.parse(header_raw_data)
    if header.version != &#39;2.0&#39;:
        raise Exception(f&#39;Invalid Header Version: {header.version} instead 2.0&#39;)
    image_size = header.image_blocks * 16
    # Initialize counter
    assert header.nonce
    counter = Counter(header.nonce)
    counter.increment(calc_cypher_block_count(index - offset))
    # ...
    signed = header.flags == 0x08
    adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
    obj = cls(signed,
              kek=kek,
              product_version=str(header.product_version),
              component_version=str(header.component_version),
              build_number=header.build_number,
              advanced_params=adv_params)
    # Parse Certificate section
    if header.flags == 0x08:
        cert_sect = CertSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
        obj._cert_section = cert_sect
        index += cert_sect.raw_size
        # Check Signature
        if not cert_sect.cert_block.verify_data(data[offset + image_size:],
                                                data[offset: offset + image_size]):
            raise Exception()
    # Parse Boot Sections
    while index &lt; (image_size + offset):
        boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter)
        obj.add_boot_section(boot_section)
        index += boot_section.raw_size
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV20.cert_block"><code class="name">var <span class="ident">cert_block</span> : Union[<a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return certificate block; None if SB file not signed or block not assigned yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_block(self) -&gt; Optional[CertBlockV2]:
    &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
    cert_sect = self._cert_section
    if cert_sect is None:
        return None

    return cert_sect.cert_block</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.cert_header_size"><code class="name">var <span class="ident">cert_header_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size (not aligned) for certificate header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_header_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
    for boot_section in self._boot_sections:
        size += boot_section.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.dek"><code class="name">var <span class="ident">dek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Data encryption key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek(self) -&gt; bytes:
    &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
    return self._dek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.sbfile.headers.ImageHeaderV2" href="headers.html#spsdk.sbfile.headers.ImageHeaderV2">ImageHeaderV2</a></code></dt>
<dd>
<div class="desc"><p>Return image header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; ImageHeaderV2:
    &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.kek"><code class="name">var <span class="ident">kek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return key for wrapping DEK and MAC keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kek(self) -&gt; bytes:
    &#34;&#34;&#34;Return key for wrapping DEK and MAC keys.&#34;&#34;&#34;
    return self._kek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Message authentication code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.private_key_pem_data"><code class="name">var <span class="ident">private_key_pem_data</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return private key data for signed images, decrypted in PEM format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def private_key_pem_data(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Return private key data for signed images, decrypted in PEM format.&#34;&#34;&#34;
    return self._private_key_pem_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size.&#34;&#34;&#34;
    size = self.raw_size_without_signature

    if self.signed:
        cert_block = self.cert_block
        assert cert_block
        size += cert_block.signature_size

    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.raw_size_without_signature"><code class="name">var <span class="ident">raw_size_without_signature</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size without signature, used to calculate image blocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size_without_signature(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size without signature, used to calculate image blocks.&#34;&#34;&#34;
    # Header, HMAC and KeyBlob
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
    # Certificates Section
    if self.signed:
        size += self.DEK_MAC_SIZE
        cert_block = self.cert_block
        assert cert_block
        size += cert_block.raw_size
    # Boot Sections
    for boot_section in self._boot_sections:
        size += boot_section.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.signed"><code class="name">var <span class="ident">signed</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check whether sb is signed + encrypted or only encrypted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signed(self) -&gt; bool:
    &#34;&#34;&#34;Check whether sb is signed + encrypted or only encrypted.&#34;&#34;&#34;
    return self._signed</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV20.add_boot_section"><code class="name flex">
<span>def <span class="ident">add_boot_section</span></span>(<span>self, section: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add new Boot section into image.</p>
<p>:param section: Boot section
:raise TypeError: raised when section is not instance of BootSectionV2 class
:raise ValueError: raise when boot section has duplicate UID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_boot_section(self, section: BootSectionV2) -&gt; None:
    &#34;&#34;&#34;Add new Boot section into image.

    :param section: Boot section
    :raise TypeError: raised when section is not instance of BootSectionV2 class
    :raise ValueError: raise when boot section has duplicate UID
    &#34;&#34;&#34;
    if not isinstance(section, BootSectionV2):
        raise TypeError()
    duplicate_uid = find_first(self._boot_sections, lambda bs: bs.uid == section.uid)
    if duplicate_uid is not None:
        raise ValueError(f&#39;Boot section with duplicate UID: {str(section.uid)}&#39;)
    self._boot_sections.append(section)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, padding: Union[bytes, NoneType] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize image object.</p>
<p>:param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
:return: exported bytes
:raise ValueError: raised when there are no boot sections or is not signed or private keys are missing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, padding: Optional[bytes] = None) -&gt; bytes:
    &#34;&#34;&#34;Serialize image object.

    :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
    :return: exported bytes
    :raise ValueError: raised when there are no boot sections or is not signed or private keys are missing
    &#34;&#34;&#34;
    assert len(self.dek) == 32 and len(self.mac) == 32
    # validate params
    if not self._boot_sections:
        raise ValueError(&#39;No boot section&#39;)
    if self.signed and (self._cert_section is None):
        raise ValueError(&#34;Certificate section is required for signed images&#34;)
    # update internals
    self.update()
    # Add Image Header data
    data = self._header.export(padding=padding)
    # Add Image Header HMAC data
    data += crypto_backend().hmac(self.mac, data)
    # Add DEK and MAC keys
    data += crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
    # Add Padding
    data += padding if padding else crypto_backend().random_bytes(8)
    # Add Certificates data
    assert self._header.nonce
    counter = Counter(self._header.nonce)
    counter.increment(calc_cypher_block_count(len(data)))
    if self._cert_section is not None:
        cert_sect_bin = self._cert_section.export(dek=self.dek, mac=self.mac, counter=counter)
        counter.increment(calc_cypher_block_count(len(cert_sect_bin)))
        data += cert_sect_bin
    # Add Boot Sections data
    for sect in self._boot_sections:
        data += sect.export(dek=self.dek, mac=self.mac, counter=counter)
    # Add Signature data
    if self.signed:
        private_key_pem_data = self.private_key_pem_data
        if private_key_pem_data is None:
            raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
        certificate_block = self.cert_block
        assert (certificate_block is not None) and certificate_block.verify_private_key(private_key_pem_data)
        data += crypto_backend().rsa_sign(private_key_pem_data, data)
    assert len(data) == self.raw_size
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
    self.update()
    nfo = &#34;\n&#34;
    nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
    nfo += self._header.info()
    if self._cert_section is not None:
        nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._cert_section.info()
    nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
    for index, section in enumerate(self._boot_sections):
        nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
        nfo += section.info()
    return nfo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV20.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update boot image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Update boot image.&#34;&#34;&#34;
    if self._boot_sections:
        self._header.first_boot_section_id = self._boot_sections[0].uid
        # calculate first boot tag block
        data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        if self._cert_section is not None:
            data_size += self._cert_section.raw_size
        self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
    # ...
    self._header.flags = 0x08 if self.signed else 0x04
    self._header.image_blocks = calc_cypher_block_count(self.raw_size_without_signature)
    self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
    self._header.max_section_mac_count = 0
    if self.signed:
        self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        self._header.offset_to_certificate_block += CmdHeader.SIZE + CertSectionV2.HMAC_SIZE * 2
        self._header.max_section_mac_count = 1
    for boot_sect in self._boot_sections:
        boot_sect.is_last = True  # this is unified with elftosb
        self._header.max_section_mac_count += boot_sect.hmac_count
    # Update certificates block header
    cert_blk = self.cert_block
    if cert_blk is not None:
        cert_blk.header.build_number = self._header.build_number
        cert_blk.header.image_length = self.cert_header_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21"><code class="flex name class">
<span>class <span class="ident">BootImageV21</span></span>
<span>(</span><span>kek: bytes, *sections: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>, product_version: str = '1.0.0', component_version: str = '1.0.0', build_number: int = 0, advanced_params: <a title="spsdk.sbfile.images.SBV2xAdvancedParams" href="#spsdk.sbfile.images.SBV2xAdvancedParams">SBV2xAdvancedParams</a> = &lt;spsdk.sbfile.images.SBV2xAdvancedParams object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Image V2.1 class.</p>
<p>Initialize Secure Boot Image V2.1.</p>
<p>:param kek: key to wrap DEC and MAC keys</p>
<p>:param product_version: The product version (default: 1.0.0)
:param component_version: The component version (default: 1.0.0)
:param build_number: The build number value (default: 0)</p>
<p>:param advanced_params: optional advanced parameters for encryption; it is recommended to use default value
:param sections: Boot sections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImageV21(BaseClass):
    &#34;&#34;&#34;Boot Image V2.1 class.&#34;&#34;&#34;
    # Image specific data
    HEADER_MAC_SIZE = 32
    KEY_BLOB_SIZE = 80

    def __init__(self, kek: bytes, *sections: BootSectionV2,
                 product_version: str = &#39;1.0.0&#39;, component_version: str = &#39;1.0.0&#39;,
                 build_number: int = 0, advanced_params: SBV2xAdvancedParams = SBV2xAdvancedParams()) -&gt; None:
        &#34;&#34;&#34;Initialize Secure Boot Image V2.1.

        :param kek: key to wrap DEC and MAC keys

        :param product_version: The product version (default: 1.0.0)
        :param component_version: The component version (default: 1.0.0)
        :param build_number: The build number value (default: 0)

        :param advanced_params: optional advanced parameters for encryption; it is recommended to use default value
        :param sections: Boot sections
        &#34;&#34;&#34;
        self._kek = kek
        self._private_key_pem_data: Optional[bytes] = None  # this should be assigned for export, not needed for parsing
        self._dek = advanced_params.dek
        self._mac = advanced_params.mac
        self._header = ImageHeaderV2(version=&#39;2.1&#39;, product_version=product_version,
                                     component_version=component_version, build_number=build_number, flags=0x08,
                                     nonce=advanced_params.nonce, timestamp=advanced_params.timestamp)
        self._cert_block: Optional[CertBlockV2] = None
        self._boot_sections: List[BootSectionV2] = []
        # ...
        for section in sections:
            self.add_boot_section(section)

    @property
    def header(self) -&gt; ImageHeaderV2:
        &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
        return self._header

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
        return self._mac

    @property
    def kek(self) -&gt; bytes:
        &#34;&#34;&#34;Return key to wrap DEC and MAC keys.&#34;&#34;&#34;
        return self._kek

    @property
    def private_key_pem_data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Return binary data of private key for signing; decrypted binary data in PEM format.

        None if not assigned yet or image not signed.
        &#34;&#34;&#34;
        return self._private_key_pem_data

    @private_key_pem_data.setter
    def private_key_pem_data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param: key for signing the image; decrypted binary data in PEM format
        &#34;&#34;&#34;
        self._private_key_pem_data = value

    @property
    def cert_block(self) -&gt; Optional[CertBlockV2]:
        &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
        return self._cert_block

    @cert_block.setter
    def cert_block(self, value: CertBlockV2) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: block to be assigned; None to remove previously assigned block
        &#34;&#34;&#34;
        assert isinstance(value, CertBlockV2)
        self._cert_block = value

    @property
    def signed(self) -&gt; bool:
        &#34;&#34;&#34;Return flag whether SB file is signed.&#34;&#34;&#34;
        return True  # SB2.1 is always signed

    @property
    def cert_header_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
        size += self.KEY_BLOB_SIZE
        # Certificates Section
        cert_blk = self.cert_block
        if cert_blk:
            size += cert_blk.raw_size
        return size

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return image raw size (not aligned).&#34;&#34;&#34;
        # Header, HMAC and KeyBlob
        size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
        size += self.KEY_BLOB_SIZE
        # Certificates Section
        cert_blk = self.cert_block
        if cert_blk:
            size += cert_blk.raw_size
            assert self.signed
            size += cert_blk.signature_size
        # Boot Sections
        for boot_section in self._boot_sections:
            size += boot_section.raw_size
        return size

    def __str__(self) -&gt; str:
        return self.info()

    def __len__(self) -&gt; int:
        return len(self._boot_sections)

    def __getitem__(self, key: int) -&gt; BootSectionV2:
        return self._boot_sections[key]

    def __setitem__(self, key: int, value: BootSectionV2) -&gt; None:
        self._boot_sections[key] = value

    def __iter__(self) -&gt; Iterator[BootSectionV2]:
        return self._boot_sections.__iter__()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update BootImageV21.&#34;&#34;&#34;
        if self._boot_sections:
            self._header.first_boot_section_id = self._boot_sections[0].uid
            # calculate first boot tag block
            data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
            cert_blk = self.cert_block
            if cert_blk is not None:
                data_size += cert_blk.raw_size
                assert self.signed
                data_size += cert_blk.signature_size
            self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
        # ...
        self._header.image_blocks = calc_cypher_block_count(self.raw_size)
        self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
        self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        # Get HMAC count
        self._header.max_section_mac_count = 0
        for boot_sect in self._boot_sections:
            boot_sect.is_last = True  # unified with elftosb
            self._header.max_section_mac_count += boot_sect.hmac_count
        # Update certificates block header
        cert_clk = self.cert_block
        if cert_clk is not None:
            cert_clk.header.build_number = self._header.build_number
            cert_clk.header.image_length = self.cert_header_size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        self.update()
        nfo = &#34;\n&#34;
        nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self._header.info()
        if self.cert_block is not None:
            nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
            nfo += self.cert_block.info()
        nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
        for index, section in enumerate(self._boot_sections):
            nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
            nfo += section.info()
        return nfo

    def add_boot_section(self, section: BootSectionV2) -&gt; None:
        &#34;&#34;&#34;Add new Boot section into image.

        :param section: Boot section to be added
        :raise TypeError: raised when section is not instance of BootSectionV2 class
        &#34;&#34;&#34;
        if not isinstance(section, BootSectionV2):
            raise TypeError()
        self._boot_sections.append(section)

    # pylint: disable=too-many-locals
    def export(self, padding: Optional[bytes] = None,
               dbg_info: Optional[List[str]] = None) -&gt; bytes:
        &#34;&#34;&#34;Serialize image object.

        :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
        :param dbg_info: optional list, where debug info is exported in text form
        :return: exported bytes
        :raise ValueError: raised when there is no boot section to be added
        :raise ValueError: raise when certificate is not assigned
        :raise ValueError: raise when private key is not assigned
        &#34;&#34;&#34;
        # validate params
        if not self._boot_sections:
            raise ValueError(&#34;At least one Boot Section must be added&#34;)
        if self.cert_block is None:
            raise ValueError(&#39;Certificate is not assigned&#39;)
        if self.private_key_pem_data is None:
            raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
        # Update internals
        if dbg_info is not None:
            dbg_info.append(&#39;[sb_file]&#39;)
        bs_dbg_info: Optional[List[str]] = list() if dbg_info else None
        self.update()
        # Export Boot Sections
        bs_data = bytes()
        # TODO: implement helper method for get key size in bytes. Now is working only with internal backend
        bs_offset = (ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE + self.cert_block.raw_size +
                     self.cert_block.signature_size)
        assert self._header.nonce
        counter = Counter(self._header.nonce, calc_cypher_block_count(bs_offset))
        for sect in self._boot_sections:
            bs_data += sect.export(dek=self.dek, mac=self.mac, counter=counter, dbg_info=bs_dbg_info)
        # Export Header
        signed_data = self._header.export(padding=padding)
        if dbg_info:
            dbg_info.append(&#39;[header]&#39;)
            dbg_info.append(signed_data.hex())
        #  Add HMAC data
        first_bs_hmac_count = self._boot_sections[0].hmac_count
        hmac_data = bs_data[CmdHeader.SIZE: CmdHeader.SIZE + (first_bs_hmac_count * 32) + 32]
        hmac = crypto_backend().hmac(self.mac, hmac_data)
        signed_data += hmac
        if dbg_info:
            dbg_info.append(&#39;[hmac]&#39;)
            dbg_info.append(hmac.hex())
        # Add KeyBlob data
        key_blob = crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
        key_blob += b&#39;\00&#39; * (self.KEY_BLOB_SIZE - len(key_blob))
        signed_data += key_blob
        if dbg_info:
            dbg_info.append(&#39;[key_blob]&#39;)
            dbg_info.append(key_blob.hex())
        # Add Certificates data
        signed_data += self.cert_block.export()
        if dbg_info:
            dbg_info.append(&#39;[cert_block]&#39;)
            dbg_info.append(self.cert_block.export().hex())
        # Add Signature data
        assert self.cert_block.verify_private_key(self.private_key_pem_data)  # verify private key matches certificate
        signature = crypto_backend().rsa_sign(self.private_key_pem_data, signed_data)
        if dbg_info:
            dbg_info.append(&#39;[signature]&#39;)
            dbg_info.append(signature.hex())
            dbg_info.append(&#39;[boot_sections]&#39;)
            assert bs_dbg_info
            dbg_info.extend(bs_dbg_info)
        return signed_data + signature + bs_data

    # pylint: disable=too-many-locals
    @classmethod
    def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes(),
              plain_sections: bool = False) -&gt; &#39;BootImageV21&#39;:
        &#34;&#34;&#34;Parse image from bytes.

        :param data: Raw data of parsed image
        :param offset: The offset of input data
        :param kek: The Key for unwrapping DEK and MAC keys (required)
        :param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
        :return: BootImageV21 parsed object
        :raise Exception: raised when header is in incorrect format
        :raise Exception: raised when signature is incorrect
        &#34;&#34;&#34;
        assert kek, &#39;kek cannot be empty&#39;
        index = offset
        header_raw_data = data[index: index + ImageHeaderV2.SIZE]
        index += ImageHeaderV2.SIZE
        # TODO not used right now: hmac_data = data[index: index + cls.HEADER_MAC_SIZE]
        index += cls.HEADER_MAC_SIZE
        key_blob = data[index: index + cls.KEY_BLOB_SIZE]
        index += cls.KEY_BLOB_SIZE
        key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
        dek = key_blob_unwrap[:32]
        mac = key_blob_unwrap[32:]
        # Parse Header
        header = ImageHeaderV2.parse(header_raw_data)
        if header.offset_to_certificate_block != (index - offset):
            raise Exception()
        # Parse Certificate Block
        cert_block = CertBlockV2.parse(data, index)
        index += cert_block.raw_size
        # Verify Signature
        if not cert_block.verify_data(data[index: index + cert_block.signature_size], data[offset: index]):
            raise Exception()
        index += cert_block.signature_size
        # Check first Boot Section HMAC
        # TODO: not implemented yet
        # hmac_data_calc = crypto_backend().hmac(mac, data[index + CmdHeader.SIZE: index + CmdHeader.SIZE + ((2) * 32)])
        # if hmac_data != hmac_data_calc:
        #    raise Exception()
        assert header.nonce
        counter = Counter(header.nonce)
        counter.increment(calc_cypher_block_count(index - offset))
        boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter, plain_sect=plain_sections)
        adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
        obj = cls(kek=kek,
                  product_version=str(header.product_version),
                  component_version=str(header.component_version),
                  build_number=header.build_number,
                  advanced_params=adv_params)
        obj.cert_block = cert_block
        obj.add_boot_section(boot_section)
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV21.HEADER_MAC_SIZE"><code class="name">var <span class="ident">HEADER_MAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.KEY_BLOB_SIZE"><code class="name">var <span class="ident">KEY_BLOB_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV21.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, kek: bytes = b'', plain_sections: bool = False) ‑> <a title="spsdk.sbfile.images.BootImageV21" href="#spsdk.sbfile.images.BootImageV21">BootImageV21</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from bytes.</p>
<p>:param data: Raw data of parsed image
:param offset: The offset of input data
:param kek: The Key for unwrapping DEK and MAC keys (required)
:param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
:return: BootImageV21 parsed object
:raise Exception: raised when header is in incorrect format
:raise Exception: raised when signature is incorrect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, kek: bytes = bytes(),
          plain_sections: bool = False) -&gt; &#39;BootImageV21&#39;:
    &#34;&#34;&#34;Parse image from bytes.

    :param data: Raw data of parsed image
    :param offset: The offset of input data
    :param kek: The Key for unwrapping DEK and MAC keys (required)
    :param plain_sections: Sections are not encrypted; this is used only for debugging, not supported by ROM code
    :return: BootImageV21 parsed object
    :raise Exception: raised when header is in incorrect format
    :raise Exception: raised when signature is incorrect
    &#34;&#34;&#34;
    assert kek, &#39;kek cannot be empty&#39;
    index = offset
    header_raw_data = data[index: index + ImageHeaderV2.SIZE]
    index += ImageHeaderV2.SIZE
    # TODO not used right now: hmac_data = data[index: index + cls.HEADER_MAC_SIZE]
    index += cls.HEADER_MAC_SIZE
    key_blob = data[index: index + cls.KEY_BLOB_SIZE]
    index += cls.KEY_BLOB_SIZE
    key_blob_unwrap = crypto_backend().aes_key_unwrap(kek, key_blob[:-8])
    dek = key_blob_unwrap[:32]
    mac = key_blob_unwrap[32:]
    # Parse Header
    header = ImageHeaderV2.parse(header_raw_data)
    if header.offset_to_certificate_block != (index - offset):
        raise Exception()
    # Parse Certificate Block
    cert_block = CertBlockV2.parse(data, index)
    index += cert_block.raw_size
    # Verify Signature
    if not cert_block.verify_data(data[index: index + cert_block.signature_size], data[offset: index]):
        raise Exception()
    index += cert_block.signature_size
    # Check first Boot Section HMAC
    # TODO: not implemented yet
    # hmac_data_calc = crypto_backend().hmac(mac, data[index + CmdHeader.SIZE: index + CmdHeader.SIZE + ((2) * 32)])
    # if hmac_data != hmac_data_calc:
    #    raise Exception()
    assert header.nonce
    counter = Counter(header.nonce)
    counter.increment(calc_cypher_block_count(index - offset))
    boot_section = BootSectionV2.parse(data, index, dek=dek, mac=mac, counter=counter, plain_sect=plain_sections)
    adv_params = SBV2xAdvancedParams(dek=dek, mac=mac, nonce=header.nonce, timestamp=header.timestamp)
    obj = cls(kek=kek,
              product_version=str(header.product_version),
              component_version=str(header.component_version),
              build_number=header.build_number,
              advanced_params=adv_params)
    obj.cert_block = cert_block
    obj.add_boot_section(boot_section)
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV21.cert_block"><code class="name">var <span class="ident">cert_block</span> : Union[<a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return certificate block; None if SB file not signed or block not assigned yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_block(self) -&gt; Optional[CertBlockV2]:
    &#34;&#34;&#34;Return certificate block; None if SB file not signed or block not assigned yet.&#34;&#34;&#34;
    return self._cert_block</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.cert_header_size"><code class="name">var <span class="ident">cert_header_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size (not aligned) for certificate header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cert_header_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size (not aligned) for certificate header.&#34;&#34;&#34;
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
    size += self.KEY_BLOB_SIZE
    # Certificates Section
    cert_blk = self.cert_block
    if cert_blk:
        size += cert_blk.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.dek"><code class="name">var <span class="ident">dek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Data encryption key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek(self) -&gt; bytes:
    &#34;&#34;&#34;Data encryption key.&#34;&#34;&#34;
    return self._dek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.sbfile.headers.ImageHeaderV2" href="headers.html#spsdk.sbfile.headers.ImageHeaderV2">ImageHeaderV2</a></code></dt>
<dd>
<div class="desc"><p>Return image header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; ImageHeaderV2:
    &#34;&#34;&#34;Return image header.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.kek"><code class="name">var <span class="ident">kek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return key to wrap DEC and MAC keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kek(self) -&gt; bytes:
    &#34;&#34;&#34;Return key to wrap DEC and MAC keys.&#34;&#34;&#34;
    return self._kek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Message authentication code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;Message authentication code.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.private_key_pem_data"><code class="name">var <span class="ident">private_key_pem_data</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return binary data of private key for signing; decrypted binary data in PEM format.</p>
<p>None if not assigned yet or image not signed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def private_key_pem_data(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Return binary data of private key for signing; decrypted binary data in PEM format.

    None if not assigned yet or image not signed.
    &#34;&#34;&#34;
    return self._private_key_pem_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return image raw size (not aligned).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Return image raw size (not aligned).&#34;&#34;&#34;
    # Header, HMAC and KeyBlob
    size = ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE
    size += self.KEY_BLOB_SIZE
    # Certificates Section
    cert_blk = self.cert_block
    if cert_blk:
        size += cert_blk.raw_size
        assert self.signed
        size += cert_blk.signature_size
    # Boot Sections
    for boot_section in self._boot_sections:
        size += boot_section.raw_size
    return size</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.signed"><code class="name">var <span class="ident">signed</span> : bool</code></dt>
<dd>
<div class="desc"><p>Return flag whether SB file is signed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signed(self) -&gt; bool:
    &#34;&#34;&#34;Return flag whether SB file is signed.&#34;&#34;&#34;
    return True  # SB2.1 is always signed</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.images.BootImageV21.add_boot_section"><code class="name flex">
<span>def <span class="ident">add_boot_section</span></span>(<span>self, section: <a title="spsdk.sbfile.sections.BootSectionV2" href="sections.html#spsdk.sbfile.sections.BootSectionV2">BootSectionV2</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add new Boot section into image.</p>
<p>:param section: Boot section to be added
:raise TypeError: raised when section is not instance of BootSectionV2 class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_boot_section(self, section: BootSectionV2) -&gt; None:
    &#34;&#34;&#34;Add new Boot section into image.

    :param section: Boot section to be added
    :raise TypeError: raised when section is not instance of BootSectionV2 class
    &#34;&#34;&#34;
    if not isinstance(section, BootSectionV2):
        raise TypeError()
    self._boot_sections.append(section)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, padding: Union[bytes, NoneType] = None, dbg_info: Union[List[str], NoneType] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize image object.</p>
<p>:param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
:param dbg_info: optional list, where debug info is exported in text form
:return: exported bytes
:raise ValueError: raised when there is no boot section to be added
:raise ValueError: raise when certificate is not assigned
:raise ValueError: raise when private key is not assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, padding: Optional[bytes] = None,
           dbg_info: Optional[List[str]] = None) -&gt; bytes:
    &#34;&#34;&#34;Serialize image object.

    :param padding: header padding (8 bytes) for testing purpose; None to use random values (recommended)
    :param dbg_info: optional list, where debug info is exported in text form
    :return: exported bytes
    :raise ValueError: raised when there is no boot section to be added
    :raise ValueError: raise when certificate is not assigned
    :raise ValueError: raise when private key is not assigned
    &#34;&#34;&#34;
    # validate params
    if not self._boot_sections:
        raise ValueError(&#34;At least one Boot Section must be added&#34;)
    if self.cert_block is None:
        raise ValueError(&#39;Certificate is not assigned&#39;)
    if self.private_key_pem_data is None:
        raise ValueError(&#39;Private key not assigned, cannot sign the image&#39;)
    # Update internals
    if dbg_info is not None:
        dbg_info.append(&#39;[sb_file]&#39;)
    bs_dbg_info: Optional[List[str]] = list() if dbg_info else None
    self.update()
    # Export Boot Sections
    bs_data = bytes()
    # TODO: implement helper method for get key size in bytes. Now is working only with internal backend
    bs_offset = (ImageHeaderV2.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE + self.cert_block.raw_size +
                 self.cert_block.signature_size)
    assert self._header.nonce
    counter = Counter(self._header.nonce, calc_cypher_block_count(bs_offset))
    for sect in self._boot_sections:
        bs_data += sect.export(dek=self.dek, mac=self.mac, counter=counter, dbg_info=bs_dbg_info)
    # Export Header
    signed_data = self._header.export(padding=padding)
    if dbg_info:
        dbg_info.append(&#39;[header]&#39;)
        dbg_info.append(signed_data.hex())
    #  Add HMAC data
    first_bs_hmac_count = self._boot_sections[0].hmac_count
    hmac_data = bs_data[CmdHeader.SIZE: CmdHeader.SIZE + (first_bs_hmac_count * 32) + 32]
    hmac = crypto_backend().hmac(self.mac, hmac_data)
    signed_data += hmac
    if dbg_info:
        dbg_info.append(&#39;[hmac]&#39;)
        dbg_info.append(hmac.hex())
    # Add KeyBlob data
    key_blob = crypto_backend().aes_key_wrap(self.kek, self.dek + self.mac)
    key_blob += b&#39;\00&#39; * (self.KEY_BLOB_SIZE - len(key_blob))
    signed_data += key_blob
    if dbg_info:
        dbg_info.append(&#39;[key_blob]&#39;)
        dbg_info.append(key_blob.hex())
    # Add Certificates data
    signed_data += self.cert_block.export()
    if dbg_info:
        dbg_info.append(&#39;[cert_block]&#39;)
        dbg_info.append(self.cert_block.export().hex())
    # Add Signature data
    assert self.cert_block.verify_private_key(self.private_key_pem_data)  # verify private key matches certificate
    signature = crypto_backend().rsa_sign(self.private_key_pem_data, signed_data)
    if dbg_info:
        dbg_info.append(&#39;[signature]&#39;)
        dbg_info.append(signature.hex())
        dbg_info.append(&#39;[boot_sections]&#39;)
        assert bs_dbg_info
        dbg_info.extend(bs_dbg_info)
    return signed_data + signature + bs_data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
    self.update()
    nfo = &#34;\n&#34;
    nfo += &#34;:::::::::::::::::::::::::::::::::: IMAGE HEADER ::::::::::::::::::::::::::::::::::::::\n&#34;
    nfo += self._header.info()
    if self.cert_block is not None:
        nfo += &#34;::::::::::::::::::::::::::::::: CERTIFICATES BLOCK ::::::::::::::::::::::::::::::::::::\n&#34;
        nfo += self.cert_block.info()
    nfo += &#34;::::::::::::::::::::::::::::::::::: BOOT SECTIONS ::::::::::::::::::::::::::::::::::::\n&#34;
    for index, section in enumerate(self._boot_sections):
        nfo += f&#34;[ SECTION: {index} | UID: 0x{section.uid:08X} ]\n&#34;
        nfo += section.info()
    return nfo</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.BootImageV21.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update BootImageV21.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Update BootImageV21.&#34;&#34;&#34;
    if self._boot_sections:
        self._header.first_boot_section_id = self._boot_sections[0].uid
        # calculate first boot tag block
        data_size = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
        cert_blk = self.cert_block
        if cert_blk is not None:
            data_size += cert_blk.raw_size
            assert self.signed
            data_size += cert_blk.signature_size
        self._header.first_boot_tag_block = calc_cypher_block_count(data_size)
    # ...
    self._header.image_blocks = calc_cypher_block_count(self.raw_size)
    self._header.header_blocks = calc_cypher_block_count(self._header.SIZE)
    self._header.offset_to_certificate_block = self._header.SIZE + self.HEADER_MAC_SIZE + self.KEY_BLOB_SIZE
    # Get HMAC count
    self._header.max_section_mac_count = 0
    for boot_sect in self._boot_sections:
        boot_sect.is_last = True  # unified with elftosb
        self._header.max_section_mac_count += boot_sect.hmac_count
    # Update certificates block header
    cert_clk = self.cert_block
    if cert_clk is not None:
        cert_clk.header.build_number = self._header.build_number
        cert_clk.header.image_length = self.cert_header_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.images.SBV2xAdvancedParams"><code class="flex name class">
<span>class <span class="ident">SBV2xAdvancedParams</span></span>
<span>(</span><span>dek: Union[bytes, NoneType] = None, mac: Union[bytes, NoneType] = None, nonce: Union[bytes, NoneType] = None, timestamp: Union[datetime.datetime, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The class holds advanced parameters for the SB file encryption.</p>
<p>These parameters are used for the tests; for production, use can use default values (random keys + current time)</p>
<p>Initialize SBV2xAdvancedParams.</p>
<p>:param dek: DEK key
:param mac: MAC key
:param nonce: nonce
:param timestamp: fixed timestamp for the header; use None to use current date/time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SBV2xAdvancedParams:
    &#34;&#34;&#34;The class holds advanced parameters for the SB file encryption.

    These parameters are used for the tests; for production, use can use default values (random keys + current time)
    &#34;&#34;&#34;

    @staticmethod
    def _create_nonce() -&gt; bytes:
        &#34;&#34;&#34;Return random nonce.&#34;&#34;&#34;
        nonce = bytearray(crypto_backend().random_bytes(16))
        # clear nonce bit at offsets 31 and 63
        nonce[9] &amp;= 0x7F
        nonce[13] &amp;= 0x7F
        return bytes(nonce)

    def __init__(self, dek: Optional[bytes] = None, mac: Optional[bytes] = None, nonce: Optional[bytes] = None,
                 timestamp: Optional[datetime] = None):
        &#34;&#34;&#34;Initialize SBV2xAdvancedParams.

        :param dek: DEK key
        :param mac: MAC key
        :param nonce: nonce
        :param timestamp: fixed timestamp for the header; use None to use current date/time
        &#34;&#34;&#34;
        self._dek: bytes = dek if dek else crypto_backend().random_bytes(32)
        self._mac: bytes = mac if mac else crypto_backend().random_bytes(32)
        self._nonce: bytes = nonce if nonce else SBV2xAdvancedParams._create_nonce()
        if timestamp is None:
            timestamp = datetime.now()
        self._timestamp = datetime.fromtimestamp(int(timestamp.timestamp()))
        assert len(self._dek) == 32 and len(self._mac) == 32
        assert len(self._nonce) == 16

    @property
    def dek(self) -&gt; bytes:
        &#34;&#34;&#34;Return DEK key.&#34;&#34;&#34;
        return self._dek

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;Return MAC key.&#34;&#34;&#34;
        return self._mac

    @property
    def nonce(self) -&gt; bytes:
        &#34;&#34;&#34;Return NONCE.&#34;&#34;&#34;
        return self._nonce

    @property
    def timestamp(self) -&gt; datetime:
        &#34;&#34;&#34;Return timestamp.&#34;&#34;&#34;
        return self._timestamp</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.images.SBV2xAdvancedParams.dek"><code class="name">var <span class="ident">dek</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return DEK key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek(self) -&gt; bytes:
    &#34;&#34;&#34;Return DEK key.&#34;&#34;&#34;
    return self._dek</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.SBV2xAdvancedParams.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return MAC key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;Return MAC key.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.SBV2xAdvancedParams.nonce"><code class="name">var <span class="ident">nonce</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return NONCE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nonce(self) -&gt; bytes:
    &#34;&#34;&#34;Return NONCE.&#34;&#34;&#34;
    return self._nonce</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.images.SBV2xAdvancedParams.timestamp"><code class="name">var <span class="ident">timestamp</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Return timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timestamp(self) -&gt; datetime:
    &#34;&#34;&#34;Return timestamp.&#34;&#34;&#34;
    return self._timestamp</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.sbfile" href="index.html">spsdk.sbfile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.sbfile.images.BootImageV20" href="#spsdk.sbfile.images.BootImageV20">BootImageV20</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.images.BootImageV20.DEK_MAC_SIZE" href="#spsdk.sbfile.images.BootImageV20.DEK_MAC_SIZE">DEK_MAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.HEADER_MAC_SIZE" href="#spsdk.sbfile.images.BootImageV20.HEADER_MAC_SIZE">HEADER_MAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.KEY_BLOB_SIZE" href="#spsdk.sbfile.images.BootImageV20.KEY_BLOB_SIZE">KEY_BLOB_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.add_boot_section" href="#spsdk.sbfile.images.BootImageV20.add_boot_section">add_boot_section</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.cert_block" href="#spsdk.sbfile.images.BootImageV20.cert_block">cert_block</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.cert_header_size" href="#spsdk.sbfile.images.BootImageV20.cert_header_size">cert_header_size</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.dek" href="#spsdk.sbfile.images.BootImageV20.dek">dek</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.export" href="#spsdk.sbfile.images.BootImageV20.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.header" href="#spsdk.sbfile.images.BootImageV20.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.info" href="#spsdk.sbfile.images.BootImageV20.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.kek" href="#spsdk.sbfile.images.BootImageV20.kek">kek</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.mac" href="#spsdk.sbfile.images.BootImageV20.mac">mac</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.parse" href="#spsdk.sbfile.images.BootImageV20.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.private_key_pem_data" href="#spsdk.sbfile.images.BootImageV20.private_key_pem_data">private_key_pem_data</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.raw_size" href="#spsdk.sbfile.images.BootImageV20.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.raw_size_without_signature" href="#spsdk.sbfile.images.BootImageV20.raw_size_without_signature">raw_size_without_signature</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.signed" href="#spsdk.sbfile.images.BootImageV20.signed">signed</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV20.update" href="#spsdk.sbfile.images.BootImageV20.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.images.BootImageV21" href="#spsdk.sbfile.images.BootImageV21">BootImageV21</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.images.BootImageV21.HEADER_MAC_SIZE" href="#spsdk.sbfile.images.BootImageV21.HEADER_MAC_SIZE">HEADER_MAC_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.KEY_BLOB_SIZE" href="#spsdk.sbfile.images.BootImageV21.KEY_BLOB_SIZE">KEY_BLOB_SIZE</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.add_boot_section" href="#spsdk.sbfile.images.BootImageV21.add_boot_section">add_boot_section</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.cert_block" href="#spsdk.sbfile.images.BootImageV21.cert_block">cert_block</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.cert_header_size" href="#spsdk.sbfile.images.BootImageV21.cert_header_size">cert_header_size</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.dek" href="#spsdk.sbfile.images.BootImageV21.dek">dek</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.export" href="#spsdk.sbfile.images.BootImageV21.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.header" href="#spsdk.sbfile.images.BootImageV21.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.info" href="#spsdk.sbfile.images.BootImageV21.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.kek" href="#spsdk.sbfile.images.BootImageV21.kek">kek</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.mac" href="#spsdk.sbfile.images.BootImageV21.mac">mac</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.parse" href="#spsdk.sbfile.images.BootImageV21.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.private_key_pem_data" href="#spsdk.sbfile.images.BootImageV21.private_key_pem_data">private_key_pem_data</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.raw_size" href="#spsdk.sbfile.images.BootImageV21.raw_size">raw_size</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.signed" href="#spsdk.sbfile.images.BootImageV21.signed">signed</a></code></li>
<li><code><a title="spsdk.sbfile.images.BootImageV21.update" href="#spsdk.sbfile.images.BootImageV21.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.images.SBV2xAdvancedParams" href="#spsdk.sbfile.images.SBV2xAdvancedParams">SBV2xAdvancedParams</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.images.SBV2xAdvancedParams.dek" href="#spsdk.sbfile.images.SBV2xAdvancedParams.dek">dek</a></code></li>
<li><code><a title="spsdk.sbfile.images.SBV2xAdvancedParams.mac" href="#spsdk.sbfile.images.SBV2xAdvancedParams.mac">mac</a></code></li>
<li><code><a title="spsdk.sbfile.images.SBV2xAdvancedParams.nonce" href="#spsdk.sbfile.images.SBV2xAdvancedParams.nonce">nonce</a></code></li>
<li><code><a title="spsdk.sbfile.images.SBV2xAdvancedParams.timestamp" href="#spsdk.sbfile.images.SBV2xAdvancedParams.timestamp">timestamp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>