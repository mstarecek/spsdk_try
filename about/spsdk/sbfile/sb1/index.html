<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.sbfile.sb1 API documentation</title>
<meta name="description" content="Module implementing SBFile version 1." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.sbfile.sb1</code></h1>
</header>
<section id="section-intro">
<p>Module implementing SBFile version 1.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Module implementing SBFile version 1.&#34;&#34;&#34;

from spsdk.mboot import ExtMemId
from .headers import SecureBootFlagsV1
from .images import SecureBootV1
from .sections import BootSectionV1
from ..commands import CmdFill, CmdTag, CmdNop, CmdMemEnable, CmdErase, CmdReset, CmdCall, CmdLoad, CmdJump, CmdProg
from ..misc import BcdVersion3

__all__ = [
    # main classes
    &#39;SecureBootV1&#39;,
    &#39;BootSectionV1&#39;,
    # commands
    &#39;CmdFill&#39;,
    &#39;CmdNop&#39;,
    &#39;CmdTag&#39;,
    &#39;CmdMemEnable&#39;,
    &#39;CmdErase&#39;,
    &#39;CmdReset&#39;,
    &#39;CmdCall&#39;,
    &#39;CmdLoad&#39;,
    &#39;CmdJump&#39;,
    &#39;CmdProg&#39;,
    # helper classes and enums
    &#39;SecureBootFlagsV1&#39;,
    &#39;BcdVersion3&#39;,
    &#39;ExtMemId&#39;,
    ]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="spsdk.sbfile.sb1.commands" href="commands.html">spsdk.sbfile.sb1.commands</a></code></dt>
<dd>
<div class="desc"><p>Commands for SBFile.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.sb1.headers" href="headers.html">spsdk.sbfile.sb1.headers</a></code></dt>
<dd>
<div class="desc"><p>Secure Boot Header.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.sb1.images" href="images.html">spsdk.sbfile.sb1.images</a></code></dt>
<dd>
<div class="desc"><p>Secure Boot Image Class.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.sbfile.sb1.sections" href="sections.html">spsdk.sbfile.sb1.sections</a></code></dt>
<dd>
<div class="desc"><p>Boot Selection for SB file.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.sbfile.sb1.BcdVersion3"><code class="flex name class">
<span>class <span class="ident">BcdVersion3</span></span>
<span>(</span><span>major: int = 1, minor: int = 0, service: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Version in format #.#.#, where # is BCD number (1-4 digits).</p>
<p>Initialize BcdVersion3.</p>
<p>:param major: number in BCD format, 1-4 decimal digits
:param minor: number in BCD format, 1-4 decimal digits
:param service: number in BCD format, 1-4 decimal digits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BcdVersion3:
    &#34;&#34;&#34;Version in format #.#.#, where # is BCD number (1-4 digits).&#34;&#34;&#34;

    # default value
    DEFAULT = &#39;999.999.999&#39;

    @staticmethod
    def _check_number(num: int) -&gt; bool:
        &#34;&#34;&#34;Check given number is a valid version number.

        :param num: to be checked
        :return: True if number format is valid
        :raise ValueError: if number format is not valid
        &#34;&#34;&#34;
        if not 0 &lt;= num &lt;= 0x9999:
            raise ValueError(&#39;Invalid number range&#39;)
        for index in range(4):
            if (num &gt;&gt; 4 * index) &amp; 0xF &gt; 0x9:
                raise ValueError(&#39;Invalid number, contains digit &gt; 9&#39;)
        return True

    @staticmethod
    def _num_from_str(text: str) -&gt; int:
        &#34;&#34;&#34;Converts BCD number from text to int.

        :param text: given string to be converted to a version number
        :return: version number
        :raise ValueError: if format is not valid
        &#34;&#34;&#34;
        assert 0 &lt;= len(text) &lt;= 4
        result = int(text, 16)
        BcdVersion3._check_number(result)
        return result

    @staticmethod
    def from_str(text: str) -&gt; &#39;BcdVersion3&#39;:
        &#34;&#34;&#34;Convert string to BcdVersion instance.

        :param text: version in format #.#.#, where # is 1-4 decimal digits
        :return: BcdVersion3 instance
        :raise: ValueError: if format is not valid
        &#34;&#34;&#34;
        parts = text.split(&#39;.&#39;)
        assert len(parts) == 3
        major = BcdVersion3._num_from_str(parts[0])
        minor = BcdVersion3._num_from_str(parts[1])
        service = BcdVersion3._num_from_str(parts[2])
        return BcdVersion3(major, minor, service)

    @staticmethod
    def to_version(input_version: BcdVersion3Format) -&gt; &#39;BcdVersion3&#39;:
        &#34;&#34;&#34;Convert different input formats into BcdVersion3 instance.

        :param input_version: either directly BcdVersion3 or string
        :raise ValueError: raises when the format is unsupported
        :return: BcdVersion3 instance
        &#34;&#34;&#34;
        if isinstance(input_version, BcdVersion3):
            return input_version
        if isinstance(input_version, str):
            return BcdVersion3.from_str(input_version)
        raise ValueError(&#39;unsupported format&#39;)

    def __init__(self, major: int = 1, minor: int = 0, service: int = 0):
        &#34;&#34;&#34;Initialize BcdVersion3.

        :param major: number in BCD format, 1-4 decimal digits
        :param minor: number in BCD format, 1-4 decimal digits
        :param service: number in BCD format, 1-4 decimal digits
        &#34;&#34;&#34;
        assert all([BcdVersion3._check_number(major), BcdVersion3._check_number(minor),
                    BcdVersion3._check_number(service)])
        self.major = major
        self.minor = minor
        self.service = service

    def __str__(self) -&gt; str:
        return f&#39;{self.major:X}.{self.minor:X}.{self.service:X}&#39;

    def __repr__(self) -&gt; str:
        return self.__class__.__name__ + &#39;: &#39; + self.__str__()

    def __eq__(self, other: Any) -&gt; bool:
        return (isinstance(other, BcdVersion3) and
                (self.major == other.major) and
                (self.minor == other.minor) and
                (self.service == other.service))

    @property
    def nums(self) -&gt; Sequence[int]:
        &#34;&#34;&#34;Return array of version numbers: [major, minor, service].&#34;&#34;&#34;
        return [self.major, self.minor, self.service]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.BcdVersion3.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.BcdVersion3.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>text: str) ‑> <a title="spsdk.sbfile.misc.BcdVersion3" href="../misc.html#spsdk.sbfile.misc.BcdVersion3">BcdVersion3</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert string to BcdVersion instance.</p>
<p>:param text: version in format #.#.#, where # is 1-4 decimal digits
:return: BcdVersion3 instance
:raise: ValueError: if format is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_str(text: str) -&gt; &#39;BcdVersion3&#39;:
    &#34;&#34;&#34;Convert string to BcdVersion instance.

    :param text: version in format #.#.#, where # is 1-4 decimal digits
    :return: BcdVersion3 instance
    :raise: ValueError: if format is not valid
    &#34;&#34;&#34;
    parts = text.split(&#39;.&#39;)
    assert len(parts) == 3
    major = BcdVersion3._num_from_str(parts[0])
    minor = BcdVersion3._num_from_str(parts[1])
    service = BcdVersion3._num_from_str(parts[2])
    return BcdVersion3(major, minor, service)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BcdVersion3.to_version"><code class="name flex">
<span>def <span class="ident">to_version</span></span>(<span>input_version: Union[ForwardRef('<a title="spsdk.sbfile.sb1.BcdVersion3" href="#spsdk.sbfile.sb1.BcdVersion3">BcdVersion3</a>'), str]) ‑> <a title="spsdk.sbfile.misc.BcdVersion3" href="../misc.html#spsdk.sbfile.misc.BcdVersion3">BcdVersion3</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert different input formats into BcdVersion3 instance.</p>
<p>:param input_version: either directly BcdVersion3 or string
:raise ValueError: raises when the format is unsupported
:return: BcdVersion3 instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_version(input_version: BcdVersion3Format) -&gt; &#39;BcdVersion3&#39;:
    &#34;&#34;&#34;Convert different input formats into BcdVersion3 instance.

    :param input_version: either directly BcdVersion3 or string
    :raise ValueError: raises when the format is unsupported
    :return: BcdVersion3 instance
    &#34;&#34;&#34;
    if isinstance(input_version, BcdVersion3):
        return input_version
    if isinstance(input_version, str):
        return BcdVersion3.from_str(input_version)
    raise ValueError(&#39;unsupported format&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.BcdVersion3.nums"><code class="name">var <span class="ident">nums</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Return array of version numbers: [major, minor, service].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nums(self) -&gt; Sequence[int]:
    &#34;&#34;&#34;Return array of version numbers: [major, minor, service].&#34;&#34;&#34;
    return [self.major, self.minor, self.service]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1"><code class="flex name class">
<span>class <span class="ident">BootSectionV1</span></span>
<span>(</span><span>section_id: int, flags: <a title="spsdk.sbfile.sb1.headers.SecureBootFlagsV1" href="headers.html#spsdk.sbfile.sb1.headers.SecureBootFlagsV1">SecureBootFlagsV1</a> = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Section for SB file 1.x.</p>
<p>Initialize BootSectionV1.</p>
<p>:param section_id: unique section ID, 32-bit int
:param flags: see SecureBootFlagsV1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootSectionV1(BaseClass):
    &#34;&#34;&#34;Boot Section for SB file 1.x.&#34;&#34;&#34;

    def __init__(self, section_id: int, flags: SecureBootFlagsV1 = SecureBootFlagsV1.NONE):
        &#34;&#34;&#34;Initialize BootSectionV1.

        :param section_id: unique section ID, 32-bit int
        :param flags: see SecureBootFlagsV1
        &#34;&#34;&#34;
        self._header = BootSectionHeaderV1(section_id, flags)
        self._commands: List[CmdBaseClass] = []

    def __str__(self) -&gt; str:
        return self.info()

    @property
    def section_id(self) -&gt; int:
        &#34;&#34;&#34;Return unique ID of the section, 32 number.&#34;&#34;&#34;
        return self._header.section_id

    @property
    def flags(self) -&gt; SecureBootFlagsV1:
        &#34;&#34;&#34;Return section flags.&#34;&#34;&#34;
        return self._header.flags

    @property
    def bootable(self) -&gt; bool:
        &#34;&#34;&#34;Return whether section is bootable.&#34;&#34;&#34;
        return self._header.bootable

    @property
    def rom_last_tag(self) -&gt; bool:
        &#34;&#34;&#34;ReturnROM_LAST_TAG flag.

        The last section header in an image always has its ROM_LAST_TAG flag set to help the ROM know at what point
        to stop searching.
        &#34;&#34;&#34;
        return self._header.rom_last_tag

    @rom_last_tag.setter
    def rom_last_tag(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: ROM_LAST_TAG flag
        &#34;&#34;&#34;
        self._header.rom_last_tag = value

    @property
    def cmd_size(self) -&gt; int:
        &#34;&#34;&#34;Return size of the binary representation of the commands.&#34;&#34;&#34;
        return sum([cmd.raw_size for cmd in self._commands])

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return size of the binary representation of the section in bytes.&#34;&#34;&#34;
        result = self._header.raw_size + self.cmd_size
        return result

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return string representation.&#34;&#34;&#34;
        result = &#34;[BootSection-V1]\n&#34;
        result += f&#34;ID: {self._header.section_id}\n&#34;
        result += f&#34;NumBlocks: {self._header.num_blocks}\n&#34;
        result += self._header.info() + &#39;\n&#39;
        result += &#34;[BootSection-commands]\n&#34;
        for cmd in self._commands:
            result += cmd.info()
        return result

    @property
    def commands(self) -&gt; Sequence[CmdBaseClass]:
        &#34;&#34;&#34;Return sequence of all commands in the section.&#34;&#34;&#34;
        return self._commands

    def append(self, cmd: CmdBaseClass) -&gt; None:
        &#34;&#34;&#34;Append command.

        :param cmd: to be added
        &#34;&#34;&#34;
        assert isinstance(cmd, (CmdNop, CmdErase, CmdLoad, CmdFill, CmdJump, CmdCall, CmdReset, CmdMemEnable, CmdProg))
        self._commands.append(cmd)

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update settings.&#34;&#34;&#34;
        self._header.num_blocks = SecBootBlckSize.to_num_blocks(self.cmd_size)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Return binary representation of the class (serialization).&#34;&#34;&#34;
        self.update()
        dbg_info.append_section(&#39;Section&#39;)
        data = self._header.export()
        dbg_info.append_binary_data(&#39;Section-header&#39;, data)
        dbg_info.append_section(&#39;Commands&#39;)
        for cmd in self._commands:
            cmd_data = cmd.export(dbg_info)
            data += cmd_data
        return data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BootSectionV1&#39;:
        &#34;&#34;&#34;Deserialization from binary format.

        :param data: to be parsed
        :param offset: to start parsing
        :return: the parsed instance
        &#34;&#34;&#34;
        header = BootSectionHeaderV1.parse(data, offset)
        result = BootSectionV1(0)
        result._header = header
        # commands
        cmd_base = offset + header.raw_size
        cmd_ofs = 0
        end_ofs = result._header.num_blocks * SecBootBlckSize.BLOCK_SIZE
        while cmd_ofs &lt; end_ofs:
            cmd = parse_v1_command(data, cmd_base + cmd_ofs)
            result.append(cmd)
            cmd_ofs += cmd.raw_size
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.BootSectionV1.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.sb1.sections.BootSectionV1" href="sections.html#spsdk.sbfile.sb1.sections.BootSectionV1">BootSectionV1</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization from binary format.</p>
<p>:param data: to be parsed
:param offset: to start parsing
:return: the parsed instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BootSectionV1&#39;:
    &#34;&#34;&#34;Deserialization from binary format.

    :param data: to be parsed
    :param offset: to start parsing
    :return: the parsed instance
    &#34;&#34;&#34;
    header = BootSectionHeaderV1.parse(data, offset)
    result = BootSectionV1(0)
    result._header = header
    # commands
    cmd_base = offset + header.raw_size
    cmd_ofs = 0
    end_ofs = result._header.num_blocks * SecBootBlckSize.BLOCK_SIZE
    while cmd_ofs &lt; end_ofs:
        cmd = parse_v1_command(data, cmd_base + cmd_ofs)
        result.append(cmd)
        cmd_ofs += cmd.raw_size
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.BootSectionV1.bootable"><code class="name">var <span class="ident">bootable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Return whether section is bootable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bootable(self) -&gt; bool:
    &#34;&#34;&#34;Return whether section is bootable.&#34;&#34;&#34;
    return self._header.bootable</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.cmd_size"><code class="name">var <span class="ident">cmd_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return size of the binary representation of the commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_size(self) -&gt; int:
    &#34;&#34;&#34;Return size of the binary representation of the commands.&#34;&#34;&#34;
    return sum([cmd.raw_size for cmd in self._commands])</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.commands"><code class="name">var <span class="ident">commands</span> : Sequence[<a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a>]</code></dt>
<dd>
<div class="desc"><p>Return sequence of all commands in the section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; Sequence[CmdBaseClass]:
    &#34;&#34;&#34;Return sequence of all commands in the section.&#34;&#34;&#34;
    return self._commands</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.flags"><code class="name">var <span class="ident">flags</span> : <a title="spsdk.sbfile.sb1.headers.SecureBootFlagsV1" href="headers.html#spsdk.sbfile.sb1.headers.SecureBootFlagsV1">SecureBootFlagsV1</a></code></dt>
<dd>
<div class="desc"><p>Return section flags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; SecureBootFlagsV1:
    &#34;&#34;&#34;Return section flags.&#34;&#34;&#34;
    return self._header.flags</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.rom_last_tag"><code class="name">var <span class="ident">rom_last_tag</span> : bool</code></dt>
<dd>
<div class="desc"><p>ReturnROM_LAST_TAG flag.</p>
<p>The last section header in an image always has its ROM_LAST_TAG flag set to help the ROM know at what point
to stop searching.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rom_last_tag(self) -&gt; bool:
    &#34;&#34;&#34;ReturnROM_LAST_TAG flag.

    The last section header in an image always has its ROM_LAST_TAG flag set to help the ROM know at what point
    to stop searching.
    &#34;&#34;&#34;
    return self._header.rom_last_tag</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.section_id"><code class="name">var <span class="ident">section_id</span> : int</code></dt>
<dd>
<div class="desc"><p>Return unique ID of the section, 32 number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def section_id(self) -&gt; int:
    &#34;&#34;&#34;Return unique ID of the section, 32 number.&#34;&#34;&#34;
    return self._header.section_id</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return size of the binary representation of the section in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Return size of the binary representation of the section in bytes.&#34;&#34;&#34;
    result = self._header.raw_size + self.cmd_size
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.BootSectionV1.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cmd: <a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append command.</p>
<p>:param cmd: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, cmd: CmdBaseClass) -&gt; None:
    &#34;&#34;&#34;Append command.

    :param cmd: to be added
    &#34;&#34;&#34;
    assert isinstance(cmd, (CmdNop, CmdErase, CmdLoad, CmdFill, CmdJump, CmdCall, CmdReset, CmdMemEnable, CmdProg))
    self._commands.append(cmd)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Return binary representation of the class (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Return binary representation of the class (serialization).&#34;&#34;&#34;
    self.update()
    dbg_info.append_section(&#39;Section&#39;)
    data = self._header.export()
    dbg_info.append_binary_data(&#39;Section-header&#39;, data)
    dbg_info.append_section(&#39;Commands&#39;)
    for cmd in self._commands:
        cmd_data = cmd.export(dbg_info)
        data += cmd_data
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return string representation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return string representation.&#34;&#34;&#34;
    result = &#34;[BootSection-V1]\n&#34;
    result += f&#34;ID: {self._header.section_id}\n&#34;
    result += f&#34;NumBlocks: {self._header.num_blocks}\n&#34;
    result += self._header.info() + &#39;\n&#39;
    result += &#34;[BootSection-commands]\n&#34;
    for cmd in self._commands:
        result += cmd.info()
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.BootSectionV1.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Update settings.&#34;&#34;&#34;
    self._header.num_blocks = SecBootBlckSize.to_num_blocks(self.cmd_size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.sbfile.sb1.CmdCall"><code class="flex name class">
<span>class <span class="ident">CmdCall</span></span>
<span>(</span><span>address: int = 0, argument: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Call.</p>
<p>The call statement is used for inserting a bootloader command that executes a function
from one of the files that are loaded into the memory.</p>
<p>Initialize Command Call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdCall(CmdBaseClass):
    &#34;&#34;&#34;Command Call.

    The call statement is used for inserting a bootloader command that executes a function
    from one of the files that are loaded into the memory.
    &#34;&#34;&#34;

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s address.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def argument(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
        return self._header.data

    @argument.setter
    def argument(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s argument.&#34;&#34;&#34;
        self._header.data = value

    def __init__(self, address: int = 0, argument: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize Command Call.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.CALL)
        self.address = address
        self.argument = argument

    def __str__(self) -&gt; str:
        return f&#34;CALL: Address=0x{self.address:08X}, Argument=0x{self.argument:08X}&#34;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCall&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Call object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.CALL
        return cls(header.address, header.data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdCall.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdCall" href="../commands.html#spsdk.sbfile.commands.CmdCall">CmdCall</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Call object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCall&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Call object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.CALL
    return cls(header.address, header.data)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdCall.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdCall.argument"><code class="name">var <span class="ident">argument</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def argument(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
    return self._header.data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdErase"><code class="flex name class">
<span>class <span class="ident">CmdErase</span></span>
<span>(</span><span>address: int = 0, length: int = 0, flags: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Erase class.</p>
<p>Initialize Command Erase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdErase(CmdBaseClass):
    &#34;&#34;&#34;Command Erase class.&#34;&#34;&#34;
    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s address.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s count.&#34;&#34;&#34;
        return self._header.count

    @length.setter
    def length(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s count.&#34;&#34;&#34;
        self._header.count = value

    @property
    def flags(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s flag.&#34;&#34;&#34;
        return self._header.flags

    @flags.setter
    def flags(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s flag.&#34;&#34;&#34;
        self._header.flags = value

    def __init__(self, address: int = 0, length: int = 0, flags: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize Command Erase.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.ERASE)
        self.address = address
        self.length = length
        self.flags = flags

    def __str__(self) -&gt; str:
        return f&#34;ERASE: Address=0x{self.address:08X}, Length={self.length}, Flags=0x{self.flags:08X}&#34;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdErase&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Erase object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.ERASE
        return cls(header.address, header.count, header.flags)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdErase.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdErase" href="../commands.html#spsdk.sbfile.commands.CmdErase">CmdErase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Erase object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdErase&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Erase object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.ERASE
    return cls(header.address, header.count, header.flags)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdErase.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdErase.flags"><code class="name">var <span class="ident">flags</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's flag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s flag.&#34;&#34;&#34;
    return self._header.flags</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdErase.length"><code class="name">var <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s count.&#34;&#34;&#34;
    return self._header.count</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdFill"><code class="flex name class">
<span>class <span class="ident">CmdFill</span></span>
<span>(</span><span>address: int, pattern: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Fill class.</p>
<p>Initialize Command Fill.</p>
<p>:param address: to write data
:param pattern: data to be written
:raise ValueError: raised when size is not aligned to 4 bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdFill(CmdBaseClass):
    &#34;&#34;&#34;Command Fill class.&#34;&#34;&#34;
    PADDING_VALUE = 0x00

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return address of the command Fill.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set address for the command Fill.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Calculate raw size of header.&#34;&#34;&#34;
        size = CmdHeader.SIZE
        size += len(self._pattern) - 4
        if size % CmdHeader.SIZE:
            size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
        return size

    def __init__(self, address: int, pattern: bytes) -&gt; None:
        &#34;&#34;&#34;Initialize Command Fill.

        :param address: to write data
        :param pattern: data to be written
        :raise ValueError: raised when size is not aligned to 4 bytes
        &#34;&#34;&#34;
        super().__init__(EnumCmdTag.FILL)
        assert isinstance(pattern, (bytes, bytearray))
        if len(pattern) &lt; 4:
            raise ValueError(&#39;pattern must be at least 4 bytes long&#39;)
        if len(pattern) % 4:
            raise ValueError(&#39;pattern size must be aligned to 4 bytes&#39;)
        self.address = address
        self._pattern = bytes(pattern)
        # update header
        self._header.data = unpack_from(&#34;&lt;L&#34;, self._pattern)[0]
        self._header.count = len(self._pattern)

    @property
    def pattern(self) -&gt; bytes:
        &#34;&#34;&#34;Return binary data to fill.&#34;&#34;&#34;
        return self._pattern

    def __str__(self) -&gt; str:
        return f&#34;FILL: Address=0x{self.address:08X}, Pattern=&#34; + &#34; &#34;.join(f&#39;{byte:02X}&#39; for byte in self._pattern)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Return command in binary form (serialization).&#34;&#34;&#34;
        # export cmd
        data = super().export(dbg_info)
        # export additional data
        if len(self._pattern) &gt; 4:
            data += bytes(self._pattern[4:])
            dbg_info.append_binary_data(&#39;pattern&#39;, self._pattern[4:])
        data = SecBootBlckSize.align_block_fill_random(data)
        return data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdFill&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Fill object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.FILL
        # The last 4 bytes of header are part of pattern value
        offset += CmdHeader.SIZE - 4
        return cls(header.address, data[offset: offset + header.count])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdFill.PADDING_VALUE"><code class="name">var <span class="ident">PADDING_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdFill.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdFill" href="../commands.html#spsdk.sbfile.commands.CmdFill">CmdFill</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Fill object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdFill&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Fill object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.FILL
    # The last 4 bytes of header are part of pattern value
    offset += CmdHeader.SIZE - 4
    return cls(header.address, data[offset: offset + header.count])</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdFill.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return address of the command Fill.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return address of the command Fill.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdFill.pattern"><code class="name">var <span class="ident">pattern</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return binary data to fill.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pattern(self) -&gt; bytes:
    &#34;&#34;&#34;Return binary data to fill.&#34;&#34;&#34;
    return self._pattern</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdFill.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Calculate raw size of header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Calculate raw size of header.&#34;&#34;&#34;
    size = CmdHeader.SIZE
    size += len(self._pattern) - 4
    if size % CmdHeader.SIZE:
        size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
    return size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdFill.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Return command in binary form (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Return command in binary form (serialization).&#34;&#34;&#34;
    # export cmd
    data = super().export(dbg_info)
    # export additional data
    if len(self._pattern) &gt; 4:
        data += bytes(self._pattern[4:])
        dbg_info.append_binary_data(&#39;pattern&#39;, self._pattern[4:])
    data = SecBootBlckSize.align_block_fill_random(data)
    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdJump"><code class="flex name class">
<span>class <span class="ident">CmdJump</span></span>
<span>(</span><span>address: int = 0, argument: int = 0, spreg: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Jump class.</p>
<p>Initialize Command Jump.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdJump(CmdBaseClass):
    &#34;&#34;&#34;Command Jump class.&#34;&#34;&#34;
    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return address of the command Jump.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set address of the command Jump.&#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def argument(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
        return self._header.data

    @argument.setter
    def argument(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s argument.&#34;&#34;&#34;
        assert 0x00 &lt;= value &lt;= 0xFF
        self._header.data = value

    @property
    def spreg(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Return command&#39;s Stack Pointer.&#34;&#34;&#34;
        if self._header.flags == 1:
            return self._header.count

        return None

    @spreg.setter
    def spreg(self, value: Optional[int]) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s Stack Pointer.&#34;&#34;&#34;
        if value is None:
            self._header.flags = 0
            self._header.count = 0
        else:
            self._header.flags = 1
            self._header.count = value

    def __init__(self, address: int = 0, argument: int = 0, spreg: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize Command Jump.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.JUMP)
        self.address = address
        self.argument = argument
        self.spreg = spreg

    def __str__(self) -&gt; str:
        nfo = f&#34;JUMP: Address=0x{self.address:08X}, Argument=0x{self.argument:08X}&#34;
        if self.spreg is not None:
            nfo += f&#34;, SP=0x{self.spreg:08X}&#34;
        return nfo

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdJump&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Jump object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.JUMP
        return cls(header.address, header.data, header.count if header.flags else None)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdJump.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdJump" href="../commands.html#spsdk.sbfile.commands.CmdJump">CmdJump</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Jump object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdJump&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Jump object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.JUMP
    return cls(header.address, header.data, header.count if header.flags else None)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdJump.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return address of the command Jump.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return address of the command Jump.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdJump.argument"><code class="name">var <span class="ident">argument</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def argument(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s argument.&#34;&#34;&#34;
    return self._header.data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdJump.spreg"><code class="name">var <span class="ident">spreg</span> : Union[int, NoneType]</code></dt>
<dd>
<div class="desc"><p>Return command's Stack Pointer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spreg(self) -&gt; Optional[int]:
    &#34;&#34;&#34;Return command&#39;s Stack Pointer.&#34;&#34;&#34;
    if self._header.flags == 1:
        return self._header.count

    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdLoad"><code class="flex name class">
<span>class <span class="ident">CmdLoad</span></span>
<span>(</span><span>address: int, data: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Load. The load statement is used to store data into the memory.</p>
<p>Initialize CMD Load.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdLoad(CmdBaseClass):
    &#34;&#34;&#34;Command Load. The load statement is used to store data into the memory.&#34;&#34;&#34;

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return address in target processor to load data.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: address in target processor to load data
        &#34;&#34;&#34;
        assert 0x00000000 &lt;= value &lt;= 0xFFFFFFFF
        self._header.address = value

    @property
    def raw_size(self) -&gt; int:
        &#34;&#34;&#34;Return aligned size of the command including header and data.&#34;&#34;&#34;
        size = CmdHeader.SIZE + len(self.data)
        if size % CmdHeader.SIZE:
            size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
        return size

    def __init__(self, address: int, data: bytes) -&gt; None:
        &#34;&#34;&#34;Initialize CMD Load.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.LOAD)
        assert isinstance(data, (bytes, bytearray))
        self.address = address
        self.data = bytes(data)

    def __str__(self) -&gt; str:
        return f&#34;LOAD: Address=0x{self.address:08X}, DataLen={len(self.data)}&#34;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export command as binary.&#34;&#34;&#34;
        self._update_data()
        result = super().export(dbg_info)
        dbg_info.append_binary_section(&#39;load-data&#39;, self.data)
        return result + self.data

    def _update_data(self) -&gt; None:
        &#34;&#34;&#34;Update command data.&#34;&#34;&#34;
        # padding data
        self.data = SecBootBlckSize.align_block_fill_random(self.data)
        # update header
        self._header.count = len(self.data)
        self._header.data = Crc32Mpeg2.calc(self.data, 0xFFFFFFFF)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdLoad&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: CMD Load object
        :raise ValueError: raised when there is invalid CRC
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.LOAD
        offset += CmdHeader.SIZE
        header_count = SecBootBlckSize.align(header.count)
        cmd_data = data[offset: offset + header_count]
        if header.data != Crc32Mpeg2.calc(cmd_data, 0xFFFFFFFF):
            raise ValueError(&#39;Invalid CRC in the command header&#39;)
        obj = CmdLoad(header.address, cmd_data)
        obj.header.data = header.data
        obj.header.flags = header.flags
        obj._update_data()
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdLoad.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdLoad" href="../commands.html#spsdk.sbfile.commands.CmdLoad">CmdLoad</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: CMD Load object
:raise ValueError: raised when there is invalid CRC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdLoad&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: CMD Load object
    :raise ValueError: raised when there is invalid CRC
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.LOAD
    offset += CmdHeader.SIZE
    header_count = SecBootBlckSize.align(header.count)
    cmd_data = data[offset: offset + header_count]
    if header.data != Crc32Mpeg2.calc(cmd_data, 0xFFFFFFFF):
        raise ValueError(&#39;Invalid CRC in the command header&#39;)
    obj = CmdLoad(header.address, cmd_data)
    obj.header.data = header.data
    obj.header.flags = header.flags
    obj._update_data()
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdLoad.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return address in target processor to load data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return address in target processor to load data.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdLoad.raw_size"><code class="name">var <span class="ident">raw_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return aligned size of the command including header and data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_size(self) -&gt; int:
    &#34;&#34;&#34;Return aligned size of the command including header and data.&#34;&#34;&#34;
    size = CmdHeader.SIZE + len(self.data)
    if size % CmdHeader.SIZE:
        size += CmdHeader.SIZE - (size % CmdHeader.SIZE)
    return size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdLoad.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export command as binary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export command as binary.&#34;&#34;&#34;
    self._update_data()
    result = super().export(dbg_info)
    dbg_info.append_binary_section(&#39;load-data&#39;, self.data)
    return result + self.data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdMemEnable"><code class="flex name class">
<span>class <span class="ident">CmdMemEnable</span></span>
<span>(</span><span>address: int, size: int, mem_type: <a title="spsdk.mboot.memories.ExtMemId" href="../../mboot/memories.html#spsdk.mboot.memories.ExtMemId">ExtMemId</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to configure certain memory.</p>
<p>Initialize CmdMemEnable.</p>
<p>:param address: source address with configuration data for memory initialization
:param size: size of configuration data used for memory initialization
:param mem_type: identification of external memory type, see enum for details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdMemEnable(CmdBaseClass):
    &#34;&#34;&#34;Command to configure certain memory.&#34;&#34;&#34;
    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
        return self._header.address

    @address.setter
    def address(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s address.&#34;&#34;&#34;
        self._header.address = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return command&#39;s size.&#34;&#34;&#34;
        return self._header.count

    @size.setter
    def size(self, value: int) -&gt; None:
        &#34;&#34;&#34;Set command&#39;s size.&#34;&#34;&#34;
        self._header.count = value

    @property
    def mem_type(self) -&gt; ExtMemId:
        &#34;&#34;&#34;Return memory to be enabled.&#34;&#34;&#34;
        return ExtMemId.from_int(swap16(self._header.flags))

    @mem_type.setter
    def mem_type(self, value: ExtMemId) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: memory to be enabled
        &#34;&#34;&#34;
        self._header.flags = swap16(value)

    def __init__(self, address: int, size: int, mem_type: ExtMemId):
        &#34;&#34;&#34;Initialize CmdMemEnable.

        :param address: source address with configuration data for memory initialization
        :param size: size of configuration data used for memory initialization
        :param mem_type: identification of external memory type, see enum for details
        &#34;&#34;&#34;
        super().__init__(EnumCmdTag.MEM_ENABLE)
        self.address = address
        self.mem_type = mem_type
        self.size = size

    def __str__(self) -&gt; str:
        return f&#34;MEM-ENABLE: Address=0x{self.address:08X}, Size={self.size}, MemType=0x{self.mem_type:08X}&#34;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdMemEnable&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Command Memory Enable object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.MEM_ENABLE
        return cls(header.address, header.count, ExtMemId.from_int(swap16(header.flags)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdMemEnable.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdMemEnable" href="../commands.html#spsdk.sbfile.commands.CmdMemEnable">CmdMemEnable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Command Memory Enable object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdMemEnable&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Command Memory Enable object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.MEM_ENABLE
    return cls(header.address, header.count, ExtMemId.from_int(swap16(header.flags)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdMemEnable.address"><code class="name">var <span class="ident">address</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s address.&#34;&#34;&#34;
    return self._header.address</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdMemEnable.mem_type"><code class="name">var <span class="ident">mem_type</span> : <a title="spsdk.mboot.memories.ExtMemId" href="../../mboot/memories.html#spsdk.mboot.memories.ExtMemId">ExtMemId</a></code></dt>
<dd>
<div class="desc"><p>Return memory to be enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mem_type(self) -&gt; ExtMemId:
    &#34;&#34;&#34;Return memory to be enabled.&#34;&#34;&#34;
    return ExtMemId.from_int(swap16(self._header.flags))</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.CmdMemEnable.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return command's size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Return command&#39;s size.&#34;&#34;&#34;
    return self._header.count</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdNop"><code class="flex name class">
<span>class <span class="ident">CmdNop</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command NOP class.</p>
<p>Initialize Command Nop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdNop(CmdBaseClass):
    &#34;&#34;&#34;Command NOP class.&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Command Nop.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.NOP)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: CMD Nop object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.NOP
        return cls()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdNop.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdNop" href="../commands.html#spsdk.sbfile.commands.CmdNop">CmdNop</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: CMD Nop object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: CMD Nop object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.NOP
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdProg"><code class="flex name class">
<span>class <span class="ident">CmdProg</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command Program class.</p>
<p>Initialize Cmd Program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdProg(CmdBaseClass):
    &#34;&#34;&#34;Command Program class.&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Cmd Program.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.PROG)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdProg&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: parsed command object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.PROG
        return cls()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdProg.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdProg" href="../commands.html#spsdk.sbfile.commands.CmdProg">CmdProg</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: parsed command object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdProg&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: parsed command object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.PROG
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdReset"><code class="flex name class">
<span>class <span class="ident">CmdReset</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command Reset class.</p>
<p>Initialize Command Reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdReset(CmdBaseClass):
    &#34;&#34;&#34;Command Reset class.&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Command Reset.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.RESET)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdReset&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: Cmd Reset object
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.RESET
        return cls()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdReset.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdReset" href="../commands.html#spsdk.sbfile.commands.CmdReset">CmdReset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: Cmd Reset object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdReset&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: Cmd Reset object
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.RESET
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.CmdTag"><code class="flex name class">
<span>class <span class="ident">CmdTag</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command TAG class.</p>
<p>It is also used as header for boot section for SB file 1.x.</p>
<p>Initialize Command Tag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdTag(CmdBaseClass):
    &#34;&#34;&#34;Command TAG class.

    It is also used as header for boot section for SB file 1.x.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize Command Tag.&#34;&#34;&#34;
        super().__init__(EnumCmdTag.TAG)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdTag&#39;:
        &#34;&#34;&#34;Parse command from bytes.

        :param data: Input data as bytes
        :param offset: The offset of input data
        :return: parsed instance
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset)
        assert header.tag == EnumCmdTag.TAG
        result = cls()
        result._header = header
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></li>
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.sbfile.sb1.headers.BootSectionHeaderV1" href="headers.html#spsdk.sbfile.sb1.headers.BootSectionHeaderV1">BootSectionHeaderV1</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.CmdTag.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.commands.CmdTag" href="../commands.html#spsdk.sbfile.commands.CmdTag">CmdTag</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse command from bytes.</p>
<p>:param data: Input data as bytes
:param offset: The offset of input data
:return: parsed instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdTag&#39;:
    &#34;&#34;&#34;Parse command from bytes.

    :param data: Input data as bytes
    :param offset: The offset of input data
    :return: parsed instance
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset)
    assert header.tag == EnumCmdTag.TAG
    result = cls()
    result._header = header
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.sbfile.commands.CmdBaseClass" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass">CmdBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.export" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.header" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.header">header</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.info" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.commands.CmdBaseClass.raw_size" href="../commands.html#spsdk.sbfile.commands.CmdBaseClass.raw_size">raw_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId"><code class="flex name class">
<span>class <span class="ident">ExtMemId</span></span>
</code></dt>
<dd>
<div class="desc"><p>McuBoot External Memory Property Tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtMemId(Enum):
    &#34;&#34;&#34;McuBoot External Memory Property Tags.&#34;&#34;&#34;

    QUAD_SPI0 = (1, &#39;QSPI&#39;, &#39;Quad SPI Memory 0&#39;)
    IFR0 = (4, &#39;Nonvolatile information register 0 (only used by SB loader)&#39;)
    SEMC_NOR = (8, &#39;SEMC-NOR&#39;, &#39;SEMC NOR Memory&#39;)
    FLEX_SPI_NOR = (9, &#39;FLEX-SPI-NOR&#39;, &#39;Flex SPI NOR Memory&#39;)
    SPIFI_NOR = (10, &#39;SPIFI-NOR&#39;, &#39;SPIFI NOR Memory&#39;)
    FLASH_EXEC_ONLY = (16, &#39;FLASH-EXEC&#39;, &#39;Execute-Only region on internal Flash&#39;)
    SEMC_NAND = (256, &#39;SEMC-NAND&#39;, &#39;SEMC NAND Memory&#39;)
    SPI_NAND = (257, &#39;SPI-NAND&#39;, &#39;SPI NAND Memory&#39;)
    SPI_NOR_EEPROM = (272, &#39;SPI-MEM&#39;, &#39;SPI NOR/EEPROM Memory&#39;)
    I2C_NOR_EEPROM = (273, &#39;I2C-MEM&#39;, &#39;I2C NOR/EEPROM Memory&#39;)
    SD_CARD = (288, &#39;SD&#39;, &#39;eSD/SD/SDHC/SDXC Memory Card&#39;)
    MMC_CARD = (289, &#39;MMC&#39;, &#39;MMC/eMMC Memory Card&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.ExtMemId.FLASH_EXEC_ONLY"><code class="name">var <span class="ident">FLASH_EXEC_ONLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.FLEX_SPI_NOR"><code class="name">var <span class="ident">FLEX_SPI_NOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.I2C_NOR_EEPROM"><code class="name">var <span class="ident">I2C_NOR_EEPROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.IFR0"><code class="name">var <span class="ident">IFR0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.MMC_CARD"><code class="name">var <span class="ident">MMC_CARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.QUAD_SPI0"><code class="name">var <span class="ident">QUAD_SPI0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.SD_CARD"><code class="name">var <span class="ident">SD_CARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.SEMC_NAND"><code class="name">var <span class="ident">SEMC_NAND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.SEMC_NOR"><code class="name">var <span class="ident">SEMC_NOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.SPIFI_NOR"><code class="name">var <span class="ident">SPIFI_NOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.SPI_NAND"><code class="name">var <span class="ident">SPI_NAND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.ExtMemId.SPI_NOR_EEPROM"><code class="name">var <span class="ident">SPI_NOR_EEPROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootFlagsV1"><code class="flex name class">
<span>class <span class="ident">SecureBootFlagsV1</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flags for SectionHeader.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SecureBootFlagsV1(Enum):
    &#34;&#34;&#34;Flags for SectionHeader.&#34;&#34;&#34;
    NONE = (0, &#39;No flags&#39;)
    ROM_SECTION_BOOTABLE = (1, &#39;The section is bootable and contains a sequence of bootloader commands.&#39;)
    ROM_SECTION_CLEARTEXT = (2, &#39;The section is unencrypted. Applies only if the rest of the boot image is encrypted.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.SecureBootFlagsV1.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootFlagsV1.ROM_SECTION_BOOTABLE"><code class="name">var <span class="ident">ROM_SECTION_BOOTABLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootFlagsV1.ROM_SECTION_CLEARTEXT"><code class="name">var <span class="ident">ROM_SECTION_CLEARTEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1"><code class="flex name class">
<span>class <span class="ident">SecureBootV1</span></span>
<span>(</span><span>version: str = '1.0', flags: int = 0, drive_tag: int = 0, product_version: Union[ForwardRef('<a title="spsdk.sbfile.sb1.BcdVersion3" href="#spsdk.sbfile.sb1.BcdVersion3">BcdVersion3</a>'), str] = '999.999.999', component_version: Union[ForwardRef('<a title="spsdk.sbfile.sb1.BcdVersion3" href="#spsdk.sbfile.sb1.BcdVersion3">BcdVersion3</a>'), str] = '999.999.999', dek: Union[bytes, NoneType] = None, mac: Union[bytes, NoneType] = None, digest: bytes = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', timestamp: Union[datetime.datetime, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>SB file 1.x.</p>
<p>Initialize Secure Boot Image V1.x.</p>
<p>:param version: string in format #.#
Major version of the boot image format, currently 1. Minor version of the boot image format, currently 1 or 2.
:param flags: for the header, 0 by default: Flags associated with the entire image.
:param product_version: Product version.
:param component_version: Component version.
:param drive_tag: For header: identifier for the disk drive or partition containing this image.
:param dek: DEK key for encrypted SB file; this is not supported yet
:param mac: MAC for encrypted SB file, this is not supported yet
:param digest: SHA-1 digest of all fields of the header (it will be updated before export anyway)
The first 16 bytes (of 20 total) also act as the initialization vector for CBC-encrypted regions.
:param timestamp: datetime of the file creation, use None for current date/time
Fixed value should be used only for regression testing to generate same results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SecureBootV1(BaseClass):
    &#34;&#34;&#34;SB file 1.x.&#34;&#34;&#34;

    def __init__(self, version: str = &#39;1.0&#39;, flags: int = 0, drive_tag: int = 0,
                 product_version: BcdVersion3Format = BcdVersion3.DEFAULT,
                 component_version: BcdVersion3Format = BcdVersion3.DEFAULT,
                 dek: Optional[bytes] = None,
                 mac: Optional[bytes] = None,
                 digest: bytes = b&#39;\0&#39; * 20,
                 timestamp: Optional[datetime] = None):
        &#34;&#34;&#34;Initialize Secure Boot Image V1.x.

        :param version: string in format #.#
        Major version of the boot image format, currently 1. Minor version of the boot image format, currently 1 or 2.
        :param flags: for the header, 0 by default: Flags associated with the entire image.
        :param product_version: Product version.
        :param component_version: Component version.
        :param drive_tag: For header: identifier for the disk drive or partition containing this image.
        :param dek: DEK key for encrypted SB file; this is not supported yet
        :param mac: MAC for encrypted SB file, this is not supported yet
        :param digest: SHA-1 digest of all fields of the header (it will be updated before export anyway)
                    The first 16 bytes (of 20 total) also act as the initialization vector for CBC-encrypted regions.
        :param timestamp: datetime of the file creation, use None for current date/time
                    Fixed value should be used only for regression testing to generate same results
        &#34;&#34;&#34;
        self._dek = dek if dek else crypto_backend().random_bytes(32)
        self._mac = mac if mac else crypto_backend().random_bytes(32)
        self._header = SecureBootHeaderV1(version=version, product_version=product_version,
                                          component_version=component_version,
                                          flags=flags, drive_tag=drive_tag, digest=digest,
                                          timestamp=timestamp)
        self._sections_hdr_table: List[SectionHeaderItemV1] = list()
        self._sections: List[BootSectionV1] = []
        self._signature = None

    def __str__(self) -&gt; str:
        return self.info()

    @property
    def first_boot_section_id(self) -&gt; int:
        &#34;&#34;&#34;Return id of first boot section.&#34;&#34;&#34;
        return self._header.first_boot_section_id

    @first_boot_section_id.setter
    def first_boot_section_id(self, value: int) -&gt; None:
        assert value &lt; len(self._sections)
        self._header.first_boot_section_id = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return size of the binary representation in bytes.&#34;&#34;&#34;
        result = self._header.size
        for sect_hdr in self._sections_hdr_table:
            result += sect_hdr.size
        for sect in self._sections:
            result += sect.size
        result += 32  # authentication
        return result

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text info about the instance, multi-line string.&#34;&#34;&#34;
        result = &#34;[SB]\n&#34;
        result += &#34;[SB-header]\n&#34;
        result += self._header.info()
        result += &#34;[Sections-Header-Table]\n&#34;
        for sect_hdr in self._sections_hdr_table:
            result += &#34;[Section-Header]\n&#34;
            result += sect_hdr.info()
        result += &#34;[Sections]\n&#34;
        for sect in self._sections:
            result += &#34;[Section]\n&#34;
            result += sect.info()
        return result

    @property
    def sections(self) -&gt; Sequence[BootSectionV1]:
        &#34;&#34;&#34;Return sequence of all sections on the SB file.&#34;&#34;&#34;
        return self._sections

    def append(self, section: BootSectionV1) -&gt; None:
        &#34;&#34;&#34;Add section into the SB file.

        :param section: to be added
        &#34;&#34;&#34;
        assert isinstance(section, BootSectionV1)
        self._sections.append(section)

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validate settings.

        :raise ValueError: if the settings is not consistent
        &#34;&#34;&#34;
        if not self._sections:
            raise ValueError(&#39;At least one section must be defined&#39;)

    def update(self) -&gt; None:
        &#34;&#34;&#34;Update content.&#34;&#34;&#34;
        # update header
        self._header.section_count = len(self._sections)

        # update ROM_LAST_TAG - set only for last bootable section
        last = True
        for sect in reversed(self._sections):
            if sect.bootable:
                sect.rom_last_tag = last
                last = False

        # update section header table
        ofs_blocks = SecBootBlckSize.to_num_blocks(self._header.size + len(self._sections) * SectionHeaderItemV1.SIZE +
                                                   BootSectionHeaderV1.SIZE)
        new_hdr_table: List[SectionHeaderItemV1] = list()
        for sect in self._sections:
            sect_blcks = SecBootBlckSize.to_num_blocks(sect.size - BootSectionHeaderV1.SIZE)
            hdr = SectionHeaderItemV1(sect.section_id, ofs_blocks, sect_blcks, sect.flags)
            new_hdr_table.append(hdr)
            ofs_blocks += sect_blcks
        self._sections_hdr_table = new_hdr_table

        # update image size
        self._header.image_blocks = SecBootBlckSize.to_num_blocks(self.size)

    def export(self, header_padding8: Optional[bytes] = None, auth_padding: Optional[bytes] = None,
               dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Serialization to binary form.

        :param header_padding8: optional header padding, 8-bytes; recommended to use None to apply random value
        :param auth_padding: optional padding used after authentication; recommended to use None to apply random value
        :param dbg_info: instance allowing to debug generated output
        :return: serialize the instance into binary data
        &#34;&#34;&#34;
        self.update()
        self.validate()
        dbg_info.append_section(&#39;SB-FILE-1.x&#39;)
        data = self._header.export(padding8=header_padding8, dbg_info=dbg_info)
        # header table
        dbg_info.append_section(&#39;Sections-Header-Table&#39;)
        for sect_hdr in self._sections_hdr_table:
            sect_hdr_data = sect_hdr.export()
            dbg_info.append_binary_data(&#39;Section-Header-Item&#39;, sect_hdr_data)
            data += sect_hdr_data
        # sections
        dbg_info.append_section(&#39;Sections&#39;)
        for sect in self._sections:
            sect_data = sect.export(dbg_info)
            assert len(sect_data) == sect.size
            data += sect_data
        # authentication: SHA1
        auth_code = crypto_backend().hash(data, &#39;sha1&#39;)
        dbg_info.append_binary_section(&#39;SHA1&#39;, auth_code)
        data += auth_code
        # padding
        padding_len = align(len(auth_code), SecBootBlckSize.BLOCK_SIZE) - len(auth_code)
        if auth_padding is None:
            auth_padding = crypto_backend().random_bytes(padding_len)
        assert padding_len == len(auth_padding)
        data += auth_padding
        dbg_info.append_binary_section(&#39;padding&#39;, auth_padding)
        return data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SecureBootV1&#39;:
        &#34;&#34;&#34;Convert binary data into the instance (deserialization).

        :param data: given binary data to be converted
        :param offset: to start parsing the data
        :return: converted instance
        :raise ValueError: raised when digest does not match
        &#34;&#34;&#34;
        obj = SecureBootV1()
        cur_pos = offset
        obj._header = SecureBootHeaderV1.parse(data, cur_pos)
        cur_pos += obj._header.size
        # sections header table
        for _ in range(obj._header.section_count):
            sect_header = SectionHeaderItemV1.parse(data, cur_pos)
            obj._sections_hdr_table.append(sect_header)
            cur_pos += sect_header.size
        # sections
        new_pos = offset + obj._header.first_boot_tag_block * SecBootBlckSize.BLOCK_SIZE
        assert new_pos &gt;= cur_pos
        cur_pos = new_pos
        for _ in range(obj._header.section_count):
            boot_sect = BootSectionV1.parse(data, cur_pos)
            obj.append(boot_sect)
            cur_pos += boot_sect.size
        # authentication code
        sha1_auth = crypto_backend().hash(data[offset:cur_pos], &#39;sha1&#39;)
        if sha1_auth != data[cur_pos: cur_pos + len(sha1_auth)]:
            raise ValueError(&#39;Authentication failure: digest does not match&#39;)
        # done
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.crypto.abstract.BaseClass" href="../../utils/crypto/abstract.html#spsdk.utils.crypto.abstract.BaseClass">BaseClass</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.SecureBootV1.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.sbfile.sb1.images.SecureBootV1" href="images.html#spsdk.sbfile.sb1.images.SecureBootV1">SecureBootV1</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary data into the instance (deserialization).</p>
<p>:param data: given binary data to be converted
:param offset: to start parsing the data
:return: converted instance
:raise ValueError: raised when digest does not match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SecureBootV1&#39;:
    &#34;&#34;&#34;Convert binary data into the instance (deserialization).

    :param data: given binary data to be converted
    :param offset: to start parsing the data
    :return: converted instance
    :raise ValueError: raised when digest does not match
    &#34;&#34;&#34;
    obj = SecureBootV1()
    cur_pos = offset
    obj._header = SecureBootHeaderV1.parse(data, cur_pos)
    cur_pos += obj._header.size
    # sections header table
    for _ in range(obj._header.section_count):
        sect_header = SectionHeaderItemV1.parse(data, cur_pos)
        obj._sections_hdr_table.append(sect_header)
        cur_pos += sect_header.size
    # sections
    new_pos = offset + obj._header.first_boot_tag_block * SecBootBlckSize.BLOCK_SIZE
    assert new_pos &gt;= cur_pos
    cur_pos = new_pos
    for _ in range(obj._header.section_count):
        boot_sect = BootSectionV1.parse(data, cur_pos)
        obj.append(boot_sect)
        cur_pos += boot_sect.size
    # authentication code
    sha1_auth = crypto_backend().hash(data[offset:cur_pos], &#39;sha1&#39;)
    if sha1_auth != data[cur_pos: cur_pos + len(sha1_auth)]:
        raise ValueError(&#39;Authentication failure: digest does not match&#39;)
    # done
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.sbfile.sb1.SecureBootV1.first_boot_section_id"><code class="name">var <span class="ident">first_boot_section_id</span> : int</code></dt>
<dd>
<div class="desc"><p>Return id of first boot section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_boot_section_id(self) -&gt; int:
    &#34;&#34;&#34;Return id of first boot section.&#34;&#34;&#34;
    return self._header.first_boot_section_id</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1.sections"><code class="name">var <span class="ident">sections</span> : Sequence[<a title="spsdk.sbfile.sb1.sections.BootSectionV1" href="sections.html#spsdk.sbfile.sb1.sections.BootSectionV1">BootSectionV1</a>]</code></dt>
<dd>
<div class="desc"><p>Return sequence of all sections on the SB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sections(self) -&gt; Sequence[BootSectionV1]:
    &#34;&#34;&#34;Return sequence of all sections on the SB file.&#34;&#34;&#34;
    return self._sections</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return size of the binary representation in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Return size of the binary representation in bytes.&#34;&#34;&#34;
    result = self._header.size
    for sect_hdr in self._sections_hdr_table:
        result += sect_hdr.size
    for sect in self._sections:
        result += sect.size
    result += 32  # authentication
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.sbfile.sb1.SecureBootV1.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, section: <a title="spsdk.sbfile.sb1.sections.BootSectionV1" href="sections.html#spsdk.sbfile.sb1.sections.BootSectionV1">BootSectionV1</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add section into the SB file.</p>
<p>:param section: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, section: BootSectionV1) -&gt; None:
    &#34;&#34;&#34;Add section into the SB file.

    :param section: to be added
    &#34;&#34;&#34;
    assert isinstance(section, BootSectionV1)
    self._sections.append(section)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, header_padding8: Union[bytes, NoneType] = None, auth_padding: Union[bytes, NoneType] = None, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialization to binary form.</p>
<p>:param header_padding8: optional header padding, 8-bytes; recommended to use None to apply random value
:param auth_padding: optional padding used after authentication; recommended to use None to apply random value
:param dbg_info: instance allowing to debug generated output
:return: serialize the instance into binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, header_padding8: Optional[bytes] = None, auth_padding: Optional[bytes] = None,
           dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Serialization to binary form.

    :param header_padding8: optional header padding, 8-bytes; recommended to use None to apply random value
    :param auth_padding: optional padding used after authentication; recommended to use None to apply random value
    :param dbg_info: instance allowing to debug generated output
    :return: serialize the instance into binary data
    &#34;&#34;&#34;
    self.update()
    self.validate()
    dbg_info.append_section(&#39;SB-FILE-1.x&#39;)
    data = self._header.export(padding8=header_padding8, dbg_info=dbg_info)
    # header table
    dbg_info.append_section(&#39;Sections-Header-Table&#39;)
    for sect_hdr in self._sections_hdr_table:
        sect_hdr_data = sect_hdr.export()
        dbg_info.append_binary_data(&#39;Section-Header-Item&#39;, sect_hdr_data)
        data += sect_hdr_data
    # sections
    dbg_info.append_section(&#39;Sections&#39;)
    for sect in self._sections:
        sect_data = sect.export(dbg_info)
        assert len(sect_data) == sect.size
        data += sect_data
    # authentication: SHA1
    auth_code = crypto_backend().hash(data, &#39;sha1&#39;)
    dbg_info.append_binary_section(&#39;SHA1&#39;, auth_code)
    data += auth_code
    # padding
    padding_len = align(len(auth_code), SecBootBlckSize.BLOCK_SIZE) - len(auth_code)
    if auth_padding is None:
        auth_padding = crypto_backend().random_bytes(padding_len)
    assert padding_len == len(auth_padding)
    data += auth_padding
    dbg_info.append_binary_section(&#39;padding&#39;, auth_padding)
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text info about the instance, multi-line string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text info about the instance, multi-line string.&#34;&#34;&#34;
    result = &#34;[SB]\n&#34;
    result += &#34;[SB-header]\n&#34;
    result += self._header.info()
    result += &#34;[Sections-Header-Table]\n&#34;
    for sect_hdr in self._sections_hdr_table:
        result += &#34;[Section-Header]\n&#34;
        result += sect_hdr.info()
    result += &#34;[Sections]\n&#34;
    for sect in self._sections:
        result += &#34;[Section]\n&#34;
        result += sect.info()
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Update content.&#34;&#34;&#34;
    # update header
    self._header.section_count = len(self._sections)

    # update ROM_LAST_TAG - set only for last bootable section
    last = True
    for sect in reversed(self._sections):
        if sect.bootable:
            sect.rom_last_tag = last
            last = False

    # update section header table
    ofs_blocks = SecBootBlckSize.to_num_blocks(self._header.size + len(self._sections) * SectionHeaderItemV1.SIZE +
                                               BootSectionHeaderV1.SIZE)
    new_hdr_table: List[SectionHeaderItemV1] = list()
    for sect in self._sections:
        sect_blcks = SecBootBlckSize.to_num_blocks(sect.size - BootSectionHeaderV1.SIZE)
        hdr = SectionHeaderItemV1(sect.section_id, ofs_blocks, sect_blcks, sect.flags)
        new_hdr_table.append(hdr)
        ofs_blocks += sect_blcks
    self._sections_hdr_table = new_hdr_table

    # update image size
    self._header.image_blocks = SecBootBlckSize.to_num_blocks(self.size)</code></pre>
</details>
</dd>
<dt id="spsdk.sbfile.sb1.SecureBootV1.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validate settings.</p>
<p>:raise ValueError: if the settings is not consistent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validate settings.

    :raise ValueError: if the settings is not consistent
    &#34;&#34;&#34;
    if not self._sections:
        raise ValueError(&#39;At least one section must be defined&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.sbfile" href="../index.html">spsdk.sbfile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="spsdk.sbfile.sb1.commands" href="commands.html">spsdk.sbfile.sb1.commands</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.headers" href="headers.html">spsdk.sbfile.sb1.headers</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.images" href="images.html">spsdk.sbfile.sb1.images</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.sections" href="sections.html">spsdk.sbfile.sb1.sections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.sbfile.sb1.BcdVersion3" href="#spsdk.sbfile.sb1.BcdVersion3">BcdVersion3</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.BcdVersion3.DEFAULT" href="#spsdk.sbfile.sb1.BcdVersion3.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BcdVersion3.from_str" href="#spsdk.sbfile.sb1.BcdVersion3.from_str">from_str</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BcdVersion3.nums" href="#spsdk.sbfile.sb1.BcdVersion3.nums">nums</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BcdVersion3.to_version" href="#spsdk.sbfile.sb1.BcdVersion3.to_version">to_version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.BootSectionV1" href="#spsdk.sbfile.sb1.BootSectionV1">BootSectionV1</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.append" href="#spsdk.sbfile.sb1.BootSectionV1.append">append</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.bootable" href="#spsdk.sbfile.sb1.BootSectionV1.bootable">bootable</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.cmd_size" href="#spsdk.sbfile.sb1.BootSectionV1.cmd_size">cmd_size</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.commands" href="#spsdk.sbfile.sb1.BootSectionV1.commands">commands</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.export" href="#spsdk.sbfile.sb1.BootSectionV1.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.flags" href="#spsdk.sbfile.sb1.BootSectionV1.flags">flags</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.info" href="#spsdk.sbfile.sb1.BootSectionV1.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.parse" href="#spsdk.sbfile.sb1.BootSectionV1.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.rom_last_tag" href="#spsdk.sbfile.sb1.BootSectionV1.rom_last_tag">rom_last_tag</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.section_id" href="#spsdk.sbfile.sb1.BootSectionV1.section_id">section_id</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.size" href="#spsdk.sbfile.sb1.BootSectionV1.size">size</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.BootSectionV1.update" href="#spsdk.sbfile.sb1.BootSectionV1.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdCall" href="#spsdk.sbfile.sb1.CmdCall">CmdCall</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdCall.address" href="#spsdk.sbfile.sb1.CmdCall.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdCall.argument" href="#spsdk.sbfile.sb1.CmdCall.argument">argument</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdCall.parse" href="#spsdk.sbfile.sb1.CmdCall.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdErase" href="#spsdk.sbfile.sb1.CmdErase">CmdErase</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdErase.address" href="#spsdk.sbfile.sb1.CmdErase.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdErase.flags" href="#spsdk.sbfile.sb1.CmdErase.flags">flags</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdErase.length" href="#spsdk.sbfile.sb1.CmdErase.length">length</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdErase.parse" href="#spsdk.sbfile.sb1.CmdErase.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdFill" href="#spsdk.sbfile.sb1.CmdFill">CmdFill</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.sb1.CmdFill.PADDING_VALUE" href="#spsdk.sbfile.sb1.CmdFill.PADDING_VALUE">PADDING_VALUE</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdFill.address" href="#spsdk.sbfile.sb1.CmdFill.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdFill.export" href="#spsdk.sbfile.sb1.CmdFill.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdFill.parse" href="#spsdk.sbfile.sb1.CmdFill.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdFill.pattern" href="#spsdk.sbfile.sb1.CmdFill.pattern">pattern</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdFill.raw_size" href="#spsdk.sbfile.sb1.CmdFill.raw_size">raw_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdJump" href="#spsdk.sbfile.sb1.CmdJump">CmdJump</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdJump.address" href="#spsdk.sbfile.sb1.CmdJump.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdJump.argument" href="#spsdk.sbfile.sb1.CmdJump.argument">argument</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdJump.parse" href="#spsdk.sbfile.sb1.CmdJump.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdJump.spreg" href="#spsdk.sbfile.sb1.CmdJump.spreg">spreg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdLoad" href="#spsdk.sbfile.sb1.CmdLoad">CmdLoad</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdLoad.address" href="#spsdk.sbfile.sb1.CmdLoad.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdLoad.export" href="#spsdk.sbfile.sb1.CmdLoad.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdLoad.parse" href="#spsdk.sbfile.sb1.CmdLoad.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdLoad.raw_size" href="#spsdk.sbfile.sb1.CmdLoad.raw_size">raw_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdMemEnable" href="#spsdk.sbfile.sb1.CmdMemEnable">CmdMemEnable</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdMemEnable.address" href="#spsdk.sbfile.sb1.CmdMemEnable.address">address</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdMemEnable.mem_type" href="#spsdk.sbfile.sb1.CmdMemEnable.mem_type">mem_type</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdMemEnable.parse" href="#spsdk.sbfile.sb1.CmdMemEnable.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.CmdMemEnable.size" href="#spsdk.sbfile.sb1.CmdMemEnable.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdNop" href="#spsdk.sbfile.sb1.CmdNop">CmdNop</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdNop.parse" href="#spsdk.sbfile.sb1.CmdNop.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdProg" href="#spsdk.sbfile.sb1.CmdProg">CmdProg</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdProg.parse" href="#spsdk.sbfile.sb1.CmdProg.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdReset" href="#spsdk.sbfile.sb1.CmdReset">CmdReset</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdReset.parse" href="#spsdk.sbfile.sb1.CmdReset.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.CmdTag" href="#spsdk.sbfile.sb1.CmdTag">CmdTag</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.CmdTag.parse" href="#spsdk.sbfile.sb1.CmdTag.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.ExtMemId" href="#spsdk.sbfile.sb1.ExtMemId">ExtMemId</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.FLASH_EXEC_ONLY" href="#spsdk.sbfile.sb1.ExtMemId.FLASH_EXEC_ONLY">FLASH_EXEC_ONLY</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.FLEX_SPI_NOR" href="#spsdk.sbfile.sb1.ExtMemId.FLEX_SPI_NOR">FLEX_SPI_NOR</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.I2C_NOR_EEPROM" href="#spsdk.sbfile.sb1.ExtMemId.I2C_NOR_EEPROM">I2C_NOR_EEPROM</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.IFR0" href="#spsdk.sbfile.sb1.ExtMemId.IFR0">IFR0</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.MMC_CARD" href="#spsdk.sbfile.sb1.ExtMemId.MMC_CARD">MMC_CARD</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.QUAD_SPI0" href="#spsdk.sbfile.sb1.ExtMemId.QUAD_SPI0">QUAD_SPI0</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.SD_CARD" href="#spsdk.sbfile.sb1.ExtMemId.SD_CARD">SD_CARD</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.SEMC_NAND" href="#spsdk.sbfile.sb1.ExtMemId.SEMC_NAND">SEMC_NAND</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.SEMC_NOR" href="#spsdk.sbfile.sb1.ExtMemId.SEMC_NOR">SEMC_NOR</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.SPIFI_NOR" href="#spsdk.sbfile.sb1.ExtMemId.SPIFI_NOR">SPIFI_NOR</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.SPI_NAND" href="#spsdk.sbfile.sb1.ExtMemId.SPI_NAND">SPI_NAND</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.ExtMemId.SPI_NOR_EEPROM" href="#spsdk.sbfile.sb1.ExtMemId.SPI_NOR_EEPROM">SPI_NOR_EEPROM</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.SecureBootFlagsV1" href="#spsdk.sbfile.sb1.SecureBootFlagsV1">SecureBootFlagsV1</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.SecureBootFlagsV1.NONE" href="#spsdk.sbfile.sb1.SecureBootFlagsV1.NONE">NONE</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootFlagsV1.ROM_SECTION_BOOTABLE" href="#spsdk.sbfile.sb1.SecureBootFlagsV1.ROM_SECTION_BOOTABLE">ROM_SECTION_BOOTABLE</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootFlagsV1.ROM_SECTION_CLEARTEXT" href="#spsdk.sbfile.sb1.SecureBootFlagsV1.ROM_SECTION_CLEARTEXT">ROM_SECTION_CLEARTEXT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.sbfile.sb1.SecureBootV1" href="#spsdk.sbfile.sb1.SecureBootV1">SecureBootV1</a></code></h4>
<ul class="">
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.append" href="#spsdk.sbfile.sb1.SecureBootV1.append">append</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.export" href="#spsdk.sbfile.sb1.SecureBootV1.export">export</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.first_boot_section_id" href="#spsdk.sbfile.sb1.SecureBootV1.first_boot_section_id">first_boot_section_id</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.info" href="#spsdk.sbfile.sb1.SecureBootV1.info">info</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.parse" href="#spsdk.sbfile.sb1.SecureBootV1.parse">parse</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.sections" href="#spsdk.sbfile.sb1.SecureBootV1.sections">sections</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.size" href="#spsdk.sbfile.sb1.SecureBootV1.size">size</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.update" href="#spsdk.sbfile.sb1.SecureBootV1.update">update</a></code></li>
<li><code><a title="spsdk.sbfile.sb1.SecureBootV1.validate" href="#spsdk.sbfile.sb1.SecureBootV1.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>