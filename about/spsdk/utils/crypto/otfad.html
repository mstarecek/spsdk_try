<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.utils.crypto.otfad API documentation</title>
<meta name="description" content="The module provides support for On-The-Fly encoding for RTxxx devices." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.utils.crypto.otfad</code></h1>
</header>
<section id="section-intro">
<p>The module provides support for On-The-Fly encoding for RTxxx devices.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;The module provides support for On-The-Fly encoding for RTxxx devices.&#34;&#34;&#34;

from struct import pack
from typing import List, Optional, Union

from Crypto.Cipher import AES

from spsdk.utils.misc import align_block
from .common import Counter, crypto_backend


class KeyBlob:
    &#34;&#34;&#34;OTFAD KeyBlob: The class specifies AES key and counter initial value for specified address range.

    typedef struct KeyBlob
    {
        unsigned char key[kAesKeySizeBytes]; // 16 bytes, 128-bits, KEY[A15...A00]
        unsigned char ctr[kCtrSizeBytes];    // 8 bytes, 64-bits, CTR[C7...C0]
        unsigned int srtaddr;                // region start, STRADDR[31 - 10]
        unsigned int endaddr;                // region end, ENDADDR[31 - 10]; lowest three bits are used as flags
        // end of 32-byte area covered by CRC
        unsigned int zero_fill;      // zeros
        unsigned int key_blob_crc32; // crc32 over 1st 32-bytes
        // end of 40 byte (5*64-bit) key blob data
        unsigned char expanded_wrap_data[8]; // 8 bytes, used for wrap expanded data
        // end of 48 byte (6*64-bit) wrap data
        unsigned char unused_filler[16]; // unused fill to 64 bytes
    } keyblob_t;
    &#34;&#34;&#34;
    # Region addresses are modulo 1024
    _ADDR_MASK = 0x400 - 1

    # Key flags mask: RO, ADE, VLD
    _KEY_FLAG_MASK = 0x07
    # This field signals that the entire set of context registers (CTXn_KEY[0-3], CTXn_CTR[0-1],
    # CTXn_RGD_W[0-1] are read-only and cannot be modified. This field is sticky and remains
    # asserted until the next system reset. SR[RRAM] provides another level of register access
    # control and is independent of the RO indicator.
    KEY_FLAG_READ_ONLY = 0x4
    # AES Decryption Enable: For accesses hitting in a valid context, this bit indicates if the fetched data is to be
    # decrypted or simply bypassed.
    KEY_FLAG_ADE = 0x2
    # Valid: This field signals if the context is valid or not.
    KEY_FLAG_VLD = 0x1

    # key length in bytes
    KEY_SIZE = 16
    # counter length in bytes
    CTR_SIZE = 8
    # len of counter init value for export
    _EXPORT_CTR_IV_SIZE = 8
    # this constant seems to be fixed for SB2.1
    _EXPORT_NBLOCKS_5 = 5
    # binary export size
    _EXPORT_KEY_BLOB_SIZE = 64
    # QSPI image alignment length, 512 is supposed to be the safe alignment level for any QSPI device
    # this means that all QSPI images generated by this tool will be sizes of multiple 512
    _IMAGE_ALIGNMENT = 512

    def __init__(self, start_addr: int, end_addr: int,
                 key: Optional[bytes] = None, counter_iv: Optional[bytes] = None,
                 key_flags: int = KEY_FLAG_VLD | KEY_FLAG_ADE,
                 # for testing
                 zero_fill: Optional[bytes] = None, crc: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param start_addr: start address of the region
        :param end_addr: end address of the region
        :param key_flags: see KEY_FLAG_xxx constants; default flags: RO = 0, ADE = 1, VLD = 1
        :param key: optional AES key; None to use random value
        :param counter_iv: optional counter init value for AES; None to use random value
        :param zero_fill: optional value for zero_fill (for testing only); None to use random value (recommended)
        :param crc: optional value for unused CRC fill (for testing only); None to use random value (recommended)
        :raises ValueError: Start or end address are not aligned
        &#34;&#34;&#34;
        if key is None:
            key = crypto_backend().random_bytes(self.KEY_SIZE)
        if counter_iv is None:
            counter_iv = crypto_backend().random_bytes(self.CTR_SIZE)
        assert (len(key) == self.KEY_SIZE) and (len(counter_iv) == self.CTR_SIZE)
        assert 0 &lt;= start_addr &lt; end_addr &lt;= 0xFFFFFFFF
        assert key_flags &amp; ~self._KEY_FLAG_MASK == 0, f&#39;key_flags exceeds mask {hex(self._KEY_FLAG_MASK)}&#39;
        if (start_addr &amp; self._ADDR_MASK) != 0:
            raise ValueError(f&#39;Start address must be aligned to {hex(self._ADDR_MASK + 1)} boundary&#39;)
        if (end_addr &amp; self._ADDR_MASK) != self._ADDR_MASK:
            raise ValueError(f&#39;End address must be aligned to {hex(self._ADDR_MASK)} boundary&#39;)
        self.key = key
        self.ctr_init_vector = counter_iv
        self.start_addr = start_addr
        self.end_addr = end_addr
        self.key_flags = key_flags
        self.zero_fill = zero_fill
        self.crc_fill = crc

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += f&#34;Key:        {self.key.hex()}\n&#34;
        msg += f&#34;Counter IV: {self.ctr_init_vector.hex()}\n&#34;
        msg += f&#34;Start Addr: {hex(self.start_addr)}\n&#34;
        msg += f&#34;End Addr:   {hex(self.end_addr)}\n&#34;
        return msg

    def plain_data(self) -&gt; bytes:
        &#34;&#34;&#34;Plain data for selected key range.

        :return: key blob exported into binary form (serialization)
        &#34;&#34;&#34;
        result = bytes()
        result += self.key
        result += self.ctr_init_vector
        result += pack(&#39;&lt;I&#39;, self.start_addr)
        end_addr_with_flags = (self.end_addr &amp; ~self._KEY_FLAG_MASK) | self.key_flags
        result += pack(&#39;&lt;I&#39;, end_addr_with_flags)
        # zero fill
        if self.zero_fill:
            assert len(self.zero_fill) == 4
            result += self.zero_fill
        else:
            result += crypto_backend().random_bytes(4)
        # CRC is not used, use random value
        if self.crc_fill:
            assert len(self.crc_fill) == 4
            result += self.crc_fill
        else:
            result += crypto_backend().random_bytes(4)
        result += bytes([0] * 8)  # expanded_wrap_data
        result += bytes([0] * 16)  # unused filler
        assert len(result) == 64
        return result

    # pylint: disable=invalid-name
    def export(self, kek: Union[bytes, str], iv: bytes = bytes([0xa6] * 8)) -&gt; bytes:
        &#34;&#34;&#34;Creates key wrap for the key blob.

        :param kek: key to encode; 16 bytes long
        :param iv: counter initialization vector; 8 bytes; optional, OTFAD uses empty init value
        :return: Serialized key blob
        :raise ValueError: if any parameter is not valid
        &#34;&#34;&#34;
        if isinstance(kek, str):
            kek = bytes.fromhex(kek)
        assert len(kek) == 16
        assert len(iv) == self._EXPORT_CTR_IV_SIZE
        n = self._EXPORT_NBLOCKS_5
        plaintext = self.plain_data()  # input data to be encrypted
        assert len(plaintext) &gt;= n * 8

        # step 1: initialize the byte - sized data variables
        # set a = iv
        # for i = 1 to n
        # r[i] = plain_data[i]

        a = iv  # 64-bit integrity check register
        r = bytearray(8) + bytearray(plaintext[0: 8 * n])  # 8-bit array of 64-bit registers

        # step 2: calculate intermediate values
        # for j = 0 to 5
        #   for i = 1 to n
        #       encr = AES(K, A | R[i])
        #       a = MSB(64, encr) ^ (n*j)+i
        #       r[i] = LSB(64, B)

        for j in range(0, 6):
            for i in range(1, n + 1):
                in_data = a + r[8 * i:8 * i + 8]  # 128-bit temporary plaintext input vector
                aes = AES.new(kek, AES.MODE_ECB)
                encr = aes.encrypt(in_data)
                xor = encr[7] ^ ((n * j) + i)
                a = bytes(encr[:7]) + bytes([xor])
                r[8 * i:8 * i + 8] = encr[8:]

        # step 3: output the results
        # set result[0] = A
        # for i = 1 to n
        #   result[i] = r[i]
        result = a + r[8:8 * n + 8]

        return align_block(result, self._EXPORT_KEY_BLOB_SIZE, padding=0)  # align to 64 bytes (0 padding)

    def _get_ctr_nonce(self) -&gt; bytes:
        &#34;&#34;&#34;Get the counter initial value for image encryption.&#34;&#34;&#34;
        #  CTRn_x[127-0] = {CTR_W0_x[C0...C3],    // 32 bits of pre-programmed CTR
        #  CTR_W1_x[C4...C7],                     // another 32 bits of CTR
        #  CTR_W0_x[C0...C3] ^ CTR_W1_x[C4...C7], // exclusive-OR of CTR values
        #  systemAddress[31-4], 0000b             // 0-modulo-16 system address */

        assert len(self.ctr_init_vector) == 8

        result = bytearray(16)
        result[:4] = self.ctr_init_vector[:4]
        result[4:8] = self.ctr_init_vector[4:]
        for i in range(0, 4):
            result[8 + i] = self.ctr_init_vector[0 + i] ^ self.ctr_init_vector[4 + i]

        # result[15:12] = start_addr as a counter; nonce has these bytes zero and value passes as counter init value

        return bytes(result)

    def contains_addr(self, addr: int) -&gt; bool:
        &#34;&#34;&#34;Whether key blob contains specified address.

        :param addr: to be tested
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return self.start_addr &lt;= addr &lt;= self.end_addr

    def matches_range(self, image_start: int, image_end: int) -&gt; bool:
        &#34;&#34;&#34;Whether key blob matches address range of the image to be encrypted.

        :param image_start: start address of the image
        :param image_end: last address of the image
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return self.contains_addr(image_start) and self.contains_addr(image_end)

    def encrypt_image(self, base_address: int, data: bytes, byte_swap: bool) -&gt; bytes:
        &#34;&#34;&#34;Encrypt specified data.

        :param base_address: of the data in target memory; must be &gt;= self.start_addr
        :param data: to be encrypted (e.g. plain image); base_address + len(data) must be &lt;= self.end_addr
        :param byte_swap: this probably depends on the flash device, how bytes are organized there
                True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
        :return: encrypted data
        :raise ValueError: if start_addr or end_addr does not match with base_address (+ data length)
        &#34;&#34;&#34;
        assert base_address % 16 == 0  # Start address has to be 16 byte aligned
        data = align_block(data, self._IMAGE_ALIGNMENT)  # align data length
        data_len = len(data)

        # check start and end addresses
        if not self.matches_range(base_address, base_address + data_len - 1):
            raise ValueError(f&#39;Image address range is not within key blob: {hex(self.start_addr)}-{hex(self.end_addr)}&#39;)

        result = bytes()
        counter = Counter(self._get_ctr_nonce(), ctr_value=base_address, ctr_byteorder_encoding=&#39;big&#39;)

        for index in range(0, data_len, 16):
            # prepare data in byte order
            if byte_swap:
                # swap 8 bytes + swap 8 bytes
                data_2_encr = data[-data_len + index + 7: -data_len + index - 1: -1] + \
                              data[-data_len + index + 15: -data_len + index + 7: -1]
            else:
                data_2_encr = data[index: index + 16]
            # encrypt
            encr_data = crypto_backend().aes_ctr_encrypt(self.key, data_2_encr, counter.value)
            # fix byte order in result
            if byte_swap:
                result += encr_data[-9: -17: -1] + encr_data[-1: -9: -1]  # swap 8 bytes + swap 8 bytes
            else:
                result += encr_data
            # update counter for encryption
            counter.increment(16)

        assert len(result) == data_len
        return bytes(result)


class Otfad:
    &#34;&#34;&#34;OTFAD: On-the-Fly AES Decryption Module.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
        self._key_blobs: List[KeyBlob] = list()

    def __getitem__(self, index: int) -&gt; KeyBlob:
        return self._key_blobs[index]

    def add_key_blob(self, key_blob: KeyBlob) -&gt; None:
        &#34;&#34;&#34;Add key for specified address range.

        :param key_blob: to be added
        &#34;&#34;&#34;
        self._key_blobs.append(key_blob)

    def encrypt_image(self, image: bytes, base_addr: int, byte_swap: bool) -&gt; bytes:
        &#34;&#34;&#34;Encrypt image.

        :param image: plain image to be encrypted
        :param base_addr: where the image will be located in target processor
        :param byte_swap: this probably depends on the flash device, how bytes are organized there
                True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
        :return: encrypted image
        :raise ValueError: if address range does not match to any key blob
        &#34;&#34;&#34;
        image_end = base_addr + len(image) - 1
        for key_blob in self._key_blobs:
            if key_blob.matches_range(base_addr, image_end):
                return key_blob.encrypt_image(base_addr, image, byte_swap)

        raise ValueError(&#39;The image address range does not match to key blob&#39;)

    def encrypt_key_blobs(self, kek: Union[bytes, str]) -&gt; bytes:
        &#34;&#34;&#34;Encrypt key blobs with specified key.

        :param kek: key to encode key blobs
        :return: encrypted binary key blobs joined together
        &#34;&#34;&#34;
        result = bytes()
        for key_blob in self._key_blobs:
            result += key_blob.export(kek)
        return align_block(result, 256)  # this is for compatibility with elftosb, probably need FLASH sector size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        msg = &#34;Key-Blob\n&#34;
        for index, key_blob in enumerate(self._key_blobs):
            msg += f&#34;Key-Blob {str(index)}:\n&#34;
            msg += key_blob.info()
        return msg</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.utils.crypto.otfad.KeyBlob"><code class="flex name class">
<span>class <span class="ident">KeyBlob</span></span>
<span>(</span><span>start_addr: int, end_addr: int, key: Union[bytes, NoneType] = None, counter_iv: Union[bytes, NoneType] = None, key_flags: int = 3, zero_fill: Union[bytes, NoneType] = None, crc: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>OTFAD KeyBlob: The class specifies AES key and counter initial value for specified address range.</p>
<p>typedef struct KeyBlob
{
unsigned char key[kAesKeySizeBytes]; // 16 bytes, 128-bits, KEY[A15&hellip;A00]
unsigned char ctr[kCtrSizeBytes];
// 8 bytes, 64-bits, CTR[C7&hellip;C0]
unsigned int srtaddr;
// region start, STRADDR[31 - 10]
unsigned int endaddr;
// region end, ENDADDR[31 - 10]; lowest three bits are used as flags
// end of 32-byte area covered by CRC
unsigned int zero_fill;
// zeros
unsigned int key_blob_crc32; // crc32 over 1st 32-bytes
// end of 40 byte (5<em>64-bit) key blob data
unsigned char expanded_wrap_data[8]; // 8 bytes, used for wrap expanded data
// end of 48 byte (6</em>64-bit) wrap data
unsigned char unused_filler[16]; // unused fill to 64 bytes
} keyblob_t;</p>
<p>Constructor.</p>
<p>:param start_addr: start address of the region
:param end_addr: end address of the region
:param key_flags: see KEY_FLAG_xxx constants; default flags: RO = 0, ADE = 1, VLD = 1
:param key: optional AES key; None to use random value
:param counter_iv: optional counter init value for AES; None to use random value
:param zero_fill: optional value for zero_fill (for testing only); None to use random value (recommended)
:param crc: optional value for unused CRC fill (for testing only); None to use random value (recommended)
:raises ValueError: Start or end address are not aligned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyBlob:
    &#34;&#34;&#34;OTFAD KeyBlob: The class specifies AES key and counter initial value for specified address range.

    typedef struct KeyBlob
    {
        unsigned char key[kAesKeySizeBytes]; // 16 bytes, 128-bits, KEY[A15...A00]
        unsigned char ctr[kCtrSizeBytes];    // 8 bytes, 64-bits, CTR[C7...C0]
        unsigned int srtaddr;                // region start, STRADDR[31 - 10]
        unsigned int endaddr;                // region end, ENDADDR[31 - 10]; lowest three bits are used as flags
        // end of 32-byte area covered by CRC
        unsigned int zero_fill;      // zeros
        unsigned int key_blob_crc32; // crc32 over 1st 32-bytes
        // end of 40 byte (5*64-bit) key blob data
        unsigned char expanded_wrap_data[8]; // 8 bytes, used for wrap expanded data
        // end of 48 byte (6*64-bit) wrap data
        unsigned char unused_filler[16]; // unused fill to 64 bytes
    } keyblob_t;
    &#34;&#34;&#34;
    # Region addresses are modulo 1024
    _ADDR_MASK = 0x400 - 1

    # Key flags mask: RO, ADE, VLD
    _KEY_FLAG_MASK = 0x07
    # This field signals that the entire set of context registers (CTXn_KEY[0-3], CTXn_CTR[0-1],
    # CTXn_RGD_W[0-1] are read-only and cannot be modified. This field is sticky and remains
    # asserted until the next system reset. SR[RRAM] provides another level of register access
    # control and is independent of the RO indicator.
    KEY_FLAG_READ_ONLY = 0x4
    # AES Decryption Enable: For accesses hitting in a valid context, this bit indicates if the fetched data is to be
    # decrypted or simply bypassed.
    KEY_FLAG_ADE = 0x2
    # Valid: This field signals if the context is valid or not.
    KEY_FLAG_VLD = 0x1

    # key length in bytes
    KEY_SIZE = 16
    # counter length in bytes
    CTR_SIZE = 8
    # len of counter init value for export
    _EXPORT_CTR_IV_SIZE = 8
    # this constant seems to be fixed for SB2.1
    _EXPORT_NBLOCKS_5 = 5
    # binary export size
    _EXPORT_KEY_BLOB_SIZE = 64
    # QSPI image alignment length, 512 is supposed to be the safe alignment level for any QSPI device
    # this means that all QSPI images generated by this tool will be sizes of multiple 512
    _IMAGE_ALIGNMENT = 512

    def __init__(self, start_addr: int, end_addr: int,
                 key: Optional[bytes] = None, counter_iv: Optional[bytes] = None,
                 key_flags: int = KEY_FLAG_VLD | KEY_FLAG_ADE,
                 # for testing
                 zero_fill: Optional[bytes] = None, crc: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param start_addr: start address of the region
        :param end_addr: end address of the region
        :param key_flags: see KEY_FLAG_xxx constants; default flags: RO = 0, ADE = 1, VLD = 1
        :param key: optional AES key; None to use random value
        :param counter_iv: optional counter init value for AES; None to use random value
        :param zero_fill: optional value for zero_fill (for testing only); None to use random value (recommended)
        :param crc: optional value for unused CRC fill (for testing only); None to use random value (recommended)
        :raises ValueError: Start or end address are not aligned
        &#34;&#34;&#34;
        if key is None:
            key = crypto_backend().random_bytes(self.KEY_SIZE)
        if counter_iv is None:
            counter_iv = crypto_backend().random_bytes(self.CTR_SIZE)
        assert (len(key) == self.KEY_SIZE) and (len(counter_iv) == self.CTR_SIZE)
        assert 0 &lt;= start_addr &lt; end_addr &lt;= 0xFFFFFFFF
        assert key_flags &amp; ~self._KEY_FLAG_MASK == 0, f&#39;key_flags exceeds mask {hex(self._KEY_FLAG_MASK)}&#39;
        if (start_addr &amp; self._ADDR_MASK) != 0:
            raise ValueError(f&#39;Start address must be aligned to {hex(self._ADDR_MASK + 1)} boundary&#39;)
        if (end_addr &amp; self._ADDR_MASK) != self._ADDR_MASK:
            raise ValueError(f&#39;End address must be aligned to {hex(self._ADDR_MASK)} boundary&#39;)
        self.key = key
        self.ctr_init_vector = counter_iv
        self.start_addr = start_addr
        self.end_addr = end_addr
        self.key_flags = key_flags
        self.zero_fill = zero_fill
        self.crc_fill = crc

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += f&#34;Key:        {self.key.hex()}\n&#34;
        msg += f&#34;Counter IV: {self.ctr_init_vector.hex()}\n&#34;
        msg += f&#34;Start Addr: {hex(self.start_addr)}\n&#34;
        msg += f&#34;End Addr:   {hex(self.end_addr)}\n&#34;
        return msg

    def plain_data(self) -&gt; bytes:
        &#34;&#34;&#34;Plain data for selected key range.

        :return: key blob exported into binary form (serialization)
        &#34;&#34;&#34;
        result = bytes()
        result += self.key
        result += self.ctr_init_vector
        result += pack(&#39;&lt;I&#39;, self.start_addr)
        end_addr_with_flags = (self.end_addr &amp; ~self._KEY_FLAG_MASK) | self.key_flags
        result += pack(&#39;&lt;I&#39;, end_addr_with_flags)
        # zero fill
        if self.zero_fill:
            assert len(self.zero_fill) == 4
            result += self.zero_fill
        else:
            result += crypto_backend().random_bytes(4)
        # CRC is not used, use random value
        if self.crc_fill:
            assert len(self.crc_fill) == 4
            result += self.crc_fill
        else:
            result += crypto_backend().random_bytes(4)
        result += bytes([0] * 8)  # expanded_wrap_data
        result += bytes([0] * 16)  # unused filler
        assert len(result) == 64
        return result

    # pylint: disable=invalid-name
    def export(self, kek: Union[bytes, str], iv: bytes = bytes([0xa6] * 8)) -&gt; bytes:
        &#34;&#34;&#34;Creates key wrap for the key blob.

        :param kek: key to encode; 16 bytes long
        :param iv: counter initialization vector; 8 bytes; optional, OTFAD uses empty init value
        :return: Serialized key blob
        :raise ValueError: if any parameter is not valid
        &#34;&#34;&#34;
        if isinstance(kek, str):
            kek = bytes.fromhex(kek)
        assert len(kek) == 16
        assert len(iv) == self._EXPORT_CTR_IV_SIZE
        n = self._EXPORT_NBLOCKS_5
        plaintext = self.plain_data()  # input data to be encrypted
        assert len(plaintext) &gt;= n * 8

        # step 1: initialize the byte - sized data variables
        # set a = iv
        # for i = 1 to n
        # r[i] = plain_data[i]

        a = iv  # 64-bit integrity check register
        r = bytearray(8) + bytearray(plaintext[0: 8 * n])  # 8-bit array of 64-bit registers

        # step 2: calculate intermediate values
        # for j = 0 to 5
        #   for i = 1 to n
        #       encr = AES(K, A | R[i])
        #       a = MSB(64, encr) ^ (n*j)+i
        #       r[i] = LSB(64, B)

        for j in range(0, 6):
            for i in range(1, n + 1):
                in_data = a + r[8 * i:8 * i + 8]  # 128-bit temporary plaintext input vector
                aes = AES.new(kek, AES.MODE_ECB)
                encr = aes.encrypt(in_data)
                xor = encr[7] ^ ((n * j) + i)
                a = bytes(encr[:7]) + bytes([xor])
                r[8 * i:8 * i + 8] = encr[8:]

        # step 3: output the results
        # set result[0] = A
        # for i = 1 to n
        #   result[i] = r[i]
        result = a + r[8:8 * n + 8]

        return align_block(result, self._EXPORT_KEY_BLOB_SIZE, padding=0)  # align to 64 bytes (0 padding)

    def _get_ctr_nonce(self) -&gt; bytes:
        &#34;&#34;&#34;Get the counter initial value for image encryption.&#34;&#34;&#34;
        #  CTRn_x[127-0] = {CTR_W0_x[C0...C3],    // 32 bits of pre-programmed CTR
        #  CTR_W1_x[C4...C7],                     // another 32 bits of CTR
        #  CTR_W0_x[C0...C3] ^ CTR_W1_x[C4...C7], // exclusive-OR of CTR values
        #  systemAddress[31-4], 0000b             // 0-modulo-16 system address */

        assert len(self.ctr_init_vector) == 8

        result = bytearray(16)
        result[:4] = self.ctr_init_vector[:4]
        result[4:8] = self.ctr_init_vector[4:]
        for i in range(0, 4):
            result[8 + i] = self.ctr_init_vector[0 + i] ^ self.ctr_init_vector[4 + i]

        # result[15:12] = start_addr as a counter; nonce has these bytes zero and value passes as counter init value

        return bytes(result)

    def contains_addr(self, addr: int) -&gt; bool:
        &#34;&#34;&#34;Whether key blob contains specified address.

        :param addr: to be tested
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return self.start_addr &lt;= addr &lt;= self.end_addr

    def matches_range(self, image_start: int, image_end: int) -&gt; bool:
        &#34;&#34;&#34;Whether key blob matches address range of the image to be encrypted.

        :param image_start: start address of the image
        :param image_end: last address of the image
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return self.contains_addr(image_start) and self.contains_addr(image_end)

    def encrypt_image(self, base_address: int, data: bytes, byte_swap: bool) -&gt; bytes:
        &#34;&#34;&#34;Encrypt specified data.

        :param base_address: of the data in target memory; must be &gt;= self.start_addr
        :param data: to be encrypted (e.g. plain image); base_address + len(data) must be &lt;= self.end_addr
        :param byte_swap: this probably depends on the flash device, how bytes are organized there
                True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
        :return: encrypted data
        :raise ValueError: if start_addr or end_addr does not match with base_address (+ data length)
        &#34;&#34;&#34;
        assert base_address % 16 == 0  # Start address has to be 16 byte aligned
        data = align_block(data, self._IMAGE_ALIGNMENT)  # align data length
        data_len = len(data)

        # check start and end addresses
        if not self.matches_range(base_address, base_address + data_len - 1):
            raise ValueError(f&#39;Image address range is not within key blob: {hex(self.start_addr)}-{hex(self.end_addr)}&#39;)

        result = bytes()
        counter = Counter(self._get_ctr_nonce(), ctr_value=base_address, ctr_byteorder_encoding=&#39;big&#39;)

        for index in range(0, data_len, 16):
            # prepare data in byte order
            if byte_swap:
                # swap 8 bytes + swap 8 bytes
                data_2_encr = data[-data_len + index + 7: -data_len + index - 1: -1] + \
                              data[-data_len + index + 15: -data_len + index + 7: -1]
            else:
                data_2_encr = data[index: index + 16]
            # encrypt
            encr_data = crypto_backend().aes_ctr_encrypt(self.key, data_2_encr, counter.value)
            # fix byte order in result
            if byte_swap:
                result += encr_data[-9: -17: -1] + encr_data[-1: -9: -1]  # swap 8 bytes + swap 8 bytes
            else:
                result += encr_data
            # update counter for encryption
            counter.increment(16)

        assert len(result) == data_len
        return bytes(result)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.CTR_SIZE"><code class="name">var <span class="ident">CTR_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_ADE"><code class="name">var <span class="ident">KEY_FLAG_ADE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_READ_ONLY"><code class="name">var <span class="ident">KEY_FLAG_READ_ONLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_VLD"><code class="name">var <span class="ident">KEY_FLAG_VLD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.KEY_SIZE"><code class="name">var <span class="ident">KEY_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.contains_addr"><code class="name flex">
<span>def <span class="ident">contains_addr</span></span>(<span>self, addr: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Whether key blob contains specified address.</p>
<p>:param addr: to be tested
:return: True if yes, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_addr(self, addr: int) -&gt; bool:
    &#34;&#34;&#34;Whether key blob contains specified address.

    :param addr: to be tested
    :return: True if yes, False otherwise
    &#34;&#34;&#34;
    return self.start_addr &lt;= addr &lt;= self.end_addr</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.encrypt_image"><code class="name flex">
<span>def <span class="ident">encrypt_image</span></span>(<span>self, base_address: int, data: bytes, byte_swap: bool) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt specified data.</p>
<p>:param base_address: of the data in target memory; must be &gt;= self.start_addr
:param data: to be encrypted (e.g. plain image); base_address + len(data) must be &lt;= self.end_addr
:param byte_swap: this probably depends on the flash device, how bytes are organized there
True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
:return: encrypted data
:raise ValueError: if start_addr or end_addr does not match with base_address (+ data length)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_image(self, base_address: int, data: bytes, byte_swap: bool) -&gt; bytes:
    &#34;&#34;&#34;Encrypt specified data.

    :param base_address: of the data in target memory; must be &gt;= self.start_addr
    :param data: to be encrypted (e.g. plain image); base_address + len(data) must be &lt;= self.end_addr
    :param byte_swap: this probably depends on the flash device, how bytes are organized there
            True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
    :return: encrypted data
    :raise ValueError: if start_addr or end_addr does not match with base_address (+ data length)
    &#34;&#34;&#34;
    assert base_address % 16 == 0  # Start address has to be 16 byte aligned
    data = align_block(data, self._IMAGE_ALIGNMENT)  # align data length
    data_len = len(data)

    # check start and end addresses
    if not self.matches_range(base_address, base_address + data_len - 1):
        raise ValueError(f&#39;Image address range is not within key blob: {hex(self.start_addr)}-{hex(self.end_addr)}&#39;)

    result = bytes()
    counter = Counter(self._get_ctr_nonce(), ctr_value=base_address, ctr_byteorder_encoding=&#39;big&#39;)

    for index in range(0, data_len, 16):
        # prepare data in byte order
        if byte_swap:
            # swap 8 bytes + swap 8 bytes
            data_2_encr = data[-data_len + index + 7: -data_len + index - 1: -1] + \
                          data[-data_len + index + 15: -data_len + index + 7: -1]
        else:
            data_2_encr = data[index: index + 16]
        # encrypt
        encr_data = crypto_backend().aes_ctr_encrypt(self.key, data_2_encr, counter.value)
        # fix byte order in result
        if byte_swap:
            result += encr_data[-9: -17: -1] + encr_data[-1: -9: -1]  # swap 8 bytes + swap 8 bytes
        else:
            result += encr_data
        # update counter for encryption
        counter.increment(16)

    assert len(result) == data_len
    return bytes(result)</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, kek: Union[bytes, str], iv: bytes = b'\xa6\xa6\xa6\xa6\xa6\xa6\xa6\xa6') ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Creates key wrap for the key blob.</p>
<p>:param kek: key to encode; 16 bytes long
:param iv: counter initialization vector; 8 bytes; optional, OTFAD uses empty init value
:return: Serialized key blob
:raise ValueError: if any parameter is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, kek: Union[bytes, str], iv: bytes = bytes([0xa6] * 8)) -&gt; bytes:
    &#34;&#34;&#34;Creates key wrap for the key blob.

    :param kek: key to encode; 16 bytes long
    :param iv: counter initialization vector; 8 bytes; optional, OTFAD uses empty init value
    :return: Serialized key blob
    :raise ValueError: if any parameter is not valid
    &#34;&#34;&#34;
    if isinstance(kek, str):
        kek = bytes.fromhex(kek)
    assert len(kek) == 16
    assert len(iv) == self._EXPORT_CTR_IV_SIZE
    n = self._EXPORT_NBLOCKS_5
    plaintext = self.plain_data()  # input data to be encrypted
    assert len(plaintext) &gt;= n * 8

    # step 1: initialize the byte - sized data variables
    # set a = iv
    # for i = 1 to n
    # r[i] = plain_data[i]

    a = iv  # 64-bit integrity check register
    r = bytearray(8) + bytearray(plaintext[0: 8 * n])  # 8-bit array of 64-bit registers

    # step 2: calculate intermediate values
    # for j = 0 to 5
    #   for i = 1 to n
    #       encr = AES(K, A | R[i])
    #       a = MSB(64, encr) ^ (n*j)+i
    #       r[i] = LSB(64, B)

    for j in range(0, 6):
        for i in range(1, n + 1):
            in_data = a + r[8 * i:8 * i + 8]  # 128-bit temporary plaintext input vector
            aes = AES.new(kek, AES.MODE_ECB)
            encr = aes.encrypt(in_data)
            xor = encr[7] ^ ((n * j) + i)
            a = bytes(encr[:7]) + bytes([xor])
            r[8 * i:8 * i + 8] = encr[8:]

    # step 3: output the results
    # set result[0] = A
    # for i = 1 to n
    #   result[i] = r[i]
    result = a + r[8:8 * n + 8]

    return align_block(result, self._EXPORT_KEY_BLOB_SIZE, padding=0)  # align to 64 bytes (0 padding)</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text info about the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += f&#34;Key:        {self.key.hex()}\n&#34;
    msg += f&#34;Counter IV: {self.ctr_init_vector.hex()}\n&#34;
    msg += f&#34;Start Addr: {hex(self.start_addr)}\n&#34;
    msg += f&#34;End Addr:   {hex(self.end_addr)}\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.matches_range"><code class="name flex">
<span>def <span class="ident">matches_range</span></span>(<span>self, image_start: int, image_end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Whether key blob matches address range of the image to be encrypted.</p>
<p>:param image_start: start address of the image
:param image_end: last address of the image
:return: True if yes, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches_range(self, image_start: int, image_end: int) -&gt; bool:
    &#34;&#34;&#34;Whether key blob matches address range of the image to be encrypted.

    :param image_start: start address of the image
    :param image_end: last address of the image
    :return: True if yes, False otherwise
    &#34;&#34;&#34;
    return self.contains_addr(image_start) and self.contains_addr(image_end)</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.KeyBlob.plain_data"><code class="name flex">
<span>def <span class="ident">plain_data</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Plain data for selected key range.</p>
<p>:return: key blob exported into binary form (serialization)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plain_data(self) -&gt; bytes:
    &#34;&#34;&#34;Plain data for selected key range.

    :return: key blob exported into binary form (serialization)
    &#34;&#34;&#34;
    result = bytes()
    result += self.key
    result += self.ctr_init_vector
    result += pack(&#39;&lt;I&#39;, self.start_addr)
    end_addr_with_flags = (self.end_addr &amp; ~self._KEY_FLAG_MASK) | self.key_flags
    result += pack(&#39;&lt;I&#39;, end_addr_with_flags)
    # zero fill
    if self.zero_fill:
        assert len(self.zero_fill) == 4
        result += self.zero_fill
    else:
        result += crypto_backend().random_bytes(4)
    # CRC is not used, use random value
    if self.crc_fill:
        assert len(self.crc_fill) == 4
        result += self.crc_fill
    else:
        result += crypto_backend().random_bytes(4)
    result += bytes([0] * 8)  # expanded_wrap_data
    result += bytes([0] * 16)  # unused filler
    assert len(result) == 64
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.utils.crypto.otfad.Otfad"><code class="flex name class">
<span>class <span class="ident">Otfad</span></span>
</code></dt>
<dd>
<div class="desc"><p>OTFAD: On-the-Fly AES Decryption Module.</p>
<p>Constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Otfad:
    &#34;&#34;&#34;OTFAD: On-the-Fly AES Decryption Module.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
        self._key_blobs: List[KeyBlob] = list()

    def __getitem__(self, index: int) -&gt; KeyBlob:
        return self._key_blobs[index]

    def add_key_blob(self, key_blob: KeyBlob) -&gt; None:
        &#34;&#34;&#34;Add key for specified address range.

        :param key_blob: to be added
        &#34;&#34;&#34;
        self._key_blobs.append(key_blob)

    def encrypt_image(self, image: bytes, base_addr: int, byte_swap: bool) -&gt; bytes:
        &#34;&#34;&#34;Encrypt image.

        :param image: plain image to be encrypted
        :param base_addr: where the image will be located in target processor
        :param byte_swap: this probably depends on the flash device, how bytes are organized there
                True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
        :return: encrypted image
        :raise ValueError: if address range does not match to any key blob
        &#34;&#34;&#34;
        image_end = base_addr + len(image) - 1
        for key_blob in self._key_blobs:
            if key_blob.matches_range(base_addr, image_end):
                return key_blob.encrypt_image(base_addr, image, byte_swap)

        raise ValueError(&#39;The image address range does not match to key blob&#39;)

    def encrypt_key_blobs(self, kek: Union[bytes, str]) -&gt; bytes:
        &#34;&#34;&#34;Encrypt key blobs with specified key.

        :param kek: key to encode key blobs
        :return: encrypted binary key blobs joined together
        &#34;&#34;&#34;
        result = bytes()
        for key_blob in self._key_blobs:
            result += key_blob.export(kek)
        return align_block(result, 256)  # this is for compatibility with elftosb, probably need FLASH sector size

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        msg = &#34;Key-Blob\n&#34;
        for index, key_blob in enumerate(self._key_blobs):
            msg += f&#34;Key-Blob {str(index)}:\n&#34;
            msg += key_blob.info()
        return msg</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spsdk.utils.crypto.otfad.Otfad.add_key_blob"><code class="name flex">
<span>def <span class="ident">add_key_blob</span></span>(<span>self, key_blob: <a title="spsdk.utils.crypto.otfad.KeyBlob" href="#spsdk.utils.crypto.otfad.KeyBlob">KeyBlob</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add key for specified address range.</p>
<p>:param key_blob: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_key_blob(self, key_blob: KeyBlob) -&gt; None:
    &#34;&#34;&#34;Add key for specified address range.

    :param key_blob: to be added
    &#34;&#34;&#34;
    self._key_blobs.append(key_blob)</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.Otfad.encrypt_image"><code class="name flex">
<span>def <span class="ident">encrypt_image</span></span>(<span>self, image: bytes, base_addr: int, byte_swap: bool) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt image.</p>
<p>:param image: plain image to be encrypted
:param base_addr: where the image will be located in target processor
:param byte_swap: this probably depends on the flash device, how bytes are organized there
True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
:return: encrypted image
:raise ValueError: if address range does not match to any key blob</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_image(self, image: bytes, base_addr: int, byte_swap: bool) -&gt; bytes:
    &#34;&#34;&#34;Encrypt image.

    :param image: plain image to be encrypted
    :param base_addr: where the image will be located in target processor
    :param byte_swap: this probably depends on the flash device, how bytes are organized there
            True should be used for FLASH on EVK RT6xx; False for FLASH on EVK RT5xx
    :return: encrypted image
    :raise ValueError: if address range does not match to any key blob
    &#34;&#34;&#34;
    image_end = base_addr + len(image) - 1
    for key_blob in self._key_blobs:
        if key_blob.matches_range(base_addr, image_end):
            return key_blob.encrypt_image(base_addr, image, byte_swap)

    raise ValueError(&#39;The image address range does not match to key blob&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.Otfad.encrypt_key_blobs"><code class="name flex">
<span>def <span class="ident">encrypt_key_blobs</span></span>(<span>self, kek: Union[bytes, str]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt key blobs with specified key.</p>
<p>:param kek: key to encode key blobs
:return: encrypted binary key blobs joined together</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_key_blobs(self, kek: Union[bytes, str]) -&gt; bytes:
    &#34;&#34;&#34;Encrypt key blobs with specified key.

    :param kek: key to encode key blobs
    :return: encrypted binary key blobs joined together
    &#34;&#34;&#34;
    result = bytes()
    for key_blob in self._key_blobs:
        result += key_blob.export(kek)
    return align_block(result, 256)  # this is for compatibility with elftosb, probably need FLASH sector size</code></pre>
</details>
</dd>
<dt id="spsdk.utils.crypto.otfad.Otfad.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text info about the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
    msg = &#34;Key-Blob\n&#34;
    for index, key_blob in enumerate(self._key_blobs):
        msg += f&#34;Key-Blob {str(index)}:\n&#34;
        msg += key_blob.info()
    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.utils.crypto" href="index.html">spsdk.utils.crypto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.utils.crypto.otfad.KeyBlob" href="#spsdk.utils.crypto.otfad.KeyBlob">KeyBlob</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.CTR_SIZE" href="#spsdk.utils.crypto.otfad.KeyBlob.CTR_SIZE">CTR_SIZE</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_ADE" href="#spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_ADE">KEY_FLAG_ADE</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_READ_ONLY" href="#spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_READ_ONLY">KEY_FLAG_READ_ONLY</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_VLD" href="#spsdk.utils.crypto.otfad.KeyBlob.KEY_FLAG_VLD">KEY_FLAG_VLD</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.KEY_SIZE" href="#spsdk.utils.crypto.otfad.KeyBlob.KEY_SIZE">KEY_SIZE</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.contains_addr" href="#spsdk.utils.crypto.otfad.KeyBlob.contains_addr">contains_addr</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.encrypt_image" href="#spsdk.utils.crypto.otfad.KeyBlob.encrypt_image">encrypt_image</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.export" href="#spsdk.utils.crypto.otfad.KeyBlob.export">export</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.info" href="#spsdk.utils.crypto.otfad.KeyBlob.info">info</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.matches_range" href="#spsdk.utils.crypto.otfad.KeyBlob.matches_range">matches_range</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.KeyBlob.plain_data" href="#spsdk.utils.crypto.otfad.KeyBlob.plain_data">plain_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.utils.crypto.otfad.Otfad" href="#spsdk.utils.crypto.otfad.Otfad">Otfad</a></code></h4>
<ul class="">
<li><code><a title="spsdk.utils.crypto.otfad.Otfad.add_key_blob" href="#spsdk.utils.crypto.otfad.Otfad.add_key_blob">add_key_blob</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.Otfad.encrypt_image" href="#spsdk.utils.crypto.otfad.Otfad.encrypt_image">encrypt_image</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.Otfad.encrypt_key_blobs" href="#spsdk.utils.crypto.otfad.Otfad.encrypt_key_blobs">encrypt_key_blobs</a></code></li>
<li><code><a title="spsdk.utils.crypto.otfad.Otfad.info" href="#spsdk.utils.crypto.otfad.Otfad.info">info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>