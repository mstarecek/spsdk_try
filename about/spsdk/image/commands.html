<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.image.commands API documentation</title>
<meta name="description" content="Commands for image module." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.image.commands</code></h1>
</header>
<section id="section-intro">
<p>Commands for image module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2017-2018 Martin Olejar
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Commands for image module.&#34;&#34;&#34;

from abc import ABC
from datetime import datetime
from struct import pack, unpack_from
from typing import Iterable, List, Optional, Tuple, Union, Any, Iterator, Mapping, Type

from asn1crypto import cms, util, x509

from spsdk.crypto import Certificate, Encoding
from spsdk.utils.crypto import matches_key_and_cert, crypto_backend
from spsdk.utils.easy_enum import Enum
from spsdk.utils.misc import DebugInfo
from .header import CmdTag, CmdHeader
from .secret import BaseClass, CertificateImg, EnumAlgorithm, MAC, Signature, SrkTable


########################################################################################################################
# Enums
########################################################################################################################

class EnumWriteOps(Enum):
    &#34;&#34;&#34;Enum definition for &#39;flags&#39; control flags in &#39;par&#39; parameter of Write Data command.&#34;&#34;&#34;
    WRITE_VALUE = (0, &#39;Write value&#39;)
    WRITE_CLEAR_BITS = (1, &#39;Write clear bits&#39;)
    CLEAR_BITMASK = (2, &#39;Clear bitmask&#39;)
    SET_BITMASK = (3, &#39;Set bitmask&#39;)


class EnumCheckOps(Enum):
    &#34;&#34;&#34;Enum definition for &#39;par&#39; parameter of Check Data command.&#34;&#34;&#34;
    ALL_CLEAR = (0, &#39;All bits clear&#39;)
    ALL_SET = (1, &#39;All bits set&#39;)
    ANY_CLEAR = (2, &#39;Any bit clear&#39;)
    ANY_SET = (3, &#39;Any bit set&#39;)


class EnumCertFormat(Enum):
    &#34;&#34;&#34;Certificate format tags.&#34;&#34;&#34;
    SRK = (0x03, &#39;SRK certificate format&#39;)
    X509 = (0x09, &#39;X.509v3 certificate format&#39;)
    CMS = (0xC5, &#39;CMS/PKCS#7 signature format&#39;)
    BLOB = (0xBB, &#39;SHW-specific wrapped key format&#39;)
    AEAD = (0xA3, &#39;Proprietary AEAD MAC format&#39;)


class EnumInsKey(Enum):
    &#34;&#34;&#34;Flags for Install Key commands.&#34;&#34;&#34;
    CLR = (0, &#39;No flags set&#39;)
    ABS = (1, &#39;Absolute certificate address&#39;)
    CSF = (2, &#39;Install CSF key&#39;)
    DAT = (4, &#39;Key binds to Data Type&#39;)
    CFG = (8, &#39;Key binds to Configuration&#39;)
    FID = (16, &#39;Key binds to Fabrication UID&#39;)
    MID = (32, &#39;Key binds to Manufacturing ID&#39;)
    CID = (64, &#39;Key binds to Caller ID&#39;)
    HSH = (128, &#39;Certificate hash present&#39;)


class EnumAuthDat(Enum):
    &#34;&#34;&#34;Flags for Authenticate Data commands.&#34;&#34;&#34;
    CLR = (0, &#39;No flags set&#39;)
    ABS = (1, &#39;Absolute signature address&#39;)


class EnumEngine(Enum):
    &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
    ANY = (0x00, &#39;First compatible engine will be selected (no engine configuration parameters are allowed)&#39;)
    SCC = (0x03, &#39;Security controller&#39;)
    RTIC = (0x05, &#39;Run-time integrity checker&#39;)
    SAHARA = (0x06, &#39;Crypto accelerator&#39;)
    CSU = (0x0A, &#39;Central Security Unit&#39;)
    SRTC = (0x0C, &#39;Secure clock&#39;)
    DCP = (0x1B, &#39;Data Co-Processor&#39;)
    CAAM = (0x1D, &#39;Cryptographic Acceleration and Assurance Module&#39;)
    SNVS = (0x1E, &#39;Secure Non-Volatile Storage&#39;)
    OCOTP = (0x21, &#39;Fuse controller&#39;)
    DTCP = (0x22, &#39;DTCP co-processor&#39;)
    ROM = (0x36, &#39;Protected ROM area&#39;)
    HDCP = (0x24, &#39;HDCP co-processor&#39;)
    SW = (0xFF, &#39;Software engine&#39;)


class EnumCAAM(Enum):
    &#34;&#34;&#34;CAAM Engine Configuration.&#34;&#34;&#34;
    DEFAULT = 0x00
    IN_SWAP8 = 0x01
    IN_SWAP16 = 0x02
    OUT_SWAP8 = 0x08
    OUT_SWAP16 = 0x10
    DSC_SWAP8 = 0x40
    DSC_SWAP16 = 0x80


class EnumItm(Enum):
    &#34;&#34;&#34;Engine configuration flags of Set command.&#34;&#34;&#34;
    MID = (0x01, &#39;Manufacturing ID (MID) fuse locations&#39;)
    ENG = (0x03, &#39;Preferred engine for a given algorithm&#39;)


########################################################################################################################
# Abstract Class
########################################################################################################################

class CmdBase:
    &#34;&#34;&#34;Base class for all commands.&#34;&#34;&#34;

    def __init__(self, tag: CmdTag, param: int, length: Optional[int] = None):
        &#34;&#34;&#34;Constructor.

        :param tag: command tag
        :param param: TODO
        :param length: of the binary command representation, in bytes
        &#34;&#34;&#34;
        self._header = CmdHeader(tag, param, length)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of command.&#34;&#34;&#34;
        return self._header.length

    @property
    def tag(self) -&gt; CmdTag:
        &#34;&#34;&#34;Command tag.&#34;&#34;&#34;
        return self._header.tag

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command needs a reference to an additional data.

        If returns True, the following methods must be implemented:
        - cmd_data_offset
        - cmd_data_reference
        &#34;&#34;&#34;
        return False  # default implementation

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as certificate, signature, etc) in binary image.&#34;&#34;&#34;
        return 0

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        :raises TypeError: if cmd-data not supported by the command
        &#34;&#34;&#34;
        raise TypeError(&#39;cmd-data not supported by the command&#39;)

    @property
    def cmd_data_reference(self) -&gt; Optional[BaseClass]:
        &#34;&#34;&#34;Reference to a command data (such as certificate, signature, etc).

        None if no reference was assigned;
        Value type is command-specific
        &#34;&#34;&#34;
        return None

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: BaseClass) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference
        Note: the method must be implemented in `self.has_cmd_data_reference` returns True

        :param value: to be set
        :raise TypeError: if reference not supported by the command
        &#34;&#34;&#34;
        raise TypeError(&#39;cmd-data not supported by the command&#39;)

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; Any:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :raises TypeError: if cmd_data is not supported by the command
        &#34;&#34;&#34;
        raise TypeError(&#39;cmd-data not supported by the command&#39;)

    def __eq__(self, other: Any) -&gt; bool:
        return isinstance(other, self.__class__) and vars(other) == vars(self)

    def __ne__(self, other: Any) -&gt; bool:
        return not self.__eq__(other)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text representation of the command.&#34;&#34;&#34;
        return f&#39;Command &#34;{CmdTag.desc(self.tag)}&#34;   [Tag={str(self.tag)}, length={str(self.size)}]\n&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        hdr_data = self._header.export()
        dbg_info.append_binary_data(&#39;header&#39;, hdr_data)
        return hdr_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdBase&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        raise NotImplementedError()


########################################################################################################################
# HAB Commands
########################################################################################################################

class CmdWriteData(CmdBase):
    &#34;&#34;&#34;Write data command.&#34;&#34;&#34;

    @property
    def num_bytes(self) -&gt; int:
        &#34;&#34;&#34;Number of bytes being written by the command.&#34;&#34;&#34;
        return self._header.param &amp; 0x7

    @num_bytes.setter
    def num_bytes(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: number of bytes being written by the command
        &#34;&#34;&#34;
        assert value in (1, 2, 4)
        self._header.param &amp;= ~0x7
        self._header.param |= value

    @property
    def ops(self) -&gt; int:
        &#34;&#34;&#34;Type of write operation.&#34;&#34;&#34;
        return (self._header.param &gt;&gt; 3) &amp; 0x3

    @ops.setter
    def ops(self, value: int) -&gt; None:
        assert value in EnumWriteOps
        self._header.param &amp;= ~(0x3 &lt;&lt; 3)
        self._header.param |= int(value) &lt;&lt; 3

    def __init__(self, numbytes: int = 4, ops: int = EnumWriteOps.WRITE_VALUE,
                 data: Iterable[Tuple[int, int]] = None) -&gt; None:
        &#34;&#34;&#34;Initialize Write Data command.

        :param numbytes: number of bytes. Must be value: 1, 2 or 4
        :param ops: type of write operation
        :param data: list of tuples: address and value
        &#34;&#34;&#34;
        assert numbytes in (1, 2, 4)
        assert ops in EnumWriteOps
        super().__init__(CmdTag.WRT_DAT, ((int(ops) &amp; 0x3) &lt;&lt; 3) | (numbytes &amp; 0x7))
        self._data: List[List[int]] = []
        if data is not None:
            assert isinstance(data, (list, tuple))
            for address, value in data:
                self.append(address, value)

    def __repr__(self) -&gt; str:
        return f&#34;CmdWriteData &lt;{EnumWriteOps.name(self.ops)}/{self.num_bytes}, {len(self._data)}&gt;&#34;

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; List[int]:
        return self._data[key]

    def __setitem__(self, key: int, value: List[int]) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[List[int]]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Write Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumWriteOps.name(self.ops),
                                                                        self.num_bytes)
        for cmd in self._data:
            msg += &#34;- Address: 0x{0:08X}, Value: 0x{1:08X}\n&#34;.format(cmd[0], cmd[1])
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def append(self, address: int, value: int) -&gt; None:
        &#34;&#34;&#34;Append of Write data command.&#34;&#34;&#34;
        assert 0 &lt;= address &lt;= 0xFFFFFFFF, &#34;address out of range&#34;
        assert 0 &lt;= value &lt;= 0xFFFFFFFF, &#34;value out of range&#34;
        self._data.append([address, value])
        self._header.length += 8

    def pop(self, index: int) -&gt; List[int]:
        &#34;&#34;&#34;Pop of Write data command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._data)
        cmd = self._data.pop(index)
        self._header.length -= 8
        return cmd

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Write data command.&#34;&#34;&#34;
        self._data.clear()
        self._header.length = self._header.size

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        for cmd in self._data:
            raw_data += pack(&#34;&gt;LL&#34;, cmd[0], cmd[1])
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdWriteData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset=offset, required_tag=CmdTag.WRT_DAT)
        obj = cls(header.param &amp; 0x7, (header.param &gt;&gt; 3) &amp; 0x3)
        index = header.size
        while index &lt; header.length:
            (address, value) = unpack_from(&#34;&gt;LL&#34;, data, offset + index)
            obj.append(address, value)
            index += 8
        return obj


class CmdCheckData(CmdBase):
    &#34;&#34;&#34;Check data command.&#34;&#34;&#34;

    @property
    def num_bytes(self) -&gt; int:
        &#34;&#34;&#34;Number of bytes.&#34;&#34;&#34;
        return self._header.param &amp; 0x7

    @num_bytes.setter
    def num_bytes(self, value: int) -&gt; None:
        assert value in (1, 2, 4)
        self._header.param &amp;= ~0x7
        self._header.param |= int(value)

    @property
    def ops(self) -&gt; int:
        &#34;&#34;&#34;Operation of Check data command.&#34;&#34;&#34;
        return (self._header.param &gt;&gt; 3) &amp; 0x3

    @ops.setter
    def ops(self, value: int) -&gt; None:
        assert value in EnumCheckOps
        self._header.param &amp;= ~(0x3 &lt;&lt; 3)
        self._header.param |= int(value) &lt;&lt; 3

    def __init__(self, numbytes: int = 4, ops: int = EnumCheckOps.ALL_SET, address: int = 0, mask: int = 0,
                 count: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize the check data command.

        :param numbytes: number of bytes
        :param ops: type of  operation
        :param address: list of tuples: address and value
        :param mask: mask value
        :param count: count value
        &#34;&#34;&#34;
        assert numbytes in (1, 2, 4)
        assert ops in EnumCheckOps
        super().__init__(CmdTag.CHK_DAT, ((int(ops) &amp; 0x3) &lt;&lt; 3) | (numbytes &amp; 0x7))
        self.address = address
        self.mask = mask
        self.count = count
        # the length of &#39;address&#39;(4B), &#39;mask&#39;(4B) and count(0 or 4B)  need to be added into Header.length
        self._header.length += 4 + 4 + (4 if count else 0)

    def __repr__(self) -&gt; str:
        return &#34;CmdCheckData &lt;{}/{}, ADDR=0x{:X}, MASK=0x{:X}&gt;&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                       self.num_bytes, self.address, self.mask)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Check Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                        self.num_bytes)
        msg += &#34;- Address: 0x{0:08X}, Mask: 0x{1:08X}&#34;.format(self.address, self.mask)
        if self.count:
            msg += &#34;, Count: {0:d}&#34;.format(self.count)
        msg += &#34;\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        raw_data += pack(&#34;&gt;LL&#34;, self.address, self.mask)
        if self.count is not None:
            raw_data += pack(&#34;&gt;L&#34;, self.count)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCheckData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.CHK_DAT)
        numbytes = header.param &amp; 0x7
        ops = (header.param &gt;&gt; 3) &amp; 0x3
        address, mask = unpack_from(&#34;&gt;LL&#34;, data, offset + header.size)
        count = None
        if (header.length - header.size) &gt; 8:
            count = unpack_from(&#34;&gt;L&#34;, data, offset + header.size + 8)[0]
        return cls(numbytes, ops, address, mask, count)


class CmdNop(CmdBase):
    &#34;&#34;&#34;Nop command.&#34;&#34;&#34;

    def __init__(self, param: int = 0):
        &#34;&#34;&#34;Initialize the nop command.&#34;&#34;&#34;
        super().__init__(CmdTag.NOP, param)

    def __repr__(self) -&gt; str:
        return &#34;CmdNop&#34;

    def __eq__(self, cmd: Any) -&gt; bool:
        if not isinstance(cmd, CmdNop):
            return False
        return True

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.NOP)
        if header.length != header.size:
            pass
        return cls(header.param)


class CmdSet(CmdBase):
    &#34;&#34;&#34;Set command.&#34;&#34;&#34;

    @property
    def itm(self) -&gt; int:
        &#34;&#34;&#34;Item of Set command.&#34;&#34;&#34;
        return self._header.param

    @itm.setter
    def itm(self, value: EnumItm) -&gt; None:
        assert value in EnumItm
        self._header.param = value

    @property
    def hash_algorithm(self) -&gt; EnumAlgorithm:
        &#34;&#34;&#34;Type of hash algorithm.&#34;&#34;&#34;
        return self._hash_alg

    @hash_algorithm.setter
    def hash_algorithm(self, value: EnumAlgorithm) -&gt; None:
        assert value in EnumAlgorithm
        self._hash_alg = value

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
        return self._engine

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._engine = value

    def __init__(self, itm: EnumItm = EnumItm.ENG, hash_alg: EnumAlgorithm = EnumAlgorithm.ANY,
                 engine: EnumEngine = EnumEngine.ANY, engine_cfg: int = 0):
        &#34;&#34;&#34;Initialize the set command.&#34;&#34;&#34;
        assert itm in EnumItm
        super().__init__(CmdTag.SET, itm)
        self.hash_algorithm: EnumAlgorithm = hash_alg
        self.engine = engine
        self.engine_cfg = engine_cfg
        self._header.length = CmdHeader.SIZE + 4

    def __repr__(self) -&gt; str:
        return &#34;CmdSet &lt;{}, {}, {}, eng_cfg=0x{:X}&gt;&#34;.format(
            EnumItm.name(self.itm), EnumAlgorithm.name(self.hash_algorithm), EnumEngine.name(self.engine),
            self.engine_cfg
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Set Command ITM : {EnumItm.name(self.itm)}\n&#34;
        msg += f&#34;HASH Algo      : {self.hash_algorithm} ({EnumAlgorithm.desc(self.hash_algorithm)})\n&#34;
        msg += f&#34;Engine         : {self.engine} ({EnumEngine.desc(self.engine)})\n&#34;
        msg += f&#34;Engine Conf    : {hex(self.engine_cfg)})\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        raw_data += pack(&#34;4B&#34;, 0x00, self.hash_algorithm, self.engine, self.engine_cfg)
        dbg_info.append_binary_data(&#39;data&#39;, raw_data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdSet&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.SET)
        (_, alg, eng, cfg) = unpack_from(&#34;4B&#34;, data, offset + CmdHeader.SIZE)
        return CmdSet(EnumItm.from_int(header.param), EnumAlgorithm.from_int(alg), EnumEngine.from_int(eng), cfg)


class CmdInitialize(CmdBase):
    &#34;&#34;&#34;Initialize command.&#34;&#34;&#34;

    @property
    def engine(self) -&gt; int:
        &#34;&#34;&#34;Engine.&#34;&#34;&#34;
        return self._header.param

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._header.param = value

    def __init__(self, engine: int = EnumEngine.ANY, data: List[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize the initialize command.&#34;&#34;&#34;
        assert engine in EnumEngine
        super().__init__(CmdTag.INIT, engine)
        self._data = data if data else []

    def __repr__(self) -&gt; str:
        return &#34;CmdInitialize &lt;{}, {}&gt;&#34;.format(EnumEngine[self.engine], len(self._data))  # type: ignore

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; int:
        return self._data[key]

    def __setitem__(self, key: int, value: int) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[int]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Initialize Command (Engine: {0:s})\n&#34;.format(EnumEngine[self.engine])  # type: ignore
        cnt = 0
        for val in self._data:
            msg += &#34; {0:02d}) Value: 0x{1:08X}\n&#34;.format(cnt, val)
            cnt += 1
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def append(self, value: int) -&gt; None:
        &#34;&#34;&#34;Appending of Initialize command.&#34;&#34;&#34;
        assert isinstance(value, int), &#34;value must be INT type&#34;
        assert 0 &lt;= value &lt; 0xFFFFFFFF, &#34;value out of range&#34;
        self._data.append(value)
        self._header.length += 4

    def pop(self, index: int) -&gt; int:
        &#34;&#34;&#34;Pop of Initialize command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._data)
        val = self._data.pop(index)
        self._header.length -= 4
        return val

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Initialize command.&#34;&#34;&#34;
        self._data.clear()
        self._header.length = self._header.size

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        for val in self._data:
            raw_data += pack(&#34;&gt;L&#34;, val)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdInitialize&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.INIT)
        obj = cls(EnumEngine.from_int(header.param))
        index = header.size
        while index &lt; header.length:
            assert (offset + index) &lt; len(data)
            val = unpack_from(&#34;&gt;L&#34;, data, offset + index)
            obj.append(val[0])
            index += 4
        return obj


class CmdUnlockAbstract(CmdBase, ABC):
    &#34;&#34;&#34;Abstract unlock engine command; the command depends on engine type.&#34;&#34;&#34;

    def __init__(self, engine: EnumEngine = EnumEngine.ANY, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Constructor.

        :param engine: to be unlocked
        :param features: engine specific features
        :param uid: Unique ID required by some engine/feature combinations
        &#34;&#34;&#34;
        super().__init__(CmdTag.UNLK, EnumEngine.from_int(engine), length=8)
        self.features = features
        self.uid = uid
        if self._need_uid:
            self._header.length += 8

    def __iter__(self) -&gt; Iterator[int]:
        return self.__iter__()

    def __repr__(self) -&gt; str:
        return &#34;{} &lt;{}, {}, {}&gt;&#34;.format(
            self.__class__.__name__,
            EnumEngine.desc(self.engine), self.features, self.uid
        )

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine to be unlocked.

        The term `engine` denotes a peripheral involved in one or more of the following functions:
        - cryptographic computation
        - security state management
        - security alarm handling
        - access control
        &#34;&#34;&#34;
        return EnumEngine.from_int(self._header.param)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = super().info()
        msg += &#34;Unlock Command\n&#34;
        msg += f&#34;Engine : {EnumEngine.desc(self.engine)}\n&#34;
        return msg

    @property
    def _need_uid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        return self.need_uid(self.engine, self.features)

    @staticmethod
    def need_uid(engine: EnumEngine, features: int) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        overall_condition = False
        ocotp_condition = (engine == EnumEngine.OCOTP and bool(features &amp; 0b1101))
        overall_condition |= ocotp_condition
        return overall_condition

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdUnlockAbstract&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: Unlock command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.UNLK)
        features = unpack_from(&#34;&gt;L&#34;, data, offset + header.size)[0]
        engine = EnumEngine.from_int(header.param)
        uid = 0
        if cls.need_uid(engine, features):
            uid = unpack_from(&#34;&gt;Q&#34;, data, offset + header.size + 4)[0]

        if engine == EnumEngine.SNVS:
            return CmdUnlockSNVS(features)
        if engine == EnumEngine.CAAM:
            return CmdUnlockCAAM(features)
        if engine == EnumEngine.OCOTP:
            return CmdUnlockOCOTP(features, uid)
        return CmdUnlock(engine, features, uid)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        # assert self.size == CmdHeader.SIZE + 4
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;L&#34;, self.features)
        dbg_info.append_binary_data(&#39;features&#39;, data)
        raw_data += data
        if self._need_uid:
            data = pack(&#34;&gt;Q&#34;, self.uid)
            dbg_info.append_binary_data(&#39;uid&#39;, data)
            raw_data += data
        return raw_data


class CmdUnlockSNVS(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock Secure Non-Volatile Storage (SNVS) Engine.&#34;&#34;&#34;

    # mask unlock LP_SWR
    FEATURE_UNLOCK_LP_SWR = 1
    # mask unlock ZMK_WRITE
    FEATURE_UNLOCK_ZMK_WRITE = 2

    def __init__(self, features: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param features: mask of FEATURE_UNLOCK_* constants
        &#34;&#34;&#34;
        super().__init__(EnumEngine.SNVS, features)

    @property
    def unlock_lp_swr(self) -&gt; bool:
        &#34;&#34;&#34;Leave LP SW reset unlocked.&#34;&#34;&#34;
        return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR != 0

    @property
    def unlock_zmk_write(self) -&gt; bool:
        &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
        return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE != 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;Unlock LP SWR    : {self.unlock_lp_swr}\n&#34;
        msg += f&#34;Unlock ZMK Write : {self.unlock_zmk_write}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg


class CmdUnlockCAAM(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock for Cryptographic Acceleration and Assurance Module .&#34;&#34;&#34;
    # Leave Job Ring and DECO Master IP unlocked
    FEATURE_UNLOCK_MID = 1
    # Leave RNG unititialized
    FEATURE_UNLOCK_RNG = 2
    # Keep manufacturing protection key in internal memory
    FEATURE_UNLOCK_MFG = 4

    def __init__(self, features: int = 0):
        &#34;&#34;&#34;Initialize.

        :param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
        &#34;&#34;&#34;
        super().__init__(EnumEngine.CAAM, features)

    @property
    def unlock_mid(self) -&gt; bool:
        &#34;&#34;&#34;Leave Job Ring and DECO master ID registers unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_MID != 0

    @property
    def unlock_rng(self) -&gt; bool:
        &#34;&#34;&#34;Leave RNG un-instantiated.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_RNG != 0

    @property
    def unlock_mfg(self) -&gt; bool:
        &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_MFG != 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;MID : {self.unlock_mid}\n&#34;
        msg += f&#34;RNG : {self.unlock_rng}\n&#34;
        msg += f&#34;MFG : {self.unlock_mfg}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

class CmdUnlockOCOTP(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock for On-Chip One-time programable memory (fuses).&#34;&#34;&#34;
    #pylint: disable = bad-whitespace
    # Leave Field Return activation unlocked.
    FEATURE_UNLOCK_FLD_RTN  = 1
    # Leave SRK revocation unlocked.
    FEATURE_UNLOCK_SRK_RVK  = 2
    # Leave SCS register unlocked.
    FEATURE_UNLOCK_SCS      = 4
    # Unlock JTAG using SCS HAB_JDE bit.
    FEATURE_UNLOCK_JTAG     = 8

    def __init__(self, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Initialize.

        :param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
        :param uid: Unique ID required by some engine/feature combinations
        &#34;&#34;&#34;
        super().__init__(EnumEngine.OCOTP, features, uid=uid)

    @property
    def _need_uid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        return self.unlock_fld_rtn or self.unlock_csc or self.unlock_jtag

    @property
    def unlock_fld_rtn(self) -&gt; bool:
        &#34;&#34;&#34;Leave Field Return activation unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_FLD_RTN != 0

    @property
    def unlock_srk_rvk(self) -&gt; bool:
        &#34;&#34;&#34;Leave SRK revocation unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_SRK_RVK != 0

    @property
    def unlock_csc(self) -&gt; bool:
        &#34;&#34;&#34;Leave SCS register unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_SCS != 0

    @property
    def unlock_jtag(self) -&gt; bool:
        &#34;&#34;&#34;Unlock JTAG using SCS HAB_JDE bit.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_JTAG != 0


    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;FLD_RTN : {self.unlock_fld_rtn}\n&#34;
        msg += f&#34;SRK_RVK : {self.unlock_srk_rvk}\n&#34;
        msg += f&#34;CSC     : {self.unlock_csc}\n&#34;
        msg += f&#34;JTAG    : {self.unlock_jtag}\n&#34;
        if self.uid:
            msg += f&#34;UID : {hex(self.uid)}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

class CmdUnlock(CmdUnlockAbstract):
    &#34;&#34;&#34;Generic unlock engine command.&#34;&#34;&#34;

    def __init__(self, engine: EnumEngine = EnumEngine.ANY, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Constructor.

        :param engine: to be unlocked
        :param features: mask of features to use by the engine
        :param uid: Unique ID (if needed)
        &#34;&#34;&#34;
        super().__init__(engine, features, uid=uid)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Features: {})\n&#34;.format(self.features)
        msg += &#34;UID:      {})\n&#34;.format(self.uid)
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg


class CmdInstallKey(CmdBase):
    &#34;&#34;&#34;Install key command.&#34;&#34;&#34;

    def __init__(self, flags: EnumInsKey = EnumInsKey.CLR, cert_fmt: EnumCertFormat = EnumCertFormat.SRK,
                 hash_alg: EnumAlgorithm = EnumAlgorithm.ANY, src_index: int = 0, tgt_index: int = 0,
                 location: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param flags: from EnumInsKey
        :param cert_fmt: format of the certificate; key authentication protocol
        :param hash_alg: hash algorithm
        :param src_index: source key (verification key, KEK) index
        :param tgt_index: target key index
        :param location: start address of an additional data such as KEY to be installed;
                Typically it is relative to CSF start; Might be absolute for DEK key
        &#34;&#34;&#34;
        super().__init__(CmdTag.INS_KEY, flags)
        self._cert_fmt: EnumCertFormat = cert_fmt
        self.hash_algorithm: EnumAlgorithm = hash_alg
        self.source_index = src_index
        self.target_index = tgt_index
        self.cmd_data_location = location
        self._header.length = CmdHeader.SIZE + 8
        self._certificate_ref: Optional[Union[CertificateImg, SrkTable]] = None

    @property
    def flags(self) -&gt; EnumInsKey:
        &#34;&#34;&#34;Flags.&#34;&#34;&#34;
        return EnumInsKey.from_int(self._header.param)

    @flags.setter
    def flags(self, value: EnumInsKey) -&gt; None:
        assert value in EnumInsKey
        self._header.param = value

    @property
    def certificate_format(self) -&gt; EnumCertFormat:
        &#34;&#34;&#34;Certificate format.&#34;&#34;&#34;
        return self._cert_fmt

    @certificate_format.setter
    def certificate_format(self, value: EnumCertFormat) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: certificate format
        &#34;&#34;&#34;
        assert value in EnumCertFormat
        self._cert_fmt = value

    @property
    def hash_algorithm(self) -&gt; EnumAlgorithm:
        &#34;&#34;&#34;Hash algorithm.&#34;&#34;&#34;
        return self._hash_alg

    @hash_algorithm.setter
    def hash_algorithm(self, value: EnumAlgorithm) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: hash algorithm
        &#34;&#34;&#34;
        assert value in EnumAlgorithm
        self._hash_alg = value

    @property
    def source_index(self) -&gt; int:
        &#34;&#34;&#34;Source key (verification key, KEK) index.

        - For SRK, it is index of the SRK key (0-3)
        - For other keys it is index of previously installed target key, typically 0
        &#34;&#34;&#34;
        return self._src_index

    @source_index.setter
    def source_index(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: source key (verification key, KEK) index
        &#34;&#34;&#34;
        if self._cert_fmt == EnumCertFormat.SRK:
            assert value in (0, 1, 2, 3)  # RT10xx supports just 4 SRK keys; this might need update for other devices
        else:
            assert value in (0, 2, 3, 4, 5)
        self._src_index = value

    @property
    def target_index(self) -&gt; int:
        &#34;&#34;&#34;Target key index.&#34;&#34;&#34;
        return self._tgt_index

    @target_index.setter
    def target_index(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: target key index
        &#34;&#34;&#34;
        assert value in (0, 1, 2, 3, 4, 5)
        self._tgt_index = value

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as certificate, signature, etc) in binary image.&#34;&#34;&#34;
        return self.cmd_data_location

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        &#34;&#34;&#34;
        self.cmd_data_location = value

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
        if self.flags == EnumInsKey.ABS:  # reference is an absolute address; instance not assigned; used for DEK key
            assert self._certificate_ref is None
            return False
        return True

    @property
    def cmd_data_reference(self) -&gt; Optional[Union[CertificateImg, SrkTable]]:
        &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

        None if no reference was assigned;
        Value type is command-specific
        &#34;&#34;&#34;
        return self._certificate_ref

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: Union[CertificateImg, SrkTable]) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference

        :param value: to be set
        :raise ValueError: if cmd reference not supported by the command
        &#34;&#34;&#34;
        assert isinstance(value, (CertificateImg, SrkTable))
        self._certificate_ref = value

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; Union[CertificateImg, SrkTable, None]:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :return: parsed data object; command-specific: certificate or SrkTable to be installed
        &#34;&#34;&#34;
        if self.certificate_format == EnumCertFormat.SRK:
            result: Union[CertificateImg, SrkTable] = SrkTable.parse(data, offset)
        else:
            result = CertificateImg.parse(data, offset)
        self.cmd_data_reference = result
        return result

    @property
    def certificate_ref(self) -&gt; Union[CertificateImg, SrkTable, None]:
        &#34;&#34;&#34;Corresponding certificate referenced by key-location.&#34;&#34;&#34;
        return self._certificate_ref

    @certificate_ref.setter
    def certificate_ref(self, value: Union[CertificateImg, SrkTable]) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: certificate to be installed by the command
        &#34;&#34;&#34;
        self._certificate_ref = value

    def __repr__(self) -&gt; str:
        return &#34;CmdInstallKey &lt;{}, {}, {}, {}, {}, 0x{:X}&gt;&#34;. \
            format(EnumInsKey[self.flags], EnumCertFormat[self.certificate_format],  # type: ignore
                   EnumAlgorithm[self.hash_algorithm],  # type: ignore
                   self.source_index, self.target_index, self.cmd_data_location)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34; Flag      : {:d} ({})\n&#34;.format(self.flags, EnumInsKey.desc(self.flags))
        msg += &#34; CertFormat: {:d} ({})\n&#34;.format(self.certificate_format,
                                                 EnumCertFormat.desc(self.certificate_format))  # type: ignore
        msg += &#34; Algorithm : {:d} ({})\n&#34;.format(self.hash_algorithm,
                                                 EnumAlgorithm.desc(self.hash_algorithm))  # type: ignore
        msg += &#34; SrcKeyIdx : {:d} (Source key index) \n&#34;.format(self.source_index)
        msg += &#34; TgtKeyIdx : {:d} (Target key index) \n&#34;.format(self.target_index)
        msg += &#34; Location  : 0x{:08X} (Start address of certificate(s) to install) \n&#34;.format(self.cmd_data_location)
        if self.certificate_ref:
            msg += &#39;[related-certificate]\n&#39;
            msg += self.certificate_ref.info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;4BL&#34;, self.certificate_format, self.hash_algorithm, self.source_index, self.target_index,
                    self.cmd_data_location)
        raw_data += data
        dbg_info.append_binary_data(&#39;data&#39;, data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; CmdBase:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to read from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.INS_KEY)
        protocol, algorithm, src_index, tgt_index, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
        return cls(EnumInsKey.from_int(header.param), protocol, algorithm, src_index, tgt_index, location)


# the type represents referenced command data: either Signature or MAC
SignatureOrMAC = Union[MAC, Signature]


class CmdAuthData(CmdBase):
    &#34;&#34;&#34;Authenticate data command.&#34;&#34;&#34;

    @property
    def flags(self) -&gt; int:
        &#34;&#34;&#34;Flag of Authenticate data command.&#34;&#34;&#34;
        return self._header.param

    @flags.setter
    def flags(self, value: int) -&gt; None:
        assert value in EnumAuthDat
        self._header.param = value

    @property
    def key_index(self) -&gt; int:
        &#34;&#34;&#34;Key index.&#34;&#34;&#34;
        return self._key_index

    @key_index.setter
    def key_index(self, value: int) -&gt; None:
        assert value in (0, 1, 2, 3, 4, 5)
        self._key_index = value

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine.&#34;&#34;&#34;
        return self._engine

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._engine = value

    def __init__(self, flags: EnumAuthDat = EnumAuthDat.CLR, key_index: int = 1,
                 sig_format: EnumCertFormat = EnumCertFormat.CMS, engine: EnumEngine = EnumEngine.ANY,
                 engine_cfg: int = 0, location: int = 0, certificate: Optional[Certificate] = None,
                 private_key_pem_data: Optional[bytes] = None):
        &#34;&#34;&#34;Initialize the Authenticate data command.&#34;&#34;&#34;
        super().__init__(CmdTag.AUT_DAT, flags)
        self.key_index = key_index
        self.sig_format = sig_format
        self.engine = engine
        self.engine_cfg = engine_cfg
        self.location = location
        self.certificate = certificate
        self.private_key_pem_data = private_key_pem_data
        self._header.length = CmdHeader.SIZE + 8
        self._blocks: List[Tuple[int, int]] = []  # list of (start-address, size)
        self._signature: Optional[SignatureOrMAC] = None
        if certificate and private_key_pem_data:
            assert isinstance(certificate, Certificate)
            assert isinstance(private_key_pem_data, bytes)
            assert matches_key_and_cert(private_key_pem_data, certificate)

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
        return True

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as signature or MAC, etc) in binary image.&#34;&#34;&#34;
        return self.location

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        &#34;&#34;&#34;
        self.location = value

    @property
    def cmd_data_reference(self) -&gt; Optional[SignatureOrMAC]:
        &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

        -   None if no reference was assigned;
        -   Value type is command-specific
        &#34;&#34;&#34;
        return self._signature

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: SignatureOrMAC) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference

        :param value: to be set
        :raise ValueError: if cmd reference not supported by the command
        &#34;&#34;&#34;
        if self.sig_format == EnumCertFormat.AEAD:
            assert isinstance(value, MAC)
        elif self.sig_format == EnumCertFormat.CMS:
            assert isinstance(value, Signature)
        else:
            assert False
        self._signature = value

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; SignatureOrMAC:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :return: parsed data object; command-specific: Signature or MAC
        &#34;&#34;&#34;
        if self.key_index == 0:  # TODO check by header
            self._signature = MAC.parse(data, offset)
        else:
            self._signature = Signature.parse(data, offset)
        return self._signature

    @property
    def signature(self) -&gt; Optional[SignatureOrMAC]:
        &#34;&#34;&#34;Signature referenced by `location` attribute.&#34;&#34;&#34;
        return self._signature

    @signature.setter
    def signature(self, value: SignatureOrMAC) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: signature to be installed by the command
        &#34;&#34;&#34;
        self.cmd_data_reference = value

    def __repr__(self) -&gt; str:
        return &#34;CmdAuthData &lt;{}, {}, {}, key:{}, 0x{:X}&gt;&#34;. \
            format(EnumAuthDat[self.flags], EnumEngine[self.engine],  # type: ignore
                   self.engine_cfg, self.key_index, self.location)

    def __len__(self) -&gt; int:
        return len(self._blocks)

    def __getitem__(self, key: int) -&gt; Tuple[int, int]:
        return self._blocks[key]

    def __setitem__(self, key: int, value: Tuple[int, int]) -&gt; None:
        assert isinstance(value, (list, tuple))
        assert len(value) == 2
        self._blocks[key] = value

    def __iter__(self) -&gt; Iterator[Union[Tuple[Any, ...], List[Any]]]:
        return self._blocks.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34; Flag:        {:d} ({})\n&#34;.format(self.flags, EnumAuthDat.desc(self.flags))
        msg += &#34; Key index:   {:d}\n&#34;.format(self.key_index)
        msg += &#34; Engine:      {:d} ({})\n&#34;.format(self.engine, EnumEngine.desc(self.engine))
        msg += &#34; Engine Conf: {:d}\n&#34;.format(self.engine_cfg)
        msg += &#34; Location:    0x{:08X} (Start address of authentication data) \n&#34;.format(self.location)
        if self.signature:
            msg += &#39;[related signature]\n&#39;
            msg += self.signature.info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        for blk in self._blocks:
            msg += &#34;- Start: 0x{0:08X}, Length: {1:d} Bytes\n&#34;.format(blk[0], blk[1])
        return msg

    def append(self, start_address: int, size: int) -&gt; None:
        &#34;&#34;&#34;Append of Authenticate data command.&#34;&#34;&#34;
        self._blocks.append((start_address, size), )
        self._header.length += 8

    def pop(self, index: int) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Pop of Authenticate data command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._blocks)
        value = self._blocks.pop(index)
        self._header.length -= 8
        return value

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Authenticate data command.&#34;&#34;&#34;
        self._blocks.clear()
        self._header.length = self._header.size + 8

    def _cms_signature(self, zulu: datetime, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Sign provided data and return CMS signature.

        :param zulu: current UTC time+date
        :param data: to be signed
        :return: CMS signature (binary)
        &#34;&#34;&#34;
        assert self.certificate is not None
        assert self.private_key_pem_data is not None

        # signed data (main section)
        signed_data = cms.SignedData()
        signed_data[&#39;version&#39;] = &#39;v1&#39;
        signed_data[&#39;encap_content_info&#39;] = util.OrderedDict([
            (&#39;content_type&#39;, &#39;data&#39;)
        ])
        signed_data[&#39;digest_algorithms&#39;] = [util.OrderedDict([
            (&#39;algorithm&#39;, &#39;sha256&#39;),
            (&#39;parameters&#39;, None)])]

        # signer info sub-section
        signer_info = cms.SignerInfo()
        signer_info[&#39;version&#39;] = &#39;v1&#39;
        signer_info[&#39;digest_algorithm&#39;] = util.OrderedDict([
            (&#39;algorithm&#39;, &#39;sha256&#39;),
            (&#39;parameters&#39;, None)])
        signer_info[&#39;signature_algorithm&#39;] = util.OrderedDict([
            (&#39;algorithm&#39;, &#39;rsassa_pkcs1v15&#39;),
            (&#39;parameters&#39;, b&#39;&#39;)])
        # signed identifier: issuer amd serial number
        asn1cert = x509.Certificate.load(self.certificate.public_bytes(Encoding.DER))
        signer_info[&#39;sid&#39;] = cms.SignerIdentifier({
            &#39;issuer_and_serial_number&#39;: cms.IssuerAndSerialNumber({
                &#39;issuer&#39;: asn1cert.issuer,
                &#39;serial_number&#39;: asn1cert.serial_number
            })
        })
        # signed attributes
        signed_attrs = cms.CMSAttributes()
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;content_type&#39;,
            &#39;values&#39;: [cms.ContentType(&#39;data&#39;)],
        }))
        # check time-zone is assigned (expected UTC+0)
        assert zulu.tzinfo
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;signing_time&#39;,
            &#39;values&#39;: [cms.Time(name=&#39;utc_time&#39;, value=zulu.strftime(&#39;%y%m%d%H%M%SZ&#39;))],
        }))
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;message_digest&#39;,
            &#39;values&#39;: [cms.OctetString(crypto_backend().hash(data))],  # digest
        }))
        signer_info[&#39;signed_attrs&#39;] = signed_attrs

        # create signature
        signer_info[&#39;signature&#39;] = crypto_backend().rsa_sign(self.private_key_pem_data, signed_attrs.dump())

        # Adding SignerInfo object to SignedData object
        signed_data[&#39;signer_infos&#39;] = [signer_info]

        # content info
        content_info = cms.ContentInfo()
        content_info[&#39;content_type&#39;] = &#39;signed_data&#39;
        content_info[&#39;content&#39;] = signed_data

        return content_info.dump()

    def update_signature(self, zulu: datetime, data: bytes, base_data_addr: int = 0xFFFFFFFF) -&gt; bool:
        &#34;&#34;&#34;Update signature.

        This method must be called from parent to provide data to be signed

        :param zulu: current UTC time+date
        :param data: currently generated binary data
        :param base_data_addr: base address of the generated data
        :raises ValueError: When certificate or private key are not assigned
        :raises ValueError: When signatures not assigned explicitly
        :return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
                        to data);
        &#34;&#34;&#34;
        if not self.certificate or not self.private_key_pem_data:
            raise ValueError(&#39;certificate or private key not assigned, cannot update signature&#39;)

        if self.signature is None:
            raise ValueError(&#39;signature must be assigned explicitly, so its version matches to CST version&#39;)

        if self._blocks:
            sign_data = b&#39;&#39;
            if data:  # if not data specified, create &#34;fake&#34; signature to update length
                total_len = 0
                for blk in self._blocks:
                    start = blk[0] - base_data_addr
                    end = blk[0] + blk[1] - base_data_addr
                    assert start &gt;= 0
                    assert end &lt;= len(data)
                    sign_data += data[start: end]
                    total_len += blk[1]
                assert len(sign_data) == total_len
        else:
            sign_data = data  # if no blocks defined, sign complete data; used for CSF
        if isinstance(self.signature, Signature):
            new_signature = self._cms_signature(zulu, sign_data)
            result = len(self.signature.data) == len(new_signature)
            self.signature.data = new_signature
        else:
            assert isinstance(self.signature, MAC)
            result = True
        return result

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        self._header.length = self.size
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;4BL&#34;, self.key_index, self.sig_format, self.engine, self.engine_cfg, self.location)
        dbg_info.append_binary_data(&#39;data&#39;, data)
        raw_data += data
        for blk in self._blocks:
            blk_data = pack(&#34;&gt;2L&#34;, blk[0], blk[1])
            dbg_info.append_binary_data(&#39;block&#39;, blk_data)
            raw_data += blk_data
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdAuthData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to read from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.AUT_DAT)
        key, sig_format, eng, cfg, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
        obj = cls(EnumAuthDat.from_int(header.param), key, sig_format, EnumEngine.from_int(eng), cfg, location)
        index = header.size + 8
        while index &lt; header.length:
            start_address, size = unpack_from(&#34;&gt;2L&#34;, data, offset + index)
            obj.append(start_address, size)
            index += 8
        return obj


# mapping of supported commands to the corresponding class
_CMD_TO_CLASS: Mapping[CmdTag, Type[CmdBase]] = {
    CmdTag.WRT_DAT: CmdWriteData,
    CmdTag.CHK_DAT: CmdCheckData,
    CmdTag.NOP: CmdNop,
    CmdTag.SET: CmdSet,
    CmdTag.INIT: CmdInitialize,
    CmdTag.UNLK: CmdUnlockAbstract,
    CmdTag.INS_KEY: CmdInstallKey,
    CmdTag.AUT_DAT: CmdAuthData
}


def parse_command(data: bytes, offset: int = 0) -&gt; CmdBase:
    &#34;&#34;&#34;Parse CSF/DCD command.

    :param data: binary data to be parsed
    :param offset: to start parsing
    :return: instance of the command
    :raise ValueError: if the command is not valid
    &#34;&#34;&#34;
    try:
        cmdtag = CmdTag.from_int(data[offset])
    except ValueError:
        raise ValueError(&#34;Unknown command at position: &#34; + hex(offset))
    cmd_class = _CMD_TO_CLASS[cmdtag]
    return cmd_class.parse(data, offset)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spsdk.image.commands.parse_command"><code class="name flex">
<span>def <span class="ident">parse_command</span></span>(<span>data:bytes, offset:int=0) ><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse CSF/DCD command.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing
:return: instance of the command
:raise ValueError: if the command is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_command(data: bytes, offset: int = 0) -&gt; CmdBase:
    &#34;&#34;&#34;Parse CSF/DCD command.

    :param data: binary data to be parsed
    :param offset: to start parsing
    :return: instance of the command
    :raise ValueError: if the command is not valid
    &#34;&#34;&#34;
    try:
        cmdtag = CmdTag.from_int(data[offset])
    except ValueError:
        raise ValueError(&#34;Unknown command at position: &#34; + hex(offset))
    cmd_class = _CMD_TO_CLASS[cmdtag]
    return cmd_class.parse(data, offset)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.image.commands.CmdAuthData"><code class="flex name class">
<span>class <span class="ident">CmdAuthData</span></span>
<span>(</span><span>flags:<a title="spsdk.image.commands.EnumAuthDat" href="#spsdk.image.commands.EnumAuthDat">EnumAuthDat</a>=0, key_index:int=1, sig_format:<a title="spsdk.image.commands.EnumCertFormat" href="#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a>=197, engine:<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a>=0, engine_cfg:int=0, location:int=0, certificate:Union[cryptography.x509.base.Certificate,NoneType]=None, private_key_pem_data:Union[bytes,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Authenticate data command.</p>
<p>Initialize the Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdAuthData(CmdBase):
    &#34;&#34;&#34;Authenticate data command.&#34;&#34;&#34;

    @property
    def flags(self) -&gt; int:
        &#34;&#34;&#34;Flag of Authenticate data command.&#34;&#34;&#34;
        return self._header.param

    @flags.setter
    def flags(self, value: int) -&gt; None:
        assert value in EnumAuthDat
        self._header.param = value

    @property
    def key_index(self) -&gt; int:
        &#34;&#34;&#34;Key index.&#34;&#34;&#34;
        return self._key_index

    @key_index.setter
    def key_index(self, value: int) -&gt; None:
        assert value in (0, 1, 2, 3, 4, 5)
        self._key_index = value

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine.&#34;&#34;&#34;
        return self._engine

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._engine = value

    def __init__(self, flags: EnumAuthDat = EnumAuthDat.CLR, key_index: int = 1,
                 sig_format: EnumCertFormat = EnumCertFormat.CMS, engine: EnumEngine = EnumEngine.ANY,
                 engine_cfg: int = 0, location: int = 0, certificate: Optional[Certificate] = None,
                 private_key_pem_data: Optional[bytes] = None):
        &#34;&#34;&#34;Initialize the Authenticate data command.&#34;&#34;&#34;
        super().__init__(CmdTag.AUT_DAT, flags)
        self.key_index = key_index
        self.sig_format = sig_format
        self.engine = engine
        self.engine_cfg = engine_cfg
        self.location = location
        self.certificate = certificate
        self.private_key_pem_data = private_key_pem_data
        self._header.length = CmdHeader.SIZE + 8
        self._blocks: List[Tuple[int, int]] = []  # list of (start-address, size)
        self._signature: Optional[SignatureOrMAC] = None
        if certificate and private_key_pem_data:
            assert isinstance(certificate, Certificate)
            assert isinstance(private_key_pem_data, bytes)
            assert matches_key_and_cert(private_key_pem_data, certificate)

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
        return True

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as signature or MAC, etc) in binary image.&#34;&#34;&#34;
        return self.location

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        &#34;&#34;&#34;
        self.location = value

    @property
    def cmd_data_reference(self) -&gt; Optional[SignatureOrMAC]:
        &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

        -   None if no reference was assigned;
        -   Value type is command-specific
        &#34;&#34;&#34;
        return self._signature

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: SignatureOrMAC) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference

        :param value: to be set
        :raise ValueError: if cmd reference not supported by the command
        &#34;&#34;&#34;
        if self.sig_format == EnumCertFormat.AEAD:
            assert isinstance(value, MAC)
        elif self.sig_format == EnumCertFormat.CMS:
            assert isinstance(value, Signature)
        else:
            assert False
        self._signature = value

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; SignatureOrMAC:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :return: parsed data object; command-specific: Signature or MAC
        &#34;&#34;&#34;
        if self.key_index == 0:  # TODO check by header
            self._signature = MAC.parse(data, offset)
        else:
            self._signature = Signature.parse(data, offset)
        return self._signature

    @property
    def signature(self) -&gt; Optional[SignatureOrMAC]:
        &#34;&#34;&#34;Signature referenced by `location` attribute.&#34;&#34;&#34;
        return self._signature

    @signature.setter
    def signature(self, value: SignatureOrMAC) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: signature to be installed by the command
        &#34;&#34;&#34;
        self.cmd_data_reference = value

    def __repr__(self) -&gt; str:
        return &#34;CmdAuthData &lt;{}, {}, {}, key:{}, 0x{:X}&gt;&#34;. \
            format(EnumAuthDat[self.flags], EnumEngine[self.engine],  # type: ignore
                   self.engine_cfg, self.key_index, self.location)

    def __len__(self) -&gt; int:
        return len(self._blocks)

    def __getitem__(self, key: int) -&gt; Tuple[int, int]:
        return self._blocks[key]

    def __setitem__(self, key: int, value: Tuple[int, int]) -&gt; None:
        assert isinstance(value, (list, tuple))
        assert len(value) == 2
        self._blocks[key] = value

    def __iter__(self) -&gt; Iterator[Union[Tuple[Any, ...], List[Any]]]:
        return self._blocks.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34; Flag:        {:d} ({})\n&#34;.format(self.flags, EnumAuthDat.desc(self.flags))
        msg += &#34; Key index:   {:d}\n&#34;.format(self.key_index)
        msg += &#34; Engine:      {:d} ({})\n&#34;.format(self.engine, EnumEngine.desc(self.engine))
        msg += &#34; Engine Conf: {:d}\n&#34;.format(self.engine_cfg)
        msg += &#34; Location:    0x{:08X} (Start address of authentication data) \n&#34;.format(self.location)
        if self.signature:
            msg += &#39;[related signature]\n&#39;
            msg += self.signature.info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        for blk in self._blocks:
            msg += &#34;- Start: 0x{0:08X}, Length: {1:d} Bytes\n&#34;.format(blk[0], blk[1])
        return msg

    def append(self, start_address: int, size: int) -&gt; None:
        &#34;&#34;&#34;Append of Authenticate data command.&#34;&#34;&#34;
        self._blocks.append((start_address, size), )
        self._header.length += 8

    def pop(self, index: int) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Pop of Authenticate data command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._blocks)
        value = self._blocks.pop(index)
        self._header.length -= 8
        return value

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Authenticate data command.&#34;&#34;&#34;
        self._blocks.clear()
        self._header.length = self._header.size + 8

    def _cms_signature(self, zulu: datetime, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Sign provided data and return CMS signature.

        :param zulu: current UTC time+date
        :param data: to be signed
        :return: CMS signature (binary)
        &#34;&#34;&#34;
        assert self.certificate is not None
        assert self.private_key_pem_data is not None

        # signed data (main section)
        signed_data = cms.SignedData()
        signed_data[&#39;version&#39;] = &#39;v1&#39;
        signed_data[&#39;encap_content_info&#39;] = util.OrderedDict([
            (&#39;content_type&#39;, &#39;data&#39;)
        ])
        signed_data[&#39;digest_algorithms&#39;] = [util.OrderedDict([
            (&#39;algorithm&#39;, &#39;sha256&#39;),
            (&#39;parameters&#39;, None)])]

        # signer info sub-section
        signer_info = cms.SignerInfo()
        signer_info[&#39;version&#39;] = &#39;v1&#39;
        signer_info[&#39;digest_algorithm&#39;] = util.OrderedDict([
            (&#39;algorithm&#39;, &#39;sha256&#39;),
            (&#39;parameters&#39;, None)])
        signer_info[&#39;signature_algorithm&#39;] = util.OrderedDict([
            (&#39;algorithm&#39;, &#39;rsassa_pkcs1v15&#39;),
            (&#39;parameters&#39;, b&#39;&#39;)])
        # signed identifier: issuer amd serial number
        asn1cert = x509.Certificate.load(self.certificate.public_bytes(Encoding.DER))
        signer_info[&#39;sid&#39;] = cms.SignerIdentifier({
            &#39;issuer_and_serial_number&#39;: cms.IssuerAndSerialNumber({
                &#39;issuer&#39;: asn1cert.issuer,
                &#39;serial_number&#39;: asn1cert.serial_number
            })
        })
        # signed attributes
        signed_attrs = cms.CMSAttributes()
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;content_type&#39;,
            &#39;values&#39;: [cms.ContentType(&#39;data&#39;)],
        }))
        # check time-zone is assigned (expected UTC+0)
        assert zulu.tzinfo
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;signing_time&#39;,
            &#39;values&#39;: [cms.Time(name=&#39;utc_time&#39;, value=zulu.strftime(&#39;%y%m%d%H%M%SZ&#39;))],
        }))
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;message_digest&#39;,
            &#39;values&#39;: [cms.OctetString(crypto_backend().hash(data))],  # digest
        }))
        signer_info[&#39;signed_attrs&#39;] = signed_attrs

        # create signature
        signer_info[&#39;signature&#39;] = crypto_backend().rsa_sign(self.private_key_pem_data, signed_attrs.dump())

        # Adding SignerInfo object to SignedData object
        signed_data[&#39;signer_infos&#39;] = [signer_info]

        # content info
        content_info = cms.ContentInfo()
        content_info[&#39;content_type&#39;] = &#39;signed_data&#39;
        content_info[&#39;content&#39;] = signed_data

        return content_info.dump()

    def update_signature(self, zulu: datetime, data: bytes, base_data_addr: int = 0xFFFFFFFF) -&gt; bool:
        &#34;&#34;&#34;Update signature.

        This method must be called from parent to provide data to be signed

        :param zulu: current UTC time+date
        :param data: currently generated binary data
        :param base_data_addr: base address of the generated data
        :raises ValueError: When certificate or private key are not assigned
        :raises ValueError: When signatures not assigned explicitly
        :return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
                        to data);
        &#34;&#34;&#34;
        if not self.certificate or not self.private_key_pem_data:
            raise ValueError(&#39;certificate or private key not assigned, cannot update signature&#39;)

        if self.signature is None:
            raise ValueError(&#39;signature must be assigned explicitly, so its version matches to CST version&#39;)

        if self._blocks:
            sign_data = b&#39;&#39;
            if data:  # if not data specified, create &#34;fake&#34; signature to update length
                total_len = 0
                for blk in self._blocks:
                    start = blk[0] - base_data_addr
                    end = blk[0] + blk[1] - base_data_addr
                    assert start &gt;= 0
                    assert end &lt;= len(data)
                    sign_data += data[start: end]
                    total_len += blk[1]
                assert len(sign_data) == total_len
        else:
            sign_data = data  # if no blocks defined, sign complete data; used for CSF
        if isinstance(self.signature, Signature):
            new_signature = self._cms_signature(zulu, sign_data)
            result = len(self.signature.data) == len(new_signature)
            self.signature.data = new_signature
        else:
            assert isinstance(self.signature, MAC)
            result = True
        return result

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        self._header.length = self.size
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;4BL&#34;, self.key_index, self.sig_format, self.engine, self.engine_cfg, self.location)
        dbg_info.append_binary_data(&#39;data&#39;, data)
        raw_data += data
        for blk in self._blocks:
            blk_data = pack(&#34;&gt;2L&#34;, blk[0], blk[1])
            dbg_info.append_binary_data(&#39;block&#39;, blk_data)
            raw_data += blk_data
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdAuthData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to read from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.AUT_DAT)
        key, sig_format, eng, cfg, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
        obj = cls(EnumAuthDat.from_int(header.param), key, sig_format, EnumEngine.from_int(eng), cfg, location)
        index = header.size + 8
        while index &lt; header.length:
            start_address, size = unpack_from(&#34;&gt;2L&#34;, data, offset + index)
            obj.append(start_address, size)
            index += 8
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdAuthData.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data:bytes, offset:int=0) ><a title="spsdk.image.commands.CmdAuthData" href="#spsdk.image.commands.CmdAuthData">CmdAuthData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary representation into command (deserialization from binary data).</p>
<p>:param data: being parsed
:param offset: current position to read from data
:return: parse command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdAuthData&#39;:
    &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

    :param data: being parsed
    :param offset: current position to read from data
    :return: parse command
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset, CmdTag.AUT_DAT)
    key, sig_format, eng, cfg, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
    obj = cls(EnumAuthDat.from_int(header.param), key, sig_format, EnumEngine.from_int(eng), cfg, location)
    index = header.size + 8
    while index &lt; header.length:
        start_address, size = unpack_from(&#34;&gt;2L&#34;, data, offset + index)
        obj.append(start_address, size)
        index += 8
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdAuthData.cmd_data_offset"><code class="name">var <span class="ident">cmd_data_offset</span> :int</code></dt>
<dd>
<div class="desc"><p>Offset of an additional data (such as signature or MAC, etc) in binary image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of an additional data (such as signature or MAC, etc) in binary image.&#34;&#34;&#34;
    return self.location</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.cmd_data_reference"><code class="name">var <span class="ident">cmd_data_reference</span> :Union[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>,<a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Reference to an additional data (such as certificate, signature, etc).</p>
<ul>
<li>None if no reference was assigned;</li>
<li>Value type is command-specific</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_reference(self) -&gt; Optional[SignatureOrMAC]:
    &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

    -   None if no reference was assigned;
    -   Value type is command-specific
    &#34;&#34;&#34;
    return self._signature</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.engine"><code class="name">var <span class="ident">engine</span> :<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a></code></dt>
<dd>
<div class="desc"><p>Engine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; EnumEngine:
    &#34;&#34;&#34;Engine.&#34;&#34;&#34;
    return self._engine</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.flags"><code class="name">var <span class="ident">flags</span> :int</code></dt>
<dd>
<div class="desc"><p>Flag of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; int:
    &#34;&#34;&#34;Flag of Authenticate data command.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.key_index"><code class="name">var <span class="ident">key_index</span> :int</code></dt>
<dd>
<div class="desc"><p>Key index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key_index(self) -&gt; int:
    &#34;&#34;&#34;Key index.&#34;&#34;&#34;
    return self._key_index</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.needs_cmd_data_reference"><code class="name">var <span class="ident">needs_cmd_data_reference</span> :bool</code></dt>
<dd>
<div class="desc"><p>Whether the command contains a reference to an additional data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def needs_cmd_data_reference(self) -&gt; bool:
    &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.signature"><code class="name">var <span class="ident">signature</span> :Union[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>,<a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Signature referenced by <code>location</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signature(self) -&gt; Optional[SignatureOrMAC]:
    &#34;&#34;&#34;Signature referenced by `location` attribute.&#34;&#34;&#34;
    return self._signature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdAuthData.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, start_address:int, size:int) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, start_address: int, size: int) -&gt; None:
    &#34;&#34;&#34;Append of Authenticate data command.&#34;&#34;&#34;
    self._blocks.append((start_address, size), )
    self._header.length += 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Authenticate data command.&#34;&#34;&#34;
    self._blocks.clear()
    self._header.length = self._header.size + 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34; Flag:        {:d} ({})\n&#34;.format(self.flags, EnumAuthDat.desc(self.flags))
    msg += &#34; Key index:   {:d}\n&#34;.format(self.key_index)
    msg += &#34; Engine:      {:d} ({})\n&#34;.format(self.engine, EnumEngine.desc(self.engine))
    msg += &#34; Engine Conf: {:d}\n&#34;.format(self.engine_cfg)
    msg += &#34; Location:    0x{:08X} (Start address of authentication data) \n&#34;.format(self.location)
    if self.signature:
        msg += &#39;[related signature]\n&#39;
        msg += self.signature.info()
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    for blk in self._blocks:
        msg += &#34;- Start: 0x{0:08X}, Length: {1:d} Bytes\n&#34;.format(blk[0], blk[1])
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.parse_cmd_data"><code class="name flex">
<span>def <span class="ident">parse_cmd_data</span></span>(<span>self, data:bytes, offset:int) >Union[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>,<a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse additional command data from binary data.</p>
<p>:param data: to be parsed
:param offset: start position in data to parse
:return: parsed data object; command-specific: Signature or MAC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_cmd_data(self, data: bytes, offset: int) -&gt; SignatureOrMAC:
    &#34;&#34;&#34;Parse additional command data from binary data.

    :param data: to be parsed
    :param offset: start position in data to parse
    :return: parsed data object; command-specific: Signature or MAC
    &#34;&#34;&#34;
    if self.key_index == 0:  # TODO check by header
        self._signature = MAC.parse(data, offset)
    else:
        self._signature = Signature.parse(data, offset)
    return self._signature</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index:int) >Tuple[int,int]</span>
</code></dt>
<dd>
<div class="desc"><p>Pop of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Pop of Authenticate data command.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._blocks)
    value = self._blocks.pop(index)
    self._header.length -= 8
    return value</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdAuthData.update_signature"><code class="name flex">
<span>def <span class="ident">update_signature</span></span>(<span>self, zulu:datetime.datetime, data:bytes, base_data_addr:int=4294967295) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update signature.</p>
<p>This method must be called from parent to provide data to be signed</p>
<p>:param zulu: current UTC time+date
:param data: currently generated binary data
:param base_data_addr: base address of the generated data
:raises ValueError: When certificate or private key are not assigned
:raises ValueError: When signatures not assigned explicitly
:return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
to data);</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_signature(self, zulu: datetime, data: bytes, base_data_addr: int = 0xFFFFFFFF) -&gt; bool:
    &#34;&#34;&#34;Update signature.

    This method must be called from parent to provide data to be signed

    :param zulu: current UTC time+date
    :param data: currently generated binary data
    :param base_data_addr: base address of the generated data
    :raises ValueError: When certificate or private key are not assigned
    :raises ValueError: When signatures not assigned explicitly
    :return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
                    to data);
    &#34;&#34;&#34;
    if not self.certificate or not self.private_key_pem_data:
        raise ValueError(&#39;certificate or private key not assigned, cannot update signature&#39;)

    if self.signature is None:
        raise ValueError(&#39;signature must be assigned explicitly, so its version matches to CST version&#39;)

    if self._blocks:
        sign_data = b&#39;&#39;
        if data:  # if not data specified, create &#34;fake&#34; signature to update length
            total_len = 0
            for blk in self._blocks:
                start = blk[0] - base_data_addr
                end = blk[0] + blk[1] - base_data_addr
                assert start &gt;= 0
                assert end &lt;= len(data)
                sign_data += data[start: end]
                total_len += blk[1]
            assert len(sign_data) == total_len
    else:
        sign_data = data  # if no blocks defined, sign complete data; used for CSF
    if isinstance(self.signature, Signature):
        new_signature = self._cms_signature(zulu, sign_data)
        result = len(self.signature.data) == len(new_signature)
        self.signature.data = new_signature
    else:
        assert isinstance(self.signature, MAC)
        result = True
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdBase"><code class="flex name class">
<span>class <span class="ident">CmdBase</span></span>
<span>(</span><span>tag:<a title="spsdk.image.header.CmdTag" href="header.html#spsdk.image.header.CmdTag">CmdTag</a>, param:int, length:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all commands.</p>
<p>Constructor.</p>
<p>:param tag: command tag
:param param: TODO
:param length: of the binary command representation, in bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdBase:
    &#34;&#34;&#34;Base class for all commands.&#34;&#34;&#34;

    def __init__(self, tag: CmdTag, param: int, length: Optional[int] = None):
        &#34;&#34;&#34;Constructor.

        :param tag: command tag
        :param param: TODO
        :param length: of the binary command representation, in bytes
        &#34;&#34;&#34;
        self._header = CmdHeader(tag, param, length)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of command.&#34;&#34;&#34;
        return self._header.length

    @property
    def tag(self) -&gt; CmdTag:
        &#34;&#34;&#34;Command tag.&#34;&#34;&#34;
        return self._header.tag

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command needs a reference to an additional data.

        If returns True, the following methods must be implemented:
        - cmd_data_offset
        - cmd_data_reference
        &#34;&#34;&#34;
        return False  # default implementation

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as certificate, signature, etc) in binary image.&#34;&#34;&#34;
        return 0

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        :raises TypeError: if cmd-data not supported by the command
        &#34;&#34;&#34;
        raise TypeError(&#39;cmd-data not supported by the command&#39;)

    @property
    def cmd_data_reference(self) -&gt; Optional[BaseClass]:
        &#34;&#34;&#34;Reference to a command data (such as certificate, signature, etc).

        None if no reference was assigned;
        Value type is command-specific
        &#34;&#34;&#34;
        return None

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: BaseClass) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference
        Note: the method must be implemented in `self.has_cmd_data_reference` returns True

        :param value: to be set
        :raise TypeError: if reference not supported by the command
        &#34;&#34;&#34;
        raise TypeError(&#39;cmd-data not supported by the command&#39;)

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; Any:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :raises TypeError: if cmd_data is not supported by the command
        &#34;&#34;&#34;
        raise TypeError(&#39;cmd-data not supported by the command&#39;)

    def __eq__(self, other: Any) -&gt; bool:
        return isinstance(other, self.__class__) and vars(other) == vars(self)

    def __ne__(self, other: Any) -&gt; bool:
        return not self.__eq__(other)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text representation of the command.&#34;&#34;&#34;
        return f&#39;Command &#34;{CmdTag.desc(self.tag)}&#34;   [Tag={str(self.tag)}, length={str(self.size)}]\n&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        hdr_data = self._header.export()
        dbg_info.append_binary_data(&#39;header&#39;, hdr_data)
        return hdr_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdBase&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdAuthData" href="#spsdk.image.commands.CmdAuthData">CmdAuthData</a></li>
<li><a title="spsdk.image.commands.CmdCheckData" href="#spsdk.image.commands.CmdCheckData">CmdCheckData</a></li>
<li><a title="spsdk.image.commands.CmdInitialize" href="#spsdk.image.commands.CmdInitialize">CmdInitialize</a></li>
<li><a title="spsdk.image.commands.CmdInstallKey" href="#spsdk.image.commands.CmdInstallKey">CmdInstallKey</a></li>
<li><a title="spsdk.image.commands.CmdNop" href="#spsdk.image.commands.CmdNop">CmdNop</a></li>
<li><a title="spsdk.image.commands.CmdSet" href="#spsdk.image.commands.CmdSet">CmdSet</a></li>
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdWriteData" href="#spsdk.image.commands.CmdWriteData">CmdWriteData</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdBase.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data:bytes, offset:int=0) ><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary representation into command (deserialization from binary data).</p>
<p>:param data: being parsed
:param offset: current position to readd from data
:return: parse command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdBase&#39;:
    &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

    :param data: being parsed
    :param offset: current position to readd from data
    :return: parse command
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdBase.cmd_data_offset"><code class="name">var <span class="ident">cmd_data_offset</span> :int</code></dt>
<dd>
<div class="desc"><p>Offset of an additional data (such as certificate, signature, etc) in binary image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of an additional data (such as certificate, signature, etc) in binary image.&#34;&#34;&#34;
    return 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdBase.cmd_data_reference"><code class="name">var <span class="ident">cmd_data_reference</span> :Union[<a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Reference to a command data (such as certificate, signature, etc).</p>
<p>None if no reference was assigned;
Value type is command-specific</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_reference(self) -&gt; Optional[BaseClass]:
    &#34;&#34;&#34;Reference to a command data (such as certificate, signature, etc).

    None if no reference was assigned;
    Value type is command-specific
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdBase.needs_cmd_data_reference"><code class="name">var <span class="ident">needs_cmd_data_reference</span> :bool</code></dt>
<dd>
<div class="desc"><p>Whether the command needs a reference to an additional data.</p>
<p>If returns True, the following methods must be implemented:
- cmd_data_offset
- cmd_data_reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def needs_cmd_data_reference(self) -&gt; bool:
    &#34;&#34;&#34;Whether the command needs a reference to an additional data.

    If returns True, the following methods must be implemented:
    - cmd_data_offset
    - cmd_data_reference
    &#34;&#34;&#34;
    return False  # default implementation</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdBase.size"><code class="name">var <span class="ident">size</span> :int</code></dt>
<dd>
<div class="desc"><p>Size of command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of command.&#34;&#34;&#34;
    return self._header.length</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdBase.tag"><code class="name">var <span class="ident">tag</span> :<a title="spsdk.image.header.CmdTag" href="header.html#spsdk.image.header.CmdTag">CmdTag</a></code></dt>
<dd>
<div class="desc"><p>Command tag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tag(self) -&gt; CmdTag:
    &#34;&#34;&#34;Command tag.&#34;&#34;&#34;
    return self._header.tag</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdBase.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info:<a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a>=&lt;spsdk.utils.misc.DebugInfo object&gt;) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary form (serialization).</p>
<p>:param dbg_info: debug information about exported data
:return: binary representation of the command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export to binary form (serialization).

    :param dbg_info: debug information about exported data
    :return: binary representation of the command
    &#34;&#34;&#34;
    hdr_data = self._header.export()
    dbg_info.append_binary_data(&#39;header&#39;, hdr_data)
    return hdr_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdBase.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text representation of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text representation of the command.&#34;&#34;&#34;
    return f&#39;Command &#34;{CmdTag.desc(self.tag)}&#34;   [Tag={str(self.tag)}, length={str(self.size)}]\n&#39;</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdBase.parse_cmd_data"><code class="name flex">
<span>def <span class="ident">parse_cmd_data</span></span>(<span>self, data:bytes, offset:int) >Any</span>
</code></dt>
<dd>
<div class="desc"><p>Parse additional command data from binary data.</p>
<p>:param data: to be parsed
:param offset: start position in data to parse
:raises TypeError: if cmd_data is not supported by the command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_cmd_data(self, data: bytes, offset: int) -&gt; Any:
    &#34;&#34;&#34;Parse additional command data from binary data.

    :param data: to be parsed
    :param offset: start position in data to parse
    :raises TypeError: if cmd_data is not supported by the command
    &#34;&#34;&#34;
    raise TypeError(&#39;cmd-data not supported by the command&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.commands.CmdCheckData"><code class="flex name class">
<span>class <span class="ident">CmdCheckData</span></span>
<span>(</span><span>numbytes:int=4, ops:int=1, address:int=0, mask:int=0, count:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check data command.</p>
<p>Initialize the check data command.</p>
<p>:param numbytes: number of bytes
:param ops: type of
operation
:param address: list of tuples: address and value
:param mask: mask value
:param count: count value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdCheckData(CmdBase):
    &#34;&#34;&#34;Check data command.&#34;&#34;&#34;

    @property
    def num_bytes(self) -&gt; int:
        &#34;&#34;&#34;Number of bytes.&#34;&#34;&#34;
        return self._header.param &amp; 0x7

    @num_bytes.setter
    def num_bytes(self, value: int) -&gt; None:
        assert value in (1, 2, 4)
        self._header.param &amp;= ~0x7
        self._header.param |= int(value)

    @property
    def ops(self) -&gt; int:
        &#34;&#34;&#34;Operation of Check data command.&#34;&#34;&#34;
        return (self._header.param &gt;&gt; 3) &amp; 0x3

    @ops.setter
    def ops(self, value: int) -&gt; None:
        assert value in EnumCheckOps
        self._header.param &amp;= ~(0x3 &lt;&lt; 3)
        self._header.param |= int(value) &lt;&lt; 3

    def __init__(self, numbytes: int = 4, ops: int = EnumCheckOps.ALL_SET, address: int = 0, mask: int = 0,
                 count: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize the check data command.

        :param numbytes: number of bytes
        :param ops: type of  operation
        :param address: list of tuples: address and value
        :param mask: mask value
        :param count: count value
        &#34;&#34;&#34;
        assert numbytes in (1, 2, 4)
        assert ops in EnumCheckOps
        super().__init__(CmdTag.CHK_DAT, ((int(ops) &amp; 0x3) &lt;&lt; 3) | (numbytes &amp; 0x7))
        self.address = address
        self.mask = mask
        self.count = count
        # the length of &#39;address&#39;(4B), &#39;mask&#39;(4B) and count(0 or 4B)  need to be added into Header.length
        self._header.length += 4 + 4 + (4 if count else 0)

    def __repr__(self) -&gt; str:
        return &#34;CmdCheckData &lt;{}/{}, ADDR=0x{:X}, MASK=0x{:X}&gt;&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                       self.num_bytes, self.address, self.mask)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Check Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                        self.num_bytes)
        msg += &#34;- Address: 0x{0:08X}, Mask: 0x{1:08X}&#34;.format(self.address, self.mask)
        if self.count:
            msg += &#34;, Count: {0:d}&#34;.format(self.count)
        msg += &#34;\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        raw_data += pack(&#34;&gt;LL&#34;, self.address, self.mask)
        if self.count is not None:
            raw_data += pack(&#34;&gt;L&#34;, self.count)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCheckData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.CHK_DAT)
        numbytes = header.param &amp; 0x7
        ops = (header.param &gt;&gt; 3) &amp; 0x3
        address, mask = unpack_from(&#34;&gt;LL&#34;, data, offset + header.size)
        count = None
        if (header.length - header.size) &gt; 8:
            count = unpack_from(&#34;&gt;L&#34;, data, offset + header.size + 8)[0]
        return cls(numbytes, ops, address, mask, count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdCheckData.num_bytes"><code class="name">var <span class="ident">num_bytes</span> :int</code></dt>
<dd>
<div class="desc"><p>Number of bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_bytes(self) -&gt; int:
    &#34;&#34;&#34;Number of bytes.&#34;&#34;&#34;
    return self._header.param &amp; 0x7</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdCheckData.ops"><code class="name">var <span class="ident">ops</span> :int</code></dt>
<dd>
<div class="desc"><p>Operation of Check data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ops(self) -&gt; int:
    &#34;&#34;&#34;Operation of Check data command.&#34;&#34;&#34;
    return (self._header.param &gt;&gt; 3) &amp; 0x3</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdCheckData.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Check Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                    self.num_bytes)
    msg += &#34;- Address: 0x{0:08X}, Mask: 0x{1:08X}&#34;.format(self.address, self.mask)
    if self.count:
        msg += &#34;, Count: {0:d}&#34;.format(self.count)
    msg += &#34;\n&#34;
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdInitialize"><code class="flex name class">
<span>class <span class="ident">CmdInitialize</span></span>
<span>(</span><span>engine:int=0, data:List[int]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize command.</p>
<p>Initialize the initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdInitialize(CmdBase):
    &#34;&#34;&#34;Initialize command.&#34;&#34;&#34;

    @property
    def engine(self) -&gt; int:
        &#34;&#34;&#34;Engine.&#34;&#34;&#34;
        return self._header.param

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._header.param = value

    def __init__(self, engine: int = EnumEngine.ANY, data: List[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize the initialize command.&#34;&#34;&#34;
        assert engine in EnumEngine
        super().__init__(CmdTag.INIT, engine)
        self._data = data if data else []

    def __repr__(self) -&gt; str:
        return &#34;CmdInitialize &lt;{}, {}&gt;&#34;.format(EnumEngine[self.engine], len(self._data))  # type: ignore

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; int:
        return self._data[key]

    def __setitem__(self, key: int, value: int) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[int]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Initialize Command (Engine: {0:s})\n&#34;.format(EnumEngine[self.engine])  # type: ignore
        cnt = 0
        for val in self._data:
            msg += &#34; {0:02d}) Value: 0x{1:08X}\n&#34;.format(cnt, val)
            cnt += 1
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def append(self, value: int) -&gt; None:
        &#34;&#34;&#34;Appending of Initialize command.&#34;&#34;&#34;
        assert isinstance(value, int), &#34;value must be INT type&#34;
        assert 0 &lt;= value &lt; 0xFFFFFFFF, &#34;value out of range&#34;
        self._data.append(value)
        self._header.length += 4

    def pop(self, index: int) -&gt; int:
        &#34;&#34;&#34;Pop of Initialize command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._data)
        val = self._data.pop(index)
        self._header.length -= 4
        return val

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Initialize command.&#34;&#34;&#34;
        self._data.clear()
        self._header.length = self._header.size

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        for val in self._data:
            raw_data += pack(&#34;&gt;L&#34;, val)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdInitialize&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.INIT)
        obj = cls(EnumEngine.from_int(header.param))
        index = header.size
        while index &lt; header.length:
            assert (offset + index) &lt; len(data)
            val = unpack_from(&#34;&gt;L&#34;, data, offset + index)
            obj.append(val[0])
            index += 4
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdInitialize.engine"><code class="name">var <span class="ident">engine</span> :int</code></dt>
<dd>
<div class="desc"><p>Engine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; int:
    &#34;&#34;&#34;Engine.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdInitialize.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value:int) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Appending of Initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value: int) -&gt; None:
    &#34;&#34;&#34;Appending of Initialize command.&#34;&#34;&#34;
    assert isinstance(value, int), &#34;value must be INT type&#34;
    assert 0 &lt;= value &lt; 0xFFFFFFFF, &#34;value out of range&#34;
    self._data.append(value)
    self._header.length += 4</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInitialize.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Initialize command.&#34;&#34;&#34;
    self._data.clear()
    self._header.length = self._header.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInitialize.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Initialize Command (Engine: {0:s})\n&#34;.format(EnumEngine[self.engine])  # type: ignore
    cnt = 0
    for val in self._data:
        msg += &#34; {0:02d}) Value: 0x{1:08X}\n&#34;.format(cnt, val)
        cnt += 1
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInitialize.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index:int) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Pop of Initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; int:
    &#34;&#34;&#34;Pop of Initialize command.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._data)
    val = self._data.pop(index)
    self._header.length -= 4
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey"><code class="flex name class">
<span>class <span class="ident">CmdInstallKey</span></span>
<span>(</span><span>flags:<a title="spsdk.image.commands.EnumInsKey" href="#spsdk.image.commands.EnumInsKey">EnumInsKey</a>=0, cert_fmt:<a title="spsdk.image.commands.EnumCertFormat" href="#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a>=3, hash_alg:<a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a>=0, src_index:int=0, tgt_index:int=0, location:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Install key command.</p>
<p>Constructor.</p>
<p>:param flags: from EnumInsKey
:param cert_fmt: format of the certificate; key authentication protocol
:param hash_alg: hash algorithm
:param src_index: source key (verification key, KEK) index
:param tgt_index: target key index
:param location: start address of an additional data such as KEY to be installed;
Typically it is relative to CSF start; Might be absolute for DEK key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdInstallKey(CmdBase):
    &#34;&#34;&#34;Install key command.&#34;&#34;&#34;

    def __init__(self, flags: EnumInsKey = EnumInsKey.CLR, cert_fmt: EnumCertFormat = EnumCertFormat.SRK,
                 hash_alg: EnumAlgorithm = EnumAlgorithm.ANY, src_index: int = 0, tgt_index: int = 0,
                 location: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param flags: from EnumInsKey
        :param cert_fmt: format of the certificate; key authentication protocol
        :param hash_alg: hash algorithm
        :param src_index: source key (verification key, KEK) index
        :param tgt_index: target key index
        :param location: start address of an additional data such as KEY to be installed;
                Typically it is relative to CSF start; Might be absolute for DEK key
        &#34;&#34;&#34;
        super().__init__(CmdTag.INS_KEY, flags)
        self._cert_fmt: EnumCertFormat = cert_fmt
        self.hash_algorithm: EnumAlgorithm = hash_alg
        self.source_index = src_index
        self.target_index = tgt_index
        self.cmd_data_location = location
        self._header.length = CmdHeader.SIZE + 8
        self._certificate_ref: Optional[Union[CertificateImg, SrkTable]] = None

    @property
    def flags(self) -&gt; EnumInsKey:
        &#34;&#34;&#34;Flags.&#34;&#34;&#34;
        return EnumInsKey.from_int(self._header.param)

    @flags.setter
    def flags(self, value: EnumInsKey) -&gt; None:
        assert value in EnumInsKey
        self._header.param = value

    @property
    def certificate_format(self) -&gt; EnumCertFormat:
        &#34;&#34;&#34;Certificate format.&#34;&#34;&#34;
        return self._cert_fmt

    @certificate_format.setter
    def certificate_format(self, value: EnumCertFormat) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: certificate format
        &#34;&#34;&#34;
        assert value in EnumCertFormat
        self._cert_fmt = value

    @property
    def hash_algorithm(self) -&gt; EnumAlgorithm:
        &#34;&#34;&#34;Hash algorithm.&#34;&#34;&#34;
        return self._hash_alg

    @hash_algorithm.setter
    def hash_algorithm(self, value: EnumAlgorithm) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: hash algorithm
        &#34;&#34;&#34;
        assert value in EnumAlgorithm
        self._hash_alg = value

    @property
    def source_index(self) -&gt; int:
        &#34;&#34;&#34;Source key (verification key, KEK) index.

        - For SRK, it is index of the SRK key (0-3)
        - For other keys it is index of previously installed target key, typically 0
        &#34;&#34;&#34;
        return self._src_index

    @source_index.setter
    def source_index(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: source key (verification key, KEK) index
        &#34;&#34;&#34;
        if self._cert_fmt == EnumCertFormat.SRK:
            assert value in (0, 1, 2, 3)  # RT10xx supports just 4 SRK keys; this might need update for other devices
        else:
            assert value in (0, 2, 3, 4, 5)
        self._src_index = value

    @property
    def target_index(self) -&gt; int:
        &#34;&#34;&#34;Target key index.&#34;&#34;&#34;
        return self._tgt_index

    @target_index.setter
    def target_index(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: target key index
        &#34;&#34;&#34;
        assert value in (0, 1, 2, 3, 4, 5)
        self._tgt_index = value

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as certificate, signature, etc) in binary image.&#34;&#34;&#34;
        return self.cmd_data_location

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        &#34;&#34;&#34;
        self.cmd_data_location = value

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
        if self.flags == EnumInsKey.ABS:  # reference is an absolute address; instance not assigned; used for DEK key
            assert self._certificate_ref is None
            return False
        return True

    @property
    def cmd_data_reference(self) -&gt; Optional[Union[CertificateImg, SrkTable]]:
        &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

        None if no reference was assigned;
        Value type is command-specific
        &#34;&#34;&#34;
        return self._certificate_ref

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: Union[CertificateImg, SrkTable]) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference

        :param value: to be set
        :raise ValueError: if cmd reference not supported by the command
        &#34;&#34;&#34;
        assert isinstance(value, (CertificateImg, SrkTable))
        self._certificate_ref = value

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; Union[CertificateImg, SrkTable, None]:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :return: parsed data object; command-specific: certificate or SrkTable to be installed
        &#34;&#34;&#34;
        if self.certificate_format == EnumCertFormat.SRK:
            result: Union[CertificateImg, SrkTable] = SrkTable.parse(data, offset)
        else:
            result = CertificateImg.parse(data, offset)
        self.cmd_data_reference = result
        return result

    @property
    def certificate_ref(self) -&gt; Union[CertificateImg, SrkTable, None]:
        &#34;&#34;&#34;Corresponding certificate referenced by key-location.&#34;&#34;&#34;
        return self._certificate_ref

    @certificate_ref.setter
    def certificate_ref(self, value: Union[CertificateImg, SrkTable]) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: certificate to be installed by the command
        &#34;&#34;&#34;
        self._certificate_ref = value

    def __repr__(self) -&gt; str:
        return &#34;CmdInstallKey &lt;{}, {}, {}, {}, {}, 0x{:X}&gt;&#34;. \
            format(EnumInsKey[self.flags], EnumCertFormat[self.certificate_format],  # type: ignore
                   EnumAlgorithm[self.hash_algorithm],  # type: ignore
                   self.source_index, self.target_index, self.cmd_data_location)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34; Flag      : {:d} ({})\n&#34;.format(self.flags, EnumInsKey.desc(self.flags))
        msg += &#34; CertFormat: {:d} ({})\n&#34;.format(self.certificate_format,
                                                 EnumCertFormat.desc(self.certificate_format))  # type: ignore
        msg += &#34; Algorithm : {:d} ({})\n&#34;.format(self.hash_algorithm,
                                                 EnumAlgorithm.desc(self.hash_algorithm))  # type: ignore
        msg += &#34; SrcKeyIdx : {:d} (Source key index) \n&#34;.format(self.source_index)
        msg += &#34; TgtKeyIdx : {:d} (Target key index) \n&#34;.format(self.target_index)
        msg += &#34; Location  : 0x{:08X} (Start address of certificate(s) to install) \n&#34;.format(self.cmd_data_location)
        if self.certificate_ref:
            msg += &#39;[related-certificate]\n&#39;
            msg += self.certificate_ref.info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;4BL&#34;, self.certificate_format, self.hash_algorithm, self.source_index, self.target_index,
                    self.cmd_data_location)
        raw_data += data
        dbg_info.append_binary_data(&#39;data&#39;, data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; CmdBase:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to read from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.INS_KEY)
        protocol, algorithm, src_index, tgt_index, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
        return cls(EnumInsKey.from_int(header.param), protocol, algorithm, src_index, tgt_index, location)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdInstallKey.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data:bytes, offset:int=0) ><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary representation into command (deserialization from binary data).</p>
<p>:param data: being parsed
:param offset: current position to read from data
:return: parse command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; CmdBase:
    &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

    :param data: being parsed
    :param offset: current position to read from data
    :return: parse command
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset, CmdTag.INS_KEY)
    protocol, algorithm, src_index, tgt_index, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
    return cls(EnumInsKey.from_int(header.param), protocol, algorithm, src_index, tgt_index, location)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdInstallKey.certificate_format"><code class="name">var <span class="ident">certificate_format</span> :<a title="spsdk.image.commands.EnumCertFormat" href="#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a></code></dt>
<dd>
<div class="desc"><p>Certificate format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def certificate_format(self) -&gt; EnumCertFormat:
    &#34;&#34;&#34;Certificate format.&#34;&#34;&#34;
    return self._cert_fmt</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.certificate_ref"><code class="name">var <span class="ident">certificate_ref</span> :Union[<a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a>,<a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Corresponding certificate referenced by key-location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def certificate_ref(self) -&gt; Union[CertificateImg, SrkTable, None]:
    &#34;&#34;&#34;Corresponding certificate referenced by key-location.&#34;&#34;&#34;
    return self._certificate_ref</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.cmd_data_reference"><code class="name">var <span class="ident">cmd_data_reference</span> :Union[<a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a>,<a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Reference to an additional data (such as certificate, signature, etc).</p>
<p>None if no reference was assigned;
Value type is command-specific</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_reference(self) -&gt; Optional[Union[CertificateImg, SrkTable]]:
    &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

    None if no reference was assigned;
    Value type is command-specific
    &#34;&#34;&#34;
    return self._certificate_ref</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.flags"><code class="name">var <span class="ident">flags</span> :<a title="spsdk.image.commands.EnumInsKey" href="#spsdk.image.commands.EnumInsKey">EnumInsKey</a></code></dt>
<dd>
<div class="desc"><p>Flags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; EnumInsKey:
    &#34;&#34;&#34;Flags.&#34;&#34;&#34;
    return EnumInsKey.from_int(self._header.param)</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.hash_algorithm"><code class="name">var <span class="ident">hash_algorithm</span> :<a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a></code></dt>
<dd>
<div class="desc"><p>Hash algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hash_algorithm(self) -&gt; EnumAlgorithm:
    &#34;&#34;&#34;Hash algorithm.&#34;&#34;&#34;
    return self._hash_alg</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.needs_cmd_data_reference"><code class="name">var <span class="ident">needs_cmd_data_reference</span> :bool</code></dt>
<dd>
<div class="desc"><p>Whether the command contains a reference to an additional data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def needs_cmd_data_reference(self) -&gt; bool:
    &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
    if self.flags == EnumInsKey.ABS:  # reference is an absolute address; instance not assigned; used for DEK key
        assert self._certificate_ref is None
        return False
    return True</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.source_index"><code class="name">var <span class="ident">source_index</span> :int</code></dt>
<dd>
<div class="desc"><p>Source key (verification key, KEK) index.</p>
<ul>
<li>For SRK, it is index of the SRK key (0-3)</li>
<li>For other keys it is index of previously installed target key, typically 0</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source_index(self) -&gt; int:
    &#34;&#34;&#34;Source key (verification key, KEK) index.

    - For SRK, it is index of the SRK key (0-3)
    - For other keys it is index of previously installed target key, typically 0
    &#34;&#34;&#34;
    return self._src_index</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.target_index"><code class="name">var <span class="ident">target_index</span> :int</code></dt>
<dd>
<div class="desc"><p>Target key index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def target_index(self) -&gt; int:
    &#34;&#34;&#34;Target key index.&#34;&#34;&#34;
    return self._tgt_index</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdInstallKey.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34; Flag      : {:d} ({})\n&#34;.format(self.flags, EnumInsKey.desc(self.flags))
    msg += &#34; CertFormat: {:d} ({})\n&#34;.format(self.certificate_format,
                                             EnumCertFormat.desc(self.certificate_format))  # type: ignore
    msg += &#34; Algorithm : {:d} ({})\n&#34;.format(self.hash_algorithm,
                                             EnumAlgorithm.desc(self.hash_algorithm))  # type: ignore
    msg += &#34; SrcKeyIdx : {:d} (Source key index) \n&#34;.format(self.source_index)
    msg += &#34; TgtKeyIdx : {:d} (Target key index) \n&#34;.format(self.target_index)
    msg += &#34; Location  : 0x{:08X} (Start address of certificate(s) to install) \n&#34;.format(self.cmd_data_location)
    if self.certificate_ref:
        msg += &#39;[related-certificate]\n&#39;
        msg += self.certificate_ref.info()
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdInstallKey.parse_cmd_data"><code class="name flex">
<span>def <span class="ident">parse_cmd_data</span></span>(<span>self, data:bytes, offset:int) >Union[<a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a>,<a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>,NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse additional command data from binary data.</p>
<p>:param data: to be parsed
:param offset: start position in data to parse
:return: parsed data object; command-specific: certificate or SrkTable to be installed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_cmd_data(self, data: bytes, offset: int) -&gt; Union[CertificateImg, SrkTable, None]:
    &#34;&#34;&#34;Parse additional command data from binary data.

    :param data: to be parsed
    :param offset: start position in data to parse
    :return: parsed data object; command-specific: certificate or SrkTable to be installed
    &#34;&#34;&#34;
    if self.certificate_format == EnumCertFormat.SRK:
        result: Union[CertificateImg, SrkTable] = SrkTable.parse(data, offset)
    else:
        result = CertificateImg.parse(data, offset)
    self.cmd_data_reference = result
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdNop"><code class="flex name class">
<span>class <span class="ident">CmdNop</span></span>
<span>(</span><span>param:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Nop command.</p>
<p>Initialize the nop command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdNop(CmdBase):
    &#34;&#34;&#34;Nop command.&#34;&#34;&#34;

    def __init__(self, param: int = 0):
        &#34;&#34;&#34;Initialize the nop command.&#34;&#34;&#34;
        super().__init__(CmdTag.NOP, param)

    def __repr__(self) -&gt; str:
        return &#34;CmdNop&#34;

    def __eq__(self, cmd: Any) -&gt; bool:
        if not isinstance(cmd, CmdNop):
            return False
        return True

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.NOP)
        if header.length != header.size:
            pass
        return cls(header.param)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdNop.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdSet"><code class="flex name class">
<span>class <span class="ident">CmdSet</span></span>
<span>(</span><span>itm:<a title="spsdk.image.commands.EnumItm" href="#spsdk.image.commands.EnumItm">EnumItm</a>=3, hash_alg:<a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a>=0, engine:<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a>=0, engine_cfg:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set command.</p>
<p>Initialize the set command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdSet(CmdBase):
    &#34;&#34;&#34;Set command.&#34;&#34;&#34;

    @property
    def itm(self) -&gt; int:
        &#34;&#34;&#34;Item of Set command.&#34;&#34;&#34;
        return self._header.param

    @itm.setter
    def itm(self, value: EnumItm) -&gt; None:
        assert value in EnumItm
        self._header.param = value

    @property
    def hash_algorithm(self) -&gt; EnumAlgorithm:
        &#34;&#34;&#34;Type of hash algorithm.&#34;&#34;&#34;
        return self._hash_alg

    @hash_algorithm.setter
    def hash_algorithm(self, value: EnumAlgorithm) -&gt; None:
        assert value in EnumAlgorithm
        self._hash_alg = value

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
        return self._engine

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._engine = value

    def __init__(self, itm: EnumItm = EnumItm.ENG, hash_alg: EnumAlgorithm = EnumAlgorithm.ANY,
                 engine: EnumEngine = EnumEngine.ANY, engine_cfg: int = 0):
        &#34;&#34;&#34;Initialize the set command.&#34;&#34;&#34;
        assert itm in EnumItm
        super().__init__(CmdTag.SET, itm)
        self.hash_algorithm: EnumAlgorithm = hash_alg
        self.engine = engine
        self.engine_cfg = engine_cfg
        self._header.length = CmdHeader.SIZE + 4

    def __repr__(self) -&gt; str:
        return &#34;CmdSet &lt;{}, {}, {}, eng_cfg=0x{:X}&gt;&#34;.format(
            EnumItm.name(self.itm), EnumAlgorithm.name(self.hash_algorithm), EnumEngine.name(self.engine),
            self.engine_cfg
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Set Command ITM : {EnumItm.name(self.itm)}\n&#34;
        msg += f&#34;HASH Algo      : {self.hash_algorithm} ({EnumAlgorithm.desc(self.hash_algorithm)})\n&#34;
        msg += f&#34;Engine         : {self.engine} ({EnumEngine.desc(self.engine)})\n&#34;
        msg += f&#34;Engine Conf    : {hex(self.engine_cfg)})\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        raw_data += pack(&#34;4B&#34;, 0x00, self.hash_algorithm, self.engine, self.engine_cfg)
        dbg_info.append_binary_data(&#39;data&#39;, raw_data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdSet&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.SET)
        (_, alg, eng, cfg) = unpack_from(&#34;4B&#34;, data, offset + CmdHeader.SIZE)
        return CmdSet(EnumItm.from_int(header.param), EnumAlgorithm.from_int(alg), EnumEngine.from_int(eng), cfg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdSet.engine"><code class="name">var <span class="ident">engine</span> :<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a></code></dt>
<dd>
<div class="desc"><p>Engine plugin tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; EnumEngine:
    &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
    return self._engine</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdSet.hash_algorithm"><code class="name">var <span class="ident">hash_algorithm</span> :<a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a></code></dt>
<dd>
<div class="desc"><p>Type of hash algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hash_algorithm(self) -&gt; EnumAlgorithm:
    &#34;&#34;&#34;Type of hash algorithm.&#34;&#34;&#34;
    return self._hash_alg</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdSet.itm"><code class="name">var <span class="ident">itm</span> :int</code></dt>
<dd>
<div class="desc"><p>Item of Set command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def itm(self) -&gt; int:
    &#34;&#34;&#34;Item of Set command.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdSet.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Set Command ITM : {EnumItm.name(self.itm)}\n&#34;
    msg += f&#34;HASH Algo      : {self.hash_algorithm} ({EnumAlgorithm.desc(self.hash_algorithm)})\n&#34;
    msg += f&#34;Engine         : {self.engine} ({EnumEngine.desc(self.engine)})\n&#34;
    msg += f&#34;Engine Conf    : {hex(self.engine_cfg)})\n&#34;
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdUnlock"><code class="flex name class">
<span>class <span class="ident">CmdUnlock</span></span>
<span>(</span><span>engine:<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a>=0, features:int=0, uid:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic unlock engine command.</p>
<p>Constructor.</p>
<p>:param engine: to be unlocked
:param features: mask of features to use by the engine
:param uid: Unique ID (if needed)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlock(CmdUnlockAbstract):
    &#34;&#34;&#34;Generic unlock engine command.&#34;&#34;&#34;

    def __init__(self, engine: EnumEngine = EnumEngine.ANY, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Constructor.

        :param engine: to be unlocked
        :param features: mask of features to use by the engine
        :param uid: Unique ID (if needed)
        &#34;&#34;&#34;
        super().__init__(engine, features, uid=uid)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Features: {})\n&#34;.format(self.features)
        msg += &#34;UID:      {})\n&#34;.format(self.uid)
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdUnlockAbstract"><code class="flex name class">
<span>class <span class="ident">CmdUnlockAbstract</span></span>
<span>(</span><span>engine:<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a>=0, features:int=0, uid:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract unlock engine command; the command depends on engine type.</p>
<p>Constructor.</p>
<p>:param engine: to be unlocked
:param features: engine specific features
:param uid: Unique ID required by some engine/feature combinations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockAbstract(CmdBase, ABC):
    &#34;&#34;&#34;Abstract unlock engine command; the command depends on engine type.&#34;&#34;&#34;

    def __init__(self, engine: EnumEngine = EnumEngine.ANY, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Constructor.

        :param engine: to be unlocked
        :param features: engine specific features
        :param uid: Unique ID required by some engine/feature combinations
        &#34;&#34;&#34;
        super().__init__(CmdTag.UNLK, EnumEngine.from_int(engine), length=8)
        self.features = features
        self.uid = uid
        if self._need_uid:
            self._header.length += 8

    def __iter__(self) -&gt; Iterator[int]:
        return self.__iter__()

    def __repr__(self) -&gt; str:
        return &#34;{} &lt;{}, {}, {}&gt;&#34;.format(
            self.__class__.__name__,
            EnumEngine.desc(self.engine), self.features, self.uid
        )

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine to be unlocked.

        The term `engine` denotes a peripheral involved in one or more of the following functions:
        - cryptographic computation
        - security state management
        - security alarm handling
        - access control
        &#34;&#34;&#34;
        return EnumEngine.from_int(self._header.param)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = super().info()
        msg += &#34;Unlock Command\n&#34;
        msg += f&#34;Engine : {EnumEngine.desc(self.engine)}\n&#34;
        return msg

    @property
    def _need_uid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        return self.need_uid(self.engine, self.features)

    @staticmethod
    def need_uid(engine: EnumEngine, features: int) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        overall_condition = False
        ocotp_condition = (engine == EnumEngine.OCOTP and bool(features &amp; 0b1101))
        overall_condition |= ocotp_condition
        return overall_condition

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdUnlockAbstract&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: Unlock command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.UNLK)
        features = unpack_from(&#34;&gt;L&#34;, data, offset + header.size)[0]
        engine = EnumEngine.from_int(header.param)
        uid = 0
        if cls.need_uid(engine, features):
            uid = unpack_from(&#34;&gt;Q&#34;, data, offset + header.size + 4)[0]

        if engine == EnumEngine.SNVS:
            return CmdUnlockSNVS(features)
        if engine == EnumEngine.CAAM:
            return CmdUnlockCAAM(features)
        if engine == EnumEngine.OCOTP:
            return CmdUnlockOCOTP(features, uid)
        return CmdUnlock(engine, features, uid)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        # assert self.size == CmdHeader.SIZE + 4
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;L&#34;, self.features)
        dbg_info.append_binary_data(&#39;features&#39;, data)
        raw_data += data
        if self._need_uid:
            data = pack(&#34;&gt;Q&#34;, self.uid)
            dbg_info.append_binary_data(&#39;uid&#39;, data)
            raw_data += data
        return raw_data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlock" href="#spsdk.image.commands.CmdUnlock">CmdUnlock</a></li>
<li><a title="spsdk.image.commands.CmdUnlockCAAM" href="#spsdk.image.commands.CmdUnlockCAAM">CmdUnlockCAAM</a></li>
<li><a title="spsdk.image.commands.CmdUnlockOCOTP" href="#spsdk.image.commands.CmdUnlockOCOTP">CmdUnlockOCOTP</a></li>
<li><a title="spsdk.image.commands.CmdUnlockSNVS" href="#spsdk.image.commands.CmdUnlockSNVS">CmdUnlockSNVS</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockAbstract.need_uid"><code class="name flex">
<span>def <span class="ident">need_uid</span></span>(<span>engine:<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a>, features:int) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if given Engine and Feature requires UID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def need_uid(engine: EnumEngine, features: int) -&gt; bool:
    &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
    overall_condition = False
    ocotp_condition = (engine == EnumEngine.OCOTP and bool(features &amp; 0b1101))
    overall_condition |= ocotp_condition
    return overall_condition</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockAbstract.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data:bytes, offset:int=0) ><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary representation into command (deserialization from binary data).</p>
<p>:param data: being parsed
:param offset: current position to readd from data
:return: Unlock command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdUnlockAbstract&#39;:
    &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

    :param data: being parsed
    :param offset: current position to readd from data
    :return: Unlock command
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset, CmdTag.UNLK)
    features = unpack_from(&#34;&gt;L&#34;, data, offset + header.size)[0]
    engine = EnumEngine.from_int(header.param)
    uid = 0
    if cls.need_uid(engine, features):
        uid = unpack_from(&#34;&gt;Q&#34;, data, offset + header.size + 4)[0]

    if engine == EnumEngine.SNVS:
        return CmdUnlockSNVS(features)
    if engine == EnumEngine.CAAM:
        return CmdUnlockCAAM(features)
    if engine == EnumEngine.OCOTP:
        return CmdUnlockOCOTP(features, uid)
    return CmdUnlock(engine, features, uid)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockAbstract.engine"><code class="name">var <span class="ident">engine</span> :<a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a></code></dt>
<dd>
<div class="desc"><p>Engine to be unlocked.</p>
<p>The term <code>engine</code> denotes a peripheral involved in one or more of the following functions:
- cryptographic computation
- security state management
- security alarm handling
- access control</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; EnumEngine:
    &#34;&#34;&#34;Engine to be unlocked.

    The term `engine` denotes a peripheral involved in one or more of the following functions:
    - cryptographic computation
    - security state management
    - security alarm handling
    - access control
    &#34;&#34;&#34;
    return EnumEngine.from_int(self._header.param)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockAbstract.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = super().info()
    msg += &#34;Unlock Command\n&#34;
    msg += f&#34;Engine : {EnumEngine.desc(self.engine)}\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdUnlockCAAM"><code class="flex name class">
<span>class <span class="ident">CmdUnlockCAAM</span></span>
<span>(</span><span>features:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Unlock for Cryptographic Acceleration and Assurance Module .</p>
<p>Initialize.</p>
<p>:param features: mask of FEATURE_UNLOCK_ constants, defaults to 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockCAAM(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock for Cryptographic Acceleration and Assurance Module .&#34;&#34;&#34;
    # Leave Job Ring and DECO Master IP unlocked
    FEATURE_UNLOCK_MID = 1
    # Leave RNG unititialized
    FEATURE_UNLOCK_RNG = 2
    # Keep manufacturing protection key in internal memory
    FEATURE_UNLOCK_MFG = 4

    def __init__(self, features: int = 0):
        &#34;&#34;&#34;Initialize.

        :param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
        &#34;&#34;&#34;
        super().__init__(EnumEngine.CAAM, features)

    @property
    def unlock_mid(self) -&gt; bool:
        &#34;&#34;&#34;Leave Job Ring and DECO master ID registers unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_MID != 0

    @property
    def unlock_rng(self) -&gt; bool:
        &#34;&#34;&#34;Leave RNG un-instantiated.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_RNG != 0

    @property
    def unlock_mfg(self) -&gt; bool:
        &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_MFG != 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;MID : {self.unlock_mid}\n&#34;
        msg += f&#34;RNG : {self.unlock_rng}\n&#34;
        msg += f&#34;MFG : {self.unlock_mfg}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_MFG"><code class="name">var <span class="ident">FEATURE_UNLOCK_MFG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_MID"><code class="name">var <span class="ident">FEATURE_UNLOCK_MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_RNG"><code class="name">var <span class="ident">FEATURE_UNLOCK_RNG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockCAAM.unlock_mfg"><code class="name">var <span class="ident">unlock_mfg</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave Zero is able Master Key write unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_mfg(self) -&gt; bool:
    &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_MFG != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockCAAM.unlock_mid"><code class="name">var <span class="ident">unlock_mid</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave Job Ring and DECO master ID registers unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_mid(self) -&gt; bool:
    &#34;&#34;&#34;Leave Job Ring and DECO master ID registers unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_MID != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockCAAM.unlock_rng"><code class="name">var <span class="ident">unlock_rng</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave RNG un-instantiated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_rng(self) -&gt; bool:
    &#34;&#34;&#34;Leave RNG un-instantiated.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_RNG != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP"><code class="flex name class">
<span>class <span class="ident">CmdUnlockOCOTP</span></span>
<span>(</span><span>features:int=0, uid:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Unlock for On-Chip One-time programable memory (fuses).</p>
<p>Initialize.</p>
<p>:param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
:param uid: Unique ID required by some engine/feature combinations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockOCOTP(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock for On-Chip One-time programable memory (fuses).&#34;&#34;&#34;
    #pylint: disable = bad-whitespace
    # Leave Field Return activation unlocked.
    FEATURE_UNLOCK_FLD_RTN  = 1
    # Leave SRK revocation unlocked.
    FEATURE_UNLOCK_SRK_RVK  = 2
    # Leave SCS register unlocked.
    FEATURE_UNLOCK_SCS      = 4
    # Unlock JTAG using SCS HAB_JDE bit.
    FEATURE_UNLOCK_JTAG     = 8

    def __init__(self, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Initialize.

        :param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
        :param uid: Unique ID required by some engine/feature combinations
        &#34;&#34;&#34;
        super().__init__(EnumEngine.OCOTP, features, uid=uid)

    @property
    def _need_uid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        return self.unlock_fld_rtn or self.unlock_csc or self.unlock_jtag

    @property
    def unlock_fld_rtn(self) -&gt; bool:
        &#34;&#34;&#34;Leave Field Return activation unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_FLD_RTN != 0

    @property
    def unlock_srk_rvk(self) -&gt; bool:
        &#34;&#34;&#34;Leave SRK revocation unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_SRK_RVK != 0

    @property
    def unlock_csc(self) -&gt; bool:
        &#34;&#34;&#34;Leave SCS register unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_SCS != 0

    @property
    def unlock_jtag(self) -&gt; bool:
        &#34;&#34;&#34;Unlock JTAG using SCS HAB_JDE bit.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_JTAG != 0


    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;FLD_RTN : {self.unlock_fld_rtn}\n&#34;
        msg += f&#34;SRK_RVK : {self.unlock_srk_rvk}\n&#34;
        msg += f&#34;CSC     : {self.unlock_csc}\n&#34;
        msg += f&#34;JTAG    : {self.unlock_jtag}\n&#34;
        if self.uid:
            msg += f&#34;UID : {hex(self.uid)}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_FLD_RTN"><code class="name">var <span class="ident">FEATURE_UNLOCK_FLD_RTN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_JTAG"><code class="name">var <span class="ident">FEATURE_UNLOCK_JTAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_SCS"><code class="name">var <span class="ident">FEATURE_UNLOCK_SCS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_SRK_RVK"><code class="name">var <span class="ident">FEATURE_UNLOCK_SRK_RVK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.unlock_csc"><code class="name">var <span class="ident">unlock_csc</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave SCS register unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_csc(self) -&gt; bool:
    &#34;&#34;&#34;Leave SCS register unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_SCS != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.unlock_fld_rtn"><code class="name">var <span class="ident">unlock_fld_rtn</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave Field Return activation unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_fld_rtn(self) -&gt; bool:
    &#34;&#34;&#34;Leave Field Return activation unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_FLD_RTN != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.unlock_jtag"><code class="name">var <span class="ident">unlock_jtag</span> :bool</code></dt>
<dd>
<div class="desc"><p>Unlock JTAG using SCS HAB_JDE bit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_jtag(self) -&gt; bool:
    &#34;&#34;&#34;Unlock JTAG using SCS HAB_JDE bit.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_JTAG != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockOCOTP.unlock_srk_rvk"><code class="name">var <span class="ident">unlock_srk_rvk</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave SRK revocation unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_srk_rvk(self) -&gt; bool:
    &#34;&#34;&#34;Leave SRK revocation unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_SRK_RVK != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdUnlockSNVS"><code class="flex name class">
<span>class <span class="ident">CmdUnlockSNVS</span></span>
<span>(</span><span>features:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Unlock Secure Non-Volatile Storage (SNVS) Engine.</p>
<p>Constructor.</p>
<p>:param features: mask of FEATURE_UNLOCK_* constants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockSNVS(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock Secure Non-Volatile Storage (SNVS) Engine.&#34;&#34;&#34;

    # mask unlock LP_SWR
    FEATURE_UNLOCK_LP_SWR = 1
    # mask unlock ZMK_WRITE
    FEATURE_UNLOCK_ZMK_WRITE = 2

    def __init__(self, features: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param features: mask of FEATURE_UNLOCK_* constants
        &#34;&#34;&#34;
        super().__init__(EnumEngine.SNVS, features)

    @property
    def unlock_lp_swr(self) -&gt; bool:
        &#34;&#34;&#34;Leave LP SW reset unlocked.&#34;&#34;&#34;
        return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR != 0

    @property
    def unlock_zmk_write(self) -&gt; bool:
        &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
        return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE != 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;Unlock LP SWR    : {self.unlock_lp_swr}\n&#34;
        msg += f&#34;Unlock ZMK Write : {self.unlock_zmk_write}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR"><code class="name">var <span class="ident">FEATURE_UNLOCK_LP_SWR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE"><code class="name">var <span class="ident">FEATURE_UNLOCK_ZMK_WRITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdUnlockSNVS.unlock_lp_swr"><code class="name">var <span class="ident">unlock_lp_swr</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave LP SW reset unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_lp_swr(self) -&gt; bool:
    &#34;&#34;&#34;Leave LP SW reset unlocked.&#34;&#34;&#34;
    return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdUnlockSNVS.unlock_zmk_write"><code class="name">var <span class="ident">unlock_zmk_write</span> :bool</code></dt>
<dd>
<div class="desc"><p>Leave Zero is able Master Key write unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_zmk_write(self) -&gt; bool:
    &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
    return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.CmdWriteData"><code class="flex name class">
<span>class <span class="ident">CmdWriteData</span></span>
<span>(</span><span>numbytes:int=4, ops:int=0, data:Iterable[Tuple[int,int]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data command.</p>
<p>Initialize Write Data command.</p>
<p>:param numbytes: number of bytes. Must be value: 1, 2 or 4
:param ops: type of write operation
:param data: list of tuples: address and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdWriteData(CmdBase):
    &#34;&#34;&#34;Write data command.&#34;&#34;&#34;

    @property
    def num_bytes(self) -&gt; int:
        &#34;&#34;&#34;Number of bytes being written by the command.&#34;&#34;&#34;
        return self._header.param &amp; 0x7

    @num_bytes.setter
    def num_bytes(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: number of bytes being written by the command
        &#34;&#34;&#34;
        assert value in (1, 2, 4)
        self._header.param &amp;= ~0x7
        self._header.param |= value

    @property
    def ops(self) -&gt; int:
        &#34;&#34;&#34;Type of write operation.&#34;&#34;&#34;
        return (self._header.param &gt;&gt; 3) &amp; 0x3

    @ops.setter
    def ops(self, value: int) -&gt; None:
        assert value in EnumWriteOps
        self._header.param &amp;= ~(0x3 &lt;&lt; 3)
        self._header.param |= int(value) &lt;&lt; 3

    def __init__(self, numbytes: int = 4, ops: int = EnumWriteOps.WRITE_VALUE,
                 data: Iterable[Tuple[int, int]] = None) -&gt; None:
        &#34;&#34;&#34;Initialize Write Data command.

        :param numbytes: number of bytes. Must be value: 1, 2 or 4
        :param ops: type of write operation
        :param data: list of tuples: address and value
        &#34;&#34;&#34;
        assert numbytes in (1, 2, 4)
        assert ops in EnumWriteOps
        super().__init__(CmdTag.WRT_DAT, ((int(ops) &amp; 0x3) &lt;&lt; 3) | (numbytes &amp; 0x7))
        self._data: List[List[int]] = []
        if data is not None:
            assert isinstance(data, (list, tuple))
            for address, value in data:
                self.append(address, value)

    def __repr__(self) -&gt; str:
        return f&#34;CmdWriteData &lt;{EnumWriteOps.name(self.ops)}/{self.num_bytes}, {len(self._data)}&gt;&#34;

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; List[int]:
        return self._data[key]

    def __setitem__(self, key: int, value: List[int]) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[List[int]]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Write Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumWriteOps.name(self.ops),
                                                                        self.num_bytes)
        for cmd in self._data:
            msg += &#34;- Address: 0x{0:08X}, Value: 0x{1:08X}\n&#34;.format(cmd[0], cmd[1])
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def append(self, address: int, value: int) -&gt; None:
        &#34;&#34;&#34;Append of Write data command.&#34;&#34;&#34;
        assert 0 &lt;= address &lt;= 0xFFFFFFFF, &#34;address out of range&#34;
        assert 0 &lt;= value &lt;= 0xFFFFFFFF, &#34;value out of range&#34;
        self._data.append([address, value])
        self._header.length += 8

    def pop(self, index: int) -&gt; List[int]:
        &#34;&#34;&#34;Pop of Write data command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._data)
        cmd = self._data.pop(index)
        self._header.length -= 8
        return cmd

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Write data command.&#34;&#34;&#34;
        self._data.clear()
        self._header.length = self._header.size

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        for cmd in self._data:
            raw_data += pack(&#34;&gt;LL&#34;, cmd[0], cmd[1])
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdWriteData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset=offset, required_tag=CmdTag.WRT_DAT)
        obj = cls(header.param &amp; 0x7, (header.param &gt;&gt; 3) &amp; 0x3)
        index = header.size
        while index &lt; header.length:
            (address, value) = unpack_from(&#34;&gt;LL&#34;, data, offset + index)
            obj.append(address, value)
            index += 8
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.commands.CmdWriteData.num_bytes"><code class="name">var <span class="ident">num_bytes</span> :int</code></dt>
<dd>
<div class="desc"><p>Number of bytes being written by the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_bytes(self) -&gt; int:
    &#34;&#34;&#34;Number of bytes being written by the command.&#34;&#34;&#34;
    return self._header.param &amp; 0x7</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdWriteData.ops"><code class="name">var <span class="ident">ops</span> :int</code></dt>
<dd>
<div class="desc"><p>Type of write operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ops(self) -&gt; int:
    &#34;&#34;&#34;Type of write operation.&#34;&#34;&#34;
    return (self._header.param &gt;&gt; 3) &amp; 0x3</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.commands.CmdWriteData.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, address:int, value:int) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append of Write data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, address: int, value: int) -&gt; None:
    &#34;&#34;&#34;Append of Write data command.&#34;&#34;&#34;
    assert 0 &lt;= address &lt;= 0xFFFFFFFF, &#34;address out of range&#34;
    assert 0 &lt;= value &lt;= 0xFFFFFFFF, &#34;value out of range&#34;
    self._data.append([address, value])
    self._header.length += 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdWriteData.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Write data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Write data command.&#34;&#34;&#34;
    self._data.clear()
    self._header.length = self._header.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdWriteData.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Write Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumWriteOps.name(self.ops),
                                                                    self.num_bytes)
    for cmd in self._data:
        msg += &#34;- Address: 0x{0:08X}, Value: 0x{1:08X}\n&#34;.format(cmd[0], cmd[1])
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.commands.CmdWriteData.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index:int) >List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Pop of Write data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; List[int]:
    &#34;&#34;&#34;Pop of Write data command.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._data)
    cmd = self._data.pop(index)
    self._header.length -= 8
    return cmd</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumAuthDat"><code class="flex name class">
<span>class <span class="ident">EnumAuthDat</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flags for Authenticate Data commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumAuthDat(Enum):
    &#34;&#34;&#34;Flags for Authenticate Data commands.&#34;&#34;&#34;
    CLR = (0, &#39;No flags set&#39;)
    ABS = (1, &#39;Absolute signature address&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumAuthDat.ABS"><code class="name">var <span class="ident">ABS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumAuthDat.CLR"><code class="name">var <span class="ident">CLR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumCAAM"><code class="flex name class">
<span>class <span class="ident">EnumCAAM</span></span>
</code></dt>
<dd>
<div class="desc"><p>CAAM Engine Configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumCAAM(Enum):
    &#34;&#34;&#34;CAAM Engine Configuration.&#34;&#34;&#34;
    DEFAULT = 0x00
    IN_SWAP8 = 0x01
    IN_SWAP16 = 0x02
    OUT_SWAP8 = 0x08
    OUT_SWAP16 = 0x10
    DSC_SWAP8 = 0x40
    DSC_SWAP16 = 0x80</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumCAAM.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCAAM.DSC_SWAP16"><code class="name">var <span class="ident">DSC_SWAP16</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCAAM.DSC_SWAP8"><code class="name">var <span class="ident">DSC_SWAP8</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCAAM.IN_SWAP16"><code class="name">var <span class="ident">IN_SWAP16</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCAAM.IN_SWAP8"><code class="name">var <span class="ident">IN_SWAP8</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCAAM.OUT_SWAP16"><code class="name">var <span class="ident">OUT_SWAP16</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCAAM.OUT_SWAP8"><code class="name">var <span class="ident">OUT_SWAP8</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumCertFormat"><code class="flex name class">
<span>class <span class="ident">EnumCertFormat</span></span>
</code></dt>
<dd>
<div class="desc"><p>Certificate format tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumCertFormat(Enum):
    &#34;&#34;&#34;Certificate format tags.&#34;&#34;&#34;
    SRK = (0x03, &#39;SRK certificate format&#39;)
    X509 = (0x09, &#39;X.509v3 certificate format&#39;)
    CMS = (0xC5, &#39;CMS/PKCS#7 signature format&#39;)
    BLOB = (0xBB, &#39;SHW-specific wrapped key format&#39;)
    AEAD = (0xA3, &#39;Proprietary AEAD MAC format&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumCertFormat.AEAD"><code class="name">var <span class="ident">AEAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCertFormat.BLOB"><code class="name">var <span class="ident">BLOB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCertFormat.CMS"><code class="name">var <span class="ident">CMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCertFormat.SRK"><code class="name">var <span class="ident">SRK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCertFormat.X509"><code class="name">var <span class="ident">X509</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumCheckOps"><code class="flex name class">
<span>class <span class="ident">EnumCheckOps</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum definition for 'par' parameter of Check Data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumCheckOps(Enum):
    &#34;&#34;&#34;Enum definition for &#39;par&#39; parameter of Check Data command.&#34;&#34;&#34;
    ALL_CLEAR = (0, &#39;All bits clear&#39;)
    ALL_SET = (1, &#39;All bits set&#39;)
    ANY_CLEAR = (2, &#39;Any bit clear&#39;)
    ANY_SET = (3, &#39;Any bit set&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumCheckOps.ALL_CLEAR"><code class="name">var <span class="ident">ALL_CLEAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCheckOps.ALL_SET"><code class="name">var <span class="ident">ALL_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCheckOps.ANY_CLEAR"><code class="name">var <span class="ident">ANY_CLEAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumCheckOps.ANY_SET"><code class="name">var <span class="ident">ANY_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumEngine"><code class="flex name class">
<span>class <span class="ident">EnumEngine</span></span>
</code></dt>
<dd>
<div class="desc"><p>Engine plugin tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumEngine(Enum):
    &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
    ANY = (0x00, &#39;First compatible engine will be selected (no engine configuration parameters are allowed)&#39;)
    SCC = (0x03, &#39;Security controller&#39;)
    RTIC = (0x05, &#39;Run-time integrity checker&#39;)
    SAHARA = (0x06, &#39;Crypto accelerator&#39;)
    CSU = (0x0A, &#39;Central Security Unit&#39;)
    SRTC = (0x0C, &#39;Secure clock&#39;)
    DCP = (0x1B, &#39;Data Co-Processor&#39;)
    CAAM = (0x1D, &#39;Cryptographic Acceleration and Assurance Module&#39;)
    SNVS = (0x1E, &#39;Secure Non-Volatile Storage&#39;)
    OCOTP = (0x21, &#39;Fuse controller&#39;)
    DTCP = (0x22, &#39;DTCP co-processor&#39;)
    ROM = (0x36, &#39;Protected ROM area&#39;)
    HDCP = (0x24, &#39;HDCP co-processor&#39;)
    SW = (0xFF, &#39;Software engine&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumEngine.ANY"><code class="name">var <span class="ident">ANY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.CAAM"><code class="name">var <span class="ident">CAAM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.CSU"><code class="name">var <span class="ident">CSU</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.DCP"><code class="name">var <span class="ident">DCP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.DTCP"><code class="name">var <span class="ident">DTCP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.HDCP"><code class="name">var <span class="ident">HDCP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.OCOTP"><code class="name">var <span class="ident">OCOTP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.ROM"><code class="name">var <span class="ident">ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.RTIC"><code class="name">var <span class="ident">RTIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.SAHARA"><code class="name">var <span class="ident">SAHARA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.SCC"><code class="name">var <span class="ident">SCC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.SNVS"><code class="name">var <span class="ident">SNVS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.SRTC"><code class="name">var <span class="ident">SRTC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumEngine.SW"><code class="name">var <span class="ident">SW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumInsKey"><code class="flex name class">
<span>class <span class="ident">EnumInsKey</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flags for Install Key commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumInsKey(Enum):
    &#34;&#34;&#34;Flags for Install Key commands.&#34;&#34;&#34;
    CLR = (0, &#39;No flags set&#39;)
    ABS = (1, &#39;Absolute certificate address&#39;)
    CSF = (2, &#39;Install CSF key&#39;)
    DAT = (4, &#39;Key binds to Data Type&#39;)
    CFG = (8, &#39;Key binds to Configuration&#39;)
    FID = (16, &#39;Key binds to Fabrication UID&#39;)
    MID = (32, &#39;Key binds to Manufacturing ID&#39;)
    CID = (64, &#39;Key binds to Caller ID&#39;)
    HSH = (128, &#39;Certificate hash present&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumInsKey.ABS"><code class="name">var <span class="ident">ABS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.CFG"><code class="name">var <span class="ident">CFG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.CID"><code class="name">var <span class="ident">CID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.CLR"><code class="name">var <span class="ident">CLR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.CSF"><code class="name">var <span class="ident">CSF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.DAT"><code class="name">var <span class="ident">DAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.FID"><code class="name">var <span class="ident">FID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.HSH"><code class="name">var <span class="ident">HSH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumInsKey.MID"><code class="name">var <span class="ident">MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumItm"><code class="flex name class">
<span>class <span class="ident">EnumItm</span></span>
</code></dt>
<dd>
<div class="desc"><p>Engine configuration flags of Set command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumItm(Enum):
    &#34;&#34;&#34;Engine configuration flags of Set command.&#34;&#34;&#34;
    MID = (0x01, &#39;Manufacturing ID (MID) fuse locations&#39;)
    ENG = (0x03, &#39;Preferred engine for a given algorithm&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumItm.ENG"><code class="name">var <span class="ident">ENG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumItm.MID"><code class="name">var <span class="ident">MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.commands.EnumWriteOps"><code class="flex name class">
<span>class <span class="ident">EnumWriteOps</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum definition for 'flags' control flags in 'par' parameter of Write Data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumWriteOps(Enum):
    &#34;&#34;&#34;Enum definition for &#39;flags&#39; control flags in &#39;par&#39; parameter of Write Data command.&#34;&#34;&#34;
    WRITE_VALUE = (0, &#39;Write value&#39;)
    WRITE_CLEAR_BITS = (1, &#39;Write clear bits&#39;)
    CLEAR_BITMASK = (2, &#39;Clear bitmask&#39;)
    SET_BITMASK = (3, &#39;Set bitmask&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.commands.EnumWriteOps.CLEAR_BITMASK"><code class="name">var <span class="ident">CLEAR_BITMASK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumWriteOps.SET_BITMASK"><code class="name">var <span class="ident">SET_BITMASK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumWriteOps.WRITE_CLEAR_BITS"><code class="name">var <span class="ident">WRITE_CLEAR_BITS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.commands.EnumWriteOps.WRITE_VALUE"><code class="name">var <span class="ident">WRITE_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.image" href="index.html">spsdk.image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spsdk.image.commands.parse_command" href="#spsdk.image.commands.parse_command">parse_command</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.image.commands.CmdAuthData" href="#spsdk.image.commands.CmdAuthData">CmdAuthData</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdAuthData.append" href="#spsdk.image.commands.CmdAuthData.append">append</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.clear" href="#spsdk.image.commands.CmdAuthData.clear">clear</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.cmd_data_offset" href="#spsdk.image.commands.CmdAuthData.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.cmd_data_reference" href="#spsdk.image.commands.CmdAuthData.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.engine" href="#spsdk.image.commands.CmdAuthData.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.flags" href="#spsdk.image.commands.CmdAuthData.flags">flags</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.info" href="#spsdk.image.commands.CmdAuthData.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.key_index" href="#spsdk.image.commands.CmdAuthData.key_index">key_index</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.needs_cmd_data_reference" href="#spsdk.image.commands.CmdAuthData.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.parse" href="#spsdk.image.commands.CmdAuthData.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.parse_cmd_data" href="#spsdk.image.commands.CmdAuthData.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.pop" href="#spsdk.image.commands.CmdAuthData.pop">pop</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.signature" href="#spsdk.image.commands.CmdAuthData.signature">signature</a></code></li>
<li><code><a title="spsdk.image.commands.CmdAuthData.update_signature" href="#spsdk.image.commands.CmdAuthData.update_signature">update_signature</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdBase" href="#spsdk.image.commands.CmdBase">CmdBase</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.info" href="#spsdk.image.commands.CmdBase.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdCheckData" href="#spsdk.image.commands.CmdCheckData">CmdCheckData</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdCheckData.info" href="#spsdk.image.commands.CmdCheckData.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdCheckData.num_bytes" href="#spsdk.image.commands.CmdCheckData.num_bytes">num_bytes</a></code></li>
<li><code><a title="spsdk.image.commands.CmdCheckData.ops" href="#spsdk.image.commands.CmdCheckData.ops">ops</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdInitialize" href="#spsdk.image.commands.CmdInitialize">CmdInitialize</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdInitialize.append" href="#spsdk.image.commands.CmdInitialize.append">append</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInitialize.clear" href="#spsdk.image.commands.CmdInitialize.clear">clear</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInitialize.engine" href="#spsdk.image.commands.CmdInitialize.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInitialize.info" href="#spsdk.image.commands.CmdInitialize.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInitialize.pop" href="#spsdk.image.commands.CmdInitialize.pop">pop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdInstallKey" href="#spsdk.image.commands.CmdInstallKey">CmdInstallKey</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdInstallKey.certificate_format" href="#spsdk.image.commands.CmdInstallKey.certificate_format">certificate_format</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.certificate_ref" href="#spsdk.image.commands.CmdInstallKey.certificate_ref">certificate_ref</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.cmd_data_reference" href="#spsdk.image.commands.CmdInstallKey.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.flags" href="#spsdk.image.commands.CmdInstallKey.flags">flags</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.hash_algorithm" href="#spsdk.image.commands.CmdInstallKey.hash_algorithm">hash_algorithm</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.info" href="#spsdk.image.commands.CmdInstallKey.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.needs_cmd_data_reference" href="#spsdk.image.commands.CmdInstallKey.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.parse" href="#spsdk.image.commands.CmdInstallKey.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.parse_cmd_data" href="#spsdk.image.commands.CmdInstallKey.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.source_index" href="#spsdk.image.commands.CmdInstallKey.source_index">source_index</a></code></li>
<li><code><a title="spsdk.image.commands.CmdInstallKey.target_index" href="#spsdk.image.commands.CmdInstallKey.target_index">target_index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdNop" href="#spsdk.image.commands.CmdNop">CmdNop</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdNop.info" href="#spsdk.image.commands.CmdNop.info">info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdSet" href="#spsdk.image.commands.CmdSet">CmdSet</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdSet.engine" href="#spsdk.image.commands.CmdSet.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdSet.hash_algorithm" href="#spsdk.image.commands.CmdSet.hash_algorithm">hash_algorithm</a></code></li>
<li><code><a title="spsdk.image.commands.CmdSet.info" href="#spsdk.image.commands.CmdSet.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdSet.itm" href="#spsdk.image.commands.CmdSet.itm">itm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdUnlock" href="#spsdk.image.commands.CmdUnlock">CmdUnlock</a></code></h4>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdUnlockAbstract" href="#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdUnlockCAAM" href="#spsdk.image.commands.CmdUnlockCAAM">CmdUnlockCAAM</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_MFG" href="#spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_MFG">FEATURE_UNLOCK_MFG</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_MID" href="#spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_MID">FEATURE_UNLOCK_MID</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_RNG" href="#spsdk.image.commands.CmdUnlockCAAM.FEATURE_UNLOCK_RNG">FEATURE_UNLOCK_RNG</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockCAAM.unlock_mfg" href="#spsdk.image.commands.CmdUnlockCAAM.unlock_mfg">unlock_mfg</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockCAAM.unlock_mid" href="#spsdk.image.commands.CmdUnlockCAAM.unlock_mid">unlock_mid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockCAAM.unlock_rng" href="#spsdk.image.commands.CmdUnlockCAAM.unlock_rng">unlock_rng</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdUnlockOCOTP" href="#spsdk.image.commands.CmdUnlockOCOTP">CmdUnlockOCOTP</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_FLD_RTN" href="#spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_FLD_RTN">FEATURE_UNLOCK_FLD_RTN</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_JTAG" href="#spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_JTAG">FEATURE_UNLOCK_JTAG</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_SCS" href="#spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_SCS">FEATURE_UNLOCK_SCS</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_SRK_RVK" href="#spsdk.image.commands.CmdUnlockOCOTP.FEATURE_UNLOCK_SRK_RVK">FEATURE_UNLOCK_SRK_RVK</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.unlock_csc" href="#spsdk.image.commands.CmdUnlockOCOTP.unlock_csc">unlock_csc</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.unlock_fld_rtn" href="#spsdk.image.commands.CmdUnlockOCOTP.unlock_fld_rtn">unlock_fld_rtn</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.unlock_jtag" href="#spsdk.image.commands.CmdUnlockOCOTP.unlock_jtag">unlock_jtag</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockOCOTP.unlock_srk_rvk" href="#spsdk.image.commands.CmdUnlockOCOTP.unlock_srk_rvk">unlock_srk_rvk</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdUnlockSNVS" href="#spsdk.image.commands.CmdUnlockSNVS">CmdUnlockSNVS</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR" href="#spsdk.image.commands.CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR">FEATURE_UNLOCK_LP_SWR</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE" href="#spsdk.image.commands.CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE">FEATURE_UNLOCK_ZMK_WRITE</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockSNVS.unlock_lp_swr" href="#spsdk.image.commands.CmdUnlockSNVS.unlock_lp_swr">unlock_lp_swr</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockSNVS.unlock_zmk_write" href="#spsdk.image.commands.CmdUnlockSNVS.unlock_zmk_write">unlock_zmk_write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.CmdWriteData" href="#spsdk.image.commands.CmdWriteData">CmdWriteData</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.commands.CmdWriteData.append" href="#spsdk.image.commands.CmdWriteData.append">append</a></code></li>
<li><code><a title="spsdk.image.commands.CmdWriteData.clear" href="#spsdk.image.commands.CmdWriteData.clear">clear</a></code></li>
<li><code><a title="spsdk.image.commands.CmdWriteData.info" href="#spsdk.image.commands.CmdWriteData.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdWriteData.num_bytes" href="#spsdk.image.commands.CmdWriteData.num_bytes">num_bytes</a></code></li>
<li><code><a title="spsdk.image.commands.CmdWriteData.ops" href="#spsdk.image.commands.CmdWriteData.ops">ops</a></code></li>
<li><code><a title="spsdk.image.commands.CmdWriteData.pop" href="#spsdk.image.commands.CmdWriteData.pop">pop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumAuthDat" href="#spsdk.image.commands.EnumAuthDat">EnumAuthDat</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.EnumAuthDat.ABS" href="#spsdk.image.commands.EnumAuthDat.ABS">ABS</a></code></li>
<li><code><a title="spsdk.image.commands.EnumAuthDat.CLR" href="#spsdk.image.commands.EnumAuthDat.CLR">CLR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumCAAM" href="#spsdk.image.commands.EnumCAAM">EnumCAAM</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.commands.EnumCAAM.DEFAULT" href="#spsdk.image.commands.EnumCAAM.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCAAM.DSC_SWAP16" href="#spsdk.image.commands.EnumCAAM.DSC_SWAP16">DSC_SWAP16</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCAAM.DSC_SWAP8" href="#spsdk.image.commands.EnumCAAM.DSC_SWAP8">DSC_SWAP8</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCAAM.IN_SWAP16" href="#spsdk.image.commands.EnumCAAM.IN_SWAP16">IN_SWAP16</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCAAM.IN_SWAP8" href="#spsdk.image.commands.EnumCAAM.IN_SWAP8">IN_SWAP8</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCAAM.OUT_SWAP16" href="#spsdk.image.commands.EnumCAAM.OUT_SWAP16">OUT_SWAP16</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCAAM.OUT_SWAP8" href="#spsdk.image.commands.EnumCAAM.OUT_SWAP8">OUT_SWAP8</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumCertFormat" href="#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.EnumCertFormat.AEAD" href="#spsdk.image.commands.EnumCertFormat.AEAD">AEAD</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCertFormat.BLOB" href="#spsdk.image.commands.EnumCertFormat.BLOB">BLOB</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCertFormat.CMS" href="#spsdk.image.commands.EnumCertFormat.CMS">CMS</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCertFormat.SRK" href="#spsdk.image.commands.EnumCertFormat.SRK">SRK</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCertFormat.X509" href="#spsdk.image.commands.EnumCertFormat.X509">X509</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumCheckOps" href="#spsdk.image.commands.EnumCheckOps">EnumCheckOps</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.EnumCheckOps.ALL_CLEAR" href="#spsdk.image.commands.EnumCheckOps.ALL_CLEAR">ALL_CLEAR</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCheckOps.ALL_SET" href="#spsdk.image.commands.EnumCheckOps.ALL_SET">ALL_SET</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCheckOps.ANY_CLEAR" href="#spsdk.image.commands.EnumCheckOps.ANY_CLEAR">ANY_CLEAR</a></code></li>
<li><code><a title="spsdk.image.commands.EnumCheckOps.ANY_SET" href="#spsdk.image.commands.EnumCheckOps.ANY_SET">ANY_SET</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumEngine" href="#spsdk.image.commands.EnumEngine">EnumEngine</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.commands.EnumEngine.ANY" href="#spsdk.image.commands.EnumEngine.ANY">ANY</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.CAAM" href="#spsdk.image.commands.EnumEngine.CAAM">CAAM</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.CSU" href="#spsdk.image.commands.EnumEngine.CSU">CSU</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.DCP" href="#spsdk.image.commands.EnumEngine.DCP">DCP</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.DTCP" href="#spsdk.image.commands.EnumEngine.DTCP">DTCP</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.HDCP" href="#spsdk.image.commands.EnumEngine.HDCP">HDCP</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.OCOTP" href="#spsdk.image.commands.EnumEngine.OCOTP">OCOTP</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.ROM" href="#spsdk.image.commands.EnumEngine.ROM">ROM</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.RTIC" href="#spsdk.image.commands.EnumEngine.RTIC">RTIC</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.SAHARA" href="#spsdk.image.commands.EnumEngine.SAHARA">SAHARA</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.SCC" href="#spsdk.image.commands.EnumEngine.SCC">SCC</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.SNVS" href="#spsdk.image.commands.EnumEngine.SNVS">SNVS</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.SRTC" href="#spsdk.image.commands.EnumEngine.SRTC">SRTC</a></code></li>
<li><code><a title="spsdk.image.commands.EnumEngine.SW" href="#spsdk.image.commands.EnumEngine.SW">SW</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumInsKey" href="#spsdk.image.commands.EnumInsKey">EnumInsKey</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.commands.EnumInsKey.ABS" href="#spsdk.image.commands.EnumInsKey.ABS">ABS</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.CFG" href="#spsdk.image.commands.EnumInsKey.CFG">CFG</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.CID" href="#spsdk.image.commands.EnumInsKey.CID">CID</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.CLR" href="#spsdk.image.commands.EnumInsKey.CLR">CLR</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.CSF" href="#spsdk.image.commands.EnumInsKey.CSF">CSF</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.DAT" href="#spsdk.image.commands.EnumInsKey.DAT">DAT</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.FID" href="#spsdk.image.commands.EnumInsKey.FID">FID</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.HSH" href="#spsdk.image.commands.EnumInsKey.HSH">HSH</a></code></li>
<li><code><a title="spsdk.image.commands.EnumInsKey.MID" href="#spsdk.image.commands.EnumInsKey.MID">MID</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumItm" href="#spsdk.image.commands.EnumItm">EnumItm</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.EnumItm.ENG" href="#spsdk.image.commands.EnumItm.ENG">ENG</a></code></li>
<li><code><a title="spsdk.image.commands.EnumItm.MID" href="#spsdk.image.commands.EnumItm.MID">MID</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.commands.EnumWriteOps" href="#spsdk.image.commands.EnumWriteOps">EnumWriteOps</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.commands.EnumWriteOps.CLEAR_BITMASK" href="#spsdk.image.commands.EnumWriteOps.CLEAR_BITMASK">CLEAR_BITMASK</a></code></li>
<li><code><a title="spsdk.image.commands.EnumWriteOps.SET_BITMASK" href="#spsdk.image.commands.EnumWriteOps.SET_BITMASK">SET_BITMASK</a></code></li>
<li><code><a title="spsdk.image.commands.EnumWriteOps.WRITE_CLEAR_BITS" href="#spsdk.image.commands.EnumWriteOps.WRITE_CLEAR_BITS">WRITE_CLEAR_BITS</a></code></li>
<li><code><a title="spsdk.image.commands.EnumWriteOps.WRITE_VALUE" href="#spsdk.image.commands.EnumWriteOps.WRITE_VALUE">WRITE_VALUE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>