<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.image API documentation</title>
<meta name="description" content="Module implementing functionality of srktool, dcdgen, mkimage and other similar tools." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.image</code></h1>
</header>
<section id="section-intro">
<p>Module implementing functionality of srktool, dcdgen, mkimage and other similar tools.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2017-2018 Martin Olejar
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Module implementing functionality of srktool, dcdgen, mkimage and other similar tools.&#34;&#34;&#34;

from .bee import BeeRegionHeader, BeeKIB, BeeProtectRegionBlock, BeeFacRegion
from .commands import EnumWriteOps, EnumCheckOps, EnumCertFormat, EnumInsKey, EnumAuthDat, EnumEngine, \
                      EnumItm, CmdWriteData, CmdCheckData, CmdNop, CmdSet, CmdInitialize, CmdUnlock, \
                      CmdUnlockCAAM, CmdUnlockOCOTP, CmdUnlockSNVS, CmdInstallKey, CmdAuthData
from .segments import SegIVT2, SegIVT3a, SegIVT3b, SegBDT, SegAPP, SegDCD, SegCSF, PaddingFCB, FlexSPIConfBlockFCB
from .secret import SrkTable, SrkItem, CertificateImg, Signature, MAC, SecretKeyBlob, EnumAlgorithm
from .images import parse, BootImgRT, BootImg2, BootImg3a, BootImg3b, BootImg4, EnumAppType
from .keystore import KeySourceType, KeyStore
from .mbimg import MasterBootImage, MasterBootImageType, MultipleImageEntry, MultipleImageTable
from .pfr import CMPA, CFPA
from .trustzone import TrustZone, TrustZoneType

__all__ = [
    # Main Classes
    &#39;BootImgRT&#39;,
    &#39;BootImg2&#39;,
    &#39;BootImg3a&#39;,
    &#39;BootImg3b&#39;,
    &#39;BootImg4&#39;,
    &#39;MasterBootImage&#39;,
    &#39;MasterBootImageType&#39;,
    # multiple images for MasterBootImage (relocation table)
    &#39;MultipleImageEntry&#39;,
    &#39;MultipleImageTable&#39;,
    # Segments
    &#39;SegIVT2&#39;,
    &#39;SegIVT3a&#39;,
    &#39;SegIVT3b&#39;,
    &#39;SegBDT&#39;,
    &#39;SegAPP&#39;,
    &#39;SegDCD&#39;,
    &#39;SegCSF&#39;,
    &#39;TrustZone&#39;,
    &#39;TrustZoneType&#39;,
    &#39;CMPA&#39;,
    &#39;CFPA&#39;,
    &#39;PaddingFCB&#39;,
    &#39;FlexSPIConfBlockFCB&#39;,
    # BEE
    &#39;BeeRegionHeader&#39;,
    &#39;BeeKIB&#39;,
    &#39;BeeProtectRegionBlock&#39;,
    &#39;BeeFacRegion&#39;,
    # Secret
    &#39;SrkTable&#39;,
    &#39;SrkItem&#39;,
    &#39;CertificateImg&#39;,
    &#39;Signature&#39;,
    &#39;MAC&#39;,
    &#39;SecretKeyBlob&#39;,
    # Enums
    &#39;EnumAppType&#39;,
    # Commands
    &#39;CmdNop&#39;,
    &#39;CmdSet&#39;,
    &#39;CmdWriteData&#39;,
    &#39;CmdCheckData&#39;,
    &#39;CmdInitialize&#39;,
    &#39;CmdInstallKey&#39;,
    &#39;CmdAuthData&#39;,
    &#39;CmdUnlock&#39;,
    &#39;CmdUnlockCAAM&#39;,
    &#39;CmdUnlockOCOTP&#39;,
    &#39;CmdUnlockSNVS&#39;,
    # Elements
    &#39;EnumWriteOps&#39;,
    &#39;EnumCheckOps&#39;,
    &#39;EnumAlgorithm&#39;,
    &#39;EnumCertFormat&#39;,
    &#39;EnumInsKey&#39;,
    &#39;EnumAuthDat&#39;,
    &#39;EnumEngine&#39;,
    &#39;EnumItm&#39;,
    # Methods
    &#39;parse&#39;,
    # KeyStore
    &#39;KeyStore&#39;,
    &#39;KeySourceType&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="spsdk.image.bee" href="bee.html">spsdk.image.bee</a></code></dt>
<dd>
<div class="desc"><p>Contains support for BEE encryption for RT10xx devices.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.commands" href="commands.html">spsdk.image.commands</a></code></dt>
<dd>
<div class="desc"><p>Commands for image module.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.hab_audit_log" href="hab_audit_log.html">spsdk.image.hab_audit_log</a></code></dt>
<dd>
<div class="desc"><p>Utility allowing parsing of HAB audit log data.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.header" href="header.html">spsdk.image.header</a></code></dt>
<dd>
<div class="desc"><p>Header.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.images" href="images.html">spsdk.image.images</a></code></dt>
<dd>
<div class="desc"><p>Image.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.keystore" href="keystore.html">spsdk.image.keystore</a></code></dt>
<dd>
<div class="desc"><p>Module provides support for KeyStore used in MasterBootImage.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.mbimg" href="mbimg.html">spsdk.image.mbimg</a></code></dt>
<dd>
<div class="desc"><p>Master Boot Image.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.misc" href="misc.html">spsdk.image.misc</a></code></dt>
<dd>
<div class="desc"><p>Misc.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.pfr" href="pfr.html">spsdk.image.pfr</a></code></dt>
<dd>
<div class="desc"><p>Module provides support for Protected Flash Region.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.secret" href="secret.html">spsdk.image.secret</a></code></dt>
<dd>
<div class="desc"><p>Commands and responses used by SDP module.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.segments" href="segments.html">spsdk.image.segments</a></code></dt>
<dd>
<div class="desc"><p>Segments within image module.</p></div>
</dd>
<dt><code class="name"><a title="spsdk.image.trustzone" href="trustzone.html">spsdk.image.trustzone</a></code></dt>
<dd>
<div class="desc"><p>Module provides support for TrustZone configuration data.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spsdk.image.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream: Union[bytes, bytearray, _io.BufferedReader, _io.BytesIO], step: int = 256, size: int = None) ‑> <a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Common parser for all versions of i.MX boot images.</p>
<p>:param stream: stream buffer to image
:raises TypeError: raised when the format of string is incorrect
:param step: Image searching step
:param size: parsing size
:return: the object of boot image
:raises Exception: when not i.MX Boot Image is passed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Common parser for all versions of i.MX boot images.

    :param stream: stream buffer to image
    :raises TypeError: raised when the format of string is incorrect
    :param step: Image searching step
    :param size: parsing size
    :return: the object of boot image
    :raises Exception: when not i.MX Boot Image is passed
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    # calculate stream size
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    while start_index &lt; (last_index - Header.SIZE):
        raw = read_raw_data(stream, Header.SIZE, no_seek=True)

        if raw[0] == SegTag.IVT2 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT2.SIZE and raw[3] in (0x40, 0x41, 0x42):
            return BootImg2.parse(stream)

        if raw[0] == SegTag.IVT2 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT3b.SIZE and raw[3] in (0x43,):
            return BootImg3b.parse(stream)

        if raw[0] == SegTag.IVT3 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT3a.SIZE and raw[3] in (0x43,):
            return BootImg3a.parse(stream)

        if raw[3] == SegTag.BIC1:
            return BootImg4.parse(stream)

        start_index = stream.seek(step, SEEK_CUR)

    raise Exception(&#39; Not an i.MX Boot Image !&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.image.BeeFacRegion"><code class="flex name class">
<span>class <span class="ident">BeeFacRegion</span></span>
<span>(</span><span>start: int = 0, length: int = 0, protected_level: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE Factory Access Control (FAC) region.</p>
<p>Constructor.</p>
<p>:param start: Start address of one FAC region, align at 1KB boundary; 32-bit number
:param length: Length of one FAC region, align at 1KB boundary; 32-bit number
:param protected_level: Protected level: 0/1/2/3; 32-bit number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeFacRegion(BeeBaseClass):
    &#34;&#34;&#34;BEE Factory Access Control (FAC) region.&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#34;&lt;3I20s&#34;

    def __init__(self, start: int = 0, length: int = 0, protected_level: int = 0):
        &#34;&#34;&#34;Constructor.

        :param start: Start address of one FAC region, align at 1KB boundary; 32-bit number
        :param length: Length of one FAC region, align at 1KB boundary; 32-bit number
        :param protected_level: Protected level: 0/1/2/3; 32-bit number
        &#34;&#34;&#34;
        self.start_addr = start
        self.length = length
        self.protected_level = protected_level
        # immediately validate all parameters
        self.validate()

    def __str__(self) -&gt; str:
        return f&#39;FAC: 0x{self.start_addr:08x}[0x{self.length:x}]&#39;

    @property
    def end_addr(self) -&gt; int:
        &#34;&#34;&#34;:return: end address of the region (which is last address of the region + 1).&#34;&#34;&#34;
        return self.start_addr + self.length

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        return f&#39;FAC(start={hex(self.start_addr)}, length={hex(self.length)}, protected_level={self.protected_level})&#39;

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates the configuration of the instance.

        :raise AssertionError: if configuration is invalid.
        &#34;&#34;&#34;
        assert (self.start_addr &amp; _ENCR_BLOCK_ADDR_MASK == 0) and (self.length &amp; _ENCR_BLOCK_ADDR_MASK == 0)
        assert 0 &lt;= self.protected_level &lt;= 3
        assert 0 &lt;= self.start_addr &lt; self.end_addr &lt;= 0xFFFFFFFF

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        return result + pack(self._struct_format(), self.start_addr, self.end_addr, self.protected_level, b&#39;\x00&#39; * 20)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeFacRegion&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        :raise ValueError: if reserved area is non-zero
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the data
        (start, end, protected_level, _reserved) = unpack_from(BeeFacRegion._struct_format(), data, offset)
        if _reserved != b&#39;\x00&#39; * 20:
            raise ValueError(&#39;Reserved area is non-zero&#39;)
        return BeeFacRegion(start, end - start, protected_level)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BeeFacRegion.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.bee.BeeFacRegion" href="bee.html#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data
:raise ValueError: if reserved area is non-zero</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeFacRegion&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data
    :raise ValueError: if reserved area is non-zero
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the data
    (start, end, protected_level, _reserved) = unpack_from(BeeFacRegion._struct_format(), data, offset)
    if _reserved != b&#39;\x00&#39; * 20:
        raise ValueError(&#39;Reserved area is non-zero&#39;)
    return BeeFacRegion(start, end - start, protected_level)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BeeFacRegion.end_addr"><code class="name">var <span class="ident">end_addr</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: end address of the region (which is last address of the region + 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_addr(self) -&gt; int:
    &#34;&#34;&#34;:return: end address of the region (which is last address of the region + 1).&#34;&#34;&#34;
    return self.start_addr + self.length</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BeeFacRegion.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
    result = super().export()
    return result + pack(self._struct_format(), self.start_addr, self.end_addr, self.protected_level, b&#39;\x00&#39; * 20)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeFacRegion.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    return f&#39;FAC(start={hex(self.start_addr)}, length={hex(self.length)}, protected_level={self.protected_level})&#39;</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeFacRegion.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the configuration of the instance.</p>
<p>:raise AssertionError: if configuration is invalid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates the configuration of the instance.

    :raise AssertionError: if configuration is invalid.
    &#34;&#34;&#34;
    assert (self.start_addr &amp; _ENCR_BLOCK_ADDR_MASK == 0) and (self.length &amp; _ENCR_BLOCK_ADDR_MASK == 0)
    assert 0 &lt;= self.protected_level &lt;= 3
    assert 0 &lt;= self.start_addr &lt; self.end_addr &lt;= 0xFFFFFFFF</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="bee.html#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="bee.html#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BeeKIB"><code class="flex name class">
<span>class <span class="ident">BeeKIB</span></span>
<span>(</span><span>kib_key: Union[bytes, NoneType] = None, kib_iv: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE Key block.</p>
<p>Contains keys used to encrypt PRDB content.</p>
<p>Constructor.</p>
<p>:param kib_key: AES key
:param kib_iv: AES initialization vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeKIB(BeeBaseClass):
    &#34;&#34;&#34;BEE Key block.

    Contains keys used to encrypt PRDB content.
    &#34;&#34;&#34;

    # key length in bytes
    _KEY_LEN = 16
    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#34;16s16s&#34;

    def __init__(self, kib_key: Optional[bytes] = None, kib_iv: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param kib_key: AES key
        :param kib_iv: AES initialization vector
        &#34;&#34;&#34;
        # Key Info Block (KIB)
        self.kib_key = kib_key if kib_key else crypto_backend().random_bytes(16)
        self.kib_iv = kib_iv if kib_iv else crypto_backend().random_bytes(16)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        return f&#34;BEE-KIB: {self.kib_key.hex()}, {self.kib_iv.hex()}&#34;

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        assert len(self.kib_key) == self._KEY_LEN
        assert len(self.kib_iv) == self._KEY_LEN

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        return result + pack(self._struct_format(), self.kib_key, self.kib_iv)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeKIB&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        (key, iv) = unpack_from(BeeKIB._struct_format(), data, offset)
        result = cls(key, iv)
        result.validate()
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BeeKIB.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.bee.BeeKIB" href="bee.html#spsdk.image.bee.BeeKIB">BeeKIB</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeKIB&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the input data
    (key, iv) = unpack_from(BeeKIB._struct_format(), data, offset)
    result = cls(key, iv)
    result.validate()
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BeeKIB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
    result = super().export()
    return result + pack(self._struct_format(), self.kib_key, self.kib_iv)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeKIB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    return f&#34;BEE-KIB: {self.kib_key.hex()}, {self.kib_iv.hex()}&#34;</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeKIB.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    &#34;&#34;&#34;
    assert len(self.kib_key) == self._KEY_LEN
    assert len(self.kib_iv) == self._KEY_LEN</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="bee.html#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="bee.html#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock"><code class="flex name class">
<span>class <span class="ident">BeeProtectRegionBlock</span></span>
<span>(</span><span>encr_mode: <a title="spsdk.image.bee.BeeProtectRegionBlockAesMode" href="bee.html#spsdk.image.bee.BeeProtectRegionBlockAesMode">BeeProtectRegionBlockAesMode</a> = 1, lock_options: int = 0, counter: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE protect region block (PRDB).</p>
<p>Constructor.</p>
<p>:param encr_mode: AES encryption mode
:param lock_options: Lock options; 32-bit number
:param counter: Counter for AES-CTR mode; 16 bytes; by default, random value is used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeProtectRegionBlock(BeeBaseClass):
    &#34;&#34;&#34;BEE protect region block (PRDB).&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#39;&lt;8I16s32s&#39;
    # low TAG used in the header
    TAGL = 0x5F474154  # &#34;TAG_&#34;
    # high TAG used in the header
    TAGH = 0x52444845  # &#34;EHDR&#34;
    # version of the format
    VERSION = 0x56010000
    # number of FAC regions included in the header; the real limit of FAC regions depends on the processor
    FAC_REGIONS = 4
    # total size
    SIZE = 0x100

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return cls.SIZE

    def __init__(self, encr_mode: BeeProtectRegionBlockAesMode = BeeProtectRegionBlockAesMode.CTR,
                 lock_options: int = 0, counter: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param encr_mode: AES encryption mode
        :param lock_options: Lock options; 32-bit number
        :param counter: Counter for AES-CTR mode; 16 bytes; by default, random value is used
        &#34;&#34;&#34;
        # - Encrypt region info:
        self._start_addr = 0  # this is calculated automatically based on FAC regions
        self._end_addr = 0xFFFFFFFF  # this is calculated automatically based on FAC regions
        self.mode = encr_mode
        self.lock_options = lock_options
        self.counter = counter if counter else crypto_backend().random_bytes(12) + b&#39;\x00\x00\x00\x00&#39;

        # - FAC regions, 1 - 4
        self.fac_regions: List[BeeFacRegion] = list()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates start and end address of the encryption region.&#34;&#34;&#34;
        super().update()
        # update FAC regions
        for fac in self.fac_regions:
            fac.update()
        # update start and end address
        min_addr = 0 if self.fac_count == 0 else 0xFFFFFFFF
        max_addr = 0
        for fac in self.fac_regions:
            min_addr = min(min_addr, fac.start_addr)
            max_addr = max(max_addr, fac.end_addr)
        self._start_addr = min_addr
        self._end_addr = max_addr

    def add_fac(self, fac: BeeFacRegion) -&gt; None:
        &#34;&#34;&#34;Append FAC region.

        :param fac: Factory Access Control to be added
        &#34;&#34;&#34;
        self.fac_regions.append(fac)
        self.update()

    @property
    def fac_count(self) -&gt; int:
        &#34;&#34;&#34;:return: number of Factory Access Control regions.&#34;&#34;&#34;
        return len(self.fac_regions)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = f&#39;BEE Region Header (start={hex(self._start_addr)}, end={hex(self._end_addr)})\n&#39;
        result += f&#39;AES Encryption mode: {BeeProtectRegionBlockAesMode.name(self.mode)}\n&#39;
        for fac in self.fac_regions:
            result += fac.info() + &#39;\n&#39;
        return result

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        assert 0 &lt;= self._start_addr &lt;= 0xFFFFFFFF
        assert self._start_addr &lt;= self._end_addr &lt;= 0xFFFFFFFF
        assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;  # TODO
        assert len(self.counter) == 16
        assert self.counter[-4:] == b&#39;\x00\x00\x00\x00&#39;, &#39;last four bytes must be zero&#39;
        assert 0 &lt; self.fac_count &lt;= self.FAC_REGIONS
        for fac in self.fac_regions:
            fac.validate()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return: binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        result += pack(self._struct_format(),
                       self.TAGL,
                       self.TAGH,
                       self.VERSION,
                       self.fac_count,
                       self._start_addr,
                       self._end_addr,
                       self.mode,
                       self.lock_options,
                       self.counter[::-1],  # bytes swapped: reversed order
                       b&#39;\x00&#39; * 32)
        for fac in self.fac_regions:
            result += fac.export()
        result = extend_block(result, self.SIZE)
        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeProtectRegionBlock&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        :raise ValueError: if format does not match
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        (
            tagl,
            tagh,
            version,
            fac_count,
            start_addr,
            end_addr,
            mode,
            lock_options,
            counter,
            _reserved_32
        ) = unpack_from(BeeProtectRegionBlock._struct_format(), data, offset)
        #
        if (tagl != BeeProtectRegionBlock.TAGL) or (tagh != BeeProtectRegionBlock.TAGH):
            raise ValueError(&#39;Invalid tag or unsupported version&#39;)
        if version != BeeProtectRegionBlock.VERSION:
            raise ValueError(&#39;Unsupported version&#39;)
        if _reserved_32 != b&#39;\x00&#39; * 32:
            raise ValueError(&#39;Reserved area is non-zero&#39;)
        #
        result = BeeProtectRegionBlock(mode, lock_options, counter[::-1])
        result._start_addr = start_addr
        result._end_addr = end_addr
        offset += calcsize(BeeProtectRegionBlock._struct_format())
        for _ in range(fac_count):
            fac = BeeFacRegion.parse(data, offset)
            result.add_fac(fac)
            offset += fac.size
        result.validate()
        return result

    def encrypt_block(self, key: bytes, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt block located in any FAC region.

        :param key: user for encryption
        :param start_addr: start address of the data
        :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
        :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
        &#34;&#34;&#34;
        assert len(data) == BEE_ENCR_BLOCK_SIZE
        if self._start_addr &lt;= start_addr &lt; self._end_addr:
            assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;
            assert len(key) == 16
            for fac in self.fac_regions:
                if fac.start_addr &lt;= start_addr &lt; fac.end_addr:
                    assert start_addr + len(data) &lt;= fac.end_addr
                    cntr_key = Counter(self.counter, ctr_value=start_addr &gt;&gt; 4, ctr_byteorder_encoding=&#39;big&#39;)
                    return crypto_backend().aes_ctr_encrypt(key, data, cntr_key.value)
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.BeeProtectRegionBlock.FAC_REGIONS"><code class="name">var <span class="ident">FAC_REGIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.TAGH"><code class="name">var <span class="ident">TAGH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.TAGL"><code class="name">var <span class="ident">TAGL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BeeProtectRegionBlock.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.bee.BeeProtectRegionBlock" href="bee.html#spsdk.image.bee.BeeProtectRegionBlock">BeeProtectRegionBlock</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data
:raise ValueError: if format does not match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeProtectRegionBlock&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data
    :raise ValueError: if format does not match
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the input data
    (
        tagl,
        tagh,
        version,
        fac_count,
        start_addr,
        end_addr,
        mode,
        lock_options,
        counter,
        _reserved_32
    ) = unpack_from(BeeProtectRegionBlock._struct_format(), data, offset)
    #
    if (tagl != BeeProtectRegionBlock.TAGL) or (tagh != BeeProtectRegionBlock.TAGH):
        raise ValueError(&#39;Invalid tag or unsupported version&#39;)
    if version != BeeProtectRegionBlock.VERSION:
        raise ValueError(&#39;Unsupported version&#39;)
    if _reserved_32 != b&#39;\x00&#39; * 32:
        raise ValueError(&#39;Reserved area is non-zero&#39;)
    #
    result = BeeProtectRegionBlock(mode, lock_options, counter[::-1])
    result._start_addr = start_addr
    result._end_addr = end_addr
    offset += calcsize(BeeProtectRegionBlock._struct_format())
    for _ in range(fac_count):
        fac = BeeFacRegion.parse(data, offset)
        result.add_fac(fac)
        offset += fac.size
    result.validate()
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BeeProtectRegionBlock.fac_count"><code class="name">var <span class="ident">fac_count</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: number of Factory Access Control regions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fac_count(self) -&gt; int:
    &#34;&#34;&#34;:return: number of Factory Access Control regions.&#34;&#34;&#34;
    return len(self.fac_regions)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BeeProtectRegionBlock.add_fac"><code class="name flex">
<span>def <span class="ident">add_fac</span></span>(<span>self, fac: <a title="spsdk.image.bee.BeeFacRegion" href="bee.html#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append FAC region.</p>
<p>:param fac: Factory Access Control to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fac(self, fac: BeeFacRegion) -&gt; None:
    &#34;&#34;&#34;Append FAC region.

    :param fac: Factory Access Control to be added
    &#34;&#34;&#34;
    self.fac_regions.append(fac)
    self.update()</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.encrypt_block"><code class="name flex">
<span>def <span class="ident">encrypt_block</span></span>(<span>self, key: bytes, start_addr: int, data: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt block located in any FAC region.</p>
<p>:param key: user for encryption
:param start_addr: start address of the data
:param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
:return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_block(self, key: bytes, start_addr: int, data: bytes) -&gt; bytes:
    &#34;&#34;&#34;Encrypt block located in any FAC region.

    :param key: user for encryption
    :param start_addr: start address of the data
    :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
    :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
    &#34;&#34;&#34;
    assert len(data) == BEE_ENCR_BLOCK_SIZE
    if self._start_addr &lt;= start_addr &lt; self._end_addr:
        assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;
        assert len(key) == 16
        for fac in self.fac_regions:
            if fac.start_addr &lt;= start_addr &lt; fac.end_addr:
                assert start_addr + len(data) &lt;= fac.end_addr
                cntr_key = Counter(self.counter, ctr_value=start_addr &gt;&gt; 4, ctr_byteorder_encoding=&#39;big&#39;)
                return crypto_backend().aes_ctr_encrypt(key, data, cntr_key.value)
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    result = f&#39;BEE Region Header (start={hex(self._start_addr)}, end={hex(self._end_addr)})\n&#39;
    result += f&#39;AES Encryption mode: {BeeProtectRegionBlockAesMode.name(self.mode)}\n&#39;
    for fac in self.fac_regions:
        result += fac.info() + &#39;\n&#39;
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Updates start and end address of the encryption region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Updates start and end address of the encryption region.&#34;&#34;&#34;
    super().update()
    # update FAC regions
    for fac in self.fac_regions:
        fac.update()
    # update start and end address
    min_addr = 0 if self.fac_count == 0 else 0xFFFFFFFF
    max_addr = 0
    for fac in self.fac_regions:
        min_addr = min(min_addr, fac.start_addr)
        max_addr = max(max_addr, fac.end_addr)
    self._start_addr = min_addr
    self._end_addr = max_addr</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeProtectRegionBlock.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    &#34;&#34;&#34;
    assert 0 &lt;= self._start_addr &lt;= 0xFFFFFFFF
    assert self._start_addr &lt;= self._end_addr &lt;= 0xFFFFFFFF
    assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;  # TODO
    assert len(self.counter) == 16
    assert self.counter[-4:] == b&#39;\x00\x00\x00\x00&#39;, &#39;last four bytes must be zero&#39;
    assert 0 &lt; self.fac_count &lt;= self.FAC_REGIONS
    for fac in self.fac_regions:
        fac.validate()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.export" href="bee.html#spsdk.image.bee.BeeBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="bee.html#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BeeRegionHeader"><code class="flex name class">
<span>class <span class="ident">BeeRegionHeader</span></span>
<span>(</span><span>prdb: Union[<a title="spsdk.image.bee.BeeProtectRegionBlock" href="bee.html#spsdk.image.bee.BeeProtectRegionBlock">BeeProtectRegionBlock</a>, NoneType] = None, sw_key: Union[bytes, NoneType] = None, kib: Union[<a title="spsdk.image.bee.BeeKIB" href="bee.html#spsdk.image.bee.BeeKIB">BeeKIB</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE keys and regions header.</p>
<p>Constructor.</p>
<p>:param prdb: protect region block; None to use default
:param sw_key: key used to encrypt KIB content
:param kib: keys block; None to use default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeRegionHeader(BeeBaseClass):
    &#34;&#34;&#34;BEE keys and regions header.&#34;&#34;&#34;

    # offset of the Protected Region Block in the header
    PRDB_OFFSET = 0x80
    # total size including padding
    SIZE = 0x400

    @classmethod
    def _struct_format(cls) -&gt; str:
        &#34;&#34;&#34;:raise AssertionError: it is not expected to called for the class.&#34;&#34;&#34;
        raise AssertionError(&#39;This method is not expected to be used for this class, format depends on its fields&#39;)

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return cls.SIZE

    def __init__(self, prdb: Optional[BeeProtectRegionBlock] = None, sw_key: Optional[bytes] = None,
                 kib: Optional[BeeKIB] = None):
        &#34;&#34;&#34;Constructor.

        :param prdb: protect region block; None to use default
        :param sw_key: key used to encrypt KIB content
        :param kib: keys block; None to use default
        &#34;&#34;&#34;
        self._prdb = prdb if (prdb is not None) else BeeProtectRegionBlock()
        self._sw_key = sw_key if (sw_key is not None) else crypto_backend().random_bytes(16)
        self._kib = kib if (kib is not None) else BeeKIB()

    def add_fac(self, fac: BeeFacRegion) -&gt; None:
        &#34;&#34;&#34;Append FAC region.

        :param fac: to be added
        &#34;&#34;&#34;
        self._prdb.add_fac(fac)

    @property
    def fac_regions(self) -&gt; Sequence[BeeFacRegion]:
        &#34;&#34;&#34;:return: lift of Factory Access Control regions.&#34;&#34;&#34;
        return self._prdb.fac_regions

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = &#39;BEE Region Header\n&#39;
        result += f&#39;- KIB: {self._kib.info()}&#39;
        result += f&#39;- PRDB: {self._prdb.info()}&#39;
        return result

    def sw_key_fuses(self) -&gt; Sequence[int]:
        &#34;&#34;&#34;:return: sequence of fuse values for SW key to be burned into processor.

        The result is ordered, first value should be burned to the lowest address.
        &#34;&#34;&#34;
        result = list()
        for pos in range(16, 0, -4):
            result.append(unpack_from(&#34;&gt;I&#34;, self._sw_key[pos - 4:pos])[0])
        return result

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        super().update()
        self._kib.update()
        self._prdb.update()

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        self._kib.validate()
        self._prdb.validate()
        assert len(self._sw_key) == 16

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Serialization to binary representation.

        :param dbg_info: instance allowing to provide debug info about exported data
        :return:binary representation of the region (serialization).
        &#34;&#34;&#34;
        result = super().export()
        # KIB
        kib_data = self._kib.export()
        dbg_info.append_binary_section(&#39;BEE-KIB (non-crypted)&#39;, kib_data)
        aes = AES.new(self._sw_key, AES.MODE_ECB)
        result += aes.encrypt(kib_data)
        # padding
        result = extend_block(result, self.PRDB_OFFSET)
        # PRDB
        prdb_data = self._prdb.export()
        dbg_info.append_binary_section(&#39;BEE-PRDB (non-crypted)&#39;, prdb_data)
        aes = AES.new(self._kib.kib_key, AES.MODE_CBC, self._kib.kib_iv)
        result += aes.encrypt(prdb_data)
        # padding
        return extend_block(result, self.SIZE)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0, sw_key: bytes = b&#39;&#39;) -&gt; &#39;BeeRegionHeader&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
        :return: instance created from binary data
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        assert len(sw_key) == 16
        aes = AES.new(sw_key, AES.MODE_ECB)
        decr_data = aes.decrypt(data[offset:offset + BeeKIB._size()])
        kib = BeeKIB.parse(decr_data)
        aes = AES.new(kib.kib_key, AES.MODE_CBC, kib.kib_iv)
        decr_data = aes.decrypt(data[offset + cls.PRDB_OFFSET:offset + cls.PRDB_OFFSET + BeeProtectRegionBlock.SIZE])
        prdb = BeeProtectRegionBlock.parse(decr_data)
        result = cls(prdb, sw_key, kib)
        result.validate()
        return result

    def encrypt_block(self, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt block located in any FAC region.

        :param start_addr: start address of the data
        :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
        :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
        &#34;&#34;&#34;
        return self._prdb.encrypt_block(self._sw_key, start_addr, data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.BeeRegionHeader.PRDB_OFFSET"><code class="name">var <span class="ident">PRDB_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BeeRegionHeader.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BeeRegionHeader.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, sw_key: bytes = b'') ‑> <a title="spsdk.image.bee.BeeRegionHeader" href="bee.html#spsdk.image.bee.BeeRegionHeader">BeeRegionHeader</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
:return: instance created from binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, sw_key: bytes = b&#39;&#39;) -&gt; &#39;BeeRegionHeader&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
    :return: instance created from binary data
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the input data
    assert len(sw_key) == 16
    aes = AES.new(sw_key, AES.MODE_ECB)
    decr_data = aes.decrypt(data[offset:offset + BeeKIB._size()])
    kib = BeeKIB.parse(decr_data)
    aes = AES.new(kib.kib_key, AES.MODE_CBC, kib.kib_iv)
    decr_data = aes.decrypt(data[offset + cls.PRDB_OFFSET:offset + cls.PRDB_OFFSET + BeeProtectRegionBlock.SIZE])
    prdb = BeeProtectRegionBlock.parse(decr_data)
    result = cls(prdb, sw_key, kib)
    result.validate()
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BeeRegionHeader.fac_regions"><code class="name">var <span class="ident">fac_regions</span> : Sequence[<a title="spsdk.image.bee.BeeFacRegion" href="bee.html#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a>]</code></dt>
<dd>
<div class="desc"><p>:return: lift of Factory Access Control regions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fac_regions(self) -&gt; Sequence[BeeFacRegion]:
    &#34;&#34;&#34;:return: lift of Factory Access Control regions.&#34;&#34;&#34;
    return self._prdb.fac_regions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BeeRegionHeader.add_fac"><code class="name flex">
<span>def <span class="ident">add_fac</span></span>(<span>self, fac: <a title="spsdk.image.bee.BeeFacRegion" href="bee.html#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append FAC region.</p>
<p>:param fac: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fac(self, fac: BeeFacRegion) -&gt; None:
    &#34;&#34;&#34;Append FAC region.

    :param fac: to be added
    &#34;&#34;&#34;
    self._prdb.add_fac(fac)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeRegionHeader.encrypt_block"><code class="name flex">
<span>def <span class="ident">encrypt_block</span></span>(<span>self, start_addr: int, data: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt block located in any FAC region.</p>
<p>:param start_addr: start address of the data
:param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
:return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_block(self, start_addr: int, data: bytes) -&gt; bytes:
    &#34;&#34;&#34;Encrypt block located in any FAC region.

    :param start_addr: start address of the data
    :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
    :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
    &#34;&#34;&#34;
    return self._prdb.encrypt_block(self._sw_key, start_addr, data)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeRegionHeader.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialization to binary representation.</p>
<p>:param dbg_info: instance allowing to provide debug info about exported data
:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Serialization to binary representation.

    :param dbg_info: instance allowing to provide debug info about exported data
    :return:binary representation of the region (serialization).
    &#34;&#34;&#34;
    result = super().export()
    # KIB
    kib_data = self._kib.export()
    dbg_info.append_binary_section(&#39;BEE-KIB (non-crypted)&#39;, kib_data)
    aes = AES.new(self._sw_key, AES.MODE_ECB)
    result += aes.encrypt(kib_data)
    # padding
    result = extend_block(result, self.PRDB_OFFSET)
    # PRDB
    prdb_data = self._prdb.export()
    dbg_info.append_binary_section(&#39;BEE-PRDB (non-crypted)&#39;, prdb_data)
    aes = AES.new(self._kib.kib_key, AES.MODE_CBC, self._kib.kib_iv)
    result += aes.encrypt(prdb_data)
    # padding
    return extend_block(result, self.SIZE)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeRegionHeader.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    result = &#39;BEE Region Header\n&#39;
    result += f&#39;- KIB: {self._kib.info()}&#39;
    result += f&#39;- PRDB: {self._prdb.info()}&#39;
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeRegionHeader.sw_key_fuses"><code class="name flex">
<span>def <span class="ident">sw_key_fuses</span></span>(<span>self) ‑> Sequence[int]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sequence of fuse values for SW key to be burned into processor.</p>
<p>The result is ordered, first value should be burned to the lowest address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sw_key_fuses(self) -&gt; Sequence[int]:
    &#34;&#34;&#34;:return: sequence of fuse values for SW key to be burned into processor.

    The result is ordered, first value should be burned to the lowest address.
    &#34;&#34;&#34;
    result = list()
    for pos in range(16, 0, -4):
        result.append(unpack_from(&#34;&gt;I&#34;, self._sw_key[pos - 4:pos])[0])
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.BeeRegionHeader.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    &#34;&#34;&#34;
    self._kib.validate()
    self._prdb.validate()
    assert len(self._sw_key) == 16</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="bee.html#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="bee.html#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="bee.html#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BootImg2"><code class="flex name class">
<span>class <span class="ident">BootImg2</span></span>
<span>(</span><span>address: int = 0, offset: int = 1024, version: int = 65, plugin: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image v2.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format
:param plugin: if plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg2(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v2.&#34;&#34;&#34;

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    APP_ALIGN = 0x1000
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC00,
                 0x100: 0x300}

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of IMX Boot Image v2.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plg

    @plugin.setter
    def plugin(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IMX Boot Image v2..&#34;&#34;&#34;
        result = self.ivt.space
        result += self.bdt.space
        if self.dcd:
            result += self.dcd.space
        result += self.app.space
        result += self.csf.space
        return result

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x41, plugin: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        :param plugin: if plugin
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = SegIVT2(version)
        self._bdt = SegBDT()
        self._app = SegAPP()
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = plugin

    def _update(self) -&gt; None:
        &#34;&#34;&#34;Update Image Object.&#34;&#34;&#34;
        # Set zero padding for IVT and BDT sections
        self.ivt.padding = 0
        self.bdt.padding = 0
        # Calculate padding for DCD, APP and CSF sections
        tmp_val = self.ivt.space + self.bdt.space
        if self.dcd:
            tmp_val += self.dcd.size
        head_size = 0xC00 if self.offset not in self.HEAD_SIZE else self.HEAD_SIZE[self.offset]
        if self.dcd:
            self.dcd.padding = head_size - tmp_val
        tmp_val = self.app.size % self.APP_ALIGN
        self.app.padding = self.APP_ALIGN - tmp_val if tmp_val &gt; 0 else 0
        # Set IVT section
        self.ivt.ivt_address = self.address + self.offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        if self.dcd:
            self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
            self.ivt.app_address = self.ivt.dcd_address + self.dcd.space
        else:
            self.ivt.dcd_address = 0
            self.ivt.app_address = self.ivt.bdt_address + self.bdt.space
        if self.csf.enabled:
            self.ivt.csf_address = self.ivt.app_address + self.app.space
            self.csf.padding = self.CSF_SIZE - self.csf.size
        else:
            self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.ivt.ivt_address - self.offset
        self.bdt.app_length = self.size + self.offset
        self.bdt.plugin = 1 if self.plugin else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image v2.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print DBI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: Type of img
        :param address: address in RAM
        :raises Exception: Raised when the data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            self.app.data = data
            if address != 0:
                self.address = address
        else:
            raise Exception(&#39;Unknown data type !&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export image as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self._update()
        data = self.ivt.export()
        data += self.bdt.export()
        if self.dcd:
            data += self.dcd.export()
        data += self.app.export()
        data += self.csf.export()
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; &#39;BootImg2&#39;:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when value type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg2 object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)} !&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or \
                    header.length == SegIVT2.SIZE or \
                    header.param in (0x40, 0x41, 0x42, 0x43):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = BootImg2()
        if header.param:
            obj.version = header.param

        img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        obj.plugin = bool(obj.bdt.plugin)
        # Parse DCD
        if obj.ivt.dcd_address:
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
        # Parse APP
        app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
        app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
            obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
        app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
        obj.app.data = read_raw_data(stream, app_size, app_start)
        obj.app.padding = 0
        # Parse CSF
        if obj.ivt.csf_address:
            csf_start = start_index + (obj.ivt.csf_address - obj.ivt.ivt_address)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF, csf_start))
            # obj.csf.padding = csf_start + obj.csf.size

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.BootImg2.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg2.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg2.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BootImg2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream: Union[bytes, bytearray, _io.BufferedReader, _io.BytesIO], step: int = 256, size: int = None) ‑> <a title="spsdk.image.images.BootImg2" href="images.html#spsdk.image.images.BootImg2">BootImg2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: raised when value type is incorrect
:raises Exception: raised when there is not an i.MX Boot Image
:return: BootImg2 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; &#39;BootImg2&#39;:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: raised when value type is incorrect
    :raises Exception: raised when there is not an i.MX Boot Image
    :return: BootImg2 object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)} !&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT2 or \
                header.length == SegIVT2.SIZE or \
                header.param in (0x40, 0x41, 0x42, 0x43):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = BootImg2()
    if header.param:
        obj.version = header.param

    img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index

    # Parse IVT
    obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
    obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
    obj.address = obj.bdt.app_start
    obj.plugin = bool(obj.bdt.plugin)
    # Parse DCD
    if obj.ivt.dcd_address:
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
    # Parse APP
    app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
    app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
        obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
    app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
    obj.app.data = read_raw_data(stream, app_size, app_start)
    obj.app.padding = 0
    # Parse CSF
    if obj.ivt.csf_address:
        csf_start = start_index + (obj.ivt.csf_address - obj.ivt.ivt_address)
        obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF, csf_start))
        # obj.csf.padding = csf_start + obj.csf.size

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BootImg2.app"><code class="name">var <span class="ident">app</span> : <a title="spsdk.image.segments.SegAPP" href="segments.html#spsdk.image.segments.SegAPP">SegAPP</a></code></dt>
<dd>
<div class="desc"><p>APP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app(self) -&gt; SegAPP:
    &#34;&#34;&#34;APP.&#34;&#34;&#34;
    return self._app</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.bdt"><code class="name">var <span class="ident">bdt</span> : <a title="spsdk.image.segments.SegBDT" href="segments.html#spsdk.image.segments.SegBDT">SegBDT</a></code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; SegBDT:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.csf"><code class="name">var <span class="ident">csf</span> : <a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.ivt"><code class="name">var <span class="ident">ivt</span> : <a title="spsdk.image.segments.SegIVT2" href="segments.html#spsdk.image.segments.SegIVT2">SegIVT2</a></code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; SegIVT2:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.plugin"><code class="name">var <span class="ident">plugin</span> : bool</code></dt>
<dd>
<div class="desc"><p>Plugin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; bool:
    &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IMX Boot Image v2..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IMX Boot Image v2..&#34;&#34;&#34;
    result = self.ivt.space
    result += self.bdt.space
    if self.dcd:
        result += self.dcd.space
    result += self.app.space
    result += self.csf.space
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Version of IMX Boot Image v2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of IMX Boot Image v2.&#34;&#34;&#34;
    return self._ivt.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BootImg2.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data: bytes, img_type: <a title="spsdk.image.images.EnumAppType" href="images.html#spsdk.image.images.EnumAppType">EnumAppType</a> = 4, address: int = 0) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of img
:param img_type: Type of img
:param address: address in RAM
:raises Exception: Raised when the data type is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of img
    :param img_type: Type of img
    :param address: address in RAM
    :raises Exception: Raised when the data type is unknown
    &#34;&#34;&#34;
    if img_type == EnumAppType.APP:
        self.app.data = data
        if address != 0:
            self.address = address
    else:
        raise Exception(&#39;Unknown data type !&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export image as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export image as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self._update()
    data = self.ivt.export()
    data += self.bdt.export()
    if self.dcd:
        data += self.dcd.export()
    data += self.app.export()
    data += self.csf.export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the IMX Boot Image v2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the IMX Boot Image v2.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self.ivt.info()
    # Print DBI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self.bdt.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="images.html#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BootImg3a"><code class="flex name class">
<span>class <span class="ident">BootImg3a</span></span>
<span>(</span><span>address: int = 0, offset: int = 1024, version: int = 67)</span>
</code></dt>
<dd>
<div class="desc"><p>i.MX Boot Image v3a.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg3a(BootImgBase):
    &#34;&#34;&#34;i.MX Boot Image v3a.&#34;&#34;&#34;

    IMG_TYPE_CSF = 0x01
    IMG_TYPE_SCD = 0x02
    IMG_TYPE_EXEC = 0x03
    IMG_TYPE_DATA = 0x04

    SCFW_FLAGS_APP = 0x01355FC4
    SCFW_FLAGS_M4_0 = 0x4a5162
    SCFW_FLAGS_M4_1 = 0x4f52a3
    SCFW_FLAGS_SCFW = 0x1

    INITIAL_LOAD_ADDR_SCU_ROM = 0x2000e000
    INITIAL_LOAD_ADDR_AP_ROM = 0x00110000
    INITIAL_LOAD_ADDR_FLEXSPI = 0x08000000

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    IMG_AUTO_ALIGN = 0x10
    SECTOR_SIZE = 0x200
    APP_ALIGN = 0x1200
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC400,
                 0x1000: 0x1400}

    PADDING_VAL = 0x00

    COUNT_OF_CONTAINERS = 2

    @property
    def plg(self) -&gt; bool:
        &#34;&#34;&#34;PLG.&#34;&#34;&#34;
        return self._plg

    @plg.setter
    def plg(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; List[SegIVT3a]:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: List) -&gt; None:
        assert isinstance(value, list) and isinstance(value[0], SegIVT3a)
        self._ivt = value

    @property
    def bdt(self) -&gt; List[SegBDS3a]:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: List) -&gt; None:
        assert isinstance(value, list) and isinstance(value[0], SegBDS3a)
        self._bdt = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x43) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = [SegIVT3a(version), SegIVT3a(version)]
        self._ivt[0].next = self._ivt[0].size
        self._ivt[0].version = 0x01
        self._ivt[1].version = 0x01
        self._bdt = [SegBDS3a(), SegBDS3a()]
        self.app = [[SegAPP() for _ in range(SegBDS3a.IMAGES_MAX_COUNT)],
                    [SegAPP() for _ in range(SegBDS3a.IMAGES_MAX_COUNT)]]
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = False
        if not isinstance(self.address, list):
            self.address = [self.INITIAL_LOAD_ADDR_SCU_ROM, self.INITIAL_LOAD_ADDR_AP_ROM]  # type: ignore
        self._sdc_address = 0

    @staticmethod
    def _compute_padding(size: int, sector_size: int) -&gt; int:
        return ((size // sector_size + (size % sector_size &gt; 0)) * sector_size) - size

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        for container in range(self.COUNT_OF_CONTAINERS):
            self.ivt[container].padding = 0
            self.bdt[container].padding = 0

            # Set IVT section
            self.ivt[container].ivt_address = (self.address[container] + self.offset +  # type: ignore
                                               container * self.ivt[container].size)
            self.ivt[container].bdt_address = (self.ivt[container].ivt_address +
                                               self.ivt[container].space * (self.COUNT_OF_CONTAINERS - container) +
                                               container * self.bdt[container].size)

            if container == 0:
                if self.dcd:
                    self.ivt[container].dcd_address = self.ivt[container].bdt_address + self.bdt[container].space * 2
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].dcd_address + self.dcd.space
                    else:
                        self.ivt[container].csf_address = 0
                else:
                    self.ivt[container].dcd_address = 0
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].bdt_address + \
                                                          self.bdt[container].space * 2
                    else:
                        self.ivt[container].csf_address = 0
            else:
                self.ivt[container].dcd_address = 0
                self.ivt[container].csf_address = 0

            self.app[container][0].padding = self._compute_padding(self.bdt[container].images[0].image_size,
                                                                   self.SECTOR_SIZE)
            if self.bdt[container].images_count != 0:
                self.bdt[container].boot_data_size = self.bdt[container].size
                if container == 0:
                    self.bdt[container].images[0].image_source = self.APP_ALIGN
                else:
                    last_image_index = self.bdt[container - 1].images_count - 1
                    last_image_address = self.bdt[container - 1].images[last_image_index].image_source
                    self.bdt[container].images[0].image_source = (last_image_address +
                                                                  self.app[container - 1][last_image_index].space)
            for i in range(self.bdt[container].images_count - 1):
                self.bdt[container].images[i + 1].image_source = self.bdt[container].images[i].image_source + \
                                                                 self.app[container][i].space
                self.app[container][i + 1].padding = self._compute_padding(self.bdt[container].images[i + 1].image_size,
                                                                           self.SECTOR_SIZE)
            if container == self.COUNT_OF_CONTAINERS - 1:
                self.app[container][self.bdt[container].images_count - 1].padding = 0
                # Set BDT section

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the i.MX Boot Image v3a.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, ivt in enumerate(self.ivt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- IVT[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, bdi in enumerate(self.bdt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- BDI[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += bdi.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of image
        :param img_type: Type of image
        :param address: address in RAM
        :raises Exception: raised when data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            image_index = self.bdt[1].images_count
            self.bdt[1].images[image_index].image_destination = address
            self.bdt[1].images[image_index].image_entry = address
            self.bdt[1].images[image_index].image_size = len(data)
            self.bdt[1].images[image_index].rom_flags = 0
            self.bdt[1].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[1].images[image_index].scfw_flags = self.SCFW_FLAGS_APP
            self.bdt[1].images_count += 1

            self.app[1][image_index].data = data
            self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = address
            self.bdt[0].images[image_index].image_entry = address
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_M4_0 if img_type == EnumAppType.M4_0 else \
                self.SCFW_FLAGS_M4_1
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type == EnumAppType.SCFW:
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = 0x1ffe0000
            self.bdt[0].images[image_index].image_entry = 0x1ffe0000
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_SCFW
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self._sdc_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                                 self._compute_padding(len(data), self.IMG_AUTO_ALIGN))

        elif img_type == EnumAppType.SCD:
            if self._sdc_address == 0:
                raise Exception(&#39;SCFW have to be define before SCD!&#39;)
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = self._sdc_address
            self.bdt[0].images[image_index].image_entry = 0
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_SCD
            self.bdt[0].images[image_index].scfw_flags = 0x1
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        else:
            raise Exception(&#39;Unknown data type!&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export Image as binary blob.&#34;&#34;&#34;
        self._update()
        data = bytes()
        data += self.ivt[0].export()
        data += self.ivt[1].export()
        data += self.bdt[0].export()
        data += self.bdt[1].export()
        if self.dcd:
            data += self.dcd.export()
        data += self.csf.export()
        data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

        for container in range(self.COUNT_OF_CONTAINERS):
            for image in range(self.bdt[container].images_count):
                data += self.app[container][image].export()

        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when the values type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg3a object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT3 or header.length == SegIVT3a.SIZE or \
                    header.param in (0x43,):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        # TODO: not used right now: img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index
        # Parse IVT
        obj.ivt[0] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
        obj.ivt[1] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
        # Parse BDT
        obj.bdt[0] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
        obj.bdt[1] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
        # Parse DCD
        if obj.ivt[0].dcd_address:
            stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        # Parse CSF
        if obj.ivt[0].csf_address:
            stream.seek(start_index + (obj.ivt[0].csf_address - obj.ivt[0].ivt_address), 0)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))
        # Parse IMAGES
        for container in range(obj.COUNT_OF_CONTAINERS):
            for i in range(obj.bdt[container].images_count):
                stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
                obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.BootImg3a.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.COUNT_OF_CONTAINERS"><code class="name">var <span class="ident">COUNT_OF_CONTAINERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.IMG_AUTO_ALIGN"><code class="name">var <span class="ident">IMG_AUTO_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.IMG_TYPE_CSF"><code class="name">var <span class="ident">IMG_TYPE_CSF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.IMG_TYPE_DATA"><code class="name">var <span class="ident">IMG_TYPE_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.IMG_TYPE_EXEC"><code class="name">var <span class="ident">IMG_TYPE_EXEC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.IMG_TYPE_SCD"><code class="name">var <span class="ident">IMG_TYPE_SCD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_AP_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_AP_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_FLEXSPI"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_FLEXSPI</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_SCU_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_SCU_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.PADDING_VAL"><code class="name">var <span class="ident">PADDING_VAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.SCFW_FLAGS_APP"><code class="name">var <span class="ident">SCFW_FLAGS_APP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.SCFW_FLAGS_M4_0"><code class="name">var <span class="ident">SCFW_FLAGS_M4_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.SCFW_FLAGS_M4_1"><code class="name">var <span class="ident">SCFW_FLAGS_M4_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.SCFW_FLAGS_SCFW"><code class="name">var <span class="ident">SCFW_FLAGS_SCFW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3a.SECTOR_SIZE"><code class="name">var <span class="ident">SECTOR_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BootImg3a.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream: Union[bytes, bytearray, _io.BufferedReader, _io.BytesIO], step: int = 256, size: int = None) ‑> <a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: raised when the values type is incorrect
:raises Exception: raised when there is not an i.MX Boot Image
:return: BootImg3a object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: raised when the values type is incorrect
    :raises Exception: raised when there is not an i.MX Boot Image
    :return: BootImg3a object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT3 or header.length == SegIVT3a.SIZE or \
                header.param in (0x43,):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = cls(version=header.param)
    # TODO: not used right now: img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index
    # Parse IVT
    obj.ivt[0] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
    obj.ivt[1] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
    # Parse BDT
    obj.bdt[0] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
    obj.bdt[1] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
    # Parse DCD
    if obj.ivt[0].dcd_address:
        stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
    # Parse CSF
    if obj.ivt[0].csf_address:
        stream.seek(start_index + (obj.ivt[0].csf_address - obj.ivt[0].ivt_address), 0)
        obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))
    # Parse IMAGES
    for container in range(obj.COUNT_OF_CONTAINERS):
        for i in range(obj.bdt[container].images_count):
            stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
            obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BootImg3a.bdt"><code class="name">var <span class="ident">bdt</span> : List[<a title="spsdk.image.segments.SegBDS3a" href="segments.html#spsdk.image.segments.SegBDS3a">SegBDS3a</a>]</code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; List[SegBDS3a]:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3a.csf"><code class="name">var <span class="ident">csf</span> : <a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3a.ivt"><code class="name">var <span class="ident">ivt</span> : List[<a title="spsdk.image.segments.SegIVT3a" href="segments.html#spsdk.image.segments.SegIVT3a">SegIVT3a</a>]</code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; List[SegIVT3a]:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3a.plg"><code class="name">var <span class="ident">plg</span> : bool</code></dt>
<dd>
<div class="desc"><p>PLG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plg(self) -&gt; bool:
    &#34;&#34;&#34;PLG.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BootImg3a.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data: bytes, img_type: <a title="spsdk.image.images.EnumAppType" href="images.html#spsdk.image.images.EnumAppType">EnumAppType</a> = 4, address: int = 0) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of image
:param img_type: Type of image
:param address: address in RAM
:raises Exception: raised when data type is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of image
    :param img_type: Type of image
    :param address: address in RAM
    :raises Exception: raised when data type is unknown
    &#34;&#34;&#34;
    if img_type == EnumAppType.APP:
        image_index = self.bdt[1].images_count
        self.bdt[1].images[image_index].image_destination = address
        self.bdt[1].images[image_index].image_entry = address
        self.bdt[1].images[image_index].image_size = len(data)
        self.bdt[1].images[image_index].rom_flags = 0
        self.bdt[1].images[image_index].hab_flags = self.IMG_TYPE_EXEC
        self.bdt[1].images[image_index].scfw_flags = self.SCFW_FLAGS_APP
        self.bdt[1].images_count += 1

        self.app[1][image_index].data = data
        self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = address
        self.bdt[0].images[image_index].image_entry = address
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].rom_flags = 0
        self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
        self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_M4_0 if img_type == EnumAppType.M4_0 else \
            self.SCFW_FLAGS_M4_1
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    elif img_type == EnumAppType.SCFW:
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = 0x1ffe0000
        self.bdt[0].images[image_index].image_entry = 0x1ffe0000
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].rom_flags = 0
        self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
        self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_SCFW
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
        self._sdc_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                             self._compute_padding(len(data), self.IMG_AUTO_ALIGN))

    elif img_type == EnumAppType.SCD:
        if self._sdc_address == 0:
            raise Exception(&#39;SCFW have to be define before SCD!&#39;)
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = self._sdc_address
        self.bdt[0].images[image_index].image_entry = 0
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].rom_flags = 0
        self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_SCD
        self.bdt[0].images[image_index].scfw_flags = 0x1
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    else:
        raise Exception(&#39;Unknown data type!&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3a.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export Image as binary blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export Image as binary blob.&#34;&#34;&#34;
    self._update()
    data = bytes()
    data += self.ivt[0].export()
    data += self.ivt[1].export()
    data += self.bdt[0].export()
    data += self.bdt[1].export()
    if self.dcd:
        data += self.dcd.export()
    data += self.csf.export()
    data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

    for container in range(self.COUNT_OF_CONTAINERS):
        for image in range(self.bdt[container].images_count):
            data += self.app[container][image].export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3a.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the i.MX Boot Image v3a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the i.MX Boot Image v3a.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, ivt in enumerate(self.ivt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- IVT[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += ivt.info()
    # Print BDI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, bdi in enumerate(self.bdt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- BDI[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += bdi.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="images.html#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BootImg3b"><code class="flex name class">
<span>class <span class="ident">BootImg3b</span></span>
<span>(</span><span>address: int = 0, offset: int = 1024, version: int = 67)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image v3b.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg3b(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v3b.&#34;&#34;&#34;

    IMG_TYPE_CSF = 0x01
    IMG_TYPE_SCD = 0x02
    IMG_TYPE_EXEC = 0x03
    IMG_TYPE_DATA = 0x04

    SCFW_FLAGS_A53 = 0x1354014
    SCFW_FLAGS_A72 = 0x1354065
    SCFW_FLAGS_M4_0 = 0x4a5162
    SCFW_FLAGS_M4_1 = 0x4f52a3
    SCFW_FLAGS_SCFW = 0x1

    INITIAL_LOAD_ADDR_SCU_ROM = 0x2000e000
    INITIAL_LOAD_ADDR_AP_ROM = 0x00110000
    INITIAL_LOAD_ADDR_FLEXSPI = 0x08000000

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value for img
    IMG_AUTO_ALIGN = 0x10
    # The align value for sector
    SECTOR_SIZE = 0x200
    # The align value of APP segment
    APP_ALIGN = 0x1200

    PADDING_VAL = 0x00
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC400,
                 0x1000: 0x1400}

    COUNT_OF_CONTAINERS = 2

    @property
    def plg(self) -&gt; bool:
        &#34;&#34;&#34;PLG.&#34;&#34;&#34;
        return self._plg

    @plg.setter
    def plg(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; List[SegIVT3b]:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: List) -&gt; None:
        assert isinstance(value, list)
        assert len(value) == self.COUNT_OF_CONTAINERS
        assert isinstance(value[0], SegIVT3b)
        self._ivt = value

    @property
    def bdt(self) -&gt; List[SegBDS3b]:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: List) -&gt; None:
        assert isinstance(value, list)
        assert len(value) == self.COUNT_OF_CONTAINERS
        assert isinstance(value[0], SegBDS3b)
        self._bdt = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x43) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = [SegIVT3b(version), SegIVT3b(version)]
        self._bdt = [SegBDS3b(), SegBDS3b()]
        self.app = [[SegAPP() for _ in range(SegBDS3b.IMAGES_MAX_COUNT)],
                    [SegAPP() for _ in range(SegBDS3b.IMAGES_MAX_COUNT)]]
        self._dcd = SegDCD()
        self.scd = SegAPP()
        self._csf = SegCSF()
        self._plg = False
        self._scd_address = 0
        if not isinstance(self.address, int):
            self.address = [self.INITIAL_LOAD_ADDR_SCU_ROM, self.INITIAL_LOAD_ADDR_AP_ROM]  # type: ignore

    @staticmethod
    def _compute_padding(image_size: int, sector_size: int) -&gt; int:
        return ((image_size // sector_size + (image_size % sector_size &gt; 0)) * sector_size) - image_size

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        for container in range(self.COUNT_OF_CONTAINERS):
            self.ivt[container].padding = 0
            self.bdt[container].padding = 0

            # Set IVT section
            self.ivt[container].ivt_address = (self.address[container] + self.offset +  # type: ignore
                                               container * self.ivt[container].size)
            self.ivt[container].bdt_address = (self.ivt[container].ivt_address +
                                               self.ivt[container].space * (2 - container) +
                                               container * self.bdt[container].size)
            if container == 0:
                if self.dcd:
                    self.ivt[container].dcd_address = self.ivt[container].bdt_address + self.bdt[container].space * 2
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].dcd_address + self.dcd.space
                    else:
                        self.ivt[container].csf_address = 0
                else:
                    self.ivt[container].dcd_address = 0
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].bdt_address + \
                                                          self.bdt[container].space * 2
                    else:
                        self.ivt[container].csf_address = 0
            else:
                self.ivt[container].dcd_address = 0
                self.ivt[container].csf_address = 0

            self.app[container][0].padding = self._compute_padding(self.bdt[container].images[0].image_size,
                                                                   self.SECTOR_SIZE)
            if self.bdt[container].images_count != 0:
                self.bdt[container].boot_data_size = self.bdt[container].size
                if container == 0:
                    self.bdt[container].images[0].image_source = self.APP_ALIGN
                else:
                    last_image_index = self.bdt[container - 1].images_count - 1
                    last_image_address = self.bdt[container - 1].images[last_image_index].image_source
                    self.bdt[container].images[0].image_source = (last_image_address +
                                                                  self.app[container - 1][last_image_index].space)
            next_image_address = 0
            for i in range(self.bdt[container].images_count - 1):
                self.bdt[container].images[i + 1].image_source = self.bdt[container].images[i].image_source + \
                                                                 self.app[container][i].space
                self.app[container][i + 1].padding = self._compute_padding(
                    self.bdt[container].images[i + 1].image_size, self.SECTOR_SIZE)
                next_image_address = self.bdt[container].images[i + 1].image_source + self.app[container][i + 1].space

            if container == 0:
                if self.bdt[container].scd.image_destination != 0:
                    self.bdt[container].scd.image_source = next_image_address
                    self.scd.padding = self._compute_padding(self.bdt[0].scd.image_size, self.SECTOR_SIZE)
                    next_image_address += self.scd.space
                    # Set BDT section

                if self.csf.enabled:
                    self.bdt[container].csf.image_source = next_image_address
                    self.csf.padding = self._compute_padding(self.bdt[0].csf.image_size, self.SECTOR_SIZE)
                    next_image_address += self.csf.space
                    # Set BDT section

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image v3b.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, ivt in enumerate(self.ivt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- IVT[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, bdi in enumerate(self.bdt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- BDI[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += bdi.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of image
        :param img_type: Type of image
        :param address: address in RAM
        :raises Exception: raised SCFW is not defined before SCD
        :raises Exception: raised when there is unknown image type
        &#34;&#34;&#34;
        if img_type in (EnumAppType.APP, EnumAppType.A72):
            image_index = self.bdt[1].images_count
            self.app[1][image_index].data = data

            self.bdt[1].images[image_index].image_destination = address
            self.bdt[1].images[image_index].image_entry = address
            self.bdt[1].images[image_index].image_size = len(data)

            if img_type == EnumAppType.APP:
                self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A53
            elif img_type == EnumAppType.A72:
                self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A72

            self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self.bdt[1].images_count += 1

        elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
            image_index = self.bdt[0].images_count
            self.app[0][image_index].data = data

            self.bdt[0].images[image_index].image_destination = address
            self.bdt[0].images[image_index].image_entry = address
            self.bdt[0].images[image_index].image_size = len(data)

            if img_type == EnumAppType.M4_0:
                self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_0
            elif img_type == EnumAppType.M4_1:
                self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_1

            self.app[0][image_index].padding = ((len(data) // self.SECTOR_SIZE +
                                                 (len(data) % self.SECTOR_SIZE &gt; 0)) * self.SECTOR_SIZE) - len(data)
            self.bdt[0].images_count += 1

        elif img_type == EnumAppType.SCFW:
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = 0x30fe0000
            self.bdt[0].images[image_index].image_entry = 0x1ffe0000
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_SCFW
            self._scd_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                                 self._compute_padding(len(data), self.IMG_AUTO_ALIGN))
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type == EnumAppType.SCD:
            if self._scd_address == 0:
                raise Exception(&#39;SCFW have to be define before SCD!&#39;)
            self.scd.data = data
            self.scd.padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self.bdt[0].scd.image_destination = self._scd_address
            self.bdt[0].scd.image_entry = 0
            self.bdt[0].scd.image_size = len(data)
            self.ivt[0].scd_address = self.bdt[0].scd.image_destination

        else:
            raise Exception(&#39;Unknown image type!&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        # data = bytearray(self._offset)
        data = bytes()
        data += self.ivt[0].export()
        data += self.ivt[1].export()
        data += self.bdt[0].export()
        data += self.bdt[1].export()
        if self.dcd:
            data += self.dcd.export()
        data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

        for container in range(self.COUNT_OF_CONTAINERS):
            for i in range(self.bdt[container].images_count):
                data += self.app[container][i].export()

        if self.bdt[0].scd.image_source != 0:
            data += self.scd.export()

        if self.bdt[0].csf.image_source != 0:
            data += self.csf.export()

        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: When the value is incorrect
        :raises Exception: If there is not an i.MX Boot Image
        :return: BootImg3b object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or header.length == SegIVT3b.SIZE or \
                    header.param in (0x43,):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        # TODO: not used right now: img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index
        # Parse IVT
        obj.ivt[0] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
        obj.ivt[1] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt[0] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
        obj.bdt[1] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
        # Parse DCD
        if obj.ivt[0].dcd_address:
            stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        # Parse IMAGES
        for container in range(obj.COUNT_OF_CONTAINERS):
            for i in range(obj.bdt[container].images_count):
                stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
                obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)
        # Parse SCD
        if obj.bdt[0].scd.image_source != 0:
            stream.seek(obj.bdt[0].scd.image_source - obj.offset, 0)
            obj.scd.data = read_raw_data(stream, obj.bdt[0].scd.image_size)
        # Parse CSF
        if obj.bdt[0].csf.image_source != 0:
            stream.seek(obj.bdt[0].csf.image_source - obj.offset, 0)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.BootImg3b.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.COUNT_OF_CONTAINERS"><code class="name">var <span class="ident">COUNT_OF_CONTAINERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.IMG_AUTO_ALIGN"><code class="name">var <span class="ident">IMG_AUTO_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.IMG_TYPE_CSF"><code class="name">var <span class="ident">IMG_TYPE_CSF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.IMG_TYPE_DATA"><code class="name">var <span class="ident">IMG_TYPE_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.IMG_TYPE_EXEC"><code class="name">var <span class="ident">IMG_TYPE_EXEC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.IMG_TYPE_SCD"><code class="name">var <span class="ident">IMG_TYPE_SCD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_AP_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_AP_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_FLEXSPI"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_FLEXSPI</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_SCU_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_SCU_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.PADDING_VAL"><code class="name">var <span class="ident">PADDING_VAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.SCFW_FLAGS_A53"><code class="name">var <span class="ident">SCFW_FLAGS_A53</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.SCFW_FLAGS_A72"><code class="name">var <span class="ident">SCFW_FLAGS_A72</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.SCFW_FLAGS_M4_0"><code class="name">var <span class="ident">SCFW_FLAGS_M4_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.SCFW_FLAGS_M4_1"><code class="name">var <span class="ident">SCFW_FLAGS_M4_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.SCFW_FLAGS_SCFW"><code class="name">var <span class="ident">SCFW_FLAGS_SCFW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImg3b.SECTOR_SIZE"><code class="name">var <span class="ident">SECTOR_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BootImg3b.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream: Union[bytes, bytearray, _io.BufferedReader, _io.BytesIO], step: int = 256, size: int = None) ‑> <a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: When the value is incorrect
:raises Exception: If there is not an i.MX Boot Image
:return: BootImg3b object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: When the value is incorrect
    :raises Exception: If there is not an i.MX Boot Image
    :return: BootImg3b object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT2 or header.length == SegIVT3b.SIZE or \
                header.param in (0x43,):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = cls(version=header.param)
    # TODO: not used right now: img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index
    # Parse IVT
    obj.ivt[0] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
    obj.ivt[1] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    obj.bdt[0] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
    obj.bdt[1] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
    # Parse DCD
    if obj.ivt[0].dcd_address:
        stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
    # Parse IMAGES
    for container in range(obj.COUNT_OF_CONTAINERS):
        for i in range(obj.bdt[container].images_count):
            stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
            obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)
    # Parse SCD
    if obj.bdt[0].scd.image_source != 0:
        stream.seek(obj.bdt[0].scd.image_source - obj.offset, 0)
        obj.scd.data = read_raw_data(stream, obj.bdt[0].scd.image_size)
    # Parse CSF
    if obj.bdt[0].csf.image_source != 0:
        stream.seek(obj.bdt[0].csf.image_source - obj.offset, 0)
        obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BootImg3b.bdt"><code class="name">var <span class="ident">bdt</span> : List[<a title="spsdk.image.segments.SegBDS3b" href="segments.html#spsdk.image.segments.SegBDS3b">SegBDS3b</a>]</code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; List[SegBDS3b]:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3b.csf"><code class="name">var <span class="ident">csf</span> : <a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3b.ivt"><code class="name">var <span class="ident">ivt</span> : List[<a title="spsdk.image.segments.SegIVT3b" href="segments.html#spsdk.image.segments.SegIVT3b">SegIVT3b</a>]</code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; List[SegIVT3b]:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3b.plg"><code class="name">var <span class="ident">plg</span> : bool</code></dt>
<dd>
<div class="desc"><p>PLG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plg(self) -&gt; bool:
    &#34;&#34;&#34;PLG.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BootImg3b.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data: bytes, img_type: <a title="spsdk.image.images.EnumAppType" href="images.html#spsdk.image.images.EnumAppType">EnumAppType</a> = 4, address: int = 0) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of image
:param img_type: Type of image
:param address: address in RAM
:raises Exception: raised SCFW is not defined before SCD
:raises Exception: raised when there is unknown image type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of image
    :param img_type: Type of image
    :param address: address in RAM
    :raises Exception: raised SCFW is not defined before SCD
    :raises Exception: raised when there is unknown image type
    &#34;&#34;&#34;
    if img_type in (EnumAppType.APP, EnumAppType.A72):
        image_index = self.bdt[1].images_count
        self.app[1][image_index].data = data

        self.bdt[1].images[image_index].image_destination = address
        self.bdt[1].images[image_index].image_entry = address
        self.bdt[1].images[image_index].image_size = len(data)

        if img_type == EnumAppType.APP:
            self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A53
        elif img_type == EnumAppType.A72:
            self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A72

        self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
        self.bdt[1].images_count += 1

    elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
        image_index = self.bdt[0].images_count
        self.app[0][image_index].data = data

        self.bdt[0].images[image_index].image_destination = address
        self.bdt[0].images[image_index].image_entry = address
        self.bdt[0].images[image_index].image_size = len(data)

        if img_type == EnumAppType.M4_0:
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_0
        elif img_type == EnumAppType.M4_1:
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_1

        self.app[0][image_index].padding = ((len(data) // self.SECTOR_SIZE +
                                             (len(data) % self.SECTOR_SIZE &gt; 0)) * self.SECTOR_SIZE) - len(data)
        self.bdt[0].images_count += 1

    elif img_type == EnumAppType.SCFW:
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = 0x30fe0000
        self.bdt[0].images[image_index].image_entry = 0x1ffe0000
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_SCFW
        self._scd_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                             self._compute_padding(len(data), self.IMG_AUTO_ALIGN))
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    elif img_type == EnumAppType.SCD:
        if self._scd_address == 0:
            raise Exception(&#39;SCFW have to be define before SCD!&#39;)
        self.scd.data = data
        self.scd.padding = self._compute_padding(len(data), self.SECTOR_SIZE)
        self.bdt[0].scd.image_destination = self._scd_address
        self.bdt[0].scd.image_entry = 0
        self.bdt[0].scd.image_size = len(data)
        self.ivt[0].scd_address = self.bdt[0].scd.image_destination

    else:
        raise Exception(&#39;Unknown image type!&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3b.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._update()
    # data = bytearray(self._offset)
    data = bytes()
    data += self.ivt[0].export()
    data += self.ivt[1].export()
    data += self.bdt[0].export()
    data += self.bdt[1].export()
    if self.dcd:
        data += self.dcd.export()
    data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

    for container in range(self.COUNT_OF_CONTAINERS):
        for i in range(self.bdt[container].images_count):
            data += self.app[container][i].export()

    if self.bdt[0].scd.image_source != 0:
        data += self.scd.export()

    if self.bdt[0].csf.image_source != 0:
        data += self.csf.export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg3b.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the IMX Boot Image v3b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the IMX Boot Image v3b.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, ivt in enumerate(self.ivt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- IVT[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += ivt.info()
    # Print BDI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, bdi in enumerate(self.bdt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- BDI[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += bdi.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="images.html#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BootImg4"><code class="flex name class">
<span>class <span class="ident">BootImg4</span></span>
<span>(</span><span>address: int = 0, offset: int = 1024)</span>
</code></dt>
<dd>
<div class="desc"><p>i.MX Boot Image v4.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of image in target memory
:param offset: The image offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg4(BootImgBase):
    &#34;&#34;&#34;i.MX Boot Image v4.&#34;&#34;&#34;

    def __init__(self, address: int = 0, offset: int = 0x400) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of image in target memory
        :param offset: The image offset
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._dcd = SegDCD()
        self._cont1_header = SegBIC1()
        self._cont2_header = SegBIC1()

    def _update(self) -&gt; None:
        pass

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the i.MX Boot Image v4.&#34;&#34;&#34;
        self._update()
        msg = &#34;&#34;
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# Boot Images Container 1\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self._cont1_header.info()
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# Boot Images Container 2\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self._cont2_header.info()
        if self.dcd:
            if self.dcd.enabled:
                msg += &#34;#&#34; * 60 + &#34;\n&#34;
                msg += &#34;# DCD (Device Config Data)\n&#34;
                msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
                msg += self.dcd.info()
        return msg

    def add_image(self, data: bytes, img_type: int, address: int) -&gt; None:
        &#34;&#34;&#34;Not implemented.&#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        data = bytes()
        data += self._cont1_header.export()
        data += self._cont2_header.export()
        # TODO: Complete Implementation
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :return: BootImg4 object
        :raises TypeError: Raised when the value type is incorrect
        :raises Exception: If there is not an i.MX Boot Image
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header2.SIZE, no_seek=True))
            if header.tag == SegTag.BIC1:
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39; Not an i.MX Boot Image !&#39;)

        # TODO: not used right now: img_size = last_index - start_index
        obj = cls()
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse Containers
        obj._cont1_header = SegBIC1.parse(read_raw_data(stream, 0x400))
        obj._cont2_header = SegBIC1.parse(read_raw_data(stream, 0x400))
        # TODO: Complete Implementation
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BootImg4.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream: Union[bytes, bytearray, _io.BufferedReader, _io.BytesIO], step: int = 256, size: int = None) ‑> <a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:return: BootImg4 object
:raises TypeError: Raised when the value type is incorrect
:raises Exception: If there is not an i.MX Boot Image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :return: BootImg4 object
    :raises TypeError: Raised when the value type is incorrect
    :raises Exception: If there is not an i.MX Boot Image
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header2.SIZE, no_seek=True))
        if header.tag == SegTag.BIC1:
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39; Not an i.MX Boot Image !&#39;)

    # TODO: not used right now: img_size = last_index - start_index
    obj = cls()
    if start_index &gt; 0:
        obj.offset = start_index

    # Parse Containers
    obj._cont1_header = SegBIC1.parse(read_raw_data(stream, 0x400))
    obj._cont2_header = SegBIC1.parse(read_raw_data(stream, 0x400))
    # TODO: Complete Implementation
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BootImg4.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data: bytes, img_type: int, address: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Not implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: int, address: int) -&gt; None:
    &#34;&#34;&#34;Not implemented.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg4.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._update()
    data = bytes()
    data += self._cont1_header.export()
    data += self._cont2_header.export()
    # TODO: Complete Implementation
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImg4.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the i.MX Boot Image v4.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the i.MX Boot Image v4.&#34;&#34;&#34;
    self._update()
    msg = &#34;&#34;
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# Boot Images Container 1\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self._cont1_header.info()
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# Boot Images Container 2\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self._cont2_header.info()
    if self.dcd:
        if self.dcd.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="images.html#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.BootImgRT"><code class="flex name class">
<span>class <span class="ident">BootImgRT</span></span>
<span>(</span><span>address: int, offset: int = 4096, version: int = 64, plugin: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image v2.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory, where the image is executed
:param offset: The IVT offset; use IVT_OFFSET_NOR_FLASH for NOR-FLASH or IVT_OFFSET_OTHER
:param version: The version of boot img format; default value should be used
:param plugin: Do not use; see <code>self.plugin</code> property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImgRT(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v2.&#34;&#34;&#34;

    # offset of the BEE PRDB Header segment
    BEE_OFFSET = 0x400
    # IVT offset for NOR flash
    IVT_OFFSET_NOR_FLASH = 0x1000
    # IVT offset for other memories
    IVT_OFFSET_OTHER = 0x400
    # supported IVT offsets
    IVT_OFFSETS = (IVT_OFFSET_OTHER, IVT_OFFSET_NOR_FLASH)
    # list of supported versions
    VERSIONS = (0x40, 0x41, 0x42, 0x43)
    # The offset and align value of APP segment (for XIP and non-XIP image)
    XIP_APP_OFFSET = 0x2000
    NON_XIP_APP_OFFSET = 0x1000
    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The length of BDT segment
    BDT_SIZE = 0x20
    # The length of DEK key section; Note: Dek key is just 16 bytes
    DEK_SIZE = 0x200  # TODO this is sector size alignment???

    def __init__(self, address: int, offset: int = IVT_OFFSET_NOR_FLASH, version: int = 0x40,
                 plugin: bool = False):
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory, where the image is executed
        :param offset: The IVT offset; use IVT_OFFSET_NOR_FLASH for NOR-FLASH or IVT_OFFSET_OTHER
        :param version: The version of boot img format; default value should be used
        :param plugin: Do not use; see `self.plugin` property
        &#34;&#34;&#34;
        assert offset in BootImgRT.IVT_OFFSETS
        assert version in self.VERSIONS
        assert plugin is False  # not supported yet
        super().__init__(address, offset)
        self._nonce: Optional[bytes] = None
        self._dek_key: Optional[bytes] = None
        self._mac: Optional[bytes] = None
        self._fcb: AbstractFCB = PaddingFCB(self.IVT_OFFSET_OTHER)
        self._bee: SegBEE = SegBEE([])
        self._ivt: SegIVT2 = SegIVT2(version)
        self._bdt: SegBDT = SegBDT(plugin=int(plugin))
        self._app: SegAPP = SegAPP()
        self._dcd: Optional[SegDCD] = None
        self._csf: Optional[SegCSF] = None

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of the image format; must be from BootImgRT.VERSIONS.&#34;&#34;&#34;
        return self._ivt.version

    @property
    def dek_key(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;DEK key for encrypted images; None for non-encrypted images.&#34;&#34;&#34;
        return self._dek_key

    @dek_key.setter
    def dek_key(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: DEK key for encrypted images
        &#34;&#34;&#34;
        assert len(value) == MAC.AES128_BLK_LEN
        self._dek_key = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Flag whether it is plugin image type; It is not fully supported by SPSDK yet.

        Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.
        &#34;&#34;&#34;
        return bool(self._bdt.plugin)

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;Image Vector Table (IVT) segment.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new value
        &#34;&#34;&#34;
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def ivt_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of the Image Vector Table (IVT) in the image.&#34;&#34;&#34;
        return self.offset

    @ivt_offset.setter
    def ivt_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new IVT offset
        &#34;&#34;&#34;
        assert value in self.IVT_OFFSETS
        self.offset = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;Boot Data Table.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new BDT value
        &#34;&#34;&#34;
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;Segment with application image.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new application image
        &#34;&#34;&#34;
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; Optional[SegCSF]:
        &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new CSF
        &#34;&#34;&#34;
        assert isinstance(value, SegCSF)
        self._csf = value
        self._update()

    @property
    def enabled_csf(self) -&gt; Optional[SegCSF]:
        &#34;&#34;&#34;Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.&#34;&#34;&#34;
        return None if (self.csf is None) or not self.csf.enabled else self.csf

    @property
    def fcb(self) -&gt; AbstractFCB:
        &#34;&#34;&#34;Flash Configuration(Control) Block, binary data; content depends on FLASH type.&#34;&#34;&#34;
        return self._fcb

    @fcb.setter
    def fcb(self, fcb: AbstractFCB) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param fcb: FCB instance to be set
        &#34;&#34;&#34;
        assert isinstance(fcb, AbstractFCB)
        self._fcb = fcb

    def set_flexspi_fcb(self, data: Union[bytes, FlexSPIConfBlockFCB]) -&gt; None:
        &#34;&#34;&#34;Set FlexSPI external FLASH configuration.

        :param data: FlexSPIConfBlockFCB or binary data representing
        :raise ValueError: if data are not valid Flex SPI configuration block
        &#34;&#34;&#34;
        self.fcb = data if isinstance(data, FlexSPIConfBlockFCB) else FlexSPIConfBlockFCB.parse(data)

    @property
    def bee(self) -&gt; SegBEE:
        &#34;&#34;&#34;:return: BEE segment that contains configuration of encrypted XIP.

        By default, BEE segment is empty. PRDB regions may be specified only for XIP images.
        &#34;&#34;&#34;
        return self._bee

    @property
    def app_offset(self) -&gt; int:
        &#34;&#34;&#34;:return: offset in the binary image, where the application starts.

        Please mind: the offset include FCB block (even the FCB block is not exported)
        The offset is 0x2000 for XIP images and 0x1000 for non-XIP images
        &#34;&#34;&#34;
        return BootImgRT.XIP_APP_OFFSET if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) \
            else BootImgRT.NON_XIP_APP_OFFSET

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the exported binary data.

        Please mind, FCB is exported optionally, but it is always included in the size
        &#34;&#34;&#34;
        if self.fcb.enabled:
            result = self.app_offset + self.app.space
        else:
            result = self.app_offset + self.app.space - self.ivt_offset
        if (self.csf is not None) and self.csf.enabled:
            result += self.csf.space
        return result

    def _update(self) -&gt; None:
        &#34;&#34;&#34;Update Image Object.&#34;&#34;&#34;
        # fcb
        self.fcb.padding_len = self.BEE_OFFSET - self.fcb.size if self.fcb.enabled else 0
        # bee
        if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) and self.fcb.enabled:
            self.bee.padding_len = self.ivt_offset - self.BEE_OFFSET - self.bee.size
        else:
            self.bee.padding_len = 0
        self.bee.update()
        # padding for APP sections
        self.app.padding_len = 0
        # Set IVT section
        self.ivt.padding_len = 0
        self.ivt.ivt_address = self.address + self.ivt_offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        self.ivt.dcd_address = 0
        self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.address
        self.bdt.app_length = self.app_offset + self.app.size
        self.bdt.plugin = 1 if self.plugin else 0
        self.bdt.padding_len = self.BDT_SIZE - self.bdt.size
        if self.dcd is not None:
            self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
            self.dcd.padding_len = 0
        csf = self.enabled_csf
        if csf:
            self._update_csf(csf)

    @property
    def dek_ram_address(self) -&gt; int:
        &#34;&#34;&#34;Address of the DEK key in the RAM memory retrieved from the corresponding command.

        -1 if the image does not contain command for DEK key installation
        &#34;&#34;&#34;
        csf = self.enabled_csf
        if csf:
            for cmd in csf.commands:
                if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                    return cmd.cmd_data_location
        return -1

    @property
    def dek_img_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of the DEK key in the image; -1 if DEK key address is available (see `dek_ram_address`).&#34;&#34;&#34;
        result = self.dek_ram_address
        return result if result &lt; 0 else result - self.address

    def _update_csf(self, csf: SegCSF) -&gt; None:
        &#34;&#34;&#34;Update CSF segment.

        :param csf: CSF segment tu be updated
        &#34;&#34;&#34;
        self.app.padding_len = align(self.app.size, 0x1000) - self.app.size
        csf.update(True)
        self.ivt.csf_address = self.address + self.app_offset + self.app.space
        csf.padding_len = self.CSF_SIZE - csf.size
        self.bdt.app_length = self.app_offset + self.app.space + csf.space
        if self.hab_encrypted:
            # calculate address of a DEK key
            for cmd in csf.commands:
                if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                    cmd.cmd_data_location = self.address + self.bdt.app_length
            #
            self.bdt.app_length += self.DEK_SIZE  # to include DEK
            # update encryption signature
            assert self._nonce
            assert self._mac
            for mac in csf.macs:
                mac.update_aead_encryption_params(self._nonce, self._mac)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        self._update()
        # Print FCB
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# FCB (Flash Configuration Block)\n&#34;
        msg += self.fcb.info()
        # Print BEE
        if self.bee_encrypted:
            msg = &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# BEE (Encrypted XIP configuration)\n&#34;
            msg += self.bee.info()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if (self.dcd is not None) and self.dcd.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        csf = self.enabled_csf
        if csf:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = -1,
                  dek_key: Optional[bytes] = None, nonce: Optional[bytes] = None) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: value must be EnumAppType.APP, no other options supported in this class
        :param address: start address of the application (entry point); Use -1 to detect the address from the image
        :param dek_key: key for AES128 image HAB encryption [16 bytes],
                    - use None for non-encrypted images;
                    - use empty bytes to create random key (recommended)
                    - use fixed key for testing to produce stable output
        :param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
                        For non-encrypted image use `None`
                        The parameter should be used only for testing to produce stable output
        :raise ValueError: if any parameter is not valid
        &#34;&#34;&#34;
        assert img_type == EnumAppType.APP
        if self.app.data:
            raise ValueError(&#39;Image was already added&#39;)
        entry_addr = unpack_from(&#39;&lt;I&#39;, data, 4)[0]
        if entry_addr == 0:  # there can be padding for images located in RAM, see flashloader
            entry_addr = address
            assert entry_addr &gt; 0, &#39;entry_addr not detected from image, must be specified explicitly&#39;
        elif (address &gt;= 0) and (address != entry_addr):
            raise ValueError(&#39;entry_address does not match with the image&#39;)
        self._ivt.app_address = entry_addr
        self.app.data = data
        if dek_key is not None:  # encrypted?
            # initialize DEK key
            self._dek_key = bytes([0]) * MAC.AES128_BLK_LEN if len(dek_key) == 0 else dek_key
            if len(self._dek_key) != MAC.AES128_BLK_LEN:
                raise ValueError(f&#39;Invalid dek_key length, expected {MAC.AES128_BLK_LEN} bytes&#39;)
            # initialize NONCE
            if nonce:
                self._nonce = nonce
            nonce_len = BootImgRT.aead_nonce_len(self.app.size)
            if self._nonce is None:
                self._nonce = crypto_backend().random_bytes(nonce_len)
            elif len(self._nonce) != nonce_len:
                raise ValueError(f&#39;Invalid nonce length, expected {nonce_len} bytes&#39;)
            # encrypt APP
            assert self.hab_encrypted
            self.app.data = self._hab_encrypt_app_data(align_block(data, MAC.AES128_BLK_LEN))
        else:
            assert nonce is None

    def add_dcd_bin(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;Add DCD binary data.

        :param data: DCD binary data to be added
        &#34;&#34;&#34;
        assert self.dcd is None
        self.dcd = SegDCD.parse(data)
        assert self.dcd  # must be enabled to include DCD into export

    def add_csf_standard_auth(self, version: int, srk_table: SrkTable, src_key_index: int,
                              csf_cert: bytes, csf_priv_key: bytes,
                              img_cert: bytes, img_priv_key: bytes) -&gt; None:
        &#34;&#34;&#34;Add CSF with standard authentication.

        Before calling, application image and address must be assigned

        :param version: CSF segment version
        :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
        :param src_key_index: index of selected SRK key used for authentication
        :param csf_cert: CSF certificate
        :param csf_priv_key: CSF private key; decrypted binary data in PEM format
        :param img_cert: IMG certificate
        :param img_priv_key: IMG private key; decrypted binary data in PEM format
        &#34;&#34;&#34;
        assert 1 &lt;= len(srk_table) &lt;= 4
        assert 0 &lt;= src_key_index &lt; len(srk_table)
        csf = SegCSF(version=version, enabled=True)
        # install SRK
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
        cmd_ins.cmd_data_reference = srk_table
        csf.append_command(cmd_ins)
        # install CSF certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
        cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate content of the CSF segment
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=csf_priv_key)
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install image certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
        cert = x509.load_pem_x509_certificate(img_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate image data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=img_priv_key)
        cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
        if self.dcd:
            cmd_auth.append(self.address + self.ivt_offset + SegIVT2.SIZE + BootImgRT.BDT_SIZE, self.dcd.size)
        app_data = self.app.data
        assert app_data is not None
        cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        self.csf = csf

    @property
    def bee_encrypted(self) -&gt; bool:
        &#34;&#34;&#34;True if BEE encrypted XIP image (with SW keys); False otherwise; see also `hab_encrypted`.&#34;&#34;&#34;
        return self.bee.size &gt; 0

    @property
    def hab_encrypted(self) -&gt; bool:
        &#34;&#34;&#34;True if HAB encrypted; False otherwise; see also `bee_encrypted`.&#34;&#34;&#34;
        return self._dek_key is not None

    @staticmethod
    def aead_nonce_len(app_data_len: int) -&gt; int:
        &#34;&#34;&#34;Nonce len for AEAD encryption.

        Note: The code was taken from CST tool
        &#34;&#34;&#34;
        if app_data_len &lt; 0x10000:
            len_bytes = 2
        elif app_data_len &lt; 0x1000000:
            len_bytes = 3
        else:
            len_bytes = 4
        return 16 - 1 - len_bytes  # AES_BLOCK_BYTES - FLAG_BYTES - len_bytes

    def _hab_encrypt_app_data(self, app_data: bytes) -&gt; bytes:
        &#34;&#34;&#34;HAB Encrypt application data.

        :param app_data: application data to be encrypted
        :return: encrypted application data (using HAB encryption)
        &#34;&#34;&#34;
        assert self._nonce is not None
        assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
        dek = self.dek_key
        assert dek is not None
        aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
        encr = aesccm.encrypt(self._nonce, app_data, b&#39;&#39;)
        assert len(encr) == len(app_data) + 16
        self._mac = encr[-16:]
        return encr[:-16]

    @property
    def decrypted_app_data(self) -&gt; bytes:
        &#34;&#34;&#34;Return decrypted binary application data.

        Note: dek key, mac and nonce must be assigned for decryption
        &#34;&#34;&#34;
        app_data = self.app.data
        assert app_data
        if not self.hab_encrypted:
            return app_data

        assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
        mac = self._mac
        dek = self.dek_key
        assert mac and self._nonce and dek
        aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
        res = aesccm.decrypt(self._nonce, app_data + mac, b&#39;&#39;)
        return res

    def add_csf_encrypted(self, version: int, srk_table: SrkTable, src_key_index: int,
                          csf_cert: bytes, csf_priv_key: bytes,
                          img_cert: bytes, img_priv_key: bytes) -&gt; None:
        &#34;&#34;&#34;Add CSF with image encryption.

        Before calling, application image and address must be assigned

        :param version: CSF segment version
        :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
        :param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
        :param csf_cert: CSF certificate
        :param csf_priv_key: CSF private key; decrypted binary data in PEM format
        :param img_cert: IMG certificate
        :param img_priv_key: IMG private key; decrypted binary data in PEM format
        &#34;&#34;&#34;
        assert 1 &lt;= len(srk_table) &lt;= 4
        assert 0 &lt;= src_key_index &lt; len(srk_table)
        csf = SegCSF(version=version, enabled=True)
        # install SRK
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
        cmd_ins.cmd_data_reference = srk_table
        csf.append_command(cmd_ins)
        # install CSF certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
        cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate content of the CSF segment
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=csf_priv_key)
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install image certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
        cert = x509.load_pem_x509_certificate(img_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate image data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS,
                               EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
        cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
        app_data = self.app.data
        assert app_data is not None
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install DEK key
        cmd_ins = CmdInstallKey(EnumInsKey.ABS, EnumCertFormat.BLOB, EnumAlgorithm.ANY, 0, 0)
        csf.append_command(cmd_ins)
        # check encrypted data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 0, EnumCertFormat.AEAD,
                               EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
        assert app_data is not None
        cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
        cmd_auth.cmd_data_reference = MAC(version=version, nonce_len=0xD, mac_len=16)
        csf.append_command(cmd_auth)
        #
        self.csf = csf

    def _export_fcb_bee(self, dbg_info: DebugInfo) -&gt; bytes:
        &#34;&#34;&#34;Export FCB and BEE segments.

        :param dbg_info: optional instance to provide info about exported data
        :return: binary FCB segment and BEE regions
        :raise ValueError: if any BEE region is configured for images not located in the FLASH
        &#34;&#34;&#34;
        if not self.fcb.enabled:
            return b&#39;&#39;
        data = self.fcb.export(dbg_info=dbg_info)
        assert len(data) == self.fcb.space
        if self.ivt_offset == self.IVT_OFFSET_NOR_FLASH:
            data += self.bee.export(dbg_info=dbg_info)
        elif self.bee.space &gt; 0:
            raise ValueError(&#39;BEE can be configured only for XIP images located in FLASH&#39;)
        return data

    def _bee_encrypt_img_data(self, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt data located in BEE regions.

        :param data: image data (including IVT offset) to be encrypted
        :return: the image with encrypted regions
        :raise ValueError: if image configuration is invalid and BEE encryption cannot be applied
        &#34;&#34;&#34;
        if not self.bee_encrypted:
            return data

        if self.ivt_offset != self.IVT_OFFSET_NOR_FLASH:
            raise ValueError(&#39;BEE encryption is supported only for NOR FLASH&#39;)
        if self.hab_encrypted:
            raise ValueError(&#39;BEE encryption cannot be used for HAB encrypted images&#39;)

        # encrypt
        return data[:self.ivt_offset] + self.bee.encrypt_data(self.address + self.ivt_offset, data[self.ivt_offset:])

    def export(self, zulu: datetime = datetime.now(timezone.utc),
               dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export image as bytes array.

        :param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
                Note: the parameter is applied to CSF only, so it is not used for unsigned images
        :param dbg_info: optional instance to provide info about exported data
        :raises ValueError: If the image is not encrypted
        :return: bytes
        &#34;&#34;&#34;
        csf = self.enabled_csf
        if csf:
            csf.update_signatures(zulu, b&#39;&#39;, 0)  # dummy call to provide size of the CSF section
        elif self.dek_key is not None:
            raise ValueError(&#39;CSF must be assigned for encrypted images&#39;)

        self._update()
        dbg_info.append_section(&#39;RT10xxBootableImage&#39;)
        # FCB + BEE
        data = self._export_fcb_bee(dbg_info)

        # IVT
        ivt_data = self.ivt.export()
        data += ivt_data
        dbg_info.append_binary_section(&#39;IVT&#39;, ivt_data)
        # BDT
        bdt_data = self.bdt.export()
        data += bdt_data
        dbg_info.append_binary_section(&#39;BDT&#39;, bdt_data)
        # DCD
        if (self.dcd is not None) and self.dcd.enabled:
            assert self.dcd.padding_len == 0  # no padding
            dcd_data = self.dcd.export()
            data += dcd_data
            dbg_info.append_binary_section(&#39;DCD&#39;, dcd_data)
        # padding before APP
        app_alignment = self.app_offset if self.fcb.enabled else self.app_offset - self.ivt_offset
        assert app_alignment &gt;= len(data)
        data = extend_block(data, app_alignment)
        # APP
        app_data = self.app.export()
        data += app_data
        dbg_info.append_binary_section(&#39;APP&#39;, app_data)
        # CSF
        if csf:
            if dbg_info:
                dbg_info.append_section(&#39;CSF&#39;)
            base_data_addr = self.address if self.fcb.enabled else self.address + self.ivt_offset
            csf.update_signatures(zulu, data, base_data_addr)
            data += csf.export(dbg_info=dbg_info)

        return self._bee_encrypt_img_data(data)

    @classmethod
    def _find_ivt_pos(cls, strm: Union[BufferedReader, BytesIO], size: Optional[int] = None) -&gt; Tuple[Header, int, int]:
        &#34;&#34;&#34;Search IVT start position in the image; used by parser.

        :param strm: of image data; start seeking from current position
        :param size: maximum length
        :raise ValueError: Raised when IVT is not found
        :return: tuple with: Header, start position, end position
        &#34;&#34;&#34;
        start_pos = strm.tell()
        end_pos = strm.seek(0, SEEK_END)

        if size:
            end_pos = min(start_pos + size, end_pos)

        for ivt_ofs in [0] + list(cls.IVT_OFFSETS):

            if start_pos + ivt_ofs &gt; end_pos:
                break
            strm.seek(start_pos + ivt_ofs)
            header_data = read_raw_data(strm, Header.SIZE, no_seek=True)
            try:
                header = Header.parse(header_data, required_tag=SegTag.IVT2)
                if (header.length == SegIVT2.SIZE) and (header.param in cls.VERSIONS):
                    return header, start_pos + ivt_ofs, end_pos
            except UnparsedException:  # ignore different header tags
                pass

        raise ValueError(&#34;IVT not found&#34;)

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0,
              size: Optional[int] = None) -&gt; &#39;BootImgRT&#39;:
        &#34;&#34;&#34;Parse bootable RT image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step (this parameter is not used for RT)
        :param size: parsing size; None to parse till the end of the stream
        :raises TypeError: Raised when the value type is incorrect
        :return: BootImgRT object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

        header, start_pos, end_pos = cls._find_ivt_pos(stream, size)

        obj = BootImgRT(0, version=header.param)
        img_size = end_pos - start_pos
        if start_pos &gt; 0:
            obj.ivt_offset = start_pos

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        stream.seek(start_pos + obj.ivt.bdt_address - obj.ivt.ivt_address)
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.ivt_offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        # Parse DCD
        if obj.ivt.dcd_address:
            stream.seek(start_pos + obj.ivt.dcd_address - obj.ivt.ivt_address)
            dcd_obj = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd = dcd_obj
            dcd_obj.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - dcd_obj.size
        # Parse APP
        if obj.ivt.csf_address &gt; 0:
            app_size = obj.ivt.csf_address - obj.ivt.ivt_address - (obj.app_offset - obj.ivt_offset)
        else:
            app_size = img_size - (obj.app_offset - obj.ivt_offset)
        obj.app.data = read_raw_data(stream, app_size, obj.app_offset - obj.ivt_offset + start_pos)
        obj.app.padding = 0
        # Parse CSF
        if obj.ivt.csf_address:
            csf_start = start_pos + (obj.ivt.csf_address - obj.ivt.ivt_address)
            obj.csf = SegCSF.parse(read_raw_data(stream, cls.CSF_SIZE, csf_start))
            # detect encrypted image using MAC section
            mac = next(obj.csf.macs, None)
            if mac:
                obj._nonce = mac.nonce
                obj._mac = mac.mac
                obj._dek_key = bytes([0]) * MAC.AES128_BLK_LEN  # dek key is not known

        # Parse FCB
        fcb_size = FlexSPIConfBlockFCB().size
        if start_pos &gt;= fcb_size:
            fcb_data = read_raw_data(stream, fcb_size, 0)
            if fcb_data == b&#39;\x00&#39; * fcb_size:  # test if empty
                obj.fcb = PaddingFCB(fcb_size)
            else:
                obj.set_flexspi_fcb(fcb_data)
        else:
            obj.fcb = PaddingFCB(0, enabled=False)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.BootImgRT.BDT_SIZE"><code class="name">var <span class="ident">BDT_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.BEE_OFFSET"><code class="name">var <span class="ident">BEE_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.DEK_SIZE"><code class="name">var <span class="ident">DEK_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.IVT_OFFSETS"><code class="name">var <span class="ident">IVT_OFFSETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.IVT_OFFSET_NOR_FLASH"><code class="name">var <span class="ident">IVT_OFFSET_NOR_FLASH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.IVT_OFFSET_OTHER"><code class="name">var <span class="ident">IVT_OFFSET_OTHER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.NON_XIP_APP_OFFSET"><code class="name">var <span class="ident">NON_XIP_APP_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.VERSIONS"><code class="name">var <span class="ident">VERSIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.BootImgRT.XIP_APP_OFFSET"><code class="name">var <span class="ident">XIP_APP_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.BootImgRT.aead_nonce_len"><code class="name flex">
<span>def <span class="ident">aead_nonce_len</span></span>(<span>app_data_len: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Nonce len for AEAD encryption.</p>
<p>Note: The code was taken from CST tool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def aead_nonce_len(app_data_len: int) -&gt; int:
    &#34;&#34;&#34;Nonce len for AEAD encryption.

    Note: The code was taken from CST tool
    &#34;&#34;&#34;
    if app_data_len &lt; 0x10000:
        len_bytes = 2
    elif app_data_len &lt; 0x1000000:
        len_bytes = 3
    else:
        len_bytes = 4
    return 16 - 1 - len_bytes  # AES_BLOCK_BYTES - FLAG_BYTES - len_bytes</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream: Union[bytes, bytearray, _io.BufferedReader, _io.BytesIO], step: int = 0, size: Union[int, NoneType] = None) ‑> <a title="spsdk.image.images.BootImgRT" href="images.html#spsdk.image.images.BootImgRT">BootImgRT</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse bootable RT image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step (this parameter is not used for RT)
:param size: parsing size; None to parse till the end of the stream
:raises TypeError: Raised when the value type is incorrect
:return: BootImgRT object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0,
          size: Optional[int] = None) -&gt; &#39;BootImgRT&#39;:
    &#34;&#34;&#34;Parse bootable RT image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step (this parameter is not used for RT)
    :param size: parsing size; None to parse till the end of the stream
    :raises TypeError: Raised when the value type is incorrect
    :return: BootImgRT object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    header, start_pos, end_pos = cls._find_ivt_pos(stream, size)

    obj = BootImgRT(0, version=header.param)
    img_size = end_pos - start_pos
    if start_pos &gt; 0:
        obj.ivt_offset = start_pos

    # Parse IVT
    obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    stream.seek(start_pos + obj.ivt.bdt_address - obj.ivt.ivt_address)
    obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
    obj.ivt_offset = obj.ivt.ivt_address - obj.bdt.app_start
    obj.address = obj.bdt.app_start
    # Parse DCD
    if obj.ivt.dcd_address:
        stream.seek(start_pos + obj.ivt.dcd_address - obj.ivt.ivt_address)
        dcd_obj = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        obj.dcd = dcd_obj
        dcd_obj.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - dcd_obj.size
    # Parse APP
    if obj.ivt.csf_address &gt; 0:
        app_size = obj.ivt.csf_address - obj.ivt.ivt_address - (obj.app_offset - obj.ivt_offset)
    else:
        app_size = img_size - (obj.app_offset - obj.ivt_offset)
    obj.app.data = read_raw_data(stream, app_size, obj.app_offset - obj.ivt_offset + start_pos)
    obj.app.padding = 0
    # Parse CSF
    if obj.ivt.csf_address:
        csf_start = start_pos + (obj.ivt.csf_address - obj.ivt.ivt_address)
        obj.csf = SegCSF.parse(read_raw_data(stream, cls.CSF_SIZE, csf_start))
        # detect encrypted image using MAC section
        mac = next(obj.csf.macs, None)
        if mac:
            obj._nonce = mac.nonce
            obj._mac = mac.mac
            obj._dek_key = bytes([0]) * MAC.AES128_BLK_LEN  # dek key is not known

    # Parse FCB
    fcb_size = FlexSPIConfBlockFCB().size
    if start_pos &gt;= fcb_size:
        fcb_data = read_raw_data(stream, fcb_size, 0)
        if fcb_data == b&#39;\x00&#39; * fcb_size:  # test if empty
            obj.fcb = PaddingFCB(fcb_size)
        else:
            obj.set_flexspi_fcb(fcb_data)
    else:
        obj.fcb = PaddingFCB(0, enabled=False)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.BootImgRT.app"><code class="name">var <span class="ident">app</span> : <a title="spsdk.image.segments.SegAPP" href="segments.html#spsdk.image.segments.SegAPP">SegAPP</a></code></dt>
<dd>
<div class="desc"><p>Segment with application image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app(self) -&gt; SegAPP:
    &#34;&#34;&#34;Segment with application image.&#34;&#34;&#34;
    return self._app</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.app_offset"><code class="name">var <span class="ident">app_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: offset in the binary image, where the application starts.</p>
<p>Please mind: the offset include FCB block (even the FCB block is not exported)
The offset is 0x2000 for XIP images and 0x1000 for non-XIP images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app_offset(self) -&gt; int:
    &#34;&#34;&#34;:return: offset in the binary image, where the application starts.

    Please mind: the offset include FCB block (even the FCB block is not exported)
    The offset is 0x2000 for XIP images and 0x1000 for non-XIP images
    &#34;&#34;&#34;
    return BootImgRT.XIP_APP_OFFSET if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) \
        else BootImgRT.NON_XIP_APP_OFFSET</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.bdt"><code class="name">var <span class="ident">bdt</span> : <a title="spsdk.image.segments.SegBDT" href="segments.html#spsdk.image.segments.SegBDT">SegBDT</a></code></dt>
<dd>
<div class="desc"><p>Boot Data Table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; SegBDT:
    &#34;&#34;&#34;Boot Data Table.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.bee"><code class="name">var <span class="ident">bee</span> : <a title="spsdk.image.segments.SegBEE" href="segments.html#spsdk.image.segments.SegBEE">SegBEE</a></code></dt>
<dd>
<div class="desc"><p>:return: BEE segment that contains configuration of encrypted XIP.</p>
<p>By default, BEE segment is empty. PRDB regions may be specified only for XIP images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bee(self) -&gt; SegBEE:
    &#34;&#34;&#34;:return: BEE segment that contains configuration of encrypted XIP.

    By default, BEE segment is empty. PRDB regions may be specified only for XIP images.
    &#34;&#34;&#34;
    return self._bee</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.bee_encrypted"><code class="name">var <span class="ident">bee_encrypted</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if BEE encrypted XIP image (with SW keys); False otherwise; see also <code>hab_encrypted</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bee_encrypted(self) -&gt; bool:
    &#34;&#34;&#34;True if BEE encrypted XIP image (with SW keys); False otherwise; see also `hab_encrypted`.&#34;&#34;&#34;
    return self.bee.size &gt; 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.csf"><code class="name">var <span class="ident">csf</span> : Union[<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Command Sequence File (CSF), signature block for Secure Boot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; Optional[SegCSF]:
    &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.decrypted_app_data"><code class="name">var <span class="ident">decrypted_app_data</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return decrypted binary application data.</p>
<p>Note: dek key, mac and nonce must be assigned for decryption</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def decrypted_app_data(self) -&gt; bytes:
    &#34;&#34;&#34;Return decrypted binary application data.

    Note: dek key, mac and nonce must be assigned for decryption
    &#34;&#34;&#34;
    app_data = self.app.data
    assert app_data
    if not self.hab_encrypted:
        return app_data

    assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
    mac = self._mac
    dek = self.dek_key
    assert mac and self._nonce and dek
    aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
    res = aesccm.decrypt(self._nonce, app_data + mac, b&#39;&#39;)
    return res</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.dek_img_offset"><code class="name">var <span class="ident">dek_img_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Offset of the DEK key in the image; -1 if DEK key address is available (see <code>dek_ram_address</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek_img_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of the DEK key in the image; -1 if DEK key address is available (see `dek_ram_address`).&#34;&#34;&#34;
    result = self.dek_ram_address
    return result if result &lt; 0 else result - self.address</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.dek_key"><code class="name">var <span class="ident">dek_key</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>DEK key for encrypted images; None for non-encrypted images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek_key(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;DEK key for encrypted images; None for non-encrypted images.&#34;&#34;&#34;
    return self._dek_key</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.dek_ram_address"><code class="name">var <span class="ident">dek_ram_address</span> : int</code></dt>
<dd>
<div class="desc"><p>Address of the DEK key in the RAM memory retrieved from the corresponding command.</p>
<p>-1 if the image does not contain command for DEK key installation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek_ram_address(self) -&gt; int:
    &#34;&#34;&#34;Address of the DEK key in the RAM memory retrieved from the corresponding command.

    -1 if the image does not contain command for DEK key installation
    &#34;&#34;&#34;
    csf = self.enabled_csf
    if csf:
        for cmd in csf.commands:
            if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                return cmd.cmd_data_location
    return -1</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.enabled_csf"><code class="name">var <span class="ident">enabled_csf</span> : Union[<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled_csf(self) -&gt; Optional[SegCSF]:
    &#34;&#34;&#34;Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.&#34;&#34;&#34;
    return None if (self.csf is None) or not self.csf.enabled else self.csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.fcb"><code class="name">var <span class="ident">fcb</span> : <a title="spsdk.image.segments.AbstractFCB" href="segments.html#spsdk.image.segments.AbstractFCB">AbstractFCB</a></code></dt>
<dd>
<div class="desc"><p>Flash Configuration(Control) Block, binary data; content depends on FLASH type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fcb(self) -&gt; AbstractFCB:
    &#34;&#34;&#34;Flash Configuration(Control) Block, binary data; content depends on FLASH type.&#34;&#34;&#34;
    return self._fcb</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.hab_encrypted"><code class="name">var <span class="ident">hab_encrypted</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if HAB encrypted; False otherwise; see also <code>bee_encrypted</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hab_encrypted(self) -&gt; bool:
    &#34;&#34;&#34;True if HAB encrypted; False otherwise; see also `bee_encrypted`.&#34;&#34;&#34;
    return self._dek_key is not None</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.ivt"><code class="name">var <span class="ident">ivt</span> : <a title="spsdk.image.segments.SegIVT2" href="segments.html#spsdk.image.segments.SegIVT2">SegIVT2</a></code></dt>
<dd>
<div class="desc"><p>Image Vector Table (IVT) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; SegIVT2:
    &#34;&#34;&#34;Image Vector Table (IVT) segment.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.ivt_offset"><code class="name">var <span class="ident">ivt_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Offset of the Image Vector Table (IVT) in the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of the Image Vector Table (IVT) in the image.&#34;&#34;&#34;
    return self.offset</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.plugin"><code class="name">var <span class="ident">plugin</span> : bool</code></dt>
<dd>
<div class="desc"><p>Flag whether it is plugin image type; It is not fully supported by SPSDK yet.</p>
<p>Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; bool:
    &#34;&#34;&#34;Flag whether it is plugin image type; It is not fully supported by SPSDK yet.

    Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.
    &#34;&#34;&#34;
    return bool(self._bdt.plugin)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the exported binary data.</p>
<p>Please mind, FCB is exported optionally, but it is always included in the size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the exported binary data.

    Please mind, FCB is exported optionally, but it is always included in the size
    &#34;&#34;&#34;
    if self.fcb.enabled:
        result = self.app_offset + self.app.space
    else:
        result = self.app_offset + self.app.space - self.ivt_offset
    if (self.csf is not None) and self.csf.enabled:
        result += self.csf.space
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Version of the image format; must be from BootImgRT.VERSIONS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of the image format; must be from BootImgRT.VERSIONS.&#34;&#34;&#34;
    return self._ivt.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.BootImgRT.add_csf_encrypted"><code class="name flex">
<span>def <span class="ident">add_csf_encrypted</span></span>(<span>self, version: int, srk_table: <a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, src_key_index: int, csf_cert: bytes, csf_priv_key: bytes, img_cert: bytes, img_priv_key: bytes) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add CSF with image encryption.</p>
<p>Before calling, application image and address must be assigned</p>
<p>:param version: CSF segment version
:param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
:param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
:param csf_cert: CSF certificate
:param csf_priv_key: CSF private key; decrypted binary data in PEM format
:param img_cert: IMG certificate
:param img_priv_key: IMG private key; decrypted binary data in PEM format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_csf_encrypted(self, version: int, srk_table: SrkTable, src_key_index: int,
                      csf_cert: bytes, csf_priv_key: bytes,
                      img_cert: bytes, img_priv_key: bytes) -&gt; None:
    &#34;&#34;&#34;Add CSF with image encryption.

    Before calling, application image and address must be assigned

    :param version: CSF segment version
    :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
    :param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
    :param csf_cert: CSF certificate
    :param csf_priv_key: CSF private key; decrypted binary data in PEM format
    :param img_cert: IMG certificate
    :param img_priv_key: IMG private key; decrypted binary data in PEM format
    &#34;&#34;&#34;
    assert 1 &lt;= len(srk_table) &lt;= 4
    assert 0 &lt;= src_key_index &lt; len(srk_table)
    csf = SegCSF(version=version, enabled=True)
    # install SRK
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
    cmd_ins.cmd_data_reference = srk_table
    csf.append_command(cmd_ins)
    # install CSF certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
    cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate content of the CSF segment
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                           certificate=cert, private_key_pem_data=csf_priv_key)
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    # install image certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
    cert = x509.load_pem_x509_certificate(img_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate image data
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS,
                           EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
    cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
    app_data = self.app.data
    assert app_data is not None
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    # install DEK key
    cmd_ins = CmdInstallKey(EnumInsKey.ABS, EnumCertFormat.BLOB, EnumAlgorithm.ANY, 0, 0)
    csf.append_command(cmd_ins)
    # check encrypted data
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 0, EnumCertFormat.AEAD,
                           EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
    assert app_data is not None
    cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
    cmd_auth.cmd_data_reference = MAC(version=version, nonce_len=0xD, mac_len=16)
    csf.append_command(cmd_auth)
    #
    self.csf = csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.add_csf_standard_auth"><code class="name flex">
<span>def <span class="ident">add_csf_standard_auth</span></span>(<span>self, version: int, srk_table: <a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, src_key_index: int, csf_cert: bytes, csf_priv_key: bytes, img_cert: bytes, img_priv_key: bytes) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add CSF with standard authentication.</p>
<p>Before calling, application image and address must be assigned</p>
<p>:param version: CSF segment version
:param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
:param src_key_index: index of selected SRK key used for authentication
:param csf_cert: CSF certificate
:param csf_priv_key: CSF private key; decrypted binary data in PEM format
:param img_cert: IMG certificate
:param img_priv_key: IMG private key; decrypted binary data in PEM format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_csf_standard_auth(self, version: int, srk_table: SrkTable, src_key_index: int,
                          csf_cert: bytes, csf_priv_key: bytes,
                          img_cert: bytes, img_priv_key: bytes) -&gt; None:
    &#34;&#34;&#34;Add CSF with standard authentication.

    Before calling, application image and address must be assigned

    :param version: CSF segment version
    :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
    :param src_key_index: index of selected SRK key used for authentication
    :param csf_cert: CSF certificate
    :param csf_priv_key: CSF private key; decrypted binary data in PEM format
    :param img_cert: IMG certificate
    :param img_priv_key: IMG private key; decrypted binary data in PEM format
    &#34;&#34;&#34;
    assert 1 &lt;= len(srk_table) &lt;= 4
    assert 0 &lt;= src_key_index &lt; len(srk_table)
    csf = SegCSF(version=version, enabled=True)
    # install SRK
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
    cmd_ins.cmd_data_reference = srk_table
    csf.append_command(cmd_ins)
    # install CSF certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
    cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate content of the CSF segment
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                           certificate=cert, private_key_pem_data=csf_priv_key)
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    # install image certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
    cert = x509.load_pem_x509_certificate(img_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate image data
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS, EnumEngine.DCP,
                           certificate=cert, private_key_pem_data=img_priv_key)
    cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
    if self.dcd:
        cmd_auth.append(self.address + self.ivt_offset + SegIVT2.SIZE + BootImgRT.BDT_SIZE, self.dcd.size)
    app_data = self.app.data
    assert app_data is not None
    cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    self.csf = csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.add_dcd_bin"><code class="name flex">
<span>def <span class="ident">add_dcd_bin</span></span>(<span>self, data: bytes) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add DCD binary data.</p>
<p>:param data: DCD binary data to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dcd_bin(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;Add DCD binary data.

    :param data: DCD binary data to be added
    &#34;&#34;&#34;
    assert self.dcd is None
    self.dcd = SegDCD.parse(data)
    assert self.dcd  # must be enabled to include DCD into export</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data: bytes, img_type: <a title="spsdk.image.images.EnumAppType" href="images.html#spsdk.image.images.EnumAppType">EnumAppType</a> = 4, address: int = -1, dek_key: Union[bytes, NoneType] = None, nonce: Union[bytes, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of img
:param img_type: value must be EnumAppType.APP, no other options supported in this class
:param address: start address of the application (entry point); Use -1 to detect the address from the image
:param dek_key: key for AES128 image HAB encryption [16 bytes],
- use None for non-encrypted images;
- use empty bytes to create random key (recommended)
- use fixed key for testing to produce stable output
:param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
For non-encrypted image use <code>None</code>
The parameter should be used only for testing to produce stable output
:raise ValueError: if any parameter is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = -1,
              dek_key: Optional[bytes] = None, nonce: Optional[bytes] = None) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of img
    :param img_type: value must be EnumAppType.APP, no other options supported in this class
    :param address: start address of the application (entry point); Use -1 to detect the address from the image
    :param dek_key: key for AES128 image HAB encryption [16 bytes],
                - use None for non-encrypted images;
                - use empty bytes to create random key (recommended)
                - use fixed key for testing to produce stable output
    :param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
                    For non-encrypted image use `None`
                    The parameter should be used only for testing to produce stable output
    :raise ValueError: if any parameter is not valid
    &#34;&#34;&#34;
    assert img_type == EnumAppType.APP
    if self.app.data:
        raise ValueError(&#39;Image was already added&#39;)
    entry_addr = unpack_from(&#39;&lt;I&#39;, data, 4)[0]
    if entry_addr == 0:  # there can be padding for images located in RAM, see flashloader
        entry_addr = address
        assert entry_addr &gt; 0, &#39;entry_addr not detected from image, must be specified explicitly&#39;
    elif (address &gt;= 0) and (address != entry_addr):
        raise ValueError(&#39;entry_address does not match with the image&#39;)
    self._ivt.app_address = entry_addr
    self.app.data = data
    if dek_key is not None:  # encrypted?
        # initialize DEK key
        self._dek_key = bytes([0]) * MAC.AES128_BLK_LEN if len(dek_key) == 0 else dek_key
        if len(self._dek_key) != MAC.AES128_BLK_LEN:
            raise ValueError(f&#39;Invalid dek_key length, expected {MAC.AES128_BLK_LEN} bytes&#39;)
        # initialize NONCE
        if nonce:
            self._nonce = nonce
        nonce_len = BootImgRT.aead_nonce_len(self.app.size)
        if self._nonce is None:
            self._nonce = crypto_backend().random_bytes(nonce_len)
        elif len(self._nonce) != nonce_len:
            raise ValueError(f&#39;Invalid nonce length, expected {nonce_len} bytes&#39;)
        # encrypt APP
        assert self.hab_encrypted
        self.app.data = self._hab_encrypt_app_data(align_block(data, MAC.AES128_BLK_LEN))
    else:
        assert nonce is None</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, zulu: datetime.datetime = datetime.datetime(2020, 10, 30, 7, 52, 42, 186926, tzinfo=datetime.timezone.utc), dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export image as bytes array.</p>
<p>:param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
Note: the parameter is applied to CSF only, so it is not used for unsigned images
:param dbg_info: optional instance to provide info about exported data
:raises ValueError: If the image is not encrypted
:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, zulu: datetime = datetime.now(timezone.utc),
           dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export image as bytes array.

    :param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
            Note: the parameter is applied to CSF only, so it is not used for unsigned images
    :param dbg_info: optional instance to provide info about exported data
    :raises ValueError: If the image is not encrypted
    :return: bytes
    &#34;&#34;&#34;
    csf = self.enabled_csf
    if csf:
        csf.update_signatures(zulu, b&#39;&#39;, 0)  # dummy call to provide size of the CSF section
    elif self.dek_key is not None:
        raise ValueError(&#39;CSF must be assigned for encrypted images&#39;)

    self._update()
    dbg_info.append_section(&#39;RT10xxBootableImage&#39;)
    # FCB + BEE
    data = self._export_fcb_bee(dbg_info)

    # IVT
    ivt_data = self.ivt.export()
    data += ivt_data
    dbg_info.append_binary_section(&#39;IVT&#39;, ivt_data)
    # BDT
    bdt_data = self.bdt.export()
    data += bdt_data
    dbg_info.append_binary_section(&#39;BDT&#39;, bdt_data)
    # DCD
    if (self.dcd is not None) and self.dcd.enabled:
        assert self.dcd.padding_len == 0  # no padding
        dcd_data = self.dcd.export()
        data += dcd_data
        dbg_info.append_binary_section(&#39;DCD&#39;, dcd_data)
    # padding before APP
    app_alignment = self.app_offset if self.fcb.enabled else self.app_offset - self.ivt_offset
    assert app_alignment &gt;= len(data)
    data = extend_block(data, app_alignment)
    # APP
    app_data = self.app.export()
    data += app_data
    dbg_info.append_binary_section(&#39;APP&#39;, app_data)
    # CSF
    if csf:
        if dbg_info:
            dbg_info.append_section(&#39;CSF&#39;)
        base_data_addr = self.address if self.fcb.enabled else self.address + self.ivt_offset
        csf.update_signatures(zulu, data, base_data_addr)
        data += csf.export(dbg_info=dbg_info)

    return self._bee_encrypt_img_data(data)</code></pre>
</details>
</dd>
<dt id="spsdk.image.BootImgRT.set_flexspi_fcb"><code class="name flex">
<span>def <span class="ident">set_flexspi_fcb</span></span>(<span>self, data: Union[bytes, <a title="spsdk.image.segments.FlexSPIConfBlockFCB" href="segments.html#spsdk.image.segments.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set FlexSPI external FLASH configuration.</p>
<p>:param data: FlexSPIConfBlockFCB or binary data representing
:raise ValueError: if data are not valid Flex SPI configuration block</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_flexspi_fcb(self, data: Union[bytes, FlexSPIConfBlockFCB]) -&gt; None:
    &#34;&#34;&#34;Set FlexSPI external FLASH configuration.

    :param data: FlexSPIConfBlockFCB or binary data representing
    :raise ValueError: if data are not valid Flex SPI configuration block
    &#34;&#34;&#34;
    self.fcb = data if isinstance(data, FlexSPIConfBlockFCB) else FlexSPIConfBlockFCB.parse(data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="images.html#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="images.html#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
<li><code><a title="spsdk.image.images.BootImgBase.info" href="images.html#spsdk.image.images.BootImgBase.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CFPA"><code class="flex name class">
<span>class <span class="ident">CFPA</span></span>
<span>(</span><span>device: str, keys: List[cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey] = None, revision: str = None, user_config: dict = None, rotkh: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Customer In-Field Configuration Area.</p>
<p>Initialize an instance.</p>
<p>:param device: device to use, list of supported devices is available via 'devices' method
:param keys: list of RSA Public Keys to compute ROTKH
:param revision: silicon revision, if not specified, the latest is being used
:param user_config: dict with user configuration
:param rotkh: pre-computed ROTKH</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CFPA(BaseConfigArea):
    &#34;&#34;&#34;Customer In-Field Configuration Area.&#34;&#34;&#34;
    CONFIG_DIR = os.path.join(BaseConfigArea.CONFIG_DIR, &#34;cfpa&#34;)
    HAS_ROTKH = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.pfr.BaseConfigArea" href="pfr.html#spsdk.image.pfr.BaseConfigArea">BaseConfigArea</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.CFPA.CONFIG_DIR"><code class="name">var <span class="ident">CONFIG_DIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CFPA.HAS_ROTKH"><code class="name">var <span class="ident">HAS_ROTKH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.pfr.BaseConfigArea" href="pfr.html#spsdk.image.pfr.BaseConfigArea">BaseConfigArea</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.pfr.BaseConfigArea.devices" href="pfr.html#spsdk.image.pfr.BaseConfigArea.devices">devices</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.export" href="pfr.html#spsdk.image.pfr.BaseConfigArea.export">export</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.generate_config" href="pfr.html#spsdk.image.pfr.BaseConfigArea.generate_config">generate_config</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.get_address" href="pfr.html#spsdk.image.pfr.BaseConfigArea.get_address">get_address</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.get_devices" href="pfr.html#spsdk.image.pfr.BaseConfigArea.get_devices">get_devices</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.get_revisions" href="pfr.html#spsdk.image.pfr.BaseConfigArea.get_revisions">get_revisions</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.parse" href="pfr.html#spsdk.image.pfr.BaseConfigArea.parse">parse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CMPA"><code class="flex name class">
<span>class <span class="ident">CMPA</span></span>
<span>(</span><span>device: str, keys: List[cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey] = None, revision: str = None, user_config: dict = None, rotkh: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Customer Manufacturing Configuration Area.</p>
<p>Initialize an instance.</p>
<p>:param device: device to use, list of supported devices is available via 'devices' method
:param keys: list of RSA Public Keys to compute ROTKH
:param revision: silicon revision, if not specified, the latest is being used
:param user_config: dict with user configuration
:param rotkh: pre-computed ROTKH</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CMPA(BaseConfigArea):
    &#34;&#34;&#34;Customer Manufacturing Configuration Area.&#34;&#34;&#34;
    CONFIG_DIR = os.path.join(BaseConfigArea.CONFIG_DIR, &#34;cmpa&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.pfr.BaseConfigArea" href="pfr.html#spsdk.image.pfr.BaseConfigArea">BaseConfigArea</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.CMPA.CONFIG_DIR"><code class="name">var <span class="ident">CONFIG_DIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.pfr.BaseConfigArea" href="pfr.html#spsdk.image.pfr.BaseConfigArea">BaseConfigArea</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.pfr.BaseConfigArea.devices" href="pfr.html#spsdk.image.pfr.BaseConfigArea.devices">devices</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.export" href="pfr.html#spsdk.image.pfr.BaseConfigArea.export">export</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.generate_config" href="pfr.html#spsdk.image.pfr.BaseConfigArea.generate_config">generate_config</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.get_address" href="pfr.html#spsdk.image.pfr.BaseConfigArea.get_address">get_address</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.get_devices" href="pfr.html#spsdk.image.pfr.BaseConfigArea.get_devices">get_devices</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.get_revisions" href="pfr.html#spsdk.image.pfr.BaseConfigArea.get_revisions">get_revisions</a></code></li>
<li><code><a title="spsdk.image.pfr.BaseConfigArea.parse" href="pfr.html#spsdk.image.pfr.BaseConfigArea.parse">parse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CertificateImg"><code class="flex name class">
<span>class <span class="ident">CertificateImg</span></span>
<span>(</span><span>version: int = 64, data: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate structure for bootable image.</p>
<p>Initialize the certificate structure for bootable image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertificateImg(BaseClass):
    &#34;&#34;&#34;Certificate structure for bootable image.&#34;&#34;&#34;

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Certificate structure for bootable image.&#34;&#34;&#34;
        return Header.SIZE + len(self._data)

    def __init__(self, version: int = 0x40, data: bytes = None) -&gt; None:
        &#34;&#34;&#34;Initialize the certificate structure for bootable image.&#34;&#34;&#34;
        super().__init__(SegTag.CRT, version)
        self._data = bytearray() if data is None else bytearray(data)

    def __repr__(self) -&gt; str:
        return f&#34;Certificate &lt;Ver: {self.version_major}.{self.version_minor}, Size: {len(self._data)}&gt;&#34;

    def __eq__(self, obj: Any) -&gt; bool:
        return isinstance(obj, CertificateImg) and vars(obj) == vars(self)

    def __ne__(self, obj: Any) -&gt; bool:
        return not self.__eq__(obj)

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; int:
        return self._data[key]

    def __setitem__(self, key: int, value: int) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[int]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the CertificateImg.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;Certificate (Ver: {:X}.{:X}, Size: {})\n&#34;.format(self.version &gt;&gt; 4, self.version &amp; 0xF, len(self._data))
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._header.length = self.size
        raw_data = self._header.export()
        dbg_info.append_binary_section(&#39;header&#39;, raw_data)
        raw_data += self._data
        dbg_info.append_binary_section(&#39;data&#39;, self._data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CertificateImg&#39;:
        &#34;&#34;&#34;Parse.&#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.CRT)
        offset += Header.SIZE
        return cls(header.param, data[offset: offset + header.length - Header.SIZE])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.CertificateImg.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CertificateImg&#39;:
    &#34;&#34;&#34;Parse.&#34;&#34;&#34;
    header = Header.parse(data, offset, SegTag.CRT)
    offset += Header.SIZE
    return cls(header.param, data[offset: offset + header.length - Header.SIZE])</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CertificateImg.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of Certificate structure for bootable image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of Certificate structure for bootable image.&#34;&#34;&#34;
    return Header.SIZE + len(self._data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CertificateImg.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._header.length = self.size
    raw_data = self._header.export()
    dbg_info.append_binary_section(&#39;header&#39;, raw_data)
    raw_data += self._data
    dbg_info.append_binary_section(&#39;data&#39;, self._data)
    return raw_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.CertificateImg.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the CertificateImg.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the CertificateImg.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;Certificate (Ver: {:X}.{:X}, Size: {})\n&#34;.format(self.version &gt;&gt; 4, self.version &amp; 0xF, len(self._data))
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.secret.BaseClass.version" href="secret.html#spsdk.image.secret.BaseClass.version">version</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_major" href="secret.html#spsdk.image.secret.BaseClass.version_major">version_major</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_minor" href="secret.html#spsdk.image.secret.BaseClass.version_minor">version_minor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdAuthData"><code class="flex name class">
<span>class <span class="ident">CmdAuthData</span></span>
<span>(</span><span>flags: <a title="spsdk.image.commands.EnumAuthDat" href="commands.html#spsdk.image.commands.EnumAuthDat">EnumAuthDat</a> = 0, key_index: int = 1, sig_format: <a title="spsdk.image.commands.EnumCertFormat" href="commands.html#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a> = 197, engine: <a title="spsdk.image.commands.EnumEngine" href="commands.html#spsdk.image.commands.EnumEngine">EnumEngine</a> = 0, engine_cfg: int = 0, location: int = 0, certificate: Union[cryptography.x509.base.Certificate, NoneType] = None, private_key_pem_data: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Authenticate data command.</p>
<p>Initialize the Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdAuthData(CmdBase):
    &#34;&#34;&#34;Authenticate data command.&#34;&#34;&#34;

    @property
    def flags(self) -&gt; int:
        &#34;&#34;&#34;Flag of Authenticate data command.&#34;&#34;&#34;
        return self._header.param

    @flags.setter
    def flags(self, value: int) -&gt; None:
        assert value in EnumAuthDat
        self._header.param = value

    @property
    def key_index(self) -&gt; int:
        &#34;&#34;&#34;Key index.&#34;&#34;&#34;
        return self._key_index

    @key_index.setter
    def key_index(self, value: int) -&gt; None:
        assert value in (0, 1, 2, 3, 4, 5)
        self._key_index = value

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine.&#34;&#34;&#34;
        return self._engine

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._engine = value

    def __init__(self, flags: EnumAuthDat = EnumAuthDat.CLR, key_index: int = 1,
                 sig_format: EnumCertFormat = EnumCertFormat.CMS, engine: EnumEngine = EnumEngine.ANY,
                 engine_cfg: int = 0, location: int = 0, certificate: Optional[Certificate] = None,
                 private_key_pem_data: Optional[bytes] = None):
        &#34;&#34;&#34;Initialize the Authenticate data command.&#34;&#34;&#34;
        super().__init__(CmdTag.AUT_DAT, flags)
        self.key_index = key_index
        self.sig_format = sig_format
        self.engine = engine
        self.engine_cfg = engine_cfg
        self.location = location
        self.certificate = certificate
        self.private_key_pem_data = private_key_pem_data
        self._header.length = CmdHeader.SIZE + 8
        self._blocks: List[Tuple[int, int]] = []  # list of (start-address, size)
        self._signature: Optional[SignatureOrMAC] = None
        if certificate and private_key_pem_data:
            assert isinstance(certificate, Certificate)
            assert isinstance(private_key_pem_data, bytes)
            assert matches_key_and_cert(private_key_pem_data, certificate)

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
        return True

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as signature or MAC, etc) in binary image.&#34;&#34;&#34;
        return self.location

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        &#34;&#34;&#34;
        self.location = value

    @property
    def cmd_data_reference(self) -&gt; Optional[SignatureOrMAC]:
        &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

        -   None if no reference was assigned;
        -   Value type is command-specific
        &#34;&#34;&#34;
        return self._signature

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: SignatureOrMAC) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference

        :param value: to be set
        :raise ValueError: if cmd reference not supported by the command
        &#34;&#34;&#34;
        if self.sig_format == EnumCertFormat.AEAD:
            assert isinstance(value, MAC)
        elif self.sig_format == EnumCertFormat.CMS:
            assert isinstance(value, Signature)
        else:
            assert False
        self._signature = value

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; SignatureOrMAC:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :return: parsed data object; command-specific: Signature or MAC
        &#34;&#34;&#34;
        if self.key_index == 0:  # TODO check by header
            self._signature = MAC.parse(data, offset)
        else:
            self._signature = Signature.parse(data, offset)
        return self._signature

    @property
    def signature(self) -&gt; Optional[SignatureOrMAC]:
        &#34;&#34;&#34;Signature referenced by `location` attribute.&#34;&#34;&#34;
        return self._signature

    @signature.setter
    def signature(self, value: SignatureOrMAC) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: signature to be installed by the command
        &#34;&#34;&#34;
        self.cmd_data_reference = value

    def __repr__(self) -&gt; str:
        return &#34;CmdAuthData &lt;{}, {}, {}, key:{}, 0x{:X}&gt;&#34;. \
            format(EnumAuthDat[self.flags], EnumEngine[self.engine],  # type: ignore
                   self.engine_cfg, self.key_index, self.location)

    def __len__(self) -&gt; int:
        return len(self._blocks)

    def __getitem__(self, key: int) -&gt; Tuple[int, int]:
        return self._blocks[key]

    def __setitem__(self, key: int, value: Tuple[int, int]) -&gt; None:
        assert isinstance(value, (list, tuple))
        assert len(value) == 2
        self._blocks[key] = value

    def __iter__(self) -&gt; Iterator[Union[Tuple[Any, ...], List[Any]]]:
        return self._blocks.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34; Flag:        {:d} ({})\n&#34;.format(self.flags, EnumAuthDat.desc(self.flags))
        msg += &#34; Key index:   {:d}\n&#34;.format(self.key_index)
        msg += &#34; Engine:      {:d} ({})\n&#34;.format(self.engine, EnumEngine.desc(self.engine))
        msg += &#34; Engine Conf: {:d}\n&#34;.format(self.engine_cfg)
        msg += &#34; Location:    0x{:08X} (Start address of authentication data) \n&#34;.format(self.location)
        if self.signature:
            msg += &#39;[related signature]\n&#39;
            msg += self.signature.info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        for blk in self._blocks:
            msg += &#34;- Start: 0x{0:08X}, Length: {1:d} Bytes\n&#34;.format(blk[0], blk[1])
        return msg

    def append(self, start_address: int, size: int) -&gt; None:
        &#34;&#34;&#34;Append of Authenticate data command.&#34;&#34;&#34;
        self._blocks.append((start_address, size), )
        self._header.length += 8

    def pop(self, index: int) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Pop of Authenticate data command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._blocks)
        value = self._blocks.pop(index)
        self._header.length -= 8
        return value

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Authenticate data command.&#34;&#34;&#34;
        self._blocks.clear()
        self._header.length = self._header.size + 8

    def _cms_signature(self, zulu: datetime, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Sign provided data and return CMS signature.

        :param zulu: current UTC time+date
        :param data: to be signed
        :return: CMS signature (binary)
        &#34;&#34;&#34;
        assert self.certificate is not None
        assert self.private_key_pem_data is not None

        # signed data (main section)
        signed_data = cms.SignedData()
        signed_data[&#39;version&#39;] = &#39;v1&#39;
        signed_data[&#39;encap_content_info&#39;] = util.OrderedDict([
            (&#39;content_type&#39;, &#39;data&#39;)
        ])
        signed_data[&#39;digest_algorithms&#39;] = [util.OrderedDict([
            (&#39;algorithm&#39;, &#39;sha256&#39;),
            (&#39;parameters&#39;, None)])]

        # signer info sub-section
        signer_info = cms.SignerInfo()
        signer_info[&#39;version&#39;] = &#39;v1&#39;
        signer_info[&#39;digest_algorithm&#39;] = util.OrderedDict([
            (&#39;algorithm&#39;, &#39;sha256&#39;),
            (&#39;parameters&#39;, None)])
        signer_info[&#39;signature_algorithm&#39;] = util.OrderedDict([
            (&#39;algorithm&#39;, &#39;rsassa_pkcs1v15&#39;),
            (&#39;parameters&#39;, b&#39;&#39;)])
        # signed identifier: issuer amd serial number
        asn1cert = x509.Certificate.load(self.certificate.public_bytes(Encoding.DER))
        signer_info[&#39;sid&#39;] = cms.SignerIdentifier({
            &#39;issuer_and_serial_number&#39;: cms.IssuerAndSerialNumber({
                &#39;issuer&#39;: asn1cert.issuer,
                &#39;serial_number&#39;: asn1cert.serial_number
            })
        })
        # signed attributes
        signed_attrs = cms.CMSAttributes()
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;content_type&#39;,
            &#39;values&#39;: [cms.ContentType(&#39;data&#39;)],
        }))
        # check time-zone is assigned (expected UTC+0)
        assert zulu.tzinfo
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;signing_time&#39;,
            &#39;values&#39;: [cms.Time(name=&#39;utc_time&#39;, value=zulu.strftime(&#39;%y%m%d%H%M%SZ&#39;))],
        }))
        signed_attrs.append(cms.CMSAttribute({
            &#39;type&#39;: &#39;message_digest&#39;,
            &#39;values&#39;: [cms.OctetString(crypto_backend().hash(data))],  # digest
        }))
        signer_info[&#39;signed_attrs&#39;] = signed_attrs

        # create signature
        signer_info[&#39;signature&#39;] = crypto_backend().rsa_sign(self.private_key_pem_data, signed_attrs.dump())

        # Adding SignerInfo object to SignedData object
        signed_data[&#39;signer_infos&#39;] = [signer_info]

        # content info
        content_info = cms.ContentInfo()
        content_info[&#39;content_type&#39;] = &#39;signed_data&#39;
        content_info[&#39;content&#39;] = signed_data

        return content_info.dump()

    def update_signature(self, zulu: datetime, data: bytes, base_data_addr: int = 0xFFFFFFFF) -&gt; bool:
        &#34;&#34;&#34;Update signature.

        This method must be called from parent to provide data to be signed

        :param zulu: current UTC time+date
        :param data: currently generated binary data
        :param base_data_addr: base address of the generated data
        :raises ValueError: When certificate or private key are not assigned
        :raises ValueError: When signatures not assigned explicitly
        :return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
                        to data);
        &#34;&#34;&#34;
        if not self.certificate or not self.private_key_pem_data:
            raise ValueError(&#39;certificate or private key not assigned, cannot update signature&#39;)

        if self.signature is None:
            raise ValueError(&#39;signature must be assigned explicitly, so its version matches to CST version&#39;)

        if self._blocks:
            sign_data = b&#39;&#39;
            if data:  # if not data specified, create &#34;fake&#34; signature to update length
                total_len = 0
                for blk in self._blocks:
                    start = blk[0] - base_data_addr
                    end = blk[0] + blk[1] - base_data_addr
                    assert start &gt;= 0
                    assert end &lt;= len(data)
                    sign_data += data[start: end]
                    total_len += blk[1]
                assert len(sign_data) == total_len
        else:
            sign_data = data  # if no blocks defined, sign complete data; used for CSF
        if isinstance(self.signature, Signature):
            new_signature = self._cms_signature(zulu, sign_data)
            result = len(self.signature.data) == len(new_signature)
            self.signature.data = new_signature
        else:
            assert isinstance(self.signature, MAC)
            result = True
        return result

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        self._header.length = self.size
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;4BL&#34;, self.key_index, self.sig_format, self.engine, self.engine_cfg, self.location)
        dbg_info.append_binary_data(&#39;data&#39;, data)
        raw_data += data
        for blk in self._blocks:
            blk_data = pack(&#34;&gt;2L&#34;, blk[0], blk[1])
            dbg_info.append_binary_data(&#39;block&#39;, blk_data)
            raw_data += blk_data
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdAuthData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to read from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.AUT_DAT)
        key, sig_format, eng, cfg, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
        obj = cls(EnumAuthDat.from_int(header.param), key, sig_format, EnumEngine.from_int(eng), cfg, location)
        index = header.size + 8
        while index &lt; header.length:
            start_address, size = unpack_from(&#34;&gt;2L&#34;, data, offset + index)
            obj.append(start_address, size)
            index += 8
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.CmdAuthData.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.commands.CmdAuthData" href="commands.html#spsdk.image.commands.CmdAuthData">CmdAuthData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary representation into command (deserialization from binary data).</p>
<p>:param data: being parsed
:param offset: current position to read from data
:return: parse command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdAuthData&#39;:
    &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

    :param data: being parsed
    :param offset: current position to read from data
    :return: parse command
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset, CmdTag.AUT_DAT)
    key, sig_format, eng, cfg, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
    obj = cls(EnumAuthDat.from_int(header.param), key, sig_format, EnumEngine.from_int(eng), cfg, location)
    index = header.size + 8
    while index &lt; header.length:
        start_address, size = unpack_from(&#34;&gt;2L&#34;, data, offset + index)
        obj.append(start_address, size)
        index += 8
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdAuthData.cmd_data_offset"><code class="name">var <span class="ident">cmd_data_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Offset of an additional data (such as signature or MAC, etc) in binary image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of an additional data (such as signature or MAC, etc) in binary image.&#34;&#34;&#34;
    return self.location</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.cmd_data_reference"><code class="name">var <span class="ident">cmd_data_reference</span> : Union[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>, <a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Reference to an additional data (such as certificate, signature, etc).</p>
<ul>
<li>None if no reference was assigned;</li>
<li>Value type is command-specific</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_reference(self) -&gt; Optional[SignatureOrMAC]:
    &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

    -   None if no reference was assigned;
    -   Value type is command-specific
    &#34;&#34;&#34;
    return self._signature</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.engine"><code class="name">var <span class="ident">engine</span> : <a title="spsdk.image.commands.EnumEngine" href="commands.html#spsdk.image.commands.EnumEngine">EnumEngine</a></code></dt>
<dd>
<div class="desc"><p>Engine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; EnumEngine:
    &#34;&#34;&#34;Engine.&#34;&#34;&#34;
    return self._engine</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.flags"><code class="name">var <span class="ident">flags</span> : int</code></dt>
<dd>
<div class="desc"><p>Flag of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; int:
    &#34;&#34;&#34;Flag of Authenticate data command.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.key_index"><code class="name">var <span class="ident">key_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Key index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key_index(self) -&gt; int:
    &#34;&#34;&#34;Key index.&#34;&#34;&#34;
    return self._key_index</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.needs_cmd_data_reference"><code class="name">var <span class="ident">needs_cmd_data_reference</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether the command contains a reference to an additional data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def needs_cmd_data_reference(self) -&gt; bool:
    &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.signature"><code class="name">var <span class="ident">signature</span> : Union[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>, <a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Signature referenced by <code>location</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signature(self) -&gt; Optional[SignatureOrMAC]:
    &#34;&#34;&#34;Signature referenced by `location` attribute.&#34;&#34;&#34;
    return self._signature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdAuthData.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, start_address: int, size: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, start_address: int, size: int) -&gt; None:
    &#34;&#34;&#34;Append of Authenticate data command.&#34;&#34;&#34;
    self._blocks.append((start_address, size), )
    self._header.length += 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Authenticate data command.&#34;&#34;&#34;
    self._blocks.clear()
    self._header.length = self._header.size + 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34; Flag:        {:d} ({})\n&#34;.format(self.flags, EnumAuthDat.desc(self.flags))
    msg += &#34; Key index:   {:d}\n&#34;.format(self.key_index)
    msg += &#34; Engine:      {:d} ({})\n&#34;.format(self.engine, EnumEngine.desc(self.engine))
    msg += &#34; Engine Conf: {:d}\n&#34;.format(self.engine_cfg)
    msg += &#34; Location:    0x{:08X} (Start address of authentication data) \n&#34;.format(self.location)
    if self.signature:
        msg += &#39;[related signature]\n&#39;
        msg += self.signature.info()
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    for blk in self._blocks:
        msg += &#34;- Start: 0x{0:08X}, Length: {1:d} Bytes\n&#34;.format(blk[0], blk[1])
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.parse_cmd_data"><code class="name flex">
<span>def <span class="ident">parse_cmd_data</span></span>(<span>self, data: bytes, offset: int) ‑> Union[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>, <a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse additional command data from binary data.</p>
<p>:param data: to be parsed
:param offset: start position in data to parse
:return: parsed data object; command-specific: Signature or MAC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_cmd_data(self, data: bytes, offset: int) -&gt; SignatureOrMAC:
    &#34;&#34;&#34;Parse additional command data from binary data.

    :param data: to be parsed
    :param offset: start position in data to parse
    :return: parsed data object; command-specific: Signature or MAC
    &#34;&#34;&#34;
    if self.key_index == 0:  # TODO check by header
        self._signature = MAC.parse(data, offset)
    else:
        self._signature = Signature.parse(data, offset)
    return self._signature</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index: int) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Pop of Authenticate data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Pop of Authenticate data command.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._blocks)
    value = self._blocks.pop(index)
    self._header.length -= 8
    return value</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdAuthData.update_signature"><code class="name flex">
<span>def <span class="ident">update_signature</span></span>(<span>self, zulu: datetime.datetime, data: bytes, base_data_addr: int = 4294967295) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update signature.</p>
<p>This method must be called from parent to provide data to be signed</p>
<p>:param zulu: current UTC time+date
:param data: currently generated binary data
:param base_data_addr: base address of the generated data
:raises ValueError: When certificate or private key are not assigned
:raises ValueError: When signatures not assigned explicitly
:return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
to data);</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_signature(self, zulu: datetime, data: bytes, base_data_addr: int = 0xFFFFFFFF) -&gt; bool:
    &#34;&#34;&#34;Update signature.

    This method must be called from parent to provide data to be signed

    :param zulu: current UTC time+date
    :param data: currently generated binary data
    :param base_data_addr: base address of the generated data
    :raises ValueError: When certificate or private key are not assigned
    :raises ValueError: When signatures not assigned explicitly
    :return: True if length of the signature was unchanged, as this may affect content of the CSF section (pointer
                    to data);
    &#34;&#34;&#34;
    if not self.certificate or not self.private_key_pem_data:
        raise ValueError(&#39;certificate or private key not assigned, cannot update signature&#39;)

    if self.signature is None:
        raise ValueError(&#39;signature must be assigned explicitly, so its version matches to CST version&#39;)

    if self._blocks:
        sign_data = b&#39;&#39;
        if data:  # if not data specified, create &#34;fake&#34; signature to update length
            total_len = 0
            for blk in self._blocks:
                start = blk[0] - base_data_addr
                end = blk[0] + blk[1] - base_data_addr
                assert start &gt;= 0
                assert end &lt;= len(data)
                sign_data += data[start: end]
                total_len += blk[1]
            assert len(sign_data) == total_len
    else:
        sign_data = data  # if no blocks defined, sign complete data; used for CSF
    if isinstance(self.signature, Signature):
        new_signature = self._cms_signature(zulu, sign_data)
        result = len(self.signature.data) == len(new_signature)
        self.signature.data = new_signature
    else:
        assert isinstance(self.signature, MAC)
        result = True
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdCheckData"><code class="flex name class">
<span>class <span class="ident">CmdCheckData</span></span>
<span>(</span><span>numbytes: int = 4, ops: int = 1, address: int = 0, mask: int = 0, count: Union[int, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check data command.</p>
<p>Initialize the check data command.</p>
<p>:param numbytes: number of bytes
:param ops: type of
operation
:param address: list of tuples: address and value
:param mask: mask value
:param count: count value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdCheckData(CmdBase):
    &#34;&#34;&#34;Check data command.&#34;&#34;&#34;

    @property
    def num_bytes(self) -&gt; int:
        &#34;&#34;&#34;Number of bytes.&#34;&#34;&#34;
        return self._header.param &amp; 0x7

    @num_bytes.setter
    def num_bytes(self, value: int) -&gt; None:
        assert value in (1, 2, 4)
        self._header.param &amp;= ~0x7
        self._header.param |= int(value)

    @property
    def ops(self) -&gt; int:
        &#34;&#34;&#34;Operation of Check data command.&#34;&#34;&#34;
        return (self._header.param &gt;&gt; 3) &amp; 0x3

    @ops.setter
    def ops(self, value: int) -&gt; None:
        assert value in EnumCheckOps
        self._header.param &amp;= ~(0x3 &lt;&lt; 3)
        self._header.param |= int(value) &lt;&lt; 3

    def __init__(self, numbytes: int = 4, ops: int = EnumCheckOps.ALL_SET, address: int = 0, mask: int = 0,
                 count: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize the check data command.

        :param numbytes: number of bytes
        :param ops: type of  operation
        :param address: list of tuples: address and value
        :param mask: mask value
        :param count: count value
        &#34;&#34;&#34;
        assert numbytes in (1, 2, 4)
        assert ops in EnumCheckOps
        super().__init__(CmdTag.CHK_DAT, ((int(ops) &amp; 0x3) &lt;&lt; 3) | (numbytes &amp; 0x7))
        self.address = address
        self.mask = mask
        self.count = count
        # the length of &#39;address&#39;(4B), &#39;mask&#39;(4B) and count(0 or 4B)  need to be added into Header.length
        self._header.length += 4 + 4 + (4 if count else 0)

    def __repr__(self) -&gt; str:
        return &#34;CmdCheckData &lt;{}/{}, ADDR=0x{:X}, MASK=0x{:X}&gt;&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                       self.num_bytes, self.address, self.mask)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Check Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                        self.num_bytes)
        msg += &#34;- Address: 0x{0:08X}, Mask: 0x{1:08X}&#34;.format(self.address, self.mask)
        if self.count:
            msg += &#34;, Count: {0:d}&#34;.format(self.count)
        msg += &#34;\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        raw_data += pack(&#34;&gt;LL&#34;, self.address, self.mask)
        if self.count is not None:
            raw_data += pack(&#34;&gt;L&#34;, self.count)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdCheckData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.CHK_DAT)
        numbytes = header.param &amp; 0x7
        ops = (header.param &gt;&gt; 3) &amp; 0x3
        address, mask = unpack_from(&#34;&gt;LL&#34;, data, offset + header.size)
        count = None
        if (header.length - header.size) &gt; 8:
            count = unpack_from(&#34;&gt;L&#34;, data, offset + header.size + 8)[0]
        return cls(numbytes, ops, address, mask, count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdCheckData.num_bytes"><code class="name">var <span class="ident">num_bytes</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_bytes(self) -&gt; int:
    &#34;&#34;&#34;Number of bytes.&#34;&#34;&#34;
    return self._header.param &amp; 0x7</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdCheckData.ops"><code class="name">var <span class="ident">ops</span> : int</code></dt>
<dd>
<div class="desc"><p>Operation of Check data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ops(self) -&gt; int:
    &#34;&#34;&#34;Operation of Check data command.&#34;&#34;&#34;
    return (self._header.param &gt;&gt; 3) &amp; 0x3</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdCheckData.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Check Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumCheckOps[self.ops],  # type: ignore
                                                                    self.num_bytes)
    msg += &#34;- Address: 0x{0:08X}, Mask: 0x{1:08X}&#34;.format(self.address, self.mask)
    if self.count:
        msg += &#34;, Count: {0:d}&#34;.format(self.count)
    msg += &#34;\n&#34;
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="commands.html#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdInitialize"><code class="flex name class">
<span>class <span class="ident">CmdInitialize</span></span>
<span>(</span><span>engine: int = 0, data: List[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize command.</p>
<p>Initialize the initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdInitialize(CmdBase):
    &#34;&#34;&#34;Initialize command.&#34;&#34;&#34;

    @property
    def engine(self) -&gt; int:
        &#34;&#34;&#34;Engine.&#34;&#34;&#34;
        return self._header.param

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._header.param = value

    def __init__(self, engine: int = EnumEngine.ANY, data: List[int] = None) -&gt; None:
        &#34;&#34;&#34;Initialize the initialize command.&#34;&#34;&#34;
        assert engine in EnumEngine
        super().__init__(CmdTag.INIT, engine)
        self._data = data if data else []

    def __repr__(self) -&gt; str:
        return &#34;CmdInitialize &lt;{}, {}&gt;&#34;.format(EnumEngine[self.engine], len(self._data))  # type: ignore

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; int:
        return self._data[key]

    def __setitem__(self, key: int, value: int) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[int]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Initialize Command (Engine: {0:s})\n&#34;.format(EnumEngine[self.engine])  # type: ignore
        cnt = 0
        for val in self._data:
            msg += &#34; {0:02d}) Value: 0x{1:08X}\n&#34;.format(cnt, val)
            cnt += 1
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def append(self, value: int) -&gt; None:
        &#34;&#34;&#34;Appending of Initialize command.&#34;&#34;&#34;
        assert isinstance(value, int), &#34;value must be INT type&#34;
        assert 0 &lt;= value &lt; 0xFFFFFFFF, &#34;value out of range&#34;
        self._data.append(value)
        self._header.length += 4

    def pop(self, index: int) -&gt; int:
        &#34;&#34;&#34;Pop of Initialize command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._data)
        val = self._data.pop(index)
        self._header.length -= 4
        return val

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Initialize command.&#34;&#34;&#34;
        self._data.clear()
        self._header.length = self._header.size

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        for val in self._data:
            raw_data += pack(&#34;&gt;L&#34;, val)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdInitialize&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.INIT)
        obj = cls(EnumEngine.from_int(header.param))
        index = header.size
        while index &lt; header.length:
            assert (offset + index) &lt; len(data)
            val = unpack_from(&#34;&gt;L&#34;, data, offset + index)
            obj.append(val[0])
            index += 4
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdInitialize.engine"><code class="name">var <span class="ident">engine</span> : int</code></dt>
<dd>
<div class="desc"><p>Engine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; int:
    &#34;&#34;&#34;Engine.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdInitialize.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Appending of Initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value: int) -&gt; None:
    &#34;&#34;&#34;Appending of Initialize command.&#34;&#34;&#34;
    assert isinstance(value, int), &#34;value must be INT type&#34;
    assert 0 &lt;= value &lt; 0xFFFFFFFF, &#34;value out of range&#34;
    self._data.append(value)
    self._header.length += 4</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInitialize.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Initialize command.&#34;&#34;&#34;
    self._data.clear()
    self._header.length = self._header.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInitialize.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Initialize Command (Engine: {0:s})\n&#34;.format(EnumEngine[self.engine])  # type: ignore
    cnt = 0
    for val in self._data:
        msg += &#34; {0:02d}) Value: 0x{1:08X}\n&#34;.format(cnt, val)
        cnt += 1
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInitialize.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Pop of Initialize command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; int:
    &#34;&#34;&#34;Pop of Initialize command.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._data)
    val = self._data.pop(index)
    self._header.length -= 4
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="commands.html#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdInstallKey"><code class="flex name class">
<span>class <span class="ident">CmdInstallKey</span></span>
<span>(</span><span>flags: <a title="spsdk.image.commands.EnumInsKey" href="commands.html#spsdk.image.commands.EnumInsKey">EnumInsKey</a> = 0, cert_fmt: <a title="spsdk.image.commands.EnumCertFormat" href="commands.html#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a> = 3, hash_alg: <a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a> = 0, src_index: int = 0, tgt_index: int = 0, location: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Install key command.</p>
<p>Constructor.</p>
<p>:param flags: from EnumInsKey
:param cert_fmt: format of the certificate; key authentication protocol
:param hash_alg: hash algorithm
:param src_index: source key (verification key, KEK) index
:param tgt_index: target key index
:param location: start address of an additional data such as KEY to be installed;
Typically it is relative to CSF start; Might be absolute for DEK key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdInstallKey(CmdBase):
    &#34;&#34;&#34;Install key command.&#34;&#34;&#34;

    def __init__(self, flags: EnumInsKey = EnumInsKey.CLR, cert_fmt: EnumCertFormat = EnumCertFormat.SRK,
                 hash_alg: EnumAlgorithm = EnumAlgorithm.ANY, src_index: int = 0, tgt_index: int = 0,
                 location: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param flags: from EnumInsKey
        :param cert_fmt: format of the certificate; key authentication protocol
        :param hash_alg: hash algorithm
        :param src_index: source key (verification key, KEK) index
        :param tgt_index: target key index
        :param location: start address of an additional data such as KEY to be installed;
                Typically it is relative to CSF start; Might be absolute for DEK key
        &#34;&#34;&#34;
        super().__init__(CmdTag.INS_KEY, flags)
        self._cert_fmt: EnumCertFormat = cert_fmt
        self.hash_algorithm: EnumAlgorithm = hash_alg
        self.source_index = src_index
        self.target_index = tgt_index
        self.cmd_data_location = location
        self._header.length = CmdHeader.SIZE + 8
        self._certificate_ref: Optional[Union[CertificateImg, SrkTable]] = None

    @property
    def flags(self) -&gt; EnumInsKey:
        &#34;&#34;&#34;Flags.&#34;&#34;&#34;
        return EnumInsKey.from_int(self._header.param)

    @flags.setter
    def flags(self, value: EnumInsKey) -&gt; None:
        assert value in EnumInsKey
        self._header.param = value

    @property
    def certificate_format(self) -&gt; EnumCertFormat:
        &#34;&#34;&#34;Certificate format.&#34;&#34;&#34;
        return self._cert_fmt

    @certificate_format.setter
    def certificate_format(self, value: EnumCertFormat) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: certificate format
        &#34;&#34;&#34;
        assert value in EnumCertFormat
        self._cert_fmt = value

    @property
    def hash_algorithm(self) -&gt; EnumAlgorithm:
        &#34;&#34;&#34;Hash algorithm.&#34;&#34;&#34;
        return self._hash_alg

    @hash_algorithm.setter
    def hash_algorithm(self, value: EnumAlgorithm) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: hash algorithm
        &#34;&#34;&#34;
        assert value in EnumAlgorithm
        self._hash_alg = value

    @property
    def source_index(self) -&gt; int:
        &#34;&#34;&#34;Source key (verification key, KEK) index.

        - For SRK, it is index of the SRK key (0-3)
        - For other keys it is index of previously installed target key, typically 0
        &#34;&#34;&#34;
        return self._src_index

    @source_index.setter
    def source_index(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: source key (verification key, KEK) index
        &#34;&#34;&#34;
        if self._cert_fmt == EnumCertFormat.SRK:
            assert value in (0, 1, 2, 3)  # RT10xx supports just 4 SRK keys; this might need update for other devices
        else:
            assert value in (0, 2, 3, 4, 5)
        self._src_index = value

    @property
    def target_index(self) -&gt; int:
        &#34;&#34;&#34;Target key index.&#34;&#34;&#34;
        return self._tgt_index

    @target_index.setter
    def target_index(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: target key index
        &#34;&#34;&#34;
        assert value in (0, 1, 2, 3, 4, 5)
        self._tgt_index = value

    @property
    def cmd_data_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of an additional data (such as certificate, signature, etc) in binary image.&#34;&#34;&#34;
        return self.cmd_data_location

    @cmd_data_offset.setter
    def cmd_data_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: offset to set
        &#34;&#34;&#34;
        self.cmd_data_location = value

    @property
    def needs_cmd_data_reference(self) -&gt; bool:
        &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
        if self.flags == EnumInsKey.ABS:  # reference is an absolute address; instance not assigned; used for DEK key
            assert self._certificate_ref is None
            return False
        return True

    @property
    def cmd_data_reference(self) -&gt; Optional[Union[CertificateImg, SrkTable]]:
        &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

        None if no reference was assigned;
        Value type is command-specific
        &#34;&#34;&#34;
        return self._certificate_ref

    @cmd_data_reference.setter
    def cmd_data_reference(self, value: Union[CertificateImg, SrkTable]) -&gt; None:
        &#34;&#34;&#34;Setter.

        By default, the command does not support cmd_data_reference

        :param value: to be set
        :raise ValueError: if cmd reference not supported by the command
        &#34;&#34;&#34;
        assert isinstance(value, (CertificateImg, SrkTable))
        self._certificate_ref = value

    def parse_cmd_data(self, data: bytes, offset: int) -&gt; Union[CertificateImg, SrkTable, None]:
        &#34;&#34;&#34;Parse additional command data from binary data.

        :param data: to be parsed
        :param offset: start position in data to parse
        :return: parsed data object; command-specific: certificate or SrkTable to be installed
        &#34;&#34;&#34;
        if self.certificate_format == EnumCertFormat.SRK:
            result: Union[CertificateImg, SrkTable] = SrkTable.parse(data, offset)
        else:
            result = CertificateImg.parse(data, offset)
        self.cmd_data_reference = result
        return result

    @property
    def certificate_ref(self) -&gt; Union[CertificateImg, SrkTable, None]:
        &#34;&#34;&#34;Corresponding certificate referenced by key-location.&#34;&#34;&#34;
        return self._certificate_ref

    @certificate_ref.setter
    def certificate_ref(self, value: Union[CertificateImg, SrkTable]) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: certificate to be installed by the command
        &#34;&#34;&#34;
        self._certificate_ref = value

    def __repr__(self) -&gt; str:
        return &#34;CmdInstallKey &lt;{}, {}, {}, {}, {}, 0x{:X}&gt;&#34;. \
            format(EnumInsKey[self.flags], EnumCertFormat[self.certificate_format],  # type: ignore
                   EnumAlgorithm[self.hash_algorithm],  # type: ignore
                   self.source_index, self.target_index, self.cmd_data_location)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34; Flag      : {:d} ({})\n&#34;.format(self.flags, EnumInsKey.desc(self.flags))
        msg += &#34; CertFormat: {:d} ({})\n&#34;.format(self.certificate_format,
                                                 EnumCertFormat.desc(self.certificate_format))  # type: ignore
        msg += &#34; Algorithm : {:d} ({})\n&#34;.format(self.hash_algorithm,
                                                 EnumAlgorithm.desc(self.hash_algorithm))  # type: ignore
        msg += &#34; SrcKeyIdx : {:d} (Source key index) \n&#34;.format(self.source_index)
        msg += &#34; TgtKeyIdx : {:d} (Target key index) \n&#34;.format(self.target_index)
        msg += &#34; Location  : 0x{:08X} (Start address of certificate(s) to install) \n&#34;.format(self.cmd_data_location)
        if self.certificate_ref:
            msg += &#39;[related-certificate]\n&#39;
            msg += self.certificate_ref.info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        data = pack(&#34;&gt;4BL&#34;, self.certificate_format, self.hash_algorithm, self.source_index, self.target_index,
                    self.cmd_data_location)
        raw_data += data
        dbg_info.append_binary_data(&#39;data&#39;, data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; CmdBase:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to read from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.INS_KEY)
        protocol, algorithm, src_index, tgt_index, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
        return cls(EnumInsKey.from_int(header.param), protocol, algorithm, src_index, tgt_index, location)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.CmdInstallKey.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert binary representation into command (deserialization from binary data).</p>
<p>:param data: being parsed
:param offset: current position to read from data
:return: parse command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; CmdBase:
    &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

    :param data: being parsed
    :param offset: current position to read from data
    :return: parse command
    &#34;&#34;&#34;
    header = CmdHeader.parse(data, offset, CmdTag.INS_KEY)
    protocol, algorithm, src_index, tgt_index, location = unpack_from(&#34;&gt;4BL&#34;, data, offset + header.size)
    return cls(EnumInsKey.from_int(header.param), protocol, algorithm, src_index, tgt_index, location)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdInstallKey.certificate_format"><code class="name">var <span class="ident">certificate_format</span> : <a title="spsdk.image.commands.EnumCertFormat" href="commands.html#spsdk.image.commands.EnumCertFormat">EnumCertFormat</a></code></dt>
<dd>
<div class="desc"><p>Certificate format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def certificate_format(self) -&gt; EnumCertFormat:
    &#34;&#34;&#34;Certificate format.&#34;&#34;&#34;
    return self._cert_fmt</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.certificate_ref"><code class="name">var <span class="ident">certificate_ref</span> : Union[<a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a>, <a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Corresponding certificate referenced by key-location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def certificate_ref(self) -&gt; Union[CertificateImg, SrkTable, None]:
    &#34;&#34;&#34;Corresponding certificate referenced by key-location.&#34;&#34;&#34;
    return self._certificate_ref</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.cmd_data_reference"><code class="name">var <span class="ident">cmd_data_reference</span> : Union[<a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a>, <a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Reference to an additional data (such as certificate, signature, etc).</p>
<p>None if no reference was assigned;
Value type is command-specific</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cmd_data_reference(self) -&gt; Optional[Union[CertificateImg, SrkTable]]:
    &#34;&#34;&#34;Reference to an additional data (such as certificate, signature, etc).

    None if no reference was assigned;
    Value type is command-specific
    &#34;&#34;&#34;
    return self._certificate_ref</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.flags"><code class="name">var <span class="ident">flags</span> : <a title="spsdk.image.commands.EnumInsKey" href="commands.html#spsdk.image.commands.EnumInsKey">EnumInsKey</a></code></dt>
<dd>
<div class="desc"><p>Flags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; EnumInsKey:
    &#34;&#34;&#34;Flags.&#34;&#34;&#34;
    return EnumInsKey.from_int(self._header.param)</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.hash_algorithm"><code class="name">var <span class="ident">hash_algorithm</span> : <a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a></code></dt>
<dd>
<div class="desc"><p>Hash algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hash_algorithm(self) -&gt; EnumAlgorithm:
    &#34;&#34;&#34;Hash algorithm.&#34;&#34;&#34;
    return self._hash_alg</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.needs_cmd_data_reference"><code class="name">var <span class="ident">needs_cmd_data_reference</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether the command contains a reference to an additional data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def needs_cmd_data_reference(self) -&gt; bool:
    &#34;&#34;&#34;Whether the command contains a reference to an additional data.&#34;&#34;&#34;
    if self.flags == EnumInsKey.ABS:  # reference is an absolute address; instance not assigned; used for DEK key
        assert self._certificate_ref is None
        return False
    return True</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.source_index"><code class="name">var <span class="ident">source_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Source key (verification key, KEK) index.</p>
<ul>
<li>For SRK, it is index of the SRK key (0-3)</li>
<li>For other keys it is index of previously installed target key, typically 0</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source_index(self) -&gt; int:
    &#34;&#34;&#34;Source key (verification key, KEK) index.

    - For SRK, it is index of the SRK key (0-3)
    - For other keys it is index of previously installed target key, typically 0
    &#34;&#34;&#34;
    return self._src_index</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.target_index"><code class="name">var <span class="ident">target_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Target key index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def target_index(self) -&gt; int:
    &#34;&#34;&#34;Target key index.&#34;&#34;&#34;
    return self._tgt_index</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdInstallKey.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34; Flag      : {:d} ({})\n&#34;.format(self.flags, EnumInsKey.desc(self.flags))
    msg += &#34; CertFormat: {:d} ({})\n&#34;.format(self.certificate_format,
                                             EnumCertFormat.desc(self.certificate_format))  # type: ignore
    msg += &#34; Algorithm : {:d} ({})\n&#34;.format(self.hash_algorithm,
                                             EnumAlgorithm.desc(self.hash_algorithm))  # type: ignore
    msg += &#34; SrcKeyIdx : {:d} (Source key index) \n&#34;.format(self.source_index)
    msg += &#34; TgtKeyIdx : {:d} (Target key index) \n&#34;.format(self.target_index)
    msg += &#34; Location  : 0x{:08X} (Start address of certificate(s) to install) \n&#34;.format(self.cmd_data_location)
    if self.certificate_ref:
        msg += &#39;[related-certificate]\n&#39;
        msg += self.certificate_ref.info()
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdInstallKey.parse_cmd_data"><code class="name flex">
<span>def <span class="ident">parse_cmd_data</span></span>(<span>self, data: bytes, offset: int) ‑> Union[<a title="spsdk.image.secret.CertificateImg" href="secret.html#spsdk.image.secret.CertificateImg">CertificateImg</a>, <a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse additional command data from binary data.</p>
<p>:param data: to be parsed
:param offset: start position in data to parse
:return: parsed data object; command-specific: certificate or SrkTable to be installed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_cmd_data(self, data: bytes, offset: int) -&gt; Union[CertificateImg, SrkTable, None]:
    &#34;&#34;&#34;Parse additional command data from binary data.

    :param data: to be parsed
    :param offset: start position in data to parse
    :return: parsed data object; command-specific: certificate or SrkTable to be installed
    &#34;&#34;&#34;
    if self.certificate_format == EnumCertFormat.SRK:
        result: Union[CertificateImg, SrkTable] = SrkTable.parse(data, offset)
    else:
        result = CertificateImg.parse(data, offset)
    self.cmd_data_reference = result
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdNop"><code class="flex name class">
<span>class <span class="ident">CmdNop</span></span>
<span>(</span><span>param: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Nop command.</p>
<p>Initialize the nop command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdNop(CmdBase):
    &#34;&#34;&#34;Nop command.&#34;&#34;&#34;

    def __init__(self, param: int = 0):
        &#34;&#34;&#34;Initialize the nop command.&#34;&#34;&#34;
        super().__init__(CmdTag.NOP, param)

    def __repr__(self) -&gt; str:
        return &#34;CmdNop&#34;

    def __eq__(self, cmd: Any) -&gt; bool:
        if not isinstance(cmd, CmdNop):
            return False
        return True

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdNop&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.NOP)
        if header.length != header.size:
            pass
        return cls(header.param)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdNop.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="commands.html#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdSet"><code class="flex name class">
<span>class <span class="ident">CmdSet</span></span>
<span>(</span><span>itm: <a title="spsdk.image.commands.EnumItm" href="commands.html#spsdk.image.commands.EnumItm">EnumItm</a> = 3, hash_alg: <a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a> = 0, engine: <a title="spsdk.image.commands.EnumEngine" href="commands.html#spsdk.image.commands.EnumEngine">EnumEngine</a> = 0, engine_cfg: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set command.</p>
<p>Initialize the set command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdSet(CmdBase):
    &#34;&#34;&#34;Set command.&#34;&#34;&#34;

    @property
    def itm(self) -&gt; int:
        &#34;&#34;&#34;Item of Set command.&#34;&#34;&#34;
        return self._header.param

    @itm.setter
    def itm(self, value: EnumItm) -&gt; None:
        assert value in EnumItm
        self._header.param = value

    @property
    def hash_algorithm(self) -&gt; EnumAlgorithm:
        &#34;&#34;&#34;Type of hash algorithm.&#34;&#34;&#34;
        return self._hash_alg

    @hash_algorithm.setter
    def hash_algorithm(self, value: EnumAlgorithm) -&gt; None:
        assert value in EnumAlgorithm
        self._hash_alg = value

    @property
    def engine(self) -&gt; EnumEngine:
        &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
        return self._engine

    @engine.setter
    def engine(self, value: EnumEngine) -&gt; None:
        assert value in EnumEngine
        self._engine = value

    def __init__(self, itm: EnumItm = EnumItm.ENG, hash_alg: EnumAlgorithm = EnumAlgorithm.ANY,
                 engine: EnumEngine = EnumEngine.ANY, engine_cfg: int = 0):
        &#34;&#34;&#34;Initialize the set command.&#34;&#34;&#34;
        assert itm in EnumItm
        super().__init__(CmdTag.SET, itm)
        self.hash_algorithm: EnumAlgorithm = hash_alg
        self.engine = engine
        self.engine_cfg = engine_cfg
        self._header.length = CmdHeader.SIZE + 4

    def __repr__(self) -&gt; str:
        return &#34;CmdSet &lt;{}, {}, {}, eng_cfg=0x{:X}&gt;&#34;.format(
            EnumItm.name(self.itm), EnumAlgorithm.name(self.hash_algorithm), EnumEngine.name(self.engine),
            self.engine_cfg
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Set Command ITM : {EnumItm.name(self.itm)}\n&#34;
        msg += f&#34;HASH Algo      : {self.hash_algorithm} ({EnumAlgorithm.desc(self.hash_algorithm)})\n&#34;
        msg += f&#34;Engine         : {self.engine} ({EnumEngine.desc(self.engine)})\n&#34;
        msg += f&#34;Engine Conf    : {hex(self.engine_cfg)})\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        raw_data += pack(&#34;4B&#34;, 0x00, self.hash_algorithm, self.engine, self.engine_cfg)
        dbg_info.append_binary_data(&#39;data&#39;, raw_data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdSet&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset, CmdTag.SET)
        (_, alg, eng, cfg) = unpack_from(&#34;4B&#34;, data, offset + CmdHeader.SIZE)
        return CmdSet(EnumItm.from_int(header.param), EnumAlgorithm.from_int(alg), EnumEngine.from_int(eng), cfg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdSet.engine"><code class="name">var <span class="ident">engine</span> : <a title="spsdk.image.commands.EnumEngine" href="commands.html#spsdk.image.commands.EnumEngine">EnumEngine</a></code></dt>
<dd>
<div class="desc"><p>Engine plugin tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def engine(self) -&gt; EnumEngine:
    &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
    return self._engine</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdSet.hash_algorithm"><code class="name">var <span class="ident">hash_algorithm</span> : <a title="spsdk.image.secret.EnumAlgorithm" href="secret.html#spsdk.image.secret.EnumAlgorithm">EnumAlgorithm</a></code></dt>
<dd>
<div class="desc"><p>Type of hash algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hash_algorithm(self) -&gt; EnumAlgorithm:
    &#34;&#34;&#34;Type of hash algorithm.&#34;&#34;&#34;
    return self._hash_alg</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdSet.itm"><code class="name">var <span class="ident">itm</span> : int</code></dt>
<dd>
<div class="desc"><p>Item of Set command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def itm(self) -&gt; int:
    &#34;&#34;&#34;Item of Set command.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdSet.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Set Command ITM : {EnumItm.name(self.itm)}\n&#34;
    msg += f&#34;HASH Algo      : {self.hash_algorithm} ({EnumAlgorithm.desc(self.hash_algorithm)})\n&#34;
    msg += f&#34;Engine         : {self.engine} ({EnumEngine.desc(self.engine)})\n&#34;
    msg += f&#34;Engine Conf    : {hex(self.engine_cfg)})\n&#34;
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="commands.html#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdUnlock"><code class="flex name class">
<span>class <span class="ident">CmdUnlock</span></span>
<span>(</span><span>engine: <a title="spsdk.image.commands.EnumEngine" href="commands.html#spsdk.image.commands.EnumEngine">EnumEngine</a> = 0, features: int = 0, uid: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic unlock engine command.</p>
<p>Constructor.</p>
<p>:param engine: to be unlocked
:param features: mask of features to use by the engine
:param uid: Unique ID (if needed)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlock(CmdUnlockAbstract):
    &#34;&#34;&#34;Generic unlock engine command.&#34;&#34;&#34;

    def __init__(self, engine: EnumEngine = EnumEngine.ANY, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Constructor.

        :param engine: to be unlocked
        :param features: mask of features to use by the engine
        :param uid: Unique ID (if needed)
        &#34;&#34;&#34;
        super().__init__(engine, features, uid=uid)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Features: {})\n&#34;.format(self.features)
        msg += &#34;UID:      {})\n&#34;.format(self.uid)
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdUnlockCAAM"><code class="flex name class">
<span>class <span class="ident">CmdUnlockCAAM</span></span>
<span>(</span><span>features: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Unlock for Cryptographic Acceleration and Assurance Module .</p>
<p>Initialize.</p>
<p>:param features: mask of FEATURE_UNLOCK_ constants, defaults to 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockCAAM(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock for Cryptographic Acceleration and Assurance Module .&#34;&#34;&#34;
    # Leave Job Ring and DECO Master IP unlocked
    FEATURE_UNLOCK_MID = 1
    # Leave RNG unititialized
    FEATURE_UNLOCK_RNG = 2
    # Keep manufacturing protection key in internal memory
    FEATURE_UNLOCK_MFG = 4

    def __init__(self, features: int = 0):
        &#34;&#34;&#34;Initialize.

        :param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
        &#34;&#34;&#34;
        super().__init__(EnumEngine.CAAM, features)

    @property
    def unlock_mid(self) -&gt; bool:
        &#34;&#34;&#34;Leave Job Ring and DECO master ID registers unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_MID != 0

    @property
    def unlock_rng(self) -&gt; bool:
        &#34;&#34;&#34;Leave RNG un-instantiated.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_RNG != 0

    @property
    def unlock_mfg(self) -&gt; bool:
        &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_MFG != 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;MID : {self.unlock_mid}\n&#34;
        msg += f&#34;RNG : {self.unlock_rng}\n&#34;
        msg += f&#34;MFG : {self.unlock_mfg}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_MFG"><code class="name">var <span class="ident">FEATURE_UNLOCK_MFG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_MID"><code class="name">var <span class="ident">FEATURE_UNLOCK_MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_RNG"><code class="name">var <span class="ident">FEATURE_UNLOCK_RNG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdUnlockCAAM.unlock_mfg"><code class="name">var <span class="ident">unlock_mfg</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave Zero is able Master Key write unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_mfg(self) -&gt; bool:
    &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_MFG != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdUnlockCAAM.unlock_mid"><code class="name">var <span class="ident">unlock_mid</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave Job Ring and DECO master ID registers unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_mid(self) -&gt; bool:
    &#34;&#34;&#34;Leave Job Ring and DECO master ID registers unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_MID != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdUnlockCAAM.unlock_rng"><code class="name">var <span class="ident">unlock_rng</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave RNG un-instantiated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_rng(self) -&gt; bool:
    &#34;&#34;&#34;Leave RNG un-instantiated.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_RNG != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP"><code class="flex name class">
<span>class <span class="ident">CmdUnlockOCOTP</span></span>
<span>(</span><span>features: int = 0, uid: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Unlock for On-Chip One-time programable memory (fuses).</p>
<p>Initialize.</p>
<p>:param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
:param uid: Unique ID required by some engine/feature combinations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockOCOTP(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock for On-Chip One-time programable memory (fuses).&#34;&#34;&#34;
    #pylint: disable = bad-whitespace
    # Leave Field Return activation unlocked.
    FEATURE_UNLOCK_FLD_RTN  = 1
    # Leave SRK revocation unlocked.
    FEATURE_UNLOCK_SRK_RVK  = 2
    # Leave SCS register unlocked.
    FEATURE_UNLOCK_SCS      = 4
    # Unlock JTAG using SCS HAB_JDE bit.
    FEATURE_UNLOCK_JTAG     = 8

    def __init__(self, features: int = 0, uid: int = 0):
        &#34;&#34;&#34;Initialize.

        :param features: mask of FEATURE_UNLOCK_ constants, defaults to 0
        :param uid: Unique ID required by some engine/feature combinations
        &#34;&#34;&#34;
        super().__init__(EnumEngine.OCOTP, features, uid=uid)

    @property
    def _need_uid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if given Engine and Feature requires UID.&#34;&#34;&#34;
        return self.unlock_fld_rtn or self.unlock_csc or self.unlock_jtag

    @property
    def unlock_fld_rtn(self) -&gt; bool:
        &#34;&#34;&#34;Leave Field Return activation unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_FLD_RTN != 0

    @property
    def unlock_srk_rvk(self) -&gt; bool:
        &#34;&#34;&#34;Leave SRK revocation unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_SRK_RVK != 0

    @property
    def unlock_csc(self) -&gt; bool:
        &#34;&#34;&#34;Leave SCS register unlocked.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_SCS != 0

    @property
    def unlock_jtag(self) -&gt; bool:
        &#34;&#34;&#34;Unlock JTAG using SCS HAB_JDE bit.&#34;&#34;&#34;
        return self.features &amp; self.FEATURE_UNLOCK_JTAG != 0


    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;FLD_RTN : {self.unlock_fld_rtn}\n&#34;
        msg += f&#34;SRK_RVK : {self.unlock_srk_rvk}\n&#34;
        msg += f&#34;CSC     : {self.unlock_csc}\n&#34;
        msg += f&#34;JTAG    : {self.unlock_jtag}\n&#34;
        if self.uid:
            msg += f&#34;UID : {hex(self.uid)}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_FLD_RTN"><code class="name">var <span class="ident">FEATURE_UNLOCK_FLD_RTN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_JTAG"><code class="name">var <span class="ident">FEATURE_UNLOCK_JTAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_SCS"><code class="name">var <span class="ident">FEATURE_UNLOCK_SCS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_SRK_RVK"><code class="name">var <span class="ident">FEATURE_UNLOCK_SRK_RVK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdUnlockOCOTP.unlock_csc"><code class="name">var <span class="ident">unlock_csc</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave SCS register unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_csc(self) -&gt; bool:
    &#34;&#34;&#34;Leave SCS register unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_SCS != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP.unlock_fld_rtn"><code class="name">var <span class="ident">unlock_fld_rtn</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave Field Return activation unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_fld_rtn(self) -&gt; bool:
    &#34;&#34;&#34;Leave Field Return activation unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_FLD_RTN != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP.unlock_jtag"><code class="name">var <span class="ident">unlock_jtag</span> : bool</code></dt>
<dd>
<div class="desc"><p>Unlock JTAG using SCS HAB_JDE bit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_jtag(self) -&gt; bool:
    &#34;&#34;&#34;Unlock JTAG using SCS HAB_JDE bit.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_JTAG != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdUnlockOCOTP.unlock_srk_rvk"><code class="name">var <span class="ident">unlock_srk_rvk</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave SRK revocation unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_srk_rvk(self) -&gt; bool:
    &#34;&#34;&#34;Leave SRK revocation unlocked.&#34;&#34;&#34;
    return self.features &amp; self.FEATURE_UNLOCK_SRK_RVK != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdUnlockSNVS"><code class="flex name class">
<span>class <span class="ident">CmdUnlockSNVS</span></span>
<span>(</span><span>features: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Unlock Secure Non-Volatile Storage (SNVS) Engine.</p>
<p>Constructor.</p>
<p>:param features: mask of FEATURE_UNLOCK_* constants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdUnlockSNVS(CmdUnlockAbstract):
    &#34;&#34;&#34;Command Unlock Secure Non-Volatile Storage (SNVS) Engine.&#34;&#34;&#34;

    # mask unlock LP_SWR
    FEATURE_UNLOCK_LP_SWR = 1
    # mask unlock ZMK_WRITE
    FEATURE_UNLOCK_ZMK_WRITE = 2

    def __init__(self, features: int = 0) -&gt; None:
        &#34;&#34;&#34;Constructor.

        :param features: mask of FEATURE_UNLOCK_* constants
        &#34;&#34;&#34;
        super().__init__(EnumEngine.SNVS, features)

    @property
    def unlock_lp_swr(self) -&gt; bool:
        &#34;&#34;&#34;Leave LP SW reset unlocked.&#34;&#34;&#34;
        return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR != 0

    @property
    def unlock_zmk_write(self) -&gt; bool:
        &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
        return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE != 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += f&#34;Unlock LP SWR    : {self.unlock_lp_swr}\n&#34;
        msg += f&#34;Unlock ZMK Write : {self.unlock_zmk_write}\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></li>
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR"><code class="name">var <span class="ident">FEATURE_UNLOCK_LP_SWR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE"><code class="name">var <span class="ident">FEATURE_UNLOCK_ZMK_WRITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdUnlockSNVS.unlock_lp_swr"><code class="name">var <span class="ident">unlock_lp_swr</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave LP SW reset unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_lp_swr(self) -&gt; bool:
    &#34;&#34;&#34;Leave LP SW reset unlocked.&#34;&#34;&#34;
    return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdUnlockSNVS.unlock_zmk_write"><code class="name">var <span class="ident">unlock_zmk_write</span> : bool</code></dt>
<dd>
<div class="desc"><p>Leave Zero is able Master Key write unlocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unlock_zmk_write(self) -&gt; bool:
    &#34;&#34;&#34;Leave Zero is able Master Key write unlocked.&#34;&#34;&#34;
    return self.features &amp; CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdUnlockAbstract" href="commands.html#spsdk.image.commands.CmdUnlockAbstract">CmdUnlockAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.engine" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.engine">engine</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.info" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.info">info</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.need_uid" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.need_uid">need_uid</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse" href="commands.html#spsdk.image.commands.CmdUnlockAbstract.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdUnlockAbstract.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.CmdWriteData"><code class="flex name class">
<span>class <span class="ident">CmdWriteData</span></span>
<span>(</span><span>numbytes: int = 4, ops: int = 0, data: Iterable[Tuple[int, int]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data command.</p>
<p>Initialize Write Data command.</p>
<p>:param numbytes: number of bytes. Must be value: 1, 2 or 4
:param ops: type of write operation
:param data: list of tuples: address and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CmdWriteData(CmdBase):
    &#34;&#34;&#34;Write data command.&#34;&#34;&#34;

    @property
    def num_bytes(self) -&gt; int:
        &#34;&#34;&#34;Number of bytes being written by the command.&#34;&#34;&#34;
        return self._header.param &amp; 0x7

    @num_bytes.setter
    def num_bytes(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: number of bytes being written by the command
        &#34;&#34;&#34;
        assert value in (1, 2, 4)
        self._header.param &amp;= ~0x7
        self._header.param |= value

    @property
    def ops(self) -&gt; int:
        &#34;&#34;&#34;Type of write operation.&#34;&#34;&#34;
        return (self._header.param &gt;&gt; 3) &amp; 0x3

    @ops.setter
    def ops(self, value: int) -&gt; None:
        assert value in EnumWriteOps
        self._header.param &amp;= ~(0x3 &lt;&lt; 3)
        self._header.param |= int(value) &lt;&lt; 3

    def __init__(self, numbytes: int = 4, ops: int = EnumWriteOps.WRITE_VALUE,
                 data: Iterable[Tuple[int, int]] = None) -&gt; None:
        &#34;&#34;&#34;Initialize Write Data command.

        :param numbytes: number of bytes. Must be value: 1, 2 or 4
        :param ops: type of write operation
        :param data: list of tuples: address and value
        &#34;&#34;&#34;
        assert numbytes in (1, 2, 4)
        assert ops in EnumWriteOps
        super().__init__(CmdTag.WRT_DAT, ((int(ops) &amp; 0x3) &lt;&lt; 3) | (numbytes &amp; 0x7))
        self._data: List[List[int]] = []
        if data is not None:
            assert isinstance(data, (list, tuple))
            for address, value in data:
                self.append(address, value)

    def __repr__(self) -&gt; str:
        return f&#34;CmdWriteData &lt;{EnumWriteOps.name(self.ops)}/{self.num_bytes}, {len(self._data)}&gt;&#34;

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; List[int]:
        return self._data[key]

    def __setitem__(self, key: int, value: List[int]) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[List[int]]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += super().info()
        msg += &#34;Write Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumWriteOps.name(self.ops),
                                                                        self.num_bytes)
        for cmd in self._data:
            msg += &#34;- Address: 0x{0:08X}, Value: 0x{1:08X}\n&#34;.format(cmd[0], cmd[1])
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    def append(self, address: int, value: int) -&gt; None:
        &#34;&#34;&#34;Append of Write data command.&#34;&#34;&#34;
        assert 0 &lt;= address &lt;= 0xFFFFFFFF, &#34;address out of range&#34;
        assert 0 &lt;= value &lt;= 0xFFFFFFFF, &#34;value out of range&#34;
        self._data.append([address, value])
        self._header.length += 8

    def pop(self, index: int) -&gt; List[int]:
        &#34;&#34;&#34;Pop of Write data command.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._data)
        cmd = self._data.pop(index)
        self._header.length -= 8
        return cmd

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Write data command.&#34;&#34;&#34;
        self._data.clear()
        self._header.length = self._header.size

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: debug information about exported data
        :return: binary representation of the command
        &#34;&#34;&#34;
        raw_data = super().export(dbg_info=dbg_info)
        for cmd in self._data:
            raw_data += pack(&#34;&gt;LL&#34;, cmd[0], cmd[1])
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;CmdWriteData&#39;:
        &#34;&#34;&#34;Convert binary representation into command (deserialization from binary data).

        :param data: being parsed
        :param offset: current position to readd from data
        :return: parse command
        &#34;&#34;&#34;
        header = CmdHeader.parse(data, offset=offset, required_tag=CmdTag.WRT_DAT)
        obj = cls(header.param &amp; 0x7, (header.param &gt;&gt; 3) &amp; 0x3)
        index = header.size
        while index &lt; header.length:
            (address, value) = unpack_from(&#34;&gt;LL&#34;, data, offset + index)
            obj.append(address, value)
            index += 8
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.CmdWriteData.num_bytes"><code class="name">var <span class="ident">num_bytes</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of bytes being written by the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_bytes(self) -&gt; int:
    &#34;&#34;&#34;Number of bytes being written by the command.&#34;&#34;&#34;
    return self._header.param &amp; 0x7</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdWriteData.ops"><code class="name">var <span class="ident">ops</span> : int</code></dt>
<dd>
<div class="desc"><p>Type of write operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ops(self) -&gt; int:
    &#34;&#34;&#34;Type of write operation.&#34;&#34;&#34;
    return (self._header.param &gt;&gt; 3) &amp; 0x3</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.CmdWriteData.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, address: int, value: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append of Write data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, address: int, value: int) -&gt; None:
    &#34;&#34;&#34;Append of Write data command.&#34;&#34;&#34;
    assert 0 &lt;= address &lt;= 0xFFFFFFFF, &#34;address out of range&#34;
    assert 0 &lt;= value &lt;= 0xFFFFFFFF, &#34;value out of range&#34;
    self._data.append([address, value])
    self._header.length += 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdWriteData.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Write data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Write data command.&#34;&#34;&#34;
    self._data.clear()
    self._header.length = self._header.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdWriteData.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the command.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += super().info()
    msg += &#34;Write Data Command (Ops: {0:s}, Bytes: {1:d})\n&#34;.format(EnumWriteOps.name(self.ops),
                                                                    self.num_bytes)
    for cmd in self._data:
        msg += &#34;- Address: 0x{0:08X}, Value: 0x{1:08X}\n&#34;.format(cmd[0], cmd[1])
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.CmdWriteData.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index: int) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Pop of Write data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; List[int]:
    &#34;&#34;&#34;Pop of Write data command.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._data)
    cmd = self._data.pop(index)
    self._header.length -= 8
    return cmd</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_offset" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.export" href="commands.html#spsdk.image.commands.CmdBase.export">export</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.needs_cmd_data_reference" href="commands.html#spsdk.image.commands.CmdBase.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse" href="commands.html#spsdk.image.commands.CmdBase.parse">parse</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.parse_cmd_data" href="commands.html#spsdk.image.commands.CmdBase.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.size" href="commands.html#spsdk.image.commands.CmdBase.size">size</a></code></li>
<li><code><a title="spsdk.image.commands.CmdBase.tag" href="commands.html#spsdk.image.commands.CmdBase.tag">tag</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumAlgorithm"><code class="flex name class">
<span>class <span class="ident">EnumAlgorithm</span></span>
</code></dt>
<dd>
<div class="desc"><p>Algorithm types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumAlgorithm(Enum):
    &#34;&#34;&#34;Algorithm types.&#34;&#34;&#34;
    ANY = (0x00, &#39;Algorithm type ANY&#39;)
    HASH = (0x01, &#39;Hash algorithm type&#39;)
    SIG = (0x02, &#39;Signature algorithm type&#39;)
    F = (0x03, &#39;Finite field arithmetic&#39;)
    EC = (0x04, &#39;Elliptic curve arithmetic&#39;)
    CIPHER = (0x05, &#39;Cipher algorithm type&#39;)
    MODE = (0x06, &#39;Cipher/hash modes&#39;)
    WRAP = (0x07, &#39;Key wrap algorithm type&#39;)
    # Hash algorithms
    SHA1 = (0x11, &#39;SHA-1 algorithm ID&#39;)
    SHA256 = (0x17, &#39;SHA-256 algorithm ID&#39;)
    SHA512 = (0x1b, &#39;SHA-512 algorithm ID&#39;)
    # Signature algorithms
    PKCS1 = (0x21, &#39;PKCS#1 RSA signature algorithm&#39;)
    # Cipher algorithms
    AES = (0x55, &#39;AES algorithm ID&#39;)
    # Cipher or hash modes
    CCM = (0x66, &#39;Counter with CBC-MAC&#39;)
    # Key wrap algorithms
    BLOB = (0x71, &#39;SHW-specific key wrap&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumAlgorithm.AES"><code class="name">var <span class="ident">AES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.ANY"><code class="name">var <span class="ident">ANY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.BLOB"><code class="name">var <span class="ident">BLOB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.CCM"><code class="name">var <span class="ident">CCM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.CIPHER"><code class="name">var <span class="ident">CIPHER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.EC"><code class="name">var <span class="ident">EC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.F"><code class="name">var <span class="ident">F</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.HASH"><code class="name">var <span class="ident">HASH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.MODE"><code class="name">var <span class="ident">MODE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.PKCS1"><code class="name">var <span class="ident">PKCS1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.SHA1"><code class="name">var <span class="ident">SHA1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.SHA256"><code class="name">var <span class="ident">SHA256</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.SHA512"><code class="name">var <span class="ident">SHA512</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.SIG"><code class="name">var <span class="ident">SIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAlgorithm.WRAP"><code class="name">var <span class="ident">WRAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumAppType"><code class="flex name class">
<span>class <span class="ident">EnumAppType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Type of the application image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumAppType(Enum):
    &#34;&#34;&#34;Type of the application image.&#34;&#34;&#34;
    SCFW = 1
    M4_0 = 2
    M4_1 = 3
    APP = 4  # actually this means APP or A35 or A53
    A72 = 5
    SCD = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumAppType.A72"><code class="name">var <span class="ident">A72</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAppType.APP"><code class="name">var <span class="ident">APP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAppType.M4_0"><code class="name">var <span class="ident">M4_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAppType.M4_1"><code class="name">var <span class="ident">M4_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAppType.SCD"><code class="name">var <span class="ident">SCD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAppType.SCFW"><code class="name">var <span class="ident">SCFW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumAuthDat"><code class="flex name class">
<span>class <span class="ident">EnumAuthDat</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flags for Authenticate Data commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumAuthDat(Enum):
    &#34;&#34;&#34;Flags for Authenticate Data commands.&#34;&#34;&#34;
    CLR = (0, &#39;No flags set&#39;)
    ABS = (1, &#39;Absolute signature address&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumAuthDat.ABS"><code class="name">var <span class="ident">ABS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumAuthDat.CLR"><code class="name">var <span class="ident">CLR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumCertFormat"><code class="flex name class">
<span>class <span class="ident">EnumCertFormat</span></span>
</code></dt>
<dd>
<div class="desc"><p>Certificate format tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumCertFormat(Enum):
    &#34;&#34;&#34;Certificate format tags.&#34;&#34;&#34;
    SRK = (0x03, &#39;SRK certificate format&#39;)
    X509 = (0x09, &#39;X.509v3 certificate format&#39;)
    CMS = (0xC5, &#39;CMS/PKCS#7 signature format&#39;)
    BLOB = (0xBB, &#39;SHW-specific wrapped key format&#39;)
    AEAD = (0xA3, &#39;Proprietary AEAD MAC format&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumCertFormat.AEAD"><code class="name">var <span class="ident">AEAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCertFormat.BLOB"><code class="name">var <span class="ident">BLOB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCertFormat.CMS"><code class="name">var <span class="ident">CMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCertFormat.SRK"><code class="name">var <span class="ident">SRK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCertFormat.X509"><code class="name">var <span class="ident">X509</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumCheckOps"><code class="flex name class">
<span>class <span class="ident">EnumCheckOps</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum definition for 'par' parameter of Check Data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumCheckOps(Enum):
    &#34;&#34;&#34;Enum definition for &#39;par&#39; parameter of Check Data command.&#34;&#34;&#34;
    ALL_CLEAR = (0, &#39;All bits clear&#39;)
    ALL_SET = (1, &#39;All bits set&#39;)
    ANY_CLEAR = (2, &#39;Any bit clear&#39;)
    ANY_SET = (3, &#39;Any bit set&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumCheckOps.ALL_CLEAR"><code class="name">var <span class="ident">ALL_CLEAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCheckOps.ALL_SET"><code class="name">var <span class="ident">ALL_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCheckOps.ANY_CLEAR"><code class="name">var <span class="ident">ANY_CLEAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumCheckOps.ANY_SET"><code class="name">var <span class="ident">ANY_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumEngine"><code class="flex name class">
<span>class <span class="ident">EnumEngine</span></span>
</code></dt>
<dd>
<div class="desc"><p>Engine plugin tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumEngine(Enum):
    &#34;&#34;&#34;Engine plugin tags.&#34;&#34;&#34;
    ANY = (0x00, &#39;First compatible engine will be selected (no engine configuration parameters are allowed)&#39;)
    SCC = (0x03, &#39;Security controller&#39;)
    RTIC = (0x05, &#39;Run-time integrity checker&#39;)
    SAHARA = (0x06, &#39;Crypto accelerator&#39;)
    CSU = (0x0A, &#39;Central Security Unit&#39;)
    SRTC = (0x0C, &#39;Secure clock&#39;)
    DCP = (0x1B, &#39;Data Co-Processor&#39;)
    CAAM = (0x1D, &#39;Cryptographic Acceleration and Assurance Module&#39;)
    SNVS = (0x1E, &#39;Secure Non-Volatile Storage&#39;)
    OCOTP = (0x21, &#39;Fuse controller&#39;)
    DTCP = (0x22, &#39;DTCP co-processor&#39;)
    ROM = (0x36, &#39;Protected ROM area&#39;)
    HDCP = (0x24, &#39;HDCP co-processor&#39;)
    SW = (0xFF, &#39;Software engine&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumEngine.ANY"><code class="name">var <span class="ident">ANY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.CAAM"><code class="name">var <span class="ident">CAAM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.CSU"><code class="name">var <span class="ident">CSU</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.DCP"><code class="name">var <span class="ident">DCP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.DTCP"><code class="name">var <span class="ident">DTCP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.HDCP"><code class="name">var <span class="ident">HDCP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.OCOTP"><code class="name">var <span class="ident">OCOTP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.ROM"><code class="name">var <span class="ident">ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.RTIC"><code class="name">var <span class="ident">RTIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.SAHARA"><code class="name">var <span class="ident">SAHARA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.SCC"><code class="name">var <span class="ident">SCC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.SNVS"><code class="name">var <span class="ident">SNVS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.SRTC"><code class="name">var <span class="ident">SRTC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumEngine.SW"><code class="name">var <span class="ident">SW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumInsKey"><code class="flex name class">
<span>class <span class="ident">EnumInsKey</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flags for Install Key commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumInsKey(Enum):
    &#34;&#34;&#34;Flags for Install Key commands.&#34;&#34;&#34;
    CLR = (0, &#39;No flags set&#39;)
    ABS = (1, &#39;Absolute certificate address&#39;)
    CSF = (2, &#39;Install CSF key&#39;)
    DAT = (4, &#39;Key binds to Data Type&#39;)
    CFG = (8, &#39;Key binds to Configuration&#39;)
    FID = (16, &#39;Key binds to Fabrication UID&#39;)
    MID = (32, &#39;Key binds to Manufacturing ID&#39;)
    CID = (64, &#39;Key binds to Caller ID&#39;)
    HSH = (128, &#39;Certificate hash present&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumInsKey.ABS"><code class="name">var <span class="ident">ABS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.CFG"><code class="name">var <span class="ident">CFG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.CID"><code class="name">var <span class="ident">CID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.CLR"><code class="name">var <span class="ident">CLR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.CSF"><code class="name">var <span class="ident">CSF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.DAT"><code class="name">var <span class="ident">DAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.FID"><code class="name">var <span class="ident">FID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.HSH"><code class="name">var <span class="ident">HSH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumInsKey.MID"><code class="name">var <span class="ident">MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumItm"><code class="flex name class">
<span>class <span class="ident">EnumItm</span></span>
</code></dt>
<dd>
<div class="desc"><p>Engine configuration flags of Set command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumItm(Enum):
    &#34;&#34;&#34;Engine configuration flags of Set command.&#34;&#34;&#34;
    MID = (0x01, &#39;Manufacturing ID (MID) fuse locations&#39;)
    ENG = (0x03, &#39;Preferred engine for a given algorithm&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumItm.ENG"><code class="name">var <span class="ident">ENG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumItm.MID"><code class="name">var <span class="ident">MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.EnumWriteOps"><code class="flex name class">
<span>class <span class="ident">EnumWriteOps</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum definition for 'flags' control flags in 'par' parameter of Write Data command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumWriteOps(Enum):
    &#34;&#34;&#34;Enum definition for &#39;flags&#39; control flags in &#39;par&#39; parameter of Write Data command.&#34;&#34;&#34;
    WRITE_VALUE = (0, &#39;Write value&#39;)
    WRITE_CLEAR_BITS = (1, &#39;Write clear bits&#39;)
    CLEAR_BITMASK = (2, &#39;Clear bitmask&#39;)
    SET_BITMASK = (3, &#39;Set bitmask&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.EnumWriteOps.CLEAR_BITMASK"><code class="name">var <span class="ident">CLEAR_BITMASK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumWriteOps.SET_BITMASK"><code class="name">var <span class="ident">SET_BITMASK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumWriteOps.WRITE_CLEAR_BITS"><code class="name">var <span class="ident">WRITE_CLEAR_BITS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.EnumWriteOps.WRITE_VALUE"><code class="name">var <span class="ident">WRITE_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.FlexSPIConfBlockFCB"><code class="flex name class">
<span>class <span class="ident">FlexSPIConfBlockFCB</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flex SPI configuration block; FCB.</p>
<p>Initialize FlexSPIConfBlockFCB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlexSPIConfBlockFCB(AbstractFCB):
    &#34;&#34;&#34;Flex SPI configuration block; FCB.&#34;&#34;&#34;
    # tag used in header to be able identify the block
    TAG = b&#39;FCFB&#39;
    # default version
    VERSION = b&#39;V\x01\x00\x00&#39;
    # format for the export
    FORMAT = &#39;&lt;6BH7I5I4B2I4I6I4H&#39;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize FlexSPIConfBlockFCB.&#34;&#34;&#34;
        super().__init__()
        self.version = self.VERSION
        # ### Fields descriptions are taken from RT1050 manual ###

        # [00C:8-bit] 0 = internal loopback; 1 = loopback from DQS pad; 3 = Flash provided DQS
        self.read_sample_clk_src = 0
        # [00D:8-bit] Serial Flash CS Hold Time Recommend default value is 0x03
        self.cs_hold_time = 3
        # [00E:8-bit] Serial Flash CS setup time. Recommended default value is 0x03
        self.cs_setup_time = 3
        # [00F:8-bit] 3 = For HyperFlash; 12/13 = For Serial NAND, see datasheet to find correct value; 0=Other devices
        self.column_address_width = 0
        # [010:8-bit] Device Mode Configuration Enable feature (0 – Disabled, 1 – Enabled)
        self.device_mode_cfg_enable = 0
        # [011:8-bit] Reserved
        self.device_mode_type = 0
        # [012:16-bit] Wait time for all configuration commands, unit 100us.
        # Available for device that support v1.1.0 FlexSPI configuration block. If it is greater than 0, ROM will wait
        # waitTimeCfgCommands * 100us for all device memory configuration commands instead of using read status to wait
        # until these commands complete.
        self.wait_time_cfg_commands = 0
        # [014:32-bit] Sequence parameter for device mode configuration
        # Bit[7:0] - number of LUT sequences for Device mode configuration command
        # Bit[15:8] - starting LUT index of Device mode configuration command
        # Bit[31:16] - must be 0
        self.device_mode_seq = 0
        # [018:32-bit] Device Mode argument, effective only when device_mode_cfg_enable = 1
        self.device_mode_arg = 0
        # [01C:32-bit] Config Command Enable feature (0 – Disabled, 1 – Enabled)
        self.config_cmd_enable = 0
        # [020:3 x 32-bit] Sequences for Config Command, allow 3 separate configuration command sequences.
        self.config_cmd_0 = 0
        self.config_cmd_1 = 0
        self.config_cmd_2 = 0
        # [02C:32-bit] reserved
        # [030:3 x 32-bit] Arguments for each separate configuration command sequence
        self.cfg_cmd_arg_0 = 0
        self.cfg_cmd_arg_1 = 0
        self.cfg_cmd_arg_2 = 0
        # [03C:32-bit] reserved
        # [040:32-bit]
        # Bit0 – differential clock enable
        # Bit1 – CK2 enable, must set to 0 in this silicon
        # Bit2 – ParallelModeEnable, must set to 0 for this silicon
        # Bit3 – wordAddressableEnable
        # Bit4 – Safe Configuration Frequency enable set to 1 for the devices that support DDR Read instructions
        # Bit5 – Pad Setting Override Enable
        # Bit6 – DDR Mode Enable, set to 1 for device supports DDR read command
        self.controller_misc_option = 0
        # [044:8-bit] 1 – Serial NOR, 2 – Serial NAND
        self.device_type = 0
        # [045:8-bit] 1 – Single pad; 2 – Dual pads; 4 – Quad pads; 8 – Octal pads
        self.sflash_pad_type = 0
        # [046:8-bit] Chip specific value, for RT1050
        # 1 – 30 MHz; 2 – 50 MHz; 3 – 60 MHz; 4 – 75 MHz; 5 – 80 MHz; 6 – 100 MHz; 7 – 133 MHz; 8 – 166 MHz;
        # Other value: 30 MHz
        self.serial_clk_freq = 0
        # [047:8-bit] 0=Use predefined LUT sequence index and number;
        #             1=Use LUT sequence parameters provided in this block
        self.lut_custom_seq_enable = 0
        # [048:8B] reserverd
        # [050:4x32-bit] For SPI NOR, need to fill with actual size; For SPI NAND, need to fill with actual size * 2
        self.sflash_a1_size = 0
        self.sflash_a2_size = 0
        self.sflash_b1_size = 0
        self.sflash_b2_size = 0
        # [060:4x32-bit] Set to 0 if it is not supported
        self.cs_pad_setting_override = 0
        self.sclk_pad_setting_override = 0
        self.data_pad_setting_override = 0
        self.dqs_pad_setting_override = 0
        # [070:32-bit] Maximum wait time during read busy status
        # 0 – Disabled timeout checking feature; Other value – Timeout if the wait time exceeds this value.
        self.timeout_in_ms = 0
        # [074:32-bit] Unit: ns; RT1050: Currently, it is used for SPI NAND only at high frequency
        self.command_interval = 0
        # [078:2x16-bit] Time from clock edge to data valid edge. unit 0.1 ns. This field is used when the FlexSPI Root
        # clock is less than 100 MHz and the read sample clock source is device provided DQS signal without CK2 support.
        self.data_valid_time_dlla = 0
        self.data_valid_time_dllb = 0
        # [07C:16-bit] busy bit offset, valid range 0-31
        self.busy_offset = 0
        # [07E:16-bit] 0 – busy bit is 1 if device is busy; 1 – busy bit is 0 if device is busy
        self.busy_bit_polarity = 0
        # [080:256B] Lookup table
        self.lookup_table = b&#39;\x00&#39; * 256
        # [180:48B] Customized LUT sequence
        self.lut_custom_seq = b&#39;\x00&#39; * 48
        # [1B0:16B] reserved
        self.reserved_padding1 = b&#39;\x00&#39; * 16
        self.reserved_padding2 = b&#39;\x00&#39; * 64

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Length of the binary exported data without padding.&#34;&#34;&#34;
        if not self.enabled:
            return 0

        return len(self.export_header()) + calcsize(self.FORMAT) + len(self.lookup_table) + len(self.lut_custom_seq) + \
               len(self.reserved_padding1) + len(self.reserved_padding2)

    def export_header(self) -&gt; bytes:
        &#34;&#34;&#34;Export FCB header info binary form.&#34;&#34;&#34;
        return self.TAG + self.version[::-1] + b&#39;\x00\x00\x00\x00&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export into binary form.

        :param dbg_info: instance allowing to debug output
        :return: binary representation used in the bootable image
        &#34;&#34;&#34;
        if not self.enabled:
            return b&#39;&#39;

        data = self.export_header()
        data += pack(self.FORMAT,
                     # B
                     self.read_sample_clk_src, self.cs_hold_time, self.cs_setup_time, self.column_address_width,
                     self.device_mode_cfg_enable, self.device_mode_type,
                     # H
                     self.wait_time_cfg_commands,
                     # I
                     self.device_mode_seq, self.device_mode_arg, self.config_cmd_enable,
                     self.config_cmd_0, self.config_cmd_1, self.config_cmd_2, 0,
                     # I
                     self.cfg_cmd_arg_0, self.cfg_cmd_arg_1, self.cfg_cmd_arg_2, 0,
                     self.controller_misc_option,
                     # B
                     self.device_type, self.sflash_pad_type, self.serial_clk_freq, self.lut_custom_seq_enable,
                     # I
                     0, 0,
                     # I
                     self.sflash_a1_size, self.sflash_a2_size, self.sflash_b1_size, self.sflash_b2_size,
                     # I
                     self.cs_pad_setting_override, self.sclk_pad_setting_override, self.data_pad_setting_override,
                     self.dqs_pad_setting_override, self.timeout_in_ms, self.command_interval,
                     # H
                     self.data_valid_time_dlla, self.data_valid_time_dllb, self.busy_offset, self.busy_bit_polarity)
        data += self.lookup_table + self.lut_custom_seq + self.reserved_padding1 + self.reserved_padding2

        dbg_info.append_binary_section(&#39;FCB&#39;, data)

        if self.padding_len &gt; 0:
            data += self._padding_export()
            dbg_info.append_section(f&#39;FCB-padding: {self.padding_len} bytes&#39;)

        return data

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the FlexSPIConfBlockFCB.&#34;&#34;&#34;
        return &#34;[FCB]\n&#34; + f&#39;{self.size} bytes\n&#39; if self.enabled else &#34;No FCB\n&#34;

    @classmethod
    def parse(cls, buffer: bytes) -&gt; &#39;FlexSPIConfBlockFCB&#39;:
        &#34;&#34;&#34;Parse binary data and creates instance of the class.

        :param buffer: data to be parsed
        :return: instance of the class representing the data
        :raise ValueError: if data are not valid Flex SPI configuration block
        &#34;&#34;&#34;
        if buffer[:4] != FlexSPIConfBlockFCB.TAG:
            raise ValueError(&#39;TAG does not match: &#39; + buffer[:4].hex())

        version = buffer[7:3:-1]
        if (version[0] != ord(&#39;V&#39;)) or (version[1] != 1) or (version[2] not in range(0, 9)) or \
                (version[3] not in range(0, 9)):
            raise ValueError(&#39;Invalid version number format&#39;)

        result = FlexSPIConfBlockFCB()
        if len(buffer) &lt; result.size:
            raise ValueError(&#39;Insufficient data length&#39;)

        offset = len(result.export_header())
        result.version = version
        (  # B
            result.read_sample_clk_src, result.cs_hold_time, result.cs_setup_time, result.column_address_width,
            result.device_mode_cfg_enable, result.device_mode_type,
            # H
            result.wait_time_cfg_commands,
            # I
            result.device_mode_seq, result.device_mode_arg, result.config_cmd_enable,
            result.config_cmd_0, result.config_cmd_1, result.config_cmd_2, _reserved1,
            # I
            result.cfg_cmd_arg_0, result.cfg_cmd_arg_1, result.cfg_cmd_arg_2, _reserved2,
            result.controller_misc_option,
            # B
            result.device_type, result.sflash_pad_type, result.serial_clk_freq, result.lut_custom_seq_enable,
            # I
            _reserved3, _reserved4,
            # I
            result.sflash_a1_size, result.sflash_a2_size, result.sflash_b1_size, result.sflash_b2_size,
            # I
            result.cs_pad_setting_override, result.sclk_pad_setting_override, result.data_pad_setting_override,
            result.dqs_pad_setting_override, result.timeout_in_ms, result.command_interval,
            # H
            result.data_valid_time_dlla, result.data_valid_time_dllb, result.busy_offset, result.busy_bit_polarity
        ) = unpack_from(FlexSPIConfBlockFCB.FORMAT, buffer, offset)
        offset += calcsize(FlexSPIConfBlockFCB.FORMAT)
        # lookup table
        result.lookup_table = buffer[offset:offset + len(result.lookup_table)]
        offset += len(result.lookup_table)
        # lookup table
        result.lut_custom_seq = buffer[offset:offset + len(result.lut_custom_seq)]
        offset += len(result.lut_custom_seq)
        # reserved padding
        result.reserved_padding1 = buffer[offset:offset + len(result.reserved_padding1)]
        offset += len(result.reserved_padding1)
        result.reserved_padding2 = buffer[offset:offset + len(result.reserved_padding2)]

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.AbstractFCB" href="segments.html#spsdk.image.segments.AbstractFCB">AbstractFCB</a></li>
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.FlexSPIConfBlockFCB.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.FlexSPIConfBlockFCB.TAG"><code class="name">var <span class="ident">TAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.FlexSPIConfBlockFCB.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.FlexSPIConfBlockFCB.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>buffer: bytes) ‑> <a title="spsdk.image.segments.FlexSPIConfBlockFCB" href="segments.html#spsdk.image.segments.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse binary data and creates instance of the class.</p>
<p>:param buffer: data to be parsed
:return: instance of the class representing the data
:raise ValueError: if data are not valid Flex SPI configuration block</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, buffer: bytes) -&gt; &#39;FlexSPIConfBlockFCB&#39;:
    &#34;&#34;&#34;Parse binary data and creates instance of the class.

    :param buffer: data to be parsed
    :return: instance of the class representing the data
    :raise ValueError: if data are not valid Flex SPI configuration block
    &#34;&#34;&#34;
    if buffer[:4] != FlexSPIConfBlockFCB.TAG:
        raise ValueError(&#39;TAG does not match: &#39; + buffer[:4].hex())

    version = buffer[7:3:-1]
    if (version[0] != ord(&#39;V&#39;)) or (version[1] != 1) or (version[2] not in range(0, 9)) or \
            (version[3] not in range(0, 9)):
        raise ValueError(&#39;Invalid version number format&#39;)

    result = FlexSPIConfBlockFCB()
    if len(buffer) &lt; result.size:
        raise ValueError(&#39;Insufficient data length&#39;)

    offset = len(result.export_header())
    result.version = version
    (  # B
        result.read_sample_clk_src, result.cs_hold_time, result.cs_setup_time, result.column_address_width,
        result.device_mode_cfg_enable, result.device_mode_type,
        # H
        result.wait_time_cfg_commands,
        # I
        result.device_mode_seq, result.device_mode_arg, result.config_cmd_enable,
        result.config_cmd_0, result.config_cmd_1, result.config_cmd_2, _reserved1,
        # I
        result.cfg_cmd_arg_0, result.cfg_cmd_arg_1, result.cfg_cmd_arg_2, _reserved2,
        result.controller_misc_option,
        # B
        result.device_type, result.sflash_pad_type, result.serial_clk_freq, result.lut_custom_seq_enable,
        # I
        _reserved3, _reserved4,
        # I
        result.sflash_a1_size, result.sflash_a2_size, result.sflash_b1_size, result.sflash_b2_size,
        # I
        result.cs_pad_setting_override, result.sclk_pad_setting_override, result.data_pad_setting_override,
        result.dqs_pad_setting_override, result.timeout_in_ms, result.command_interval,
        # H
        result.data_valid_time_dlla, result.data_valid_time_dllb, result.busy_offset, result.busy_bit_polarity
    ) = unpack_from(FlexSPIConfBlockFCB.FORMAT, buffer, offset)
    offset += calcsize(FlexSPIConfBlockFCB.FORMAT)
    # lookup table
    result.lookup_table = buffer[offset:offset + len(result.lookup_table)]
    offset += len(result.lookup_table)
    # lookup table
    result.lut_custom_seq = buffer[offset:offset + len(result.lut_custom_seq)]
    offset += len(result.lut_custom_seq)
    # reserved padding
    result.reserved_padding1 = buffer[offset:offset + len(result.reserved_padding1)]
    offset += len(result.reserved_padding1)
    result.reserved_padding2 = buffer[offset:offset + len(result.reserved_padding2)]

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.FlexSPIConfBlockFCB.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Length of the binary exported data without padding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Length of the binary exported data without padding.&#34;&#34;&#34;
    if not self.enabled:
        return 0

    return len(self.export_header()) + calcsize(self.FORMAT) + len(self.lookup_table) + len(self.lut_custom_seq) + \
           len(self.reserved_padding1) + len(self.reserved_padding2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.FlexSPIConfBlockFCB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export into binary form.</p>
<p>:param dbg_info: instance allowing to debug output
:return: binary representation used in the bootable image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export into binary form.

    :param dbg_info: instance allowing to debug output
    :return: binary representation used in the bootable image
    &#34;&#34;&#34;
    if not self.enabled:
        return b&#39;&#39;

    data = self.export_header()
    data += pack(self.FORMAT,
                 # B
                 self.read_sample_clk_src, self.cs_hold_time, self.cs_setup_time, self.column_address_width,
                 self.device_mode_cfg_enable, self.device_mode_type,
                 # H
                 self.wait_time_cfg_commands,
                 # I
                 self.device_mode_seq, self.device_mode_arg, self.config_cmd_enable,
                 self.config_cmd_0, self.config_cmd_1, self.config_cmd_2, 0,
                 # I
                 self.cfg_cmd_arg_0, self.cfg_cmd_arg_1, self.cfg_cmd_arg_2, 0,
                 self.controller_misc_option,
                 # B
                 self.device_type, self.sflash_pad_type, self.serial_clk_freq, self.lut_custom_seq_enable,
                 # I
                 0, 0,
                 # I
                 self.sflash_a1_size, self.sflash_a2_size, self.sflash_b1_size, self.sflash_b2_size,
                 # I
                 self.cs_pad_setting_override, self.sclk_pad_setting_override, self.data_pad_setting_override,
                 self.dqs_pad_setting_override, self.timeout_in_ms, self.command_interval,
                 # H
                 self.data_valid_time_dlla, self.data_valid_time_dllb, self.busy_offset, self.busy_bit_polarity)
    data += self.lookup_table + self.lut_custom_seq + self.reserved_padding1 + self.reserved_padding2

    dbg_info.append_binary_section(&#39;FCB&#39;, data)

    if self.padding_len &gt; 0:
        data += self._padding_export()
        dbg_info.append_section(f&#39;FCB-padding: {self.padding_len} bytes&#39;)

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.FlexSPIConfBlockFCB.export_header"><code class="name flex">
<span>def <span class="ident">export_header</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export FCB header info binary form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_header(self) -&gt; bytes:
    &#34;&#34;&#34;Export FCB header info binary form.&#34;&#34;&#34;
    return self.TAG + self.version[::-1] + b&#39;\x00\x00\x00\x00&#39;</code></pre>
</details>
</dd>
<dt id="spsdk.image.FlexSPIConfBlockFCB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the FlexSPIConfBlockFCB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the FlexSPIConfBlockFCB.&#34;&#34;&#34;
    return &#34;[FCB]\n&#34; + f&#39;{self.size} bytes\n&#39; if self.enabled else &#34;No FCB\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.AbstractFCB" href="segments.html#spsdk.image.segments.AbstractFCB">AbstractFCB</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.AbstractFCB.enabled" href="segments.html#spsdk.image.segments.AbstractFCB.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.space" href="segments.html#spsdk.image.segments.AbstractFCB.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.KeySourceType"><code class="flex name class">
<span>class <span class="ident">KeySourceType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Device key source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeySourceType(Enum):
    &#34;&#34;&#34;Device key source.&#34;&#34;&#34;
    OTP = (0, &#39;Device keys stored in OTP&#39;)
    KEYSTORE = (1, &#39;Device keys stored in KeyStore&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.KeySourceType.KEYSTORE"><code class="name">var <span class="ident">KEYSTORE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.KeySourceType.OTP"><code class="name">var <span class="ident">OTP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.KeyStore"><code class="flex name class">
<span>class <span class="ident">KeyStore</span></span>
<span>(</span><span>key_source: <a title="spsdk.image.keystore.KeySourceType" href="keystore.html#spsdk.image.keystore.KeySourceType">KeySourceType</a>, key_store: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide info about KeyStore for MaterBootImage.</p>
<p>Initialize Keystore.</p>
<p>:param key_source: device key source
:param key_store: initial content of the key store in the bootable image; None if empty
:raises ValueError: if invalid key-store size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyStore:
    &#34;&#34;&#34;Provide info about KeyStore for MaterBootImage.&#34;&#34;&#34;
    # size of key store in bytes
    KEY_STORE_SIZE = 1424  # TODO size can be device-specific, the current value is valid for RT5xx and RT6xx

    @property
    def key_source(self) -&gt; KeySourceType:
        &#34;&#34;&#34;Device key source.&#34;&#34;&#34;
        return self._key_source

    def __init__(self, key_source: KeySourceType, key_store: bytes = None) -&gt; None:
        &#34;&#34;&#34;Initialize Keystore.

        :param key_source: device key source
        :param key_store: initial content of the key store in the bootable image; None if empty
        :raises ValueError: if invalid key-store size
        &#34;&#34;&#34;
        if key_store:
            if len(key_store) != self.KEY_STORE_SIZE:
                raise ValueError(f&#34;Invalid key-store size, expected is {str(self.KEY_STORE_SIZE)} bytes&#34;)
            assert key_source == KeySourceType.KEYSTORE, &#34;KeyStore can be initialized only if key_source == KEYSTORE&#34;

        self._key_source = key_source
        self._key_store = key_store

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Binary key store content; empty bytes for empty key-store.&#34;&#34;&#34;
        return self._key_store if self._key_store else bytes()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Information about key store in text form.&#34;&#34;&#34;
        msg = f&#34;Device key source:    {KeySourceType.name(self.key_source)}\n&#34; + \
              f&#34;Device key store len: {str(len(self.export()))}&#34;
        return msg

    @staticmethod
    def derive_hmac_key(hmac_key: bytes) -&gt; bytes:
        &#34;&#34;&#34;Derive HMAC from master or user key.

        :param hmac_key: either master-key (for key_source == OTP) or user key (for key_source == KEYSTORE)
        :return: key used for image header authentication in LoadToRam images
        &#34;&#34;&#34;
        assert len(hmac_key) == 32
        aes = AES.new(hmac_key, AES.MODE_ECB)
        return aes.encrypt(bytes([0] * 16))

    @staticmethod
    def derive_enc_image_key(master_key: bytes) -&gt; bytes:
        &#34;&#34;&#34;Derive &#34;enc_image_key&#34; from master key.

        :param master_key: stored in OTP
        :return: key used to decrypt encrypted images during boot
        &#34;&#34;&#34;
        assert len(master_key) == 32
        aes = AES.new(master_key, AES.MODE_ECB)
        return aes.encrypt(bytes([1] + [0] * 15 + [2] + [0] * 15))

    @staticmethod
    def derive_sb_kek_key(master_key: bytes) -&gt; bytes:
        &#34;&#34;&#34;Derive SBKEK key from master key.

        :param master_key: 32 bytes key, stored in OTP
        :return: encryption key to handle SB2 file (update capsule)
        &#34;&#34;&#34;
        assert len(master_key) == 32
        aes = AES.new(master_key, AES.MODE_ECB)
        return aes.encrypt(bytes([3] + [0] * 15 + [4] + [0] * 15))

    @staticmethod
    def derive_otfad_kek_key(master_key: bytes, otfad_input: bytes) -&gt; bytes:
        &#34;&#34;&#34;Derive OTFAD KEK key from master key and OTFAD input.

        :param master_key: 32 bytes key, stored in OTP
        :param otfad_input: 16 bytes input, stored in OTP
        :return: OTFAD encryption key for FLASH encryption/decryption
        &#34;&#34;&#34;
        assert len(master_key) == 32
        assert len(otfad_input) == 16
        aes = AES.new(master_key, AES.MODE_ECB)
        return aes.encrypt(otfad_input)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.KeyStore.KEY_STORE_SIZE"><code class="name">var <span class="ident">KEY_STORE_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.KeyStore.derive_enc_image_key"><code class="name flex">
<span>def <span class="ident">derive_enc_image_key</span></span>(<span>master_key: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Derive "enc_image_key" from master key.</p>
<p>:param master_key: stored in OTP
:return: key used to decrypt encrypted images during boot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def derive_enc_image_key(master_key: bytes) -&gt; bytes:
    &#34;&#34;&#34;Derive &#34;enc_image_key&#34; from master key.

    :param master_key: stored in OTP
    :return: key used to decrypt encrypted images during boot
    &#34;&#34;&#34;
    assert len(master_key) == 32
    aes = AES.new(master_key, AES.MODE_ECB)
    return aes.encrypt(bytes([1] + [0] * 15 + [2] + [0] * 15))</code></pre>
</details>
</dd>
<dt id="spsdk.image.KeyStore.derive_hmac_key"><code class="name flex">
<span>def <span class="ident">derive_hmac_key</span></span>(<span>hmac_key: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Derive HMAC from master or user key.</p>
<p>:param hmac_key: either master-key (for key_source == OTP) or user key (for key_source == KEYSTORE)
:return: key used for image header authentication in LoadToRam images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def derive_hmac_key(hmac_key: bytes) -&gt; bytes:
    &#34;&#34;&#34;Derive HMAC from master or user key.

    :param hmac_key: either master-key (for key_source == OTP) or user key (for key_source == KEYSTORE)
    :return: key used for image header authentication in LoadToRam images
    &#34;&#34;&#34;
    assert len(hmac_key) == 32
    aes = AES.new(hmac_key, AES.MODE_ECB)
    return aes.encrypt(bytes([0] * 16))</code></pre>
</details>
</dd>
<dt id="spsdk.image.KeyStore.derive_otfad_kek_key"><code class="name flex">
<span>def <span class="ident">derive_otfad_kek_key</span></span>(<span>master_key: bytes, otfad_input: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Derive OTFAD KEK key from master key and OTFAD input.</p>
<p>:param master_key: 32 bytes key, stored in OTP
:param otfad_input: 16 bytes input, stored in OTP
:return: OTFAD encryption key for FLASH encryption/decryption</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def derive_otfad_kek_key(master_key: bytes, otfad_input: bytes) -&gt; bytes:
    &#34;&#34;&#34;Derive OTFAD KEK key from master key and OTFAD input.

    :param master_key: 32 bytes key, stored in OTP
    :param otfad_input: 16 bytes input, stored in OTP
    :return: OTFAD encryption key for FLASH encryption/decryption
    &#34;&#34;&#34;
    assert len(master_key) == 32
    assert len(otfad_input) == 16
    aes = AES.new(master_key, AES.MODE_ECB)
    return aes.encrypt(otfad_input)</code></pre>
</details>
</dd>
<dt id="spsdk.image.KeyStore.derive_sb_kek_key"><code class="name flex">
<span>def <span class="ident">derive_sb_kek_key</span></span>(<span>master_key: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Derive SBKEK key from master key.</p>
<p>:param master_key: 32 bytes key, stored in OTP
:return: encryption key to handle SB2 file (update capsule)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def derive_sb_kek_key(master_key: bytes) -&gt; bytes:
    &#34;&#34;&#34;Derive SBKEK key from master key.

    :param master_key: 32 bytes key, stored in OTP
    :return: encryption key to handle SB2 file (update capsule)
    &#34;&#34;&#34;
    assert len(master_key) == 32
    aes = AES.new(master_key, AES.MODE_ECB)
    return aes.encrypt(bytes([3] + [0] * 15 + [4] + [0] * 15))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.KeyStore.key_source"><code class="name">var <span class="ident">key_source</span> : <a title="spsdk.image.keystore.KeySourceType" href="keystore.html#spsdk.image.keystore.KeySourceType">KeySourceType</a></code></dt>
<dd>
<div class="desc"><p>Device key source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key_source(self) -&gt; KeySourceType:
    &#34;&#34;&#34;Device key source.&#34;&#34;&#34;
    return self._key_source</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.KeyStore.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Binary key store content; empty bytes for empty key-store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Binary key store content; empty bytes for empty key-store.&#34;&#34;&#34;
    return self._key_store if self._key_store else bytes()</code></pre>
</details>
</dd>
<dt id="spsdk.image.KeyStore.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Information about key store in text form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Information about key store in text form.&#34;&#34;&#34;
    msg = f&#34;Device key source:    {KeySourceType.name(self.key_source)}\n&#34; + \
          f&#34;Device key store len: {str(len(self.export()))}&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.MAC"><code class="flex name class">
<span>class <span class="ident">MAC</span></span>
<span>(</span><span>version: int = 64, nonce_len: int = 0, mac_len: int = 16, data: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure that holds initial parameter for AES encryption/description.</p>
<ul>
<li>nonce - initialization vector for AEAD AES128 decryption</li>
<li>mac - message authentication code to verify the decryption was successful</li>
</ul>
<p>Constructor.</p>
<p>:param version: format version, should be 0x4x
:param nonce_len: number of NONCE bytes
:param mac_len: number of MAC bytes
:param data: nonce and mac bytes joined together</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MAC(BaseClass):
    &#34;&#34;&#34;Structure that holds initial parameter for AES encryption/description.

    - nonce - initialization vector for AEAD AES128 decryption
    - mac - message authentication code to verify the decryption was successful
    &#34;&#34;&#34;

    # AES block size in bytes; This also match size of the MAC and
    AES128_BLK_LEN = 16

    def __init__(self, version: int = 0x40, nonce_len: int = 0, mac_len: int = AES128_BLK_LEN,
                 data: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param version: format version, should be 0x4x
        :param nonce_len: number of NONCE bytes
        :param mac_len: number of MAC bytes
        :param data: nonce and mac bytes joined together
        &#34;&#34;&#34;
        super().__init__(tag=SegTag.MAC, version=version)
        self.nonce_len = nonce_len
        self.mac_len = mac_len
        self._data: bytes = bytes() if data is None else bytes(data)
        if data:
            self._validate_data()

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of binary representation in bytes.&#34;&#34;&#34;
        return Header.SIZE + 4 + self.nonce_len + self.mac_len

    def _validate_data(self) -&gt; None:
        &#34;&#34;&#34;Validates the data.

        :raise ValueError: if data length does not match with parameters
        &#34;&#34;&#34;
        if len(self.data) != self.nonce_len + self.mac_len:
            raise ValueError(f&#34;length of data ({len(self.data)}) does not match with &#34;
                             f&#34;nonce_bytes({self.nonce_len})+mac_bytes({self.mac_len})&#34;)

    @property
    def data(self) -&gt; bytes:
        &#34;&#34;&#34;NONCE and MAC bytes joined together.&#34;&#34;&#34;
        return self._data

    @data.setter
    def data(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: NONCE and MAC bytes joined together
        &#34;&#34;&#34;
        self._data = value
        self._validate_data()

    @property
    def nonce(self) -&gt; bytes:
        &#34;&#34;&#34;NONCE bytes for the encryption/decryption.&#34;&#34;&#34;
        self._validate_data()
        return self._data[0:self.nonce_len]

    @property
    def mac(self) -&gt; bytes:
        &#34;&#34;&#34;MAC bytes for the encryption/decryption.&#34;&#34;&#34;
        self._validate_data()
        return self._data[self.nonce_len: self.nonce_len + self.mac_len]

    def update_aead_encryption_params(self, nonce: bytes, mac: bytes) -&gt; None:
        &#34;&#34;&#34;Update AEAD encryption parameters for encrypted image.

        :param nonce: initialization vector, length depends on image size,
        :param mac: message authentication code used to authenticate uncrypted data, 16 bytes
        &#34;&#34;&#34;
        assert len(mac) == MAC.AES128_BLK_LEN
        assert 11 &lt;= len(nonce) &lt;= 13
        self.nonce_len = len(nonce)
        assert self.mac_len == MAC.AES128_BLK_LEN
        self.data = nonce + mac

    def __repr__(self) -&gt; str:
        return &#34;MAC &lt;Ver: {:X}.{:X}, Nonce: {}, MAC: {}&gt;&#34;.format(self.version_major, self.version_minor,
                                                                 self.nonce_len, self.mac_len)

    def __eq__(self, obj: Any) -&gt; bool:
        return isinstance(obj, MAC) and vars(obj) == vars(self)

    def __ne__(self, obj: Any) -&gt; bool:
        return not self.__eq__(obj)

    def __len__(self) -&gt; int:
        return len(self._data)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;MAC (Version: {:X}.{:X})\n&#34;.format(self.version &gt;&gt; 4, self.version &amp; 0xF)
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;Nonce Len: {} Bytes\n&#34;.format(self.nonce_len)
        msg += &#34;MAC Len:   {} Bytes\n&#34;.format(self.mac_len)
        msg += f&#34;[{self._data.hex()}]\n&#34;
        return msg

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export instance into binary form (serialization).

        :param dbg_info: optional instance providing debug info about exported content
        :return: binary form
        &#34;&#34;&#34;
        self._validate_data()
        self._header.length = self.size
        raw_data = self._header.export()
        dbg_info.append_binary_data(&#39;header&#39;, raw_data)
        raw_data += pack(&#34;&gt;4B&#34;, 0, self.nonce_len, 0, self.mac_len)
        dbg_info.append(&#39;nonce=&#39; + self.nonce.hex())
        dbg_info.append(&#39;mac=&#39; + self.mac.hex())
        raw_data += self.data
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;MAC&#39;:
        &#34;&#34;&#34;Parse binary data and creates the instance (deserialization).

        :param data: being parsed
        :param offset: to start parse the data
        :return: the instance
        &#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.MAC)
        offset += Header.SIZE
        (_, nonce_bytes, _, mac_bytes) = unpack_from(&#34;&gt;4B&#34;, data, offset)
        offset += 4
        return cls(header.param, nonce_bytes, mac_bytes, data[offset: offset + header.length - (Header.SIZE + 4)])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.MAC.AES128_BLK_LEN"><code class="name">var <span class="ident">AES128_BLK_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.MAC.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse binary data and creates the instance (deserialization).</p>
<p>:param data: being parsed
:param offset: to start parse the data
:return: the instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;MAC&#39;:
    &#34;&#34;&#34;Parse binary data and creates the instance (deserialization).

    :param data: being parsed
    :param offset: to start parse the data
    :return: the instance
    &#34;&#34;&#34;
    header = Header.parse(data, offset, SegTag.MAC)
    offset += Header.SIZE
    (_, nonce_bytes, _, mac_bytes) = unpack_from(&#34;&gt;4B&#34;, data, offset)
    offset += 4
    return cls(header.param, nonce_bytes, mac_bytes, data[offset: offset + header.length - (Header.SIZE + 4)])</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.MAC.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"><p>NONCE and MAC bytes joined together.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; bytes:
    &#34;&#34;&#34;NONCE and MAC bytes joined together.&#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="spsdk.image.MAC.mac"><code class="name">var <span class="ident">mac</span> : bytes</code></dt>
<dd>
<div class="desc"><p>MAC bytes for the encryption/decryption.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; bytes:
    &#34;&#34;&#34;MAC bytes for the encryption/decryption.&#34;&#34;&#34;
    self._validate_data()
    return self._data[self.nonce_len: self.nonce_len + self.mac_len]</code></pre>
</details>
</dd>
<dt id="spsdk.image.MAC.nonce"><code class="name">var <span class="ident">nonce</span> : bytes</code></dt>
<dd>
<div class="desc"><p>NONCE bytes for the encryption/decryption.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nonce(self) -&gt; bytes:
    &#34;&#34;&#34;NONCE bytes for the encryption/decryption.&#34;&#34;&#34;
    self._validate_data()
    return self._data[0:self.nonce_len]</code></pre>
</details>
</dd>
<dt id="spsdk.image.MAC.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of binary representation in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of binary representation in bytes.&#34;&#34;&#34;
    return Header.SIZE + 4 + self.nonce_len + self.mac_len</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.MAC.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export instance into binary form (serialization).</p>
<p>:param dbg_info: optional instance providing debug info about exported content
:return: binary form</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export instance into binary form (serialization).

    :param dbg_info: optional instance providing debug info about exported content
    :return: binary form
    &#34;&#34;&#34;
    self._validate_data()
    self._header.length = self.size
    raw_data = self._header.export()
    dbg_info.append_binary_data(&#39;header&#39;, raw_data)
    raw_data += pack(&#34;&gt;4B&#34;, 0, self.nonce_len, 0, self.mac_len)
    dbg_info.append(&#39;nonce=&#39; + self.nonce.hex())
    dbg_info.append(&#39;mac=&#39; + self.mac.hex())
    raw_data += self.data
    return raw_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.MAC.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text info about the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;MAC (Version: {:X}.{:X})\n&#34;.format(self.version &gt;&gt; 4, self.version &amp; 0xF)
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;Nonce Len: {} Bytes\n&#34;.format(self.nonce_len)
    msg += &#34;MAC Len:   {} Bytes\n&#34;.format(self.mac_len)
    msg += f&#34;[{self._data.hex()}]\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.MAC.update_aead_encryption_params"><code class="name flex">
<span>def <span class="ident">update_aead_encryption_params</span></span>(<span>self, nonce: bytes, mac: bytes) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update AEAD encryption parameters for encrypted image.</p>
<p>:param nonce: initialization vector, length depends on image size,
:param mac: message authentication code used to authenticate uncrypted data, 16 bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_aead_encryption_params(self, nonce: bytes, mac: bytes) -&gt; None:
    &#34;&#34;&#34;Update AEAD encryption parameters for encrypted image.

    :param nonce: initialization vector, length depends on image size,
    :param mac: message authentication code used to authenticate uncrypted data, 16 bytes
    &#34;&#34;&#34;
    assert len(mac) == MAC.AES128_BLK_LEN
    assert 11 &lt;= len(nonce) &lt;= 13
    self.nonce_len = len(nonce)
    assert self.mac_len == MAC.AES128_BLK_LEN
    self.data = nonce + mac</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.secret.BaseClass.version" href="secret.html#spsdk.image.secret.BaseClass.version">version</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_major" href="secret.html#spsdk.image.secret.BaseClass.version_major">version_major</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_minor" href="secret.html#spsdk.image.secret.BaseClass.version_minor">version_minor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.MasterBootImage"><code class="flex name class">
<span>class <span class="ident">MasterBootImage</span></span>
<span>(</span><span>app: Union[bytes, bytearray], load_addr: int, image_type: <a title="spsdk.image.mbimg.MasterBootImageType" href="mbimg.html#spsdk.image.mbimg.MasterBootImageType">MasterBootImageType</a> = 0, trust_zone: Union[<a title="spsdk.image.trustzone.TrustZone" href="trustzone.html#spsdk.image.trustzone.TrustZone">TrustZone</a>, NoneType] = None, app_table: Union[<a title="spsdk.image.mbimg.MultipleImageTable" href="mbimg.html#spsdk.image.mbimg.MultipleImageTable">MultipleImageTable</a>, NoneType] = None, cert_block: Union[<a title="spsdk.utils.crypto.cert_blocks.CertBlockV2" href="../utils/crypto/cert_blocks.html#spsdk.utils.crypto.cert_blocks.CertBlockV2">CertBlockV2</a>, NoneType] = None, priv_key_pem_data: Union[bytes, NoneType] = None, hmac_key: Union[bytes, str] = None, key_store: <a title="spsdk.image.keystore.KeyStore" href="keystore.html#spsdk.image.keystore.KeyStore">KeyStore</a> = None, enable_hw_user_mode_keys: bool = False, ctr_init_vector: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic representation of Master Boot Image layout.</p>
<p>Constructor.</p>
<p>:param app: input image (binary)
:param load_addr: address in RAM, where 'RAM' image will be copied;
for XIP images address, where the image is located in FLASH memory
:param image_type: type of the master boot image
:param trust_zone: TrustZone instance; None to use default settings (TrustZone enabled)
:param app_table: optional table with additional images; None if no additional images needed
:param cert_block: block of certificates; None for unsigned image
:param priv_key_pem_data: private key to sign the image, decrypted binary data in PEM format
:param hmac_key: optional key for HMAC generation (either binary ot HEX string; 32 bytes);
None if HMAC is not in the image
If key_store.key_source == KeySourceType.KEYSTORE, this is a user-key from key-store
If key_store.key_source == KeySourceType.OTP, this is a master-key burned in OTP
:param key_store: optional key store binary content; None if key store is not in the image
:param enable_hw_user_mode_keys: flag for controlling secure hardware key bus. If true, then it is possible to
access keys on hardware secure bus from non-secure application, else non-secure application will read zeros.
:param ctr_init_vector: optional initial vector for encryption counter; None to use random vector
:raises TypeError: if type is not binary data
:raises ValueError: if images are not loaded from RAM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MasterBootImage:
    &#34;&#34;&#34;Basic representation of Master Boot Image layout.&#34;&#34;&#34;

    # offset alignment of the certificate position
    _IMAGE_ALIGNMENT = 4

    IMAGE_LENGTH_OFFSET = 0x20
    # offset with flags: image type, trust zone, key-store and HW_USER_KEY_EN
    IMAGE_FLAGS_OFFSET = 0x24
    # flag for image type, if the image contains key-store
    _KEY_STORE_FLAG = 0x8000
    # flag that image contains relocation table
    _RELOC_TABLE_FLAG = 0x800
    # enableHwUserModeKeys : flag for controlling secure hardware key bus. If enabled(1), then it is possible to access
    # keys on hardware secure bus from non-secure application, else non-secure application will read zeros.
    _HW_USER_KEY_EN_FLAG = 0x1000

    CRC_BLOCK_OFFSET = 0x28
    CERTIFICATE_OFFSET = 0x28
    LOAD_ADDR_OFFSET = 0x34
    # offset in the image, where the HMAC table is located
    HMAC_OFFSET = 64
    # size of HMAC table in bytes
    HMAC_SIZE = 32
    # length of user key or master key, in bytes
    _HMAC_KEY_LENGTH = 32
    # length of derived key for HMAC, in bytes
    _HMAC_DERIVED_KEY_LEN = 16
    # length of counter initialization vector
    _CTR_INIT_VECTOR_SIZE = 16

    @property
    def app_len(self) -&gt; int:
        &#34;&#34;&#34;Length of binary app data; this includes also size of the relocation table.&#34;&#34;&#34;
        result = len(self.app)
        if self.app_table:
            result += len(self.app_table.export(0))
        return result

    @property
    def data(self) -&gt; bytes:
        &#34;&#34;&#34;Plain, unsigned binary data for the image.

        It consists of:
        - application image
        - optionally trust zone data
        Please mind the result does not contain: certification block, HMAC, keystore and signature
        &#34;&#34;&#34;
        # binary image
        data = self.app
        if self.app_table:
            data += self.app_table.export(len(data))
        # trust zone data
        data += self.trust_zone.export()
        return data

    @property
    def total_len(self) -&gt; int:
        &#34;&#34;&#34;Total length of the image.

        It is sum of:
        - image length + length of trust zone data
        - HMAC length
        - KeyStore length
        - certificate length (+ for encrypted images also encrypted header and CRT init vector)
        - signature length
        &#34;&#34;&#34;
        plain_data = self.data
        certificate_len = len(self._certificate(plain_data))
        hmac_data_len = len(self._hmac(self.data))
        key_store_len = len(self.key_store.export()) if self.key_store else 0
        return len(plain_data) + hmac_data_len + key_store_len + certificate_len + self.signature_len

    # pylint: disable=too-many-arguments
    def __init__(self, app: Union[bytes, bytearray],
                 load_addr: int,
                 image_type: MasterBootImageType = MasterBootImageType.PLAIN_IMAGE,
                 trust_zone: Optional[TrustZone] = None, app_table: Optional[MultipleImageTable] = None,
                 cert_block: Optional[CertBlockV2] = None, priv_key_pem_data: Optional[bytes] = None,
                 hmac_key: Union[bytes, str] = None, key_store: KeyStore = None,
                 enable_hw_user_mode_keys: bool = False, ctr_init_vector: bytes = None):
        &#34;&#34;&#34;Constructor.

        :param app: input image (binary)
        :param load_addr: address in RAM, where &#39;RAM&#39; image will be copied;
                    for XIP images address, where the image is located in FLASH memory
        :param image_type: type of the master boot image
        :param trust_zone: TrustZone instance; None to use default settings (TrustZone enabled)
        :param app_table: optional table with additional images; None if no additional images needed
        :param cert_block: block of certificates; None for unsigned image
        :param priv_key_pem_data: private key to sign the image, decrypted binary data in PEM format
        :param hmac_key: optional key for HMAC generation (either binary ot HEX string; 32 bytes);
                                None if HMAC is not in the image
                If key_store.key_source == KeySourceType.KEYSTORE, this is a user-key from key-store
                If key_store.key_source == KeySourceType.OTP, this is a master-key burned in OTP
        :param key_store: optional key store binary content; None if key store is not in the image
        :param enable_hw_user_mode_keys: flag for controlling secure hardware key bus. If true, then it is possible to
            access keys on hardware secure bus from non-secure application, else non-secure application will read zeros.
        :param ctr_init_vector: optional initial vector for encryption counter; None to use random vector
        :raises TypeError: if type is not binary data
        :raises ValueError: if images are not loaded from RAM
        &#34;&#34;&#34;
        if not isinstance(app, (bytes, bytearray)):
            raise TypeError(&#34;app must be binary data (bytes, bytearray)&#34;)
        if app_table and not MasterBootImageType.is_copied_to_ram(image_type):
            raise ValueError(&#39;app_table can be used only for images loaded to RAM&#39;)
        assert load_addr &gt;= 0
        self.load_addr = load_addr
        self.image_type = image_type
        alignment = MasterBootImage._IMAGE_ALIGNMENT
        self.app = misc.align_block(bytes(app), alignment)
        self.app_table = app_table
        # hmac + key store
        self.hmac_key = bytes.fromhex(hmac_key) if isinstance(hmac_key, str) else hmac_key
        self.key_store = key_store
        # trust zone
        self.trust_zone = trust_zone or TrustZone.enabled()
        # security stuff
        self.cert_block = cert_block
        if self.cert_block:
            self.cert_block.alignment = 4  # this value is used by elf-to-sb-gui
            self.signature_len = self.cert_block.signature_size
        else:
            self.signature_len = 0
        self._priv_key_pem_data = priv_key_pem_data
        self.enable_hw_user_mode_keys = enable_hw_user_mode_keys
        self.ctr_init_vector = ctr_init_vector
        if MasterBootImageType.is_encrypted(self.image_type) and not ctr_init_vector:
            self.ctr_init_vector = crypto_backend().random_bytes(self._CTR_INIT_VECTOR_SIZE)
        self._verify_private_key()
        # validate parameters
        self._validate_new_instance()

    def _validate_new_instance(self) -&gt; None:
        &#34;&#34;&#34;Validate new instance.

        :raise ValueError: if there are invalid or conflicting parameters
        &#34;&#34;&#34;
        # table
        if self.app_table:
            if not self.app_table.entries:
                raise ValueError(&#34;app_table is empty&#34;)

        # image size
        if len(self.data) &lt; self.HMAC_OFFSET:
            raise ValueError(&#34;Image must be at least {} bytes&#34;.format(str(self.HMAC_OFFSET)))

        # security stuff
        if MasterBootImageType.is_signed(self.image_type):
            if not self.cert_block:
                raise ValueError(&#34;Certificate block must be specified for signed image (cert_block)&#34;)
            if not self._priv_key_pem_data:
                raise ValueError(&#34;Private Key must be specified for signed image (priv_key_path)&#34;)
        else:
            if self.cert_block:
                raise ValueError(&#34;Certificate block must be specified only for signed image (cert_block)&#34;)
            if self._priv_key_pem_data:
                raise ValueError(&#34;Private Key must be specified only for signed image (priv_key_path)&#34;)

        if MasterBootImageType.is_encrypted(self.image_type):
            if not self.ctr_init_vector or (len(self.ctr_init_vector) != self._CTR_INIT_VECTOR_SIZE):
                raise ValueError(f&#34;Invalid length of CTR init vector, expected {str(self._CTR_INIT_VECTOR_SIZE)} bytes&#34;)

        # hmac
        if MasterBootImageType.has_hmac(self.image_type):
            if not self.hmac_key:
                raise ValueError(&#34;HMAC key must be specified for load-to-ram signed images (hmac_key)&#34;)
        else:
            if self.hmac_key:
                raise ValueError(&#34;HMAC user key cannot be applied into selected image (hmac_user_key)&#34;)
            if self.key_store:
                raise ValueError(&#34;KeyStore cannot be applied into selected image (key_store)&#34;)

    def _verify_private_key(self) -&gt; None:
        &#34;&#34;&#34;Verifies private key.

        :raise ValueError: if any parameter not valid
        &#34;&#34;&#34;
        if self._priv_key_pem_data:
            cert_blk = self.cert_block
            assert cert_blk is not None
            if not cert_blk.verify_private_key(self._priv_key_pem_data):
                raise ValueError(&#39;Signature verification failed, private key does not match to certificate&#39;)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text description of the instance.&#34;&#34;&#34;
        msg = &#34;Master Boot Image&#34;
        msg += &#34;Image type       : {}\n&#34;.format(MasterBootImageType.desc(self.image_type))
        msg += &#34;Img load addr    : {}\n&#34;.format(hex(self.load_addr))
        msg += &#34;Image length     : {}\n&#34;.format(len(self.data))
        msg += &#34;HW user mode keys: {}\n&#34;.format(&#34;enabled&#34; if self.enable_hw_user_mode_keys else &#34;disabled&#34;)
        msg += &#34;TrustZone        : {}\n&#34;.format(TrustZoneType.desc(self.trust_zone.type))
        if self.cert_block:
            msg += &#34;[Certificate Block]\n&#34;
            msg += self.cert_block.info()
        if self._priv_key_pem_data:
            msg += &#34;Private Key  : {Yes}\n&#34;
        return msg

    def _update_ivt(self, data: bytes) -&gt; bytes:
        data = bytearray(data)
        data[self.IMAGE_LENGTH_OFFSET: self.IMAGE_LENGTH_OFFSET + 4] = struct.pack(&#34;&lt;I&#34;, self.total_len)
        # flags
        flags = (self.trust_zone.type &lt;&lt; 8) + self.image_type
        if self.key_store and self.key_store.export():
            flags |= self._KEY_STORE_FLAG
        if self.app_table:
            flags |= self._RELOC_TABLE_FLAG
        if self.enable_hw_user_mode_keys:
            flags |= self._HW_USER_KEY_EN_FLAG
        data[self.IMAGE_FLAGS_OFFSET: self.IMAGE_FLAGS_OFFSET + 4] = struct.pack(&#34;&lt;I&#34;, flags)
        #
        data[self.LOAD_ADDR_OFFSET: self.LOAD_ADDR_OFFSET + 4] = struct.pack(&#34;&lt;I&#34;, self.load_addr)
        if MasterBootImageType.is_signed(self.image_type):
            data[self.CERTIFICATE_OFFSET: self.CERTIFICATE_OFFSET + 4] = struct.pack(&#34;&lt;I&#34;, self.app_len)
        if MasterBootImageType.has_crc(self.image_type):
            # calculate CRC using MPEG2 specification over all of data (app and trustzone)
            # expect for 4 bytes at CRC_BLOCK_OFFSET and put the resulting CRC there
            crc = Crc32Mpeg2.calc(data[:self.CRC_BLOCK_OFFSET])
            crc = Crc32Mpeg2.calc(data[self.CRC_BLOCK_OFFSET + 4:], crc)
            data[self.CRC_BLOCK_OFFSET: self.CRC_BLOCK_OFFSET + 4] = struct.pack(&#34;&lt;I&#34;, crc)
        return bytes(data)

    def _certificate(self, encr_data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Create certificate optionally followed by encrypted image header and CTR init vector.

        :param encr_data: encrypted data for encrypted image; plain data otherwise
        :return:
        - for encrypted image: certificate with encrypted image header and CTR init vector
        - for signed image: certificate
        - for plain image: empty bytes
        &#34;&#34;&#34;
        if not self.cert_block:
            return bytes()

        # for encrypted image create encrypted header located behind certificate
        if MasterBootImageType.is_encrypted(self.image_type):
            assert self.ctr_init_vector
            encr_header = encr_data[:56] + self.ctr_init_vector
        else:
            encr_header = bytes()
        self.cert_block.image_length = len(encr_data) + len(self.cert_block.export()) + len(encr_header)
        return self.cert_block.export() + encr_header

    def _hmac(self, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Calculate HMAC for provided data.

        :param data: to calculate hmac
        :return: calculated hmac; empty bytes if the block does not contain any HMAC
        &#34;&#34;&#34;
        if not MasterBootImageType.has_hmac(self.image_type):
            return bytes()

        assert self.hmac_key and len(self.hmac_key) == self._HMAC_KEY_LENGTH
        key = KeyStore.derive_hmac_key(self.hmac_key)
        assert len(key) == self._HMAC_DERIVED_KEY_LEN
        result = crypto_backend().hmac(key, data)
        assert len(result) == self.HMAC_SIZE
        return result

    def _encrypt(self, data: bytes) -&gt; bytes:
        if not MasterBootImageType.is_encrypted(self.image_type):
            return data

        assert self.key_store, &#34;key_store must be specified for encrypted image&#34;
        assert self.hmac_key and len(self.hmac_key) == self._HMAC_KEY_LENGTH
        assert self.ctr_init_vector

        if self.key_store.key_source == KeySourceType.KEYSTORE:
            key = self.hmac_key  # user_key, the key not derived
        elif self.key_store.key_source == KeySourceType.OTP:
            key = self.key_store.derive_enc_image_key(self.hmac_key)
        else:
            assert False, &#34;Unsupported key_source&#34;

        aes = AES.new(key, AES.MODE_CTR, initial_value=self.ctr_init_vector, nonce=bytes())
        return aes.encrypt(data)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Master boot image (binary).&#34;&#34;&#34;
        data = self._update_ivt(self.data)

        # signed or encrypted
        if MasterBootImageType.is_signed(self.image_type):
            assert self._priv_key_pem_data
            cb = self.cert_block
            assert (cb is not None) and cb.verify_private_key(self._priv_key_pem_data)
            # encrypt
            encr_data = self._encrypt(data)
            encr_data = (self._update_ivt(encr_data[:self.HMAC_OFFSET]) +  # header
                         encr_data[self.HMAC_OFFSET:self.app_len] +  # encrypted image
                         self._certificate(encr_data) +  # certificate + encoded image header + CTR init vector
                         encr_data[self.app_len:])  # TZ encoded data
            encr_data += crypto_backend().rsa_sign(self._priv_key_pem_data, encr_data)  # signature
            # hmac + key store
            if MasterBootImageType.has_hmac(self.image_type):
                hmac_keystore = self._hmac(encr_data[:self.HMAC_OFFSET])
                if self.key_store:
                    hmac_keystore += self.key_store.export()
                encr_data = encr_data[:self.HMAC_OFFSET] + hmac_keystore + encr_data[self.HMAC_OFFSET:]
            return bytes(encr_data)

        return bytes(data)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Parse.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.MasterBootImage.CERTIFICATE_OFFSET"><code class="name">var <span class="ident">CERTIFICATE_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImage.CRC_BLOCK_OFFSET"><code class="name">var <span class="ident">CRC_BLOCK_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImage.HMAC_OFFSET"><code class="name">var <span class="ident">HMAC_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImage.HMAC_SIZE"><code class="name">var <span class="ident">HMAC_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImage.IMAGE_FLAGS_OFFSET"><code class="name">var <span class="ident">IMAGE_FLAGS_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImage.IMAGE_LENGTH_OFFSET"><code class="name">var <span class="ident">IMAGE_LENGTH_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImage.LOAD_ADDR_OFFSET"><code class="name">var <span class="ident">LOAD_ADDR_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.MasterBootImage.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, **kwargs: Any) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, **kwargs: Any) -&gt; None:
    &#34;&#34;&#34;Parse.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.MasterBootImage.app_len"><code class="name">var <span class="ident">app_len</span> : int</code></dt>
<dd>
<div class="desc"><p>Length of binary app data; this includes also size of the relocation table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app_len(self) -&gt; int:
    &#34;&#34;&#34;Length of binary app data; this includes also size of the relocation table.&#34;&#34;&#34;
    result = len(self.app)
    if self.app_table:
        result += len(self.app_table.export(0))
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImage.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Plain, unsigned binary data for the image.</p>
<p>It consists of:
- application image
- optionally trust zone data
Please mind the result does not contain: certification block, HMAC, keystore and signature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; bytes:
    &#34;&#34;&#34;Plain, unsigned binary data for the image.

    It consists of:
    - application image
    - optionally trust zone data
    Please mind the result does not contain: certification block, HMAC, keystore and signature
    &#34;&#34;&#34;
    # binary image
    data = self.app
    if self.app_table:
        data += self.app_table.export(len(data))
    # trust zone data
    data += self.trust_zone.export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImage.total_len"><code class="name">var <span class="ident">total_len</span> : int</code></dt>
<dd>
<div class="desc"><p>Total length of the image.</p>
<p>It is sum of:
- image length + length of trust zone data
- HMAC length
- KeyStore length
- certificate length (+ for encrypted images also encrypted header and CRT init vector)
- signature length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total_len(self) -&gt; int:
    &#34;&#34;&#34;Total length of the image.

    It is sum of:
    - image length + length of trust zone data
    - HMAC length
    - KeyStore length
    - certificate length (+ for encrypted images also encrypted header and CRT init vector)
    - signature length
    &#34;&#34;&#34;
    plain_data = self.data
    certificate_len = len(self._certificate(plain_data))
    hmac_data_len = len(self._hmac(self.data))
    key_store_len = len(self.key_store.export()) if self.key_store else 0
    return len(plain_data) + hmac_data_len + key_store_len + certificate_len + self.signature_len</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.MasterBootImage.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Master boot image (binary).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Master boot image (binary).&#34;&#34;&#34;
    data = self._update_ivt(self.data)

    # signed or encrypted
    if MasterBootImageType.is_signed(self.image_type):
        assert self._priv_key_pem_data
        cb = self.cert_block
        assert (cb is not None) and cb.verify_private_key(self._priv_key_pem_data)
        # encrypt
        encr_data = self._encrypt(data)
        encr_data = (self._update_ivt(encr_data[:self.HMAC_OFFSET]) +  # header
                     encr_data[self.HMAC_OFFSET:self.app_len] +  # encrypted image
                     self._certificate(encr_data) +  # certificate + encoded image header + CTR init vector
                     encr_data[self.app_len:])  # TZ encoded data
        encr_data += crypto_backend().rsa_sign(self._priv_key_pem_data, encr_data)  # signature
        # hmac + key store
        if MasterBootImageType.has_hmac(self.image_type):
            hmac_keystore = self._hmac(encr_data[:self.HMAC_OFFSET])
            if self.key_store:
                hmac_keystore += self.key_store.export()
            encr_data = encr_data[:self.HMAC_OFFSET] + hmac_keystore + encr_data[self.HMAC_OFFSET:]
        return bytes(encr_data)

    return bytes(data)</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImage.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text description of the instance.&#34;&#34;&#34;
    msg = &#34;Master Boot Image&#34;
    msg += &#34;Image type       : {}\n&#34;.format(MasterBootImageType.desc(self.image_type))
    msg += &#34;Img load addr    : {}\n&#34;.format(hex(self.load_addr))
    msg += &#34;Image length     : {}\n&#34;.format(len(self.data))
    msg += &#34;HW user mode keys: {}\n&#34;.format(&#34;enabled&#34; if self.enable_hw_user_mode_keys else &#34;disabled&#34;)
    msg += &#34;TrustZone        : {}\n&#34;.format(TrustZoneType.desc(self.trust_zone.type))
    if self.cert_block:
        msg += &#34;[Certificate Block]\n&#34;
        msg += self.cert_block.info()
    if self._priv_key_pem_data:
        msg += &#34;Private Key  : {Yes}\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.MasterBootImageType"><code class="flex name class">
<span>class <span class="ident">MasterBootImageType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of various types of MBIs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MasterBootImageType(Enum):
    &#34;&#34;&#34;Enumeration of various types of MBIs.&#34;&#34;&#34;
    PLAIN_IMAGE = (0x00, &#34;Plain Image (either XIP or Load-to-RAM)&#34;)
    SIGNED_RAM_IMAGE = (0x01, &#34;Plain Signed Load-to-RAM Image&#34;)
    CRC_RAM_IMAGE = (0x02, &#34;Plain CRC Load-to-RAM Image&#34;)
    ENCRYPTED_RAM_IMAGE = (0x03, &#34;Encrypted Load-to-RAM Image&#34;)
    SIGNED_XIP_IMAGE = (0x04, &#34;Plain Signed XIP Image&#34;)
    CRC_XIP_IMAGE = (0x05, &#34;Plain CRC XIP Image&#34;)

    @staticmethod
    def is_xip(image_type: int) -&gt; bool:
        &#34;&#34;&#34;True is the image type is executed in place (XIP).&#34;&#34;&#34;
        return image_type in [MasterBootImageType.PLAIN_IMAGE,
                              MasterBootImageType.SIGNED_XIP_IMAGE,
                              MasterBootImageType.CRC_XIP_IMAGE]

    @staticmethod
    def is_copied_to_ram(image_type: int) -&gt; bool:
        &#34;&#34;&#34;True is the image type is copied and executed in RAM.&#34;&#34;&#34;
        return image_type in [MasterBootImageType.CRC_RAM_IMAGE,
                              MasterBootImageType.SIGNED_RAM_IMAGE,
                              MasterBootImageType.ENCRYPTED_RAM_IMAGE]

    @staticmethod
    def has_crc(image_type: int) -&gt; bool:
        &#34;&#34;&#34;True is the image type contains CRC; False otherwise.&#34;&#34;&#34;
        return image_type in [MasterBootImageType.CRC_XIP_IMAGE, MasterBootImageType.CRC_RAM_IMAGE]

    @staticmethod
    def is_signed(image_type: int) -&gt; bool:
        &#34;&#34;&#34;True is the image type is signed; False otherwise.&#34;&#34;&#34;
        return image_type in [MasterBootImageType.SIGNED_XIP_IMAGE,
                              MasterBootImageType.SIGNED_RAM_IMAGE,
                              MasterBootImageType.ENCRYPTED_RAM_IMAGE]

    @staticmethod
    def is_encrypted(image_type: int) -&gt; bool:
        &#34;&#34;&#34;True is the image type is encrypted; False otherwise.&#34;&#34;&#34;
        return image_type == MasterBootImageType.ENCRYPTED_RAM_IMAGE

    @staticmethod
    def has_hmac(image_type: int) -&gt; bool:
        &#34;&#34;&#34;Whether the image contains HMAC.&#34;&#34;&#34;
        return MasterBootImageType.is_signed(image_type) and MasterBootImageType.is_copied_to_ram(image_type)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.MasterBootImageType.CRC_RAM_IMAGE"><code class="name">var <span class="ident">CRC_RAM_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImageType.CRC_XIP_IMAGE"><code class="name">var <span class="ident">CRC_XIP_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImageType.ENCRYPTED_RAM_IMAGE"><code class="name">var <span class="ident">ENCRYPTED_RAM_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImageType.PLAIN_IMAGE"><code class="name">var <span class="ident">PLAIN_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImageType.SIGNED_RAM_IMAGE"><code class="name">var <span class="ident">SIGNED_RAM_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.MasterBootImageType.SIGNED_XIP_IMAGE"><code class="name">var <span class="ident">SIGNED_XIP_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.MasterBootImageType.has_crc"><code class="name flex">
<span>def <span class="ident">has_crc</span></span>(<span>image_type: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>True is the image type contains CRC; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def has_crc(image_type: int) -&gt; bool:
    &#34;&#34;&#34;True is the image type contains CRC; False otherwise.&#34;&#34;&#34;
    return image_type in [MasterBootImageType.CRC_XIP_IMAGE, MasterBootImageType.CRC_RAM_IMAGE]</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImageType.has_hmac"><code class="name flex">
<span>def <span class="ident">has_hmac</span></span>(<span>image_type: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the image contains HMAC.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def has_hmac(image_type: int) -&gt; bool:
    &#34;&#34;&#34;Whether the image contains HMAC.&#34;&#34;&#34;
    return MasterBootImageType.is_signed(image_type) and MasterBootImageType.is_copied_to_ram(image_type)</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImageType.is_copied_to_ram"><code class="name flex">
<span>def <span class="ident">is_copied_to_ram</span></span>(<span>image_type: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>True is the image type is copied and executed in RAM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_copied_to_ram(image_type: int) -&gt; bool:
    &#34;&#34;&#34;True is the image type is copied and executed in RAM.&#34;&#34;&#34;
    return image_type in [MasterBootImageType.CRC_RAM_IMAGE,
                          MasterBootImageType.SIGNED_RAM_IMAGE,
                          MasterBootImageType.ENCRYPTED_RAM_IMAGE]</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImageType.is_encrypted"><code class="name flex">
<span>def <span class="ident">is_encrypted</span></span>(<span>image_type: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>True is the image type is encrypted; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_encrypted(image_type: int) -&gt; bool:
    &#34;&#34;&#34;True is the image type is encrypted; False otherwise.&#34;&#34;&#34;
    return image_type == MasterBootImageType.ENCRYPTED_RAM_IMAGE</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImageType.is_signed"><code class="name flex">
<span>def <span class="ident">is_signed</span></span>(<span>image_type: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>True is the image type is signed; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_signed(image_type: int) -&gt; bool:
    &#34;&#34;&#34;True is the image type is signed; False otherwise.&#34;&#34;&#34;
    return image_type in [MasterBootImageType.SIGNED_XIP_IMAGE,
                          MasterBootImageType.SIGNED_RAM_IMAGE,
                          MasterBootImageType.ENCRYPTED_RAM_IMAGE]</code></pre>
</details>
</dd>
<dt id="spsdk.image.MasterBootImageType.is_xip"><code class="name flex">
<span>def <span class="ident">is_xip</span></span>(<span>image_type: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>True is the image type is executed in place (XIP).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_xip(image_type: int) -&gt; bool:
    &#34;&#34;&#34;True is the image type is executed in place (XIP).&#34;&#34;&#34;
    return image_type in [MasterBootImageType.PLAIN_IMAGE,
                          MasterBootImageType.SIGNED_XIP_IMAGE,
                          MasterBootImageType.CRC_XIP_IMAGE]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.MultipleImageEntry"><code class="flex name class">
<span>class <span class="ident">MultipleImageEntry</span></span>
<span>(</span><span>img: bytes, dst_addr: int, flags: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>The class represents an entry in relocation table.</p>
<p>It also contains a corresponding image (binary)</p>
<p>Constructor.</p>
<p>:param img: binary image data
:param dst_addr: destination address
:param flags: see LTI constants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleImageEntry:
    &#34;&#34;&#34;The class represents an entry in relocation table.

    It also contains a corresponding image (binary)
    &#34;&#34;&#34;
    # flag to simply copy load segment into target memory
    LTI_LOAD = (1 &lt;&lt; 0)

    def __init__(self, img: bytes, dst_addr: int, flags: int = LTI_LOAD):
        &#34;&#34;&#34;Constructor.

        :param img: binary image data
        :param dst_addr: destination address
        :param flags: see LTI constants
        &#34;&#34;&#34;
        assert 0 &lt;= dst_addr &lt;= 0xFFFFFFFF
        assert flags == self.LTI_LOAD  # for now, other section types (INIT) are not supported
        self._img = img
        self._src_addr = 0
        self._dst_addr = dst_addr
        self._flags = flags

    @property
    def image(self) -&gt; bytes:
        &#34;&#34;&#34;Binary image data.&#34;&#34;&#34;
        return self._img

    @property
    def src_addr(self) -&gt; int:
        &#34;&#34;&#34;Source address; this value is calculated automatically when building the image.&#34;&#34;&#34;
        return self._src_addr

    @src_addr.setter
    def src_addr(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: to set
        &#34;&#34;&#34;
        self._src_addr = value

    @property
    def dst_addr(self) -&gt; int:
        &#34;&#34;&#34;Destination address.&#34;&#34;&#34;
        return self._dst_addr

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the image (not aligned).&#34;&#34;&#34;
        return len(self.image)

    @property
    def flags(self) -&gt; int:
        &#34;&#34;&#34;Flags, currently not used.&#34;&#34;&#34;
        return self._flags

    @property
    def is_load(self) -&gt; bool:
        &#34;&#34;&#34;True if entry represents LOAD section.&#34;&#34;&#34;
        return (self.flags &amp; self.LTI_LOAD) != 0

    def export_entry(self) -&gt; bytes:
        &#34;&#34;&#34;Export relocation table entry in binary form.&#34;&#34;&#34;
        result = bytes()
        result += struct.pack(&#34;&lt;I&#34;, self.src_addr)  # source address
        result += struct.pack(&#34;&lt;I&#34;, self.dst_addr)  # dest address
        result += struct.pack(&#34;&lt;I&#34;, self.size)  # length
        result += struct.pack(&#34;&lt;I&#34;, self.flags)  # flags
        return result

    def export_image(self) -&gt; bytes:
        &#34;&#34;&#34;Binary image aligned to the 4-bytes boundary.&#34;&#34;&#34;
        return misc.align_block(self.image, 4)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.MultipleImageEntry.LTI_LOAD"><code class="name">var <span class="ident">LTI_LOAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.MultipleImageEntry.dst_addr"><code class="name">var <span class="ident">dst_addr</span> : int</code></dt>
<dd>
<div class="desc"><p>Destination address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dst_addr(self) -&gt; int:
    &#34;&#34;&#34;Destination address.&#34;&#34;&#34;
    return self._dst_addr</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageEntry.flags"><code class="name">var <span class="ident">flags</span> : int</code></dt>
<dd>
<div class="desc"><p>Flags, currently not used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self) -&gt; int:
    &#34;&#34;&#34;Flags, currently not used.&#34;&#34;&#34;
    return self._flags</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageEntry.image"><code class="name">var <span class="ident">image</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Binary image data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image(self) -&gt; bytes:
    &#34;&#34;&#34;Binary image data.&#34;&#34;&#34;
    return self._img</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageEntry.is_load"><code class="name">var <span class="ident">is_load</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if entry represents LOAD section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_load(self) -&gt; bool:
    &#34;&#34;&#34;True if entry represents LOAD section.&#34;&#34;&#34;
    return (self.flags &amp; self.LTI_LOAD) != 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageEntry.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the image (not aligned).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the image (not aligned).&#34;&#34;&#34;
    return len(self.image)</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageEntry.src_addr"><code class="name">var <span class="ident">src_addr</span> : int</code></dt>
<dd>
<div class="desc"><p>Source address; this value is calculated automatically when building the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def src_addr(self) -&gt; int:
    &#34;&#34;&#34;Source address; this value is calculated automatically when building the image.&#34;&#34;&#34;
    return self._src_addr</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.MultipleImageEntry.export_entry"><code class="name flex">
<span>def <span class="ident">export_entry</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export relocation table entry in binary form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_entry(self) -&gt; bytes:
    &#34;&#34;&#34;Export relocation table entry in binary form.&#34;&#34;&#34;
    result = bytes()
    result += struct.pack(&#34;&lt;I&#34;, self.src_addr)  # source address
    result += struct.pack(&#34;&lt;I&#34;, self.dst_addr)  # dest address
    result += struct.pack(&#34;&lt;I&#34;, self.size)  # length
    result += struct.pack(&#34;&lt;I&#34;, self.flags)  # flags
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageEntry.export_image"><code class="name flex">
<span>def <span class="ident">export_image</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Binary image aligned to the 4-bytes boundary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_image(self) -&gt; bytes:
    &#34;&#34;&#34;Binary image aligned to the 4-bytes boundary.&#34;&#34;&#34;
    return misc.align_block(self.image, 4)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.MultipleImageTable"><code class="flex name class">
<span>class <span class="ident">MultipleImageTable</span></span>
</code></dt>
<dd>
<div class="desc"><p>The class allows to merge several images into single image and add relocation table.</p>
<p>It can be used for multicore images (one image for each core)
or trustzone images (merging secure and non-secure image)</p>
<p>Initialize the Multiple Image Table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleImageTable:
    &#34;&#34;&#34;The class allows to merge several images into single image and add relocation table.

    It can be used for multicore images (one image for each core)
    or trustzone images (merging secure and non-secure image)
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize the Multiple Image Table.&#34;&#34;&#34;
        self._entries: List[MultipleImageEntry] = list()

    @property
    def header_version(self) -&gt; int:
        &#34;&#34;&#34;Format version of the structure for the header.&#34;&#34;&#34;
        return 0

    @property
    def entries(self) -&gt; Sequence[MultipleImageEntry]:
        &#34;&#34;&#34;List of all entries.&#34;&#34;&#34;
        return self._entries

    def add_entry(self, entry: MultipleImageEntry) -&gt; None:
        &#34;&#34;&#34;Add entry into relocation table.

        :param entry: to add
        &#34;&#34;&#34;
        self._entries.append(entry)

    def reloc_table(self, start_addr: int) -&gt; bytes:
        &#34;&#34;&#34;Relocate table.

        :param start_addr: start address of the relocation table
        :return: export relocation table in binary form
        &#34;&#34;&#34;
        result = bytes()
        # export relocation entries table
        for entry in self.entries:
            result += entry.export_entry()
        # export relocation table header
        result += struct.pack(&#34;&lt;I&#34;, 0x4C54424C)  # header marker
        result += struct.pack(&#34;&lt;I&#34;, self.header_version)  # version
        result += struct.pack(&#34;&lt;I&#34;, len(self._entries))  # number of entries
        result += struct.pack(&#34;&lt;I&#34;, start_addr)  # pointer to entries
        return result

    def export(self, start_addr: int) -&gt; bytes:
        &#34;&#34;&#34;Export.

        :param start_addr: start address where the images are exported;
                        the value matches source address for the first image
        :return: images with relocation table
        &#34;&#34;&#34;
        assert self._entries, &#39;There must be at least one entry for export&#39;
        src_addr = start_addr
        result = bytes()
        for entry in self.entries:
            if entry.is_load:
                entry.src_addr = src_addr
                entry_img = entry.export_image()
                result += entry_img
                src_addr += len(entry_img)
        result += self.reloc_table(start_addr + len(result))
        # TODO result += struct.pack(&#34;&lt;I&#34;, src_addr)  # pointer to relocation table
        return result</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.MultipleImageTable.entries"><code class="name">var <span class="ident">entries</span> : Sequence[<a title="spsdk.image.mbimg.MultipleImageEntry" href="mbimg.html#spsdk.image.mbimg.MultipleImageEntry">MultipleImageEntry</a>]</code></dt>
<dd>
<div class="desc"><p>List of all entries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def entries(self) -&gt; Sequence[MultipleImageEntry]:
    &#34;&#34;&#34;List of all entries.&#34;&#34;&#34;
    return self._entries</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageTable.header_version"><code class="name">var <span class="ident">header_version</span> : int</code></dt>
<dd>
<div class="desc"><p>Format version of the structure for the header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header_version(self) -&gt; int:
    &#34;&#34;&#34;Format version of the structure for the header.&#34;&#34;&#34;
    return 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.MultipleImageTable.add_entry"><code class="name flex">
<span>def <span class="ident">add_entry</span></span>(<span>self, entry: <a title="spsdk.image.mbimg.MultipleImageEntry" href="mbimg.html#spsdk.image.mbimg.MultipleImageEntry">MultipleImageEntry</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add entry into relocation table.</p>
<p>:param entry: to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entry(self, entry: MultipleImageEntry) -&gt; None:
    &#34;&#34;&#34;Add entry into relocation table.

    :param entry: to add
    &#34;&#34;&#34;
    self._entries.append(entry)</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageTable.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, start_addr: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p>
<p>:param start_addr: start address where the images are exported;
the value matches source address for the first image
:return: images with relocation table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, start_addr: int) -&gt; bytes:
    &#34;&#34;&#34;Export.

    :param start_addr: start address where the images are exported;
                    the value matches source address for the first image
    :return: images with relocation table
    &#34;&#34;&#34;
    assert self._entries, &#39;There must be at least one entry for export&#39;
    src_addr = start_addr
    result = bytes()
    for entry in self.entries:
        if entry.is_load:
            entry.src_addr = src_addr
            entry_img = entry.export_image()
            result += entry_img
            src_addr += len(entry_img)
    result += self.reloc_table(start_addr + len(result))
    # TODO result += struct.pack(&#34;&lt;I&#34;, src_addr)  # pointer to relocation table
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.MultipleImageTable.reloc_table"><code class="name flex">
<span>def <span class="ident">reloc_table</span></span>(<span>self, start_addr: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Relocate table.</p>
<p>:param start_addr: start address of the relocation table
:return: export relocation table in binary form</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reloc_table(self, start_addr: int) -&gt; bytes:
    &#34;&#34;&#34;Relocate table.

    :param start_addr: start address of the relocation table
    :return: export relocation table in binary form
    &#34;&#34;&#34;
    result = bytes()
    # export relocation entries table
    for entry in self.entries:
        result += entry.export_entry()
    # export relocation table header
    result += struct.pack(&#34;&lt;I&#34;, 0x4C54424C)  # header marker
    result += struct.pack(&#34;&lt;I&#34;, self.header_version)  # version
    result += struct.pack(&#34;&lt;I&#34;, len(self._entries))  # number of entries
    result += struct.pack(&#34;&lt;I&#34;, start_addr)  # pointer to entries
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.PaddingFCB"><code class="flex name class">
<span>class <span class="ident">PaddingFCB</span></span>
<span>(</span><span>size: int, padding_value: int = 0, enabled: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Padding FCB.</p>
<p>Constructor.</p>
<p>:param size: of the exported padding
:param padding_value: byte value used as padding; 0 by default
:param enabled: whether enabled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PaddingFCB(AbstractFCB):
    &#34;&#34;&#34;Padding FCB.&#34;&#34;&#34;

    def __init__(self, size: int, padding_value: int = 0, enabled: bool = True):
        &#34;&#34;&#34;Constructor.

        :param size: of the exported padding
        :param padding_value: byte value used as padding; 0 by default
        :param enabled: whether enabled
        &#34;&#34;&#34;
        super().__init__()
        assert 0 &lt;= size &lt;= 0xFFFF
        assert 0 &lt;= padding_value &lt;= 0xFF
        self._size = size
        self._padding_byte = bytes([padding_value])
        self.enabled = enabled

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return size of the exported data in bytes.&#34;&#34;&#34;
        return self._size if self.enabled else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        return f&#39;PaddingFCB: {self.size} bytes&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: instance allowing to debug output format
        :return: binary representation
        &#34;&#34;&#34;
        if not self.enabled:
            return b&#39;&#39;

        result = self._padding_byte * self._size + self._padding_export()
        dbg_info.append_section(f&#39;FCB-padding: {len(result)} bytes&#39;)
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.AbstractFCB" href="segments.html#spsdk.image.segments.AbstractFCB">AbstractFCB</a></li>
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.PaddingFCB.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return size of the exported data in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Return size of the exported data in bytes.&#34;&#34;&#34;
    return self._size if self.enabled else 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.PaddingFCB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary form (serialization).</p>
<p>:param dbg_info: instance allowing to debug output format
:return: binary representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export to binary form (serialization).

    :param dbg_info: instance allowing to debug output format
    :return: binary representation
    &#34;&#34;&#34;
    if not self.enabled:
        return b&#39;&#39;

    result = self._padding_byte * self._size + self._padding_export()
    dbg_info.append_section(f&#39;FCB-padding: {len(result)} bytes&#39;)
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.PaddingFCB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
    return f&#39;PaddingFCB: {self.size} bytes&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.AbstractFCB" href="segments.html#spsdk.image.segments.AbstractFCB">AbstractFCB</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.AbstractFCB.enabled" href="segments.html#spsdk.image.segments.AbstractFCB.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.parse" href="segments.html#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.space" href="segments.html#spsdk.image.segments.AbstractFCB.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SecretKeyBlob"><code class="flex name class">
<span>class <span class="ident">SecretKeyBlob</span></span>
<span>(</span><span>mode: int, algorithm: int, flag: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Secret Key Blob.</p>
<p>Initialize Secret Key Blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SecretKeyBlob:
    &#34;&#34;&#34;Secret Key Blob.&#34;&#34;&#34;

    @property
    def blob(self) -&gt; bytes:
        &#34;&#34;&#34;Data of Secret Key Blob.&#34;&#34;&#34;
        return self._data

    @blob.setter
    def blob(self, value: Union[bytes, bytearray]) -&gt; None:
        assert isinstance(value, (bytes, bytearray))
        self._data = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Secret Key Blob.&#34;&#34;&#34;
        return len(self._data) + 4

    def __init__(self, mode: int, algorithm: int, flag: int) -&gt; None:
        &#34;&#34;&#34;Initialize Secret Key Blob.&#34;&#34;&#34;
        self.mode = mode
        self.algorithm = algorithm
        self.flag = flag
        self._data = bytearray()

    def __repr__(self) -&gt; str:
        return &#34;SecKeyBlob &lt;Mode: {}, Algo: {}, Flag: 0x{:02X}, Size: {}&gt;&#34;.format(self.mode, self.algorithm,
                                                                                  self.flag, len(self._data))

    def __eq__(self, obj: Any) -&gt; bool:
        return isinstance(obj, SecretKeyBlob) and vars(obj) == vars(self)

    def __ne__(self, obj: Any) -&gt; bool:
        return not self.__eq__(obj)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the Secret Key Blob.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;SecKeyBlob\n&#34;
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;Mode:      {}\n&#34;.format(self.mode)
        msg += &#34;Algorithm: {}\n&#34;.format(self.algorithm)
        msg += &#34;Flag:      0x{:02X}\n&#34;.format(self.flag)
        msg += &#34;Size:      {} Bytes\n&#34;.format(len(self._data))
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export of Secret Key Blob.&#34;&#34;&#34;
        raw_data = pack(&#34;4B&#34;, self.mode, self.algorithm, self.size, self.flag)
        raw_data += bytes(self._data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SecretKeyBlob&#39;:
        &#34;&#34;&#34;Parse of Secret Key Blob.&#34;&#34;&#34;
        (mode, alg, size, flg) = unpack_from(&#34;4B&#34;, data, offset)
        offset += 4
        obj = cls(mode, alg, flg)
        obj.blob = data[offset: offset + size]
        return obj</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SecretKeyBlob.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.secret.SecretKeyBlob" href="secret.html#spsdk.image.secret.SecretKeyBlob">SecretKeyBlob</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse of Secret Key Blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SecretKeyBlob&#39;:
    &#34;&#34;&#34;Parse of Secret Key Blob.&#34;&#34;&#34;
    (mode, alg, size, flg) = unpack_from(&#34;4B&#34;, data, offset)
    offset += 4
    obj = cls(mode, alg, flg)
    obj.blob = data[offset: offset + size]
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SecretKeyBlob.blob"><code class="name">var <span class="ident">blob</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Data of Secret Key Blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def blob(self) -&gt; bytes:
    &#34;&#34;&#34;Data of Secret Key Blob.&#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SecretKeyBlob.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of Secret Key Blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of Secret Key Blob.&#34;&#34;&#34;
    return len(self._data) + 4</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SecretKeyBlob.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export of Secret Key Blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export of Secret Key Blob.&#34;&#34;&#34;
    raw_data = pack(&#34;4B&#34;, self.mode, self.algorithm, self.size, self.flag)
    raw_data += bytes(self._data)
    return raw_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SecretKeyBlob.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the Secret Key Blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the Secret Key Blob.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;SecKeyBlob\n&#34;
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;Mode:      {}\n&#34;.format(self.mode)
    msg += &#34;Algorithm: {}\n&#34;.format(self.algorithm)
    msg += &#34;Flag:      0x{:02X}\n&#34;.format(self.flag)
    msg += &#34;Size:      {} Bytes\n&#34;.format(len(self._data))
    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.SegAPP"><code class="flex name class">
<span>class <span class="ident">SegAPP</span></span>
<span>(</span><span>data: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>APP segment.</p>
<p>Initialize APP segment.</p>
<p>:param data: application binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegAPP(BaseSegment):
    &#34;&#34;&#34;APP segment.&#34;&#34;&#34;

    def __init__(self, data: Optional[bytes] = None) -&gt; None:
        &#34;&#34;&#34;Initialize APP segment.

        :param data: application binary data
        &#34;&#34;&#34;
        super().__init__()
        self._data = data

    @property
    def data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
        return self._data

    @data.setter
    def data(self, value: Union[bytearray, bytes]) -&gt; None:
        &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
        assert isinstance(value, (bytes, bytearray))
        self._data = bytes(value)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of APP segment.&#34;&#34;&#34;
        return 0 if (self._data is None) else len(self._data)

    def __repr__(self) -&gt; str:
        return &#34;APP &lt;LEN: {} Bytes&gt;&#34;.format(self.size)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegAPP.&#34;&#34;&#34;
        msg = &#34; Size: {0:d} Bytes\n&#34;.format(self.size)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self._data:
            data += bytes(self._data)
        data += self._padding_export()
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegAPP.data"><code class="name">var <span class="ident">data</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Application binary data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegAPP.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of APP segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of APP segment.&#34;&#34;&#34;
    return 0 if (self._data is None) else len(self._data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegAPP.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = b&#39;&#39;
    if self._data:
        data += bytes(self._data)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegAPP.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegAPP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegAPP.&#34;&#34;&#34;
    msg = &#34; Size: {0:d} Bytes\n&#34;.format(self.size)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.parse" href="segments.html#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="segments.html#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SegBDT"><code class="flex name class">
<span>class <span class="ident">SegBDT</span></span>
<span>(</span><span>app_start: int = 0, app_length: int = 0, plugin: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Data Table segment.</p>
<p>Initialize BDT segment.</p>
<p>:param app_start: first address of the application
:param app_length: length of the application
:param plugin: 0 .. 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBDT(BaseSegment):
    &#34;&#34;&#34;Boot Data Table segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;3L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def plugin(self) -&gt; int:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plugin

    @plugin.setter
    def plugin(self, value: int) -&gt; None:
        assert value in (0, 1, 2), &#34;Plugin value must be 0 .. 2&#34;
        self._plugin = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the exported binary data (without padding).&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, app_start: int = 0, app_length: int = 0, plugin: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize BDT segment.

        :param app_start: first address of the application
        :param app_length: length of the application
        :param plugin: 0 .. 2
        &#34;&#34;&#34;
        super().__init__()
        self.app_start = app_start
        self.app_length = app_length
        self.plugin = plugin

    def __repr__(self) -&gt; str:
        return &#34;BDT &lt;ADDR: 0x{:X}, LEN: {} Bytes, Plugin: {}&gt;&#34;.format(self.app_start, self.app_length, self.plugin)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDT.&#34;&#34;&#34;
        msg = f&#34; Start      :  0x{self.app_start:08X}\n&#34;
        msg += f&#34; App Length : {size_fmt(self.app_length)} ({self.app_length} Bytes)\n&#34;
        msg += f&#34; Plugin     : {&#39;YES&#39; if self.plugin else &#39;NO&#39;}\n&#34;
        msg += &#34;\n&#34;

        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT, self.app_start, self.app_length, self.plugin)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDT&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDT segment
        :return: SegBDT object
        &#34;&#34;&#34;
        return cls(*unpack_from(cls.FORMAT, data))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.SegBDT.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.SegBDT.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SegBDT.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegBDT" href="segments.html#spsdk.image.segments.SegBDT">SegBDT</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of BDT segment
:return: SegBDT object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegBDT&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of BDT segment
    :return: SegBDT object
    &#34;&#34;&#34;
    return cls(*unpack_from(cls.FORMAT, data))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegBDT.plugin"><code class="name">var <span class="ident">plugin</span> : int</code></dt>
<dd>
<div class="desc"><p>Plugin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; int:
    &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
    return self._plugin</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegBDT.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the exported binary data (without padding).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the exported binary data (without padding).&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegBDT.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT, self.app_start, self.app_length, self.plugin)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegBDT.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegBDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegBDT.&#34;&#34;&#34;
    msg = f&#34; Start      :  0x{self.app_start:08X}\n&#34;
    msg += f&#34; App Length : {size_fmt(self.app_length)} ({self.app_length} Bytes)\n&#34;
    msg += f&#34; Plugin     : {&#39;YES&#39; if self.plugin else &#39;NO&#39;}\n&#34;
    msg += &#34;\n&#34;

    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="segments.html#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SegCSF"><code class="flex name class">
<span>class <span class="ident">SegCSF</span></span>
<span>(</span><span>version: int = 64, enabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Sequence File (CSF), signature block for Secure Boot.</p>
<p>A script of commands used to guide image authentication and device configuration operations.</p>
<p>Initialize CSF segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegCSF(BaseSegment):
    &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.

    A script of commands used to guide image authentication and device configuration operations.
    &#34;&#34;&#34;

    # list of supported CSF commands
    _COMMANDS: Tuple[CmdTag, ...] = (
        CmdTag.WRT_DAT, CmdTag.CHK_DAT, CmdTag.NOP, CmdTag.SET, CmdTag.INIT, CmdTag.UNLK, CmdTag.INS_KEY, CmdTag.AUT_DAT
    )

    @classmethod
    def _is_csf_command(cls, cmd: object) -&gt; bool:
        &#34;&#34;&#34;Test whether given class is instance of supported CSF command.

        :param cmd: instance to be tested
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return isinstance(cmd, CmdBase) and (cmd.tag in cls._COMMANDS)

    def __init__(self, version: int = 0x40, enabled: bool = False):
        &#34;&#34;&#34;Initialize CSF segment.&#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.CSF, version)
        self.enabled = enabled
        self._commands: List[CmdBase] = []
        # additional command data: keys and certificates; these data are stored after the commands
        #   - key is an offset of the data section in segment
        #   - value is an instance of the data section
        self._cmd_data: Dict[int, BaseClass] = dict()
        # this allows to export segment, that was parsered, but certificate and private keys are not available
        self.no_signature_updates = False

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of CSF segment.&#34;&#34;&#34;
        return self._header.param

    @property
    def commands(self) -&gt; List[CmdBase]:
        &#34;&#34;&#34;List of CSF commands in the segment.&#34;&#34;&#34;
        return self._commands

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary representation of the segment; 0 is not enabled.&#34;&#34;&#34;
        if not self.enabled:
            return 0

        result = self._header.length
        for offset, cmd_data in self._cmd_data.items():
            result = max(result, offset + cmd_data.size)
        return result

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary representation of the segment including padding; 0 is not enabled.&#34;&#34;&#34;
        return self.size + self.padding_len if self.enabled else 0

    @property
    def macs(self) -&gt; Iterator[MAC]:
        &#34;&#34;&#34;Iterator of all MAC sections.&#34;&#34;&#34;
        # noinspection PyTypeChecker
        return filter(lambda m: isinstance(m, MAC), self._cmd_data.values())  # type: ignore

    def __repr__(self) -&gt; str:
        return &#34;CSF &lt;Commands: {}&gt;&#34;.format(len(self.commands))

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBase:
        return self.commands[key]

    def __setitem__(self, key: int, value: CmdBase) -&gt; None:
        assert SegCSF._is_csf_command(value)
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator[CmdBase]:
        return self.commands.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegCSF.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += f&#34;CSF Version        : {hex(self.version)}\n&#34;
        msg += f&#34;Number of commands : {len(self.commands)}\n&#34;
        for cmd in self.commands:
            msg += cmd.info()
            msg += &#34;\n&#34;

        # certificates and signatures
        msg += &#34;[CMD-DATA]\n&#34;
        for offset, cmd_data in self._cmd_data.items():
            msg += f&#34;- OFFSET : {offset}\n&#34;
            msg += cmd_data.info()

        return msg

    def append_command(self, cmd: CmdBase) -&gt; None:
        &#34;&#34;&#34;Append CSF command to the segment.

        :param cmd: to be added
        &#34;&#34;&#34;
        assert SegCSF._is_csf_command(cmd)
        self._commands.append(cmd)
        self._header.length += cmd.size
        self.update(False)

    def clear_commands(self) -&gt; None:
        &#34;&#34;&#34;Removes= all commands.&#34;&#34;&#34;
        self._commands.clear()
        self._header.length = self._header.size
        self.update(True)

    def update(self, reset_cmddata_offsets: bool) -&gt; None:
        &#34;&#34;&#34;Update the offsets for the export.

        :param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
                                    False to avoid any reset;
                                    Note: reset should be done during parsing process as the data are incomplete

        &#34;&#34;&#34;
        cur_ofs = self._header.length
        new_cmd_data: Dict[int, BaseClass] = dict()
        for cmd in filter(lambda c: c.needs_cmd_data_reference, self.commands):
            key = cmd.cmd_data_reference
            if key is not None:
                cmd.cmd_data_offset = cur_ofs
                new_cmd_data[cur_ofs] = key
                cur_ofs += align(key.size, 4)
            elif reset_cmddata_offsets and (cmd.cmd_data_offset &gt; 0):
                cmd.cmd_data_offset = 0

        self._cmd_data = new_cmd_data

    def _export_base(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export base part of the CSF section (header and commands) without keys and signatures.

        :param dbg_info: optional instance allowing to produce deung information about exported data
        :return: exported binary data
        &#34;&#34;&#34;
        self.update(True)
        data = self._header.export()
        dbg_info.append_binary_section(&#39;header&#39;, data)
        for command in self.commands:
            dbg_info.append_section(f&#39;COMMAND: {CmdTag.desc(command.tag)}&#39;)
            cmd_data = command.export(dbg_info)
            data += cmd_data
        return data

    def update_signatures(self, zulu: datetime, data: bytes, base_data_addr: int) -&gt; None:
        &#34;&#34;&#34;Update signatures in all CmdAuthData commands.

        :param zulu: current UTC time+date
        :param data: currently generated binary data; empty to create &#34;fake&#34; signature to update size of the segment
        :param base_data_addr: base address of the generated data
        &#34;&#34;&#34;
        if self.no_signature_updates:
            return

        for cmd in self.commands:
            if isinstance(cmd, CmdAuthData):
                if len(cmd) &gt; 0:  # any blocks defined? =&gt; sign image data
                    if not cmd.update_signature(zulu, data, base_data_addr):
                        assert len(data) == 0
                else:  # sign CSF section
                    if not cmd.update_signature(zulu, self._export_base()):
                        assert len(data) == 0

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array (serialization).

        :param dbg_info: optional list of strings to produce debug information about exported data
        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self.enabled:
            data = self._export_base(dbg_info)
            dbg_info.append_section(&#39;CSF-DATA: CERTIFICATES and SIGNATURES&#39;)
            cmd_data_by_offset = sorted(self._cmd_data.items(), key=lambda t: str(t[0]).zfill(8))
            for offset, cmd_data in cmd_data_by_offset:
                data = extend_block(data, offset)
                dbg_info.append_section(f&#39;CMD-DATA: {type(cmd_data).__name__}&#39;)
                data += cmd_data.export(dbg_info=dbg_info)
            # padding
            data += self._padding_export()

        return data

    def _parse_cmd_data(self, cmd: CmdBase, data: bytes) -&gt; None:
        &#34;&#34;&#34;Parse data for key installation or key authentication commands (certificate or signature).

        :param cmd: command with reference to a cmd-data
        :param data: binary data array to be parsed
        :return: parsed instance, either Certificate or Signature
        &#34;&#34;&#34;
        assert cmd.needs_cmd_data_reference
        assert self._cmd_data.get(cmd.cmd_data_offset) is None
        result = cmd.parse_cmd_data(data, cmd.cmd_data_offset)
        self._cmd_data[cmd.cmd_data_offset] = result

        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SegCSF&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of CSF segment
        :param offset: to start parsing the data
        :raises CorruptedException: When there is unknown command
        :raises CorruptedException: When command can not be parsed
        :return: SegCSF instance
        &#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.CSF)
        index = header.size
        obj = cls(header.param, True)
        obj.no_signature_updates = True
        while index &lt; header.length:
            try:
                cmd_obj = parse_command(data, offset + index)
                obj.append_command(cmd_obj)
            except ValueError:
                raise CorruptedException(&#34;Failed to parse command at position: &#34; + hex(offset + index))
            index += cmd_obj.size

        for cmd in obj.commands:
            if cmd.needs_cmd_data_reference:
                obj._parse_cmd_data(cmd, data)

        obj.update(True)
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SegCSF.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of CSF segment
:param offset: to start parsing the data
:raises CorruptedException: When there is unknown command
:raises CorruptedException: When command can not be parsed
:return: SegCSF instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SegCSF&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of CSF segment
    :param offset: to start parsing the data
    :raises CorruptedException: When there is unknown command
    :raises CorruptedException: When command can not be parsed
    :return: SegCSF instance
    &#34;&#34;&#34;
    header = Header.parse(data, offset, SegTag.CSF)
    index = header.size
    obj = cls(header.param, True)
    obj.no_signature_updates = True
    while index &lt; header.length:
        try:
            cmd_obj = parse_command(data, offset + index)
            obj.append_command(cmd_obj)
        except ValueError:
            raise CorruptedException(&#34;Failed to parse command at position: &#34; + hex(offset + index))
        index += cmd_obj.size

    for cmd in obj.commands:
        if cmd.needs_cmd_data_reference:
            obj._parse_cmd_data(cmd, data)

    obj.update(True)
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegCSF.commands"><code class="name">var <span class="ident">commands</span> : List[<a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>]</code></dt>
<dd>
<div class="desc"><p>List of CSF commands in the segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; List[CmdBase]:
    &#34;&#34;&#34;List of CSF commands in the segment.&#34;&#34;&#34;
    return self._commands</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.macs"><code class="name">var <span class="ident">macs</span> : Iterator[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>]</code></dt>
<dd>
<div class="desc"><p>Iterator of all MAC sections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def macs(self) -&gt; Iterator[MAC]:
    &#34;&#34;&#34;Iterator of all MAC sections.&#34;&#34;&#34;
    # noinspection PyTypeChecker
    return filter(lambda m: isinstance(m, MAC), self._cmd_data.values())  # type: ignore</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the binary representation of the segment; 0 is not enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the binary representation of the segment; 0 is not enabled.&#34;&#34;&#34;
    if not self.enabled:
        return 0

    result = self._header.length
    for offset, cmd_data in self._cmd_data.items():
        result = max(result, offset + cmd_data.size)
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.space"><code class="name">var <span class="ident">space</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the binary representation of the segment including padding; 0 is not enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def space(self) -&gt; int:
    &#34;&#34;&#34;Size of the binary representation of the segment including padding; 0 is not enabled.&#34;&#34;&#34;
    return self.size + self.padding_len if self.enabled else 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Version of CSF segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of CSF segment.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegCSF.append_command"><code class="name flex">
<span>def <span class="ident">append_command</span></span>(<span>self, cmd: <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append CSF command to the segment.</p>
<p>:param cmd: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_command(self, cmd: CmdBase) -&gt; None:
    &#34;&#34;&#34;Append CSF command to the segment.

    :param cmd: to be added
    &#34;&#34;&#34;
    assert SegCSF._is_csf_command(cmd)
    self._commands.append(cmd)
    self._header.length += cmd.size
    self.update(False)</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.clear_commands"><code class="name flex">
<span>def <span class="ident">clear_commands</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Removes= all commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_commands(self) -&gt; None:
    &#34;&#34;&#34;Removes= all commands.&#34;&#34;&#34;
    self._commands.clear()
    self._header.length = self._header.size
    self.update(True)</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array (serialization).</p>
<p>:param dbg_info: optional list of strings to produce debug information about exported data
:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array (serialization).

    :param dbg_info: optional list of strings to produce debug information about exported data
    :return: bytes
    &#34;&#34;&#34;
    data = b&#39;&#39;
    if self.enabled:
        data = self._export_base(dbg_info)
        dbg_info.append_section(&#39;CSF-DATA: CERTIFICATES and SIGNATURES&#39;)
        cmd_data_by_offset = sorted(self._cmd_data.items(), key=lambda t: str(t[0]).zfill(8))
        for offset, cmd_data in cmd_data_by_offset:
            data = extend_block(data, offset)
            dbg_info.append_section(f&#39;CMD-DATA: {type(cmd_data).__name__}&#39;)
            data += cmd_data.export(dbg_info=dbg_info)
        # padding
        data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegCSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegCSF.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += f&#34;CSF Version        : {hex(self.version)}\n&#34;
    msg += f&#34;Number of commands : {len(self.commands)}\n&#34;
    for cmd in self.commands:
        msg += cmd.info()
        msg += &#34;\n&#34;

    # certificates and signatures
    msg += &#34;[CMD-DATA]\n&#34;
    for offset, cmd_data in self._cmd_data.items():
        msg += f&#34;- OFFSET : {offset}\n&#34;
        msg += cmd_data.info()

    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, reset_cmddata_offsets: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update the offsets for the export.</p>
<p>:param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
False to avoid any reset;
Note: reset should be done during parsing process as the data are incomplete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, reset_cmddata_offsets: bool) -&gt; None:
    &#34;&#34;&#34;Update the offsets for the export.

    :param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
                                False to avoid any reset;
                                Note: reset should be done during parsing process as the data are incomplete

    &#34;&#34;&#34;
    cur_ofs = self._header.length
    new_cmd_data: Dict[int, BaseClass] = dict()
    for cmd in filter(lambda c: c.needs_cmd_data_reference, self.commands):
        key = cmd.cmd_data_reference
        if key is not None:
            cmd.cmd_data_offset = cur_ofs
            new_cmd_data[cur_ofs] = key
            cur_ofs += align(key.size, 4)
        elif reset_cmddata_offsets and (cmd.cmd_data_offset &gt; 0):
            cmd.cmd_data_offset = 0

    self._cmd_data = new_cmd_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegCSF.update_signatures"><code class="name flex">
<span>def <span class="ident">update_signatures</span></span>(<span>self, zulu: datetime.datetime, data: bytes, base_data_addr: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update signatures in all CmdAuthData commands.</p>
<p>:param zulu: current UTC time+date
:param data: currently generated binary data; empty to create "fake" signature to update size of the segment
:param base_data_addr: base address of the generated data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_signatures(self, zulu: datetime, data: bytes, base_data_addr: int) -&gt; None:
    &#34;&#34;&#34;Update signatures in all CmdAuthData commands.

    :param zulu: current UTC time+date
    :param data: currently generated binary data; empty to create &#34;fake&#34; signature to update size of the segment
    :param base_data_addr: base address of the generated data
    &#34;&#34;&#34;
    if self.no_signature_updates:
        return

    for cmd in self.commands:
        if isinstance(cmd, CmdAuthData):
            if len(cmd) &gt; 0:  # any blocks defined? =&gt; sign image data
                if not cmd.update_signature(zulu, data, base_data_addr):
                    assert len(data) == 0
            else:  # sign CSF section
                if not cmd.update_signature(zulu, self._export_base()):
                    assert len(data) == 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SegDCD"><code class="flex name class">
<span>class <span class="ident">SegDCD</span></span>
<span>(</span><span>param: int = 65, enabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Device configuration data (DCD) segment.</p>
<p>IC configuration data, usually is used to configure DDR/SDRAM memory. Typically this is optional</p>
<p>Initialize DCD segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegDCD(BaseSegment):
    &#34;&#34;&#34;Device configuration data (DCD) segment.

    IC configuration data, usually is used to configure DDR/SDRAM memory. Typically this is optional
    &#34;&#34;&#34;

    # list of supported DCD commands
    _COMMANDS: Tuple[CmdTag, ...] = (CmdTag.WRT_DAT, CmdTag.CHK_DAT, CmdTag.NOP, CmdTag.UNLK)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._header

    @property
    def commands(self) -&gt; List[CmdBase]:
        &#34;&#34;&#34;Commands of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._commands

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._header.length if self.enabled else 0

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Add space.&#34;&#34;&#34;
        return self.size + self.padding if self.enabled else 0

    def __init__(self, param: int = 0x41, enabled: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize DCD segment.&#34;&#34;&#34;
        super().__init__()
        self.enabled = enabled
        self._header = Header(SegTag.DCD, param)
        self._header.length = self._header.size
        self._commands: List[CmdBase] = []

    def __repr__(self) -&gt; str:
        return &#34;DCD &lt;Commands: {}&gt;&#34;.format(len(self._commands))

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBase:
        return self._commands[key]

    def __setitem__(self, key: int, value: CmdBase) -&gt; None:
        assert value.tag in self._COMMANDS
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator:
        return self._commands.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegDCD.&#34;&#34;&#34;
        msg = &#34;&#34;
        for cmd in self._commands:
            msg += cmd.info()
            msg += &#34;\n&#34;
        return msg

    def append(self, cmd: CmdBase) -&gt; None:
        &#34;&#34;&#34;Appending of Device configuration data (DCD) segment.&#34;&#34;&#34;
        assert isinstance(cmd, CmdBase) and (cmd.tag in self._COMMANDS)
        self._commands.append(cmd)
        self._header.length += cmd.size

    def pop(self, index: int) -&gt; CmdBase:
        &#34;&#34;&#34;Popping of Device configuration data (DCD) segment.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._commands)
        cmd = self._commands.pop(index)
        self._header.length -= cmd.size
        return cmd

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Device configuration data (DCD) segment.&#34;&#34;&#34;
        self._commands.clear()
        self._header.length = self._header.size

    def export_txt(self, txt_data: str = None) -&gt; str:
        &#34;&#34;&#34;Export txt of Device configuration data (DCD) segment.&#34;&#34;&#34;
        write_ops = (&#39;WriteValue&#39;, &#39;WriteClearBits&#39;, &#39;ClearBitMask&#39;, &#39;SetBitMask&#39;)
        check_ops = (&#39;CheckAllClear&#39;, &#39;CheckAllSet&#39;, &#39;CheckAnyClear&#39;, &#39;CheckAnySet&#39;)
        if txt_data is None:
            txt_data = &#34;&#34;

        for cmd in self._commands:
            if isinstance(cmd, CmdWriteData):
                for (address, value) in cmd:
                    txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}\n&#34;.format(write_ops[cmd.ops], cmd.num_bytes, address,
                                                                           value)
            elif isinstance(cmd, CmdCheckData):
                txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}&#34;.format(check_ops[cmd.ops], cmd.num_bytes, cmd.address,
                                                                     cmd.mask)
                txt_data += &#34; {0:d}\n&#34;.format(cmd.count) if cmd.count else &#34;\n&#34;

            elif isinstance(cmd, CmdUnlock):
                txt_data += &#34;Unlock {0:s}&#34;.format(EnumEngine[cmd.engine]) # type: ignore
                cnt = 1
                for value in cmd:
                    if cnt &gt; 6:
                        txt_data += &#34; \\\n&#34;
                        cnt = 0
                    txt_data += &#34; 0x{0:08X}&#34;.format(value)
                    cnt += 1

                txt_data += &#39;\n&#39;

            else:
                txt_data += &#34;Nop\n&#34;

            # Split with new line every group of commands
            txt_data += &#39;\n&#39;

        return txt_data

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self.enabled:
            data = self._header.export()
            for command in self._commands:
                data += command.export()
            # padding
            data += self._padding_export()

        return data

    @classmethod
    def parse_txt(cls, text: str) -&gt; &#39;SegDCD&#39;:
        &#34;&#34;&#34;Parse segment from text file.

        :param text: The string with DCD commands
        :return: SegDCD object
        &#34;&#34;&#34;
        return SegDcdBuilder().build(text)

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegDCD&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of DCD segment
        :raises CorruptedException: Exception caused by corrupted data
        :return: SegDCD object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.DCD)
        index = header.size
        obj = cls(header.param, True)
        while index &lt; header.length:
            try:
                cmd_obj = parse_command(data, index)
            except ValueError:
                raise CorruptedException(&#34;Unknown command at position: &#34; + hex(index))

            obj.append(cmd_obj)
            index += cmd_obj.size
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SegDCD.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegDCD" href="segments.html#spsdk.image.segments.SegDCD">SegDCD</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of DCD segment
:raises CorruptedException: Exception caused by corrupted data
:return: SegDCD object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegDCD&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of DCD segment
    :raises CorruptedException: Exception caused by corrupted data
    :return: SegDCD object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.DCD)
    index = header.size
    obj = cls(header.param, True)
    while index &lt; header.length:
        try:
            cmd_obj = parse_command(data, index)
        except ValueError:
            raise CorruptedException(&#34;Unknown command at position: &#34; + hex(index))

        obj.append(cmd_obj)
        index += cmd_obj.size
    return obj</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.parse_txt"><code class="name flex">
<span>def <span class="ident">parse_txt</span></span>(<span>text: str) ‑> <a title="spsdk.image.segments.SegDCD" href="segments.html#spsdk.image.segments.SegDCD">SegDCD</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from text file.</p>
<p>:param text: The string with DCD commands
:return: SegDCD object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_txt(cls, text: str) -&gt; &#39;SegDCD&#39;:
    &#34;&#34;&#34;Parse segment from text file.

    :param text: The string with DCD commands
    :return: SegDCD object
    &#34;&#34;&#34;
    return SegDcdBuilder().build(text)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegDCD.commands"><code class="name">var <span class="ident">commands</span> : List[<a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>]</code></dt>
<dd>
<div class="desc"><p>Commands of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; List[CmdBase]:
    &#34;&#34;&#34;Commands of Device configuration data (DCD) segment.&#34;&#34;&#34;
    return self._commands</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.image.header.Header" href="header.html#spsdk.image.header.Header">Header</a></code></dt>
<dd>
<div class="desc"><p>Header of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Header:
    &#34;&#34;&#34;Header of Device configuration data (DCD) segment.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of Device configuration data (DCD) segment.&#34;&#34;&#34;
    return self._header.length if self.enabled else 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.space"><code class="name">var <span class="ident">space</span> : int</code></dt>
<dd>
<div class="desc"><p>Add space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def space(self) -&gt; int:
    &#34;&#34;&#34;Add space.&#34;&#34;&#34;
    return self.size + self.padding if self.enabled else 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegDCD.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cmd: <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Appending of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, cmd: CmdBase) -&gt; None:
    &#34;&#34;&#34;Appending of Device configuration data (DCD) segment.&#34;&#34;&#34;
    assert isinstance(cmd, CmdBase) and (cmd.tag in self._COMMANDS)
    self._commands.append(cmd)
    self._header.length += cmd.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Device configuration data (DCD) segment.&#34;&#34;&#34;
    self._commands.clear()
    self._header.length = self._header.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = b&#39;&#39;
    if self.enabled:
        data = self._header.export()
        for command in self._commands:
            data += command.export()
        # padding
        data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.export_txt"><code class="name flex">
<span>def <span class="ident">export_txt</span></span>(<span>self, txt_data: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Export txt of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_txt(self, txt_data: str = None) -&gt; str:
    &#34;&#34;&#34;Export txt of Device configuration data (DCD) segment.&#34;&#34;&#34;
    write_ops = (&#39;WriteValue&#39;, &#39;WriteClearBits&#39;, &#39;ClearBitMask&#39;, &#39;SetBitMask&#39;)
    check_ops = (&#39;CheckAllClear&#39;, &#39;CheckAllSet&#39;, &#39;CheckAnyClear&#39;, &#39;CheckAnySet&#39;)
    if txt_data is None:
        txt_data = &#34;&#34;

    for cmd in self._commands:
        if isinstance(cmd, CmdWriteData):
            for (address, value) in cmd:
                txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}\n&#34;.format(write_ops[cmd.ops], cmd.num_bytes, address,
                                                                       value)
        elif isinstance(cmd, CmdCheckData):
            txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}&#34;.format(check_ops[cmd.ops], cmd.num_bytes, cmd.address,
                                                                 cmd.mask)
            txt_data += &#34; {0:d}\n&#34;.format(cmd.count) if cmd.count else &#34;\n&#34;

        elif isinstance(cmd, CmdUnlock):
            txt_data += &#34;Unlock {0:s}&#34;.format(EnumEngine[cmd.engine]) # type: ignore
            cnt = 1
            for value in cmd:
                if cnt &gt; 6:
                    txt_data += &#34; \\\n&#34;
                    cnt = 0
                txt_data += &#34; 0x{0:08X}&#34;.format(value)
                cnt += 1

            txt_data += &#39;\n&#39;

        else:
            txt_data += &#34;Nop\n&#34;

        # Split with new line every group of commands
        txt_data += &#39;\n&#39;

    return txt_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegDCD.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegDCD.&#34;&#34;&#34;
    msg = &#34;&#34;
    for cmd in self._commands:
        msg += cmd.info()
        msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegDCD.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index: int) ‑> <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Popping of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; CmdBase:
    &#34;&#34;&#34;Popping of Device configuration data (DCD) segment.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._commands)
    cmd = self._commands.pop(index)
    self._header.length -= cmd.size
    return cmd</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SegIVT2"><code class="flex name class">
<span>class <span class="ident">SegIVT2</span></span>
<span>(</span><span>version: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Image Vector Table, IVT2 segment.</p>
<p>Initialize IVT2 segment.</p>
<p>:param version: The version of IVT and Image format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIVT2(BaseSegment):
    &#34;&#34;&#34;Image Vector Table, IVT2 segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;7L&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
        assert 0x40 &lt;= value &lt; 0x4F
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary data.&#34;&#34;&#34;
        return self._header.length

    def __init__(self, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT2 segment.

        :param version: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT2, version)
        self._header.length = self.SIZE
        self.app_address = 0
        self.rs1 = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.rs2 = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT2 &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, APP:0x{:X}, CSF:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.app_address, self.csf_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT2.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; format version   : 0x{:02X}\n&#34;.format(self.version)
        msg += &#34; IVT start address: 0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT start address: 0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD start address: 0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; APP entry point  : 0x{:08X}\n&#34;.format(self.app_address)
        msg += &#34; CSF start address: 0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validate settings of the segment.

        :raises ValueError: if there is configuration problem
        &#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X} &lt; 0x{:X}&#34;.format(self.dcd_address, self.ivt_address))
        # TODO: resolve commented code: if self.app_address and self.app_address &lt; self.ivt_address:
        #  raise ValueError(&#34;Not valid APP address: 0x{:X} &lt; 0x{:X}&#34;.format(self.app_address, self.ivt_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X} &lt; 0x{:X}&#34;.format(self.csf_address, self.ivt_address))
        if self.padding &gt; 0:
            raise ValueError(&#34;IVT padding should be zero: {}&#34;.format(self.padding))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export to binary representation (serialization).

        :return: segment exported as binary data
        &#34;&#34;&#34;
        self.validate()

        data = self._header.export()
        data += pack(self.FORMAT, self.app_address, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address,
                     self.csf_address, self.rs2)

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT2&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT2 segment
        :return: SegIVT2 object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT2)
        obj = cls(header.param)
        # Parse IVT items
        (obj.app_address,
         obj.rs1,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.rs2) = unpack_from(cls.FORMAT, data, header.size)
        # Calculate IVT padding (should be zero)
        obj.padding = obj.bdt_address - obj.ivt_address - obj.size
        # Validate parsed values
        obj.validate()
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.SegIVT2.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.SegIVT2.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SegIVT2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIVT2" href="segments.html#spsdk.image.segments.SegIVT2">SegIVT2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IVT2 segment
:return: SegIVT2 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIVT2&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IVT2 segment
    :return: SegIVT2 object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.IVT2)
    obj = cls(header.param)
    # Parse IVT items
    (obj.app_address,
     obj.rs1,
     obj.dcd_address,
     obj.bdt_address,
     obj.ivt_address,
     obj.csf_address,
     obj.rs2) = unpack_from(cls.FORMAT, data, header.size)
    # Calculate IVT padding (should be zero)
    obj.padding = obj.bdt_address - obj.ivt_address - obj.size
    # Validate parsed values
    obj.validate()
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegIVT2.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the binary data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the binary data.&#34;&#34;&#34;
    return self._header.length</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT2.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>The version of IVT and Image format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegIVT2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary representation (serialization).</p>
<p>:return: segment exported as binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export to binary representation (serialization).

    :return: segment exported as binary data
    &#34;&#34;&#34;
    self.validate()

    data = self._header.export()
    data += pack(self.FORMAT, self.app_address, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address,
                 self.csf_address, self.rs2)

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIVT2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIVT2.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; format version   : 0x{:02X}\n&#34;.format(self.version)
    msg += &#34; IVT start address: 0x{:08X}\n&#34;.format(self.ivt_address)
    msg += &#34; BDT start address: 0x{:08X}\n&#34;.format(self.bdt_address)
    msg += &#34; DCD start address: 0x{:08X}\n&#34;.format(self.dcd_address)
    msg += &#34; APP entry point  : 0x{:08X}\n&#34;.format(self.app_address)
    msg += &#34; CSF start address: 0x{:08X}\n&#34;.format(self.csf_address)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT2.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validate settings of the segment.</p>
<p>:raises ValueError: if there is configuration problem</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validate settings of the segment.

    :raises ValueError: if there is configuration problem
    &#34;&#34;&#34;
    if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid IVT/BDT address&#34;)
    if self.dcd_address and self.dcd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid DCD address: 0x{:X} &lt; 0x{:X}&#34;.format(self.dcd_address, self.ivt_address))
    # TODO: resolve commented code: if self.app_address and self.app_address &lt; self.ivt_address:
    #  raise ValueError(&#34;Not valid APP address: 0x{:X} &lt; 0x{:X}&#34;.format(self.app_address, self.ivt_address))
    if self.csf_address and self.csf_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid CSF address: 0x{:X} &lt; 0x{:X}&#34;.format(self.csf_address, self.ivt_address))
    if self.padding &gt; 0:
        raise ValueError(&#34;IVT padding should be zero: {}&#34;.format(self.padding))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="segments.html#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SegIVT3a"><code class="flex name class">
<span>class <span class="ident">SegIVT3a</span></span>
<span>(</span><span>param: int)</span>
</code></dt>
<dd>
<div class="desc"><p>IVT3a segment.</p>
<p>Initialize IVT segment.</p>
<p>:param param: The version of IVT and Image format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIVT3a(BaseSegment):
    &#34;&#34;&#34;IVT3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;1L5Q&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of IVT3a segment.&#34;&#34;&#34;
        return self._header

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IVT3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, param: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT segment.

        :param param: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT3, param)
        self._header.length = self.SIZE
        self.version = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.next = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT3a &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, CSF:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.csf_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT3a.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; VER:  {}\n&#34;.format(self.version)
        msg += &#34; IVT:  0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT:  0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD:  0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; CSF:  0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34; NEXT: 0x{:08X}\n&#34;.format(self.next)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validation of IVT3a segment.&#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self.header.export()
        data += pack(self.FORMAT, self.version, self.dcd_address, self.bdt_address, self.ivt_address,
                     self.csf_address, self.next)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT3a segment
        :return: SegIVT3a object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT3)
        obj = cls(header.param)

        (obj.version,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.next) = unpack_from(cls.FORMAT, data, header.size)

        obj.validate()

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.SegIVT3a.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.SegIVT3a.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SegIVT3a.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIVT3a" href="segments.html#spsdk.image.segments.SegIVT3a">SegIVT3a</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IVT3a segment
:return: SegIVT3a object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIVT3a&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IVT3a segment
    :return: SegIVT3a object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.IVT3)
    obj = cls(header.param)

    (obj.version,
     obj.dcd_address,
     obj.bdt_address,
     obj.ivt_address,
     obj.csf_address,
     obj.next) = unpack_from(cls.FORMAT, data, header.size)

    obj.validate()

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegIVT3a.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.image.header.Header" href="header.html#spsdk.image.header.Header">Header</a></code></dt>
<dd>
<div class="desc"><p>Header of IVT3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Header:
    &#34;&#34;&#34;Header of IVT3a segment.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT3a.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IVT3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IVT3a segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegIVT3a.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self.validate()

    data = self.header.export()
    data += pack(self.FORMAT, self.version, self.dcd_address, self.bdt_address, self.ivt_address,
                 self.csf_address, self.next)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT3a.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIVT3a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIVT3a.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; VER:  {}\n&#34;.format(self.version)
    msg += &#34; IVT:  0x{:08X}\n&#34;.format(self.ivt_address)
    msg += &#34; BDT:  0x{:08X}\n&#34;.format(self.bdt_address)
    msg += &#34; DCD:  0x{:08X}\n&#34;.format(self.dcd_address)
    msg += &#34; CSF:  0x{:08X}\n&#34;.format(self.csf_address)
    msg += &#34; NEXT: 0x{:08X}\n&#34;.format(self.next)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT3a.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of IVT3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validation of IVT3a segment.&#34;&#34;&#34;
    if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid IVT/BDT address&#34;)
    if self.dcd_address and self.dcd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
    if self.csf_address and self.csf_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="segments.html#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SegIVT3b"><code class="flex name class">
<span>class <span class="ident">SegIVT3b</span></span>
<span>(</span><span>version: int)</span>
</code></dt>
<dd>
<div class="desc"><p>IVT3b segment.</p>
<p>Initialize IVT segment.</p>
<p>:param version: The version of IVT and Image format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIVT3b(BaseSegment):
    &#34;&#34;&#34;IVT3b segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;1L7Q&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of IVT3b segment.&#34;&#34;&#34;
        return self._header

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IVT3b segment.

        :return size
        &#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT segment.

        :param version: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT2, version)
        self._header.length = self.SIZE
        self.rs1 = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.scd_address = 0
        self.rs2h = 0
        self.rs2l = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT3b &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, CSF:0x{:X}, SCD:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.csf_address, self.scd_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT3b.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; IVT: 0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT: 0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD: 0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; SCD: 0x{:08X}\n&#34;.format(self.scd_address)
        msg += &#34; CSF: 0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validation of IVT3b segment.&#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))
        if self.scd_address and self.scd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid SCD address: 0x{:X}&#34;.format(self.scd_address))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self.header.export()
        data += pack(self.FORMAT, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address, self.csf_address,
                     self.scd_address, self.rs2h, self.rs2l)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT3b segment
        :return: SegIVT3b object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT2)
        obj = cls(header.param)

        (obj.rs1,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.scd_address,
         obj.rs2h,
         obj.rs2l) = unpack_from(cls.FORMAT, data, header.size)

        obj.validate()

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.SegIVT3b.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.SegIVT3b.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SegIVT3b.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIVT3b" href="segments.html#spsdk.image.segments.SegIVT3b">SegIVT3b</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IVT3b segment
:return: SegIVT3b object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIVT3b&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IVT3b segment
    :return: SegIVT3b object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.IVT2)
    obj = cls(header.param)

    (obj.rs1,
     obj.dcd_address,
     obj.bdt_address,
     obj.ivt_address,
     obj.csf_address,
     obj.scd_address,
     obj.rs2h,
     obj.rs2l) = unpack_from(cls.FORMAT, data, header.size)

    obj.validate()

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SegIVT3b.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.image.header.Header" href="header.html#spsdk.image.header.Header">Header</a></code></dt>
<dd>
<div class="desc"><p>Header of IVT3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Header:
    &#34;&#34;&#34;Header of IVT3b segment.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT3b.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IVT3b segment.</p>
<p>:return size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IVT3b segment.

    :return size
    &#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SegIVT3b.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self.validate()

    data = self.header.export()
    data += pack(self.FORMAT, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address, self.csf_address,
                 self.scd_address, self.rs2h, self.rs2l)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT3b.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIVT3b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIVT3b.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; IVT: 0x{:08X}\n&#34;.format(self.ivt_address)
    msg += &#34; BDT: 0x{:08X}\n&#34;.format(self.bdt_address)
    msg += &#34; DCD: 0x{:08X}\n&#34;.format(self.dcd_address)
    msg += &#34; SCD: 0x{:08X}\n&#34;.format(self.scd_address)
    msg += &#34; CSF: 0x{:08X}\n&#34;.format(self.csf_address)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.SegIVT3b.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of IVT3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validation of IVT3b segment.&#34;&#34;&#34;
    if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid IVT/BDT address&#34;)
    if self.dcd_address and self.dcd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
    if self.csf_address and self.csf_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))
    if self.scd_address and self.scd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid SCD address: 0x{:X}&#34;.format(self.scd_address))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="segments.html#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="segments.html#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="segments.html#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.Signature"><code class="flex name class">
<span>class <span class="ident">Signature</span></span>
<span>(</span><span>version: int = 64, data: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a signature.</p>
<p>Initialize the signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signature(BaseClass):
    &#34;&#34;&#34;Class representing a signature.&#34;&#34;&#34;

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of a signature.&#34;&#34;&#34;
        return Header.SIZE + len(self._data)

    def __init__(self, version: int = 0x40, data: bytes = None) -&gt; None:
        &#34;&#34;&#34;Initialize the signature.&#34;&#34;&#34;
        super().__init__(tag=SegTag.SIG, version=version)
        self._data = bytearray() if data is None else bytearray(data)

    def __repr__(self) -&gt; str:
        return f&#34;Signature &lt;Ver: {self.version &gt;&gt; 4}.{self.version &amp; 0xF}, Size: {len(self._data)}&gt;&#34;

    def __eq__(self, obj: Any) -&gt; bool:
        return isinstance(obj, Signature) and vars(obj) == vars(self)

    def __ne__(self, obj: Any) -&gt; bool:
        return not self.__eq__(obj)

    def __len__(self) -&gt; int:
        return len(self._data)

    def __getitem__(self, key: int) -&gt; int:
        return self._data[key]

    def __setitem__(self, key: int, value: int) -&gt; None:
        self._data[key] = value

    def __iter__(self) -&gt; Iterator[int]:
        return self._data.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the signature.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;Signature (Ver: {:X}.{:X}, Size: {})\n&#34;.format(self.version &gt;&gt; 4, self.version &amp; 0xF, len(self._data))
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        return msg

    @property
    def data(self) -&gt; bytes:
        &#34;&#34;&#34;Signature data.&#34;&#34;&#34;
        return bytes(self._data)

    @data.setter
    def data(self, value: Union[bytes, bytearray]) -&gt; None:
        &#34;&#34;&#34;Signature data.&#34;&#34;&#34;
        self._data = bytearray(value)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._header.length = self.size
        raw_data = self._header.export()
        dbg_info.append_binary_section(&#39;header&#39;, raw_data)
        raw_data += self.data
        dbg_info.append_binary_section(&#39;data&#39;, self.data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;Signature&#39;:
        &#34;&#34;&#34;Parse.&#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.SIG)
        offset += Header.SIZE
        return cls(header.param, data[offset: offset + header.length - Header.SIZE])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.Signature.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.secret.Signature" href="secret.html#spsdk.image.secret.Signature">Signature</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;Signature&#39;:
    &#34;&#34;&#34;Parse.&#34;&#34;&#34;
    header = Header.parse(data, offset, SegTag.SIG)
    offset += Header.SIZE
    return cls(header.param, data[offset: offset + header.length - Header.SIZE])</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.Signature.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Signature data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; bytes:
    &#34;&#34;&#34;Signature data.&#34;&#34;&#34;
    return bytes(self._data)</code></pre>
</details>
</dd>
<dt id="spsdk.image.Signature.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of a signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of a signature.&#34;&#34;&#34;
    return Header.SIZE + len(self._data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.Signature.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._header.length = self.size
    raw_data = self._header.export()
    dbg_info.append_binary_section(&#39;header&#39;, raw_data)
    raw_data += self.data
    dbg_info.append_binary_section(&#39;data&#39;, self.data)
    return raw_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.Signature.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the signature.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;Signature (Ver: {:X}.{:X}, Size: {})\n&#34;.format(self.version &gt;&gt; 4, self.version &amp; 0xF, len(self._data))
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.secret.BaseClass.version" href="secret.html#spsdk.image.secret.BaseClass.version">version</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_major" href="secret.html#spsdk.image.secret.BaseClass.version_major">version_major</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_minor" href="secret.html#spsdk.image.secret.BaseClass.version_minor">version_minor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.SrkItem"><code class="flex name class">
<span>class <span class="ident">SrkItem</span></span>
<span>(</span><span>modulus: bytes, exponent: bytes, flag: int = 0, algorithm: int = 33)</span>
</code></dt>
<dd>
<div class="desc"><p>Item in SRK Table, see <code><a title="spsdk.image.SrkTable" href="#spsdk.image.SrkTable">SrkTable</a></code> class.</p>
<p>Initialize the srk table item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SrkItem:
    &#34;&#34;&#34;Item in SRK Table, see `SrkTable` class.&#34;&#34;&#34;

    SRK_TAG = 0xE1

    @property
    def algorithm(self) -&gt; int:
        &#34;&#34;&#34;Algorithm.&#34;&#34;&#34;
        return self._header.param

    @property
    def flag(self) -&gt; int:
        &#34;&#34;&#34;Flag.&#34;&#34;&#34;
        return self._flag

    @flag.setter
    def flag(self, value: int) -&gt; None:
        assert value in (0, 0x80)
        self._flag = value

    @property
    def key_length(self) -&gt; int:
        &#34;&#34;&#34;Key length of Item in SRK Table.&#34;&#34;&#34;
        return len(self.modulus) * 8

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of SrkItem.&#34;&#34;&#34;
        return self._header.length

    def __init__(self, modulus: bytes, exponent: bytes, flag: int = 0,
                 algorithm: int = EnumAlgorithm.PKCS1) -&gt; None:
        &#34;&#34;&#34;Initialize the srk table item.&#34;&#34;&#34;
        assert isinstance(modulus, bytes)
        assert isinstance(exponent, bytes)
        self._header = Header(tag=self.SRK_TAG, param=algorithm)
        self.flag = flag
        self.modulus = modulus
        self.exponent = exponent
        self._header.length += 8 + len(self.modulus) + len(self.exponent)

    def __repr__(self) -&gt; str:
        return &#34;SRK &lt;Algorithm: {}, CA: {}&gt;&#34;.format(EnumAlgorithm[self.algorithm],  # type: ignore
                                                    &#39;YES&#39; if self.flag == 0x80 else &#39;NO&#39;)  # type: ignore

    def __eq__(self, obj: Any) -&gt; bool:
        return isinstance(obj, SrkItem) and vars(obj) == vars(self)

    def __ne__(self, obj: Any) -&gt; bool:
        return not self.__eq__(obj)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of SrkItem.&#34;&#34;&#34;
        msg = str()
        msg += &#34;Algorithm: {}\n&#34;.format(EnumAlgorithm[self.algorithm])  # type: ignore
        msg += &#34;Flag:      0x{:02X} {}\n&#34;.format(self.flag, &#39;(CA)&#39; if self.flag == 0x80 else &#39;&#39;)
        msg += &#34;Length:    {} bit\n&#34;.format(self.key_length)
        msg += &#34;Modulus:\n&#34;
        msg += modulus_fmt(self.modulus)
        msg += &#34;\n&#34;
        msg += &#34;Exponent: {0} (0x{0:X})\n&#34;.format(int.from_bytes(self.exponent, &#39;big&#39;))
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        data = self._header.export()
        data += pack(&#34;&gt;4B2H&#34;, 0, 0, 0, self.flag, len(self.modulus), len(self.exponent))
        data += bytes(self.modulus)
        data += bytes(self.exponent)
        return data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SrkItem&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of SRK segment
        :param offset: The offset of input data
        :return: SrkItem: SrkItem object
        &#34;&#34;&#34;
        header = Header.parse(data, offset, cls.SRK_TAG)
        offset += Header.SIZE + 3
        (flag, modulus_len, exponent_len) = unpack_from(&#34;&gt;B2H&#34;, data, offset)
        offset += 5
        modulus = data[offset: offset + modulus_len]
        offset += modulus_len
        exponent = data[offset: offset + exponent_len]
        return cls(modulus, exponent, flag, header.param)

    @classmethod
    @no_type_check
    def from_certificate(cls, cert: Certificate) -&gt; &#39;SrkItem&#39;:
        &#34;&#34;&#34;Create SRKItem from certificate.&#34;&#34;&#34;
        assert isinstance(cert, Certificate)

        flag = 0

        for extension in cert.extensions:
            if extension.oid._name == &#39;keyUsage&#39;:
                if extension.value.key_cert_sign:
                    flag = 0x80

        # get modulus and exponent of public key
        pub_key_numbers = cert.public_key().public_numbers()
        modulus_len = pub_key_numbers.n.bit_length() // 8
        if pub_key_numbers.n.bit_length() % 8:
            modulus_len += 1
        exponent_len = pub_key_numbers.e.bit_length() // 8
        if pub_key_numbers.e.bit_length() % 8:
            exponent_len += 1
        modulus = pub_key_numbers.n.to_bytes(modulus_len, &#34;big&#34;)
        exponent = pub_key_numbers.e.to_bytes(exponent_len, &#34;big&#34;)

        return cls(modulus, exponent, flag)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.SrkItem.SRK_TAG"><code class="name">var <span class="ident">SRK_TAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SrkItem.from_certificate"><code class="name flex">
<span>def <span class="ident">from_certificate</span></span>(<span>cert: cryptography.x509.base.Certificate) ‑> <a title="spsdk.image.SrkItem" href="#spsdk.image.SrkItem">SrkItem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create SRKItem from certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
@no_type_check
def from_certificate(cls, cert: Certificate) -&gt; &#39;SrkItem&#39;:
    &#34;&#34;&#34;Create SRKItem from certificate.&#34;&#34;&#34;
    assert isinstance(cert, Certificate)

    flag = 0

    for extension in cert.extensions:
        if extension.oid._name == &#39;keyUsage&#39;:
            if extension.value.key_cert_sign:
                flag = 0x80

    # get modulus and exponent of public key
    pub_key_numbers = cert.public_key().public_numbers()
    modulus_len = pub_key_numbers.n.bit_length() // 8
    if pub_key_numbers.n.bit_length() % 8:
        modulus_len += 1
    exponent_len = pub_key_numbers.e.bit_length() // 8
    if pub_key_numbers.e.bit_length() % 8:
        exponent_len += 1
    modulus = pub_key_numbers.n.to_bytes(modulus_len, &#34;big&#34;)
    exponent = pub_key_numbers.e.to_bytes(exponent_len, &#34;big&#34;)

    return cls(modulus, exponent, flag)</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkItem.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.secret.SrkItem" href="secret.html#spsdk.image.secret.SrkItem">SrkItem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of SRK segment
:param offset: The offset of input data
:return: SrkItem: SrkItem object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SrkItem&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of SRK segment
    :param offset: The offset of input data
    :return: SrkItem: SrkItem object
    &#34;&#34;&#34;
    header = Header.parse(data, offset, cls.SRK_TAG)
    offset += Header.SIZE + 3
    (flag, modulus_len, exponent_len) = unpack_from(&#34;&gt;B2H&#34;, data, offset)
    offset += 5
    modulus = data[offset: offset + modulus_len]
    offset += modulus_len
    exponent = data[offset: offset + exponent_len]
    return cls(modulus, exponent, flag, header.param)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SrkItem.algorithm"><code class="name">var <span class="ident">algorithm</span> : int</code></dt>
<dd>
<div class="desc"><p>Algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def algorithm(self) -&gt; int:
    &#34;&#34;&#34;Algorithm.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkItem.flag"><code class="name">var <span class="ident">flag</span> : int</code></dt>
<dd>
<div class="desc"><p>Flag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flag(self) -&gt; int:
    &#34;&#34;&#34;Flag.&#34;&#34;&#34;
    return self._flag</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkItem.key_length"><code class="name">var <span class="ident">key_length</span> : int</code></dt>
<dd>
<div class="desc"><p>Key length of Item in SRK Table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key_length(self) -&gt; int:
    &#34;&#34;&#34;Key length of Item in SRK Table.&#34;&#34;&#34;
    return len(self.modulus) * 8</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkItem.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of SrkItem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of SrkItem.&#34;&#34;&#34;
    return self._header.length</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SrkItem.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    data = self._header.export()
    data += pack(&#34;&gt;4B2H&#34;, 0, 0, 0, self.flag, len(self.modulus), len(self.exponent))
    data += bytes(self.modulus)
    data += bytes(self.exponent)
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkItem.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of SrkItem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of SrkItem.&#34;&#34;&#34;
    msg = str()
    msg += &#34;Algorithm: {}\n&#34;.format(EnumAlgorithm[self.algorithm])  # type: ignore
    msg += &#34;Flag:      0x{:02X} {}\n&#34;.format(self.flag, &#39;(CA)&#39; if self.flag == 0x80 else &#39;&#39;)
    msg += &#34;Length:    {} bit\n&#34;.format(self.key_length)
    msg += &#34;Modulus:\n&#34;
    msg += modulus_fmt(self.modulus)
    msg += &#34;\n&#34;
    msg += &#34;Exponent: {0} (0x{0:X})\n&#34;.format(int.from_bytes(self.exponent, &#39;big&#39;))
    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.SrkTable"><code class="flex name class">
<span>class <span class="ident">SrkTable</span></span>
<span>(</span><span>version: int = 64)</span>
</code></dt>
<dd>
<div class="desc"><p>SRK table.</p>
<p>Initialize SRT Table.</p>
<p>:param version: format version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SrkTable(BaseClass):
    &#34;&#34;&#34;SRK table.&#34;&#34;&#34;

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of SRK table.&#34;&#34;&#34;
        size = Header.SIZE
        for key in self._keys:
            size += key.size
        return size

    def __init__(self, version: int = 0x40) -&gt; None:
        &#34;&#34;&#34;Initialize SRT Table.

        :param version: format version
        &#34;&#34;&#34;
        super().__init__(tag=SegTag.CRT, version=version)
        self._keys: List[SrkItem] = []

    def __repr__(self) -&gt; str:
        return &#34;SRK_Table &lt;Version: {:X}.{:X}, Keys: {}&gt;&#34;.format(self.version_major,
                                                                 self.version_minor, len(self._keys))

    def __eq__(self, obj: Any) -&gt; bool:
        return isinstance(obj, SrkTable) and vars(obj) == vars(self)

    def __ne__(self, obj: Any) -&gt; bool:
        return not self.__eq__(obj)

    def __len__(self) -&gt; int:
        return len(self._keys)

    def __getitem__(self, key: int) -&gt; SrkItem:
        return self._keys[key]

    def __setitem__(self, key: int, value: SrkItem) -&gt; None:
        assert isinstance(value, SrkItem)
        self._keys[key] = value

    def __iter__(self) -&gt; Iterator[SrkItem]:
        return self._keys.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        msg = &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;SRK Table (Version: {:X}.{:X}, #Keys: {})\n&#34;.format(self.version_major,
                                                                    self.version_minor,
                                                                    len(self._keys))
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        for i, srk in enumerate(self._keys):
            msg += f&#34;SRK Key Index: {i} \n&#34;
            msg += srk.info()
            msg += &#34;\n&#34;
        return msg

    def append(self, srk: SrkItem) -&gt; None:
        &#34;&#34;&#34;Add SRK item.

        :param srk: item to be added
        &#34;&#34;&#34;
        self._keys.append(srk)

    def get_fuse(self, index: int) -&gt; int:
        &#34;&#34;&#34;Retrieve fuse value for the given index.

        :param index: of the fuse, 0-7
        :return: value of the specified fuse; the value is in format, that cane be used as parameter for SDP
                `efuse_read_once` or `efuse_write_once`
        &#34;&#34;&#34;
        assert 0 &lt;= index &lt; 8
        int_data = self.export_fuses()[index * 4: (1 + index) * 4]
        assert len(int_data) == 4
        return unpack(&#34;&lt;I&#34;, int_data)[0]

    def export_fuses(self) -&gt; bytes:
        &#34;&#34;&#34;SRK items in binary form, see `SRK_fuses.bin` file.&#34;&#34;&#34;
        data = b&#39;&#39;
        for srk in self._keys:
            srk_data = srk.export()
            data += sha256(srk_data).digest()
        return sha256(data).digest()

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export into binary form (serialization).

        :param dbg_info: optional instance allowing to debug exported content
        :return: binary representation of the instance
        &#34;&#34;&#34;
        self._header.length = self.size
        raw_data = self._header.export()
        dbg_info.append_binary_section(&#39;header&#39;, raw_data)
        for srk in self._keys:
            item_data = srk.export()
            raw_data += item_data
            dbg_info.append_binary_section(&#39;srk_item&#39;, item_data)
        return raw_data

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SrkTable&#39;:
        &#34;&#34;&#34;Parse of SRK table.&#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.CRT)
        offset += Header.SIZE
        obj = cls(header.param)
        obj._header.length = header.length
        length = header.length - Header.SIZE
        while length &gt; 0:
            srk = SrkItem.parse(data, offset)
            offset += srk.size
            length -= srk.size
            obj.append(srk)
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.SrkTable.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse of SRK table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SrkTable&#39;:
    &#34;&#34;&#34;Parse of SRK table.&#34;&#34;&#34;
    header = Header.parse(data, offset, SegTag.CRT)
    offset += Header.SIZE
    obj = cls(header.param)
    obj._header.length = header.length
    length = header.length - Header.SIZE
    while length &gt; 0:
        srk = SrkItem.parse(data, offset)
        offset += srk.size
        length -= srk.size
        obj.append(srk)
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.SrkTable.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of SRK table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of SRK table.&#34;&#34;&#34;
    size = Header.SIZE
    for key in self._keys:
        size += key.size
    return size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.SrkTable.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, srk: <a title="spsdk.image.secret.SrkItem" href="secret.html#spsdk.image.secret.SrkItem">SrkItem</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add SRK item.</p>
<p>:param srk: item to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, srk: SrkItem) -&gt; None:
    &#34;&#34;&#34;Add SRK item.

    :param srk: item to be added
    &#34;&#34;&#34;
    self._keys.append(srk)</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkTable.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export into binary form (serialization).</p>
<p>:param dbg_info: optional instance allowing to debug exported content
:return: binary representation of the instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export into binary form (serialization).

    :param dbg_info: optional instance allowing to debug exported content
    :return: binary representation of the instance
    &#34;&#34;&#34;
    self._header.length = self.size
    raw_data = self._header.export()
    dbg_info.append_binary_section(&#39;header&#39;, raw_data)
    for srk in self._keys:
        item_data = srk.export()
        raw_data += item_data
        dbg_info.append_binary_section(&#39;srk_item&#39;, item_data)
    return raw_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkTable.export_fuses"><code class="name flex">
<span>def <span class="ident">export_fuses</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>SRK items in binary form, see <code>SRK_fuses.bin</code> file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_fuses(self) -&gt; bytes:
    &#34;&#34;&#34;SRK items in binary form, see `SRK_fuses.bin` file.&#34;&#34;&#34;
    data = b&#39;&#39;
    for srk in self._keys:
        srk_data = srk.export()
        data += sha256(srk_data).digest()
    return sha256(data).digest()</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkTable.get_fuse"><code class="name flex">
<span>def <span class="ident">get_fuse</span></span>(<span>self, index: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve fuse value for the given index.</p>
<p>:param index: of the fuse, 0-7
:return: value of the specified fuse; the value is in format, that cane be used as parameter for SDP
<code>efuse_read_once</code> or <code>efuse_write_once</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fuse(self, index: int) -&gt; int:
    &#34;&#34;&#34;Retrieve fuse value for the given index.

    :param index: of the fuse, 0-7
    :return: value of the specified fuse; the value is in format, that cane be used as parameter for SDP
            `efuse_read_once` or `efuse_write_once`
    &#34;&#34;&#34;
    assert 0 &lt;= index &lt; 8
    int_data = self.export_fuses()[index * 4: (1 + index) * 4]
    assert len(int_data) == 4
    return unpack(&#34;&lt;I&#34;, int_data)[0]</code></pre>
</details>
</dd>
<dt id="spsdk.image.SrkTable.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Text info about the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
    msg = &#34;-&#34; * 60 + &#34;\n&#34;
    msg += &#34;SRK Table (Version: {:X}.{:X}, #Keys: {})\n&#34;.format(self.version_major,
                                                                self.version_minor,
                                                                len(self._keys))
    msg += &#34;-&#34; * 60 + &#34;\n&#34;
    for i, srk in enumerate(self._keys):
        msg += f&#34;SRK Key Index: {i} \n&#34;
        msg += srk.info()
        msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.secret.BaseClass" href="secret.html#spsdk.image.secret.BaseClass">BaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.secret.BaseClass.version" href="secret.html#spsdk.image.secret.BaseClass.version">version</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_major" href="secret.html#spsdk.image.secret.BaseClass.version_major">version_major</a></code></li>
<li><code><a title="spsdk.image.secret.BaseClass.version_minor" href="secret.html#spsdk.image.secret.BaseClass.version_minor">version_minor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.TrustZone"><code class="flex name class">
<span>class <span class="ident">TrustZone</span></span>
<span>(</span><span>tz_type: <a title="spsdk.image.trustzone.TrustZoneType" href="trustzone.html#spsdk.image.trustzone.TrustZoneType">TrustZoneType</a> = 0, family: str = None, revision: str = None, customizations: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide creation of binary data to set up the TrustZone engine in CM-33.</p>
<p>Initialize the trustzone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrustZone:
    &#34;&#34;&#34;Provide creation of binary data to set up the TrustZone engine in CM-33.&#34;&#34;&#34;
    PRESET_DIR = os.path.normpath(os.path.join(os.path.dirname(__file__), &#34;..&#34;, &#34;data&#34;, &#34;tz_presets&#34;))
    CONFIG_FILE = os.path.join(PRESET_DIR, &#34;database.json&#34;)

    @classmethod
    def enabled(cls) -&gt; &#34;TrustZone&#34;:
        &#34;&#34;&#34;Alternate constructor for ENABLED type of TrustZone.&#34;&#34;&#34;
        return cls(tz_type=TrustZoneType.ENABLED)

    @classmethod
    def disabled(cls) -&gt; &#34;TrustZone&#34;:
        &#34;&#34;&#34;Alternate constructor for DISABLED type of TrustZone.&#34;&#34;&#34;
        return cls(tz_type=TrustZoneType.DISABLED)

    @classmethod
    def custom(cls, family: str, customizations: dict, revision: str = None) -&gt; &#34;TrustZone&#34;:
        &#34;&#34;&#34;Alternate constructor for CUSTOM type of TrustZone.&#34;&#34;&#34;
        return cls(tz_type=TrustZoneType.CUSTOM, family=family, revision=revision,
                   customizations=customizations)

    def __init__(self, tz_type: TrustZoneType = TrustZoneType.ENABLED,
                 family: str = None, revision: str = None, customizations: dict = None) -&gt; None:
        &#34;&#34;&#34;Initialize the trustzone.&#34;&#34;&#34;
        self.type = tz_type
        self.family: Optional[str] = family
        self.config: dict = self._load_config_file()
        self.customs: Optional[dict] = customizations
        self.revision: Optional[str] = revision

        if self.type == TrustZoneType.DISABLED and customizations:
            raise ValueError(&#34;TrustZone was disabled, can&#39;t add trust_zone_data&#34;)

        # TODO: Should empty customs qualifies for CUSTOM TZ type???
        if self.customs is not None:
            self.type = TrustZoneType.CUSTOM

        if self.type == TrustZoneType.CUSTOM:
            assert self.family, &#34;Need to provide &#39;family&#39; parameter&#34;
            assert self.customs is not None, &#34;Need to provide &#39;customization&#39; parameter&#34;

            self.family = self.family.lower()
            assert self.family in self.get_families(), &#34;Chip family &#39;{}&#39; is not supported\n&#34;.format(self.family)
            self.revision = self.sanitize_revision(self.family, self.revision)
            assert self.revision in self.get_revisions(), \
                &#34;Revision &#39;{}&#39; is not supported on family &#39;{}&#39;\n&#34;.format(self.revision, self.family)

            self.presets: dict = self._load_presets()
            if not TrustZone.validate_custom_data(self.presets, self.customs):
                raise ValueError(&#34;Invalid register found in customization data:\n&#34;
                                 &#34;%s&#34; % [item for item in self.customs if item not in self.presets])

    def __str__(self) -&gt; str:
        return f&#34;&lt;TrustZone: type: {self.type} ({TrustZoneType.desc(self.type)})&#34;

    def _load_config_file(self) -&gt; dict:
        &#34;&#34;&#34;Load data from TZ config file.&#34;&#34;&#34;
        with open(self.CONFIG_FILE) as f:
            return json.load(f)

    def get_families(self) -&gt; list:
        &#34;&#34;&#34;Return list of supported chip families.&#34;&#34;&#34;
        return list(self.config.keys())

    def get_revisions(self, family: str = None) -&gt; list:
        &#34;&#34;&#34;Return a list of revisions for given family.&#34;&#34;&#34;
        return list(self.config[family or self.family][&#34;revisions&#34;].keys())

    def get_latest_revision(self, family: str = None) -&gt; str:
        &#34;&#34;&#34;Return latest revision for given family.&#34;&#34;&#34;
        return self.config[family or self.family][&#34;latest&#34;]

    def sanitize_revision(self, family: str, revision: Optional[str]) -&gt; str:
        &#34;&#34;&#34;Sanitize revision.

        if the &#39;revision&#39; is None return the latest revision
        if the &#39;revision&#39; is provided return it as lower-case
        &#34;&#34;&#34;
        return revision.lower() if revision else self.get_latest_revision(family)

    def _get_preset_file(self) -&gt; str:
        return os.path.join(TrustZone.PRESET_DIR, self.config[self.family][&#34;revisions&#34;][self.revision])

    def _load_presets(self) -&gt; dict:
        &#34;&#34;&#34;Load default TrustZone settings for given family and revision.&#34;&#34;&#34;
        with open(self._get_preset_file()) as preset_file:
            return json.load(preset_file)

    @staticmethod
    def validate_custom_data(data: dict, customizations: dict) -&gt; bool:
        &#34;&#34;&#34;Check whether all register names in custom data are valid (present in presets).&#34;&#34;&#34;
        return all(item in data for item in customizations)

    def _custom_export(self) -&gt; bytes:
        assert self.presets is not None
        assert self.customs is not None
        logging.info(f&#34;{len(self.presets)} registers loaded from defaults&#34;)
        logging.debug(self.presets)
        logging.info(f&#34;{len(self.customs)} modifications provided&#34;)
        logging.debug(self.customs)
        data = self.presets
        data.update(self.customs)
        registers = [parse_int(item) for item in data.values()]
        # transform data into binary format (little endian, 32b per register)
        return struct.pack(f&#34;&lt;{len(registers)}I&#34;, *registers)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Return the TrustZone data as bytes.&#34;&#34;&#34;
        return self._custom_export() if self.type == TrustZoneType.CUSTOM else bytes()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.TrustZone.CONFIG_FILE"><code class="name">var <span class="ident">CONFIG_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.TrustZone.PRESET_DIR"><code class="name">var <span class="ident">PRESET_DIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.TrustZone.custom"><code class="name flex">
<span>def <span class="ident">custom</span></span>(<span>family: str, customizations: dict, revision: str = None) ‑> <a title="spsdk.image.trustzone.TrustZone" href="trustzone.html#spsdk.image.trustzone.TrustZone">TrustZone</a></span>
</code></dt>
<dd>
<div class="desc"><p>Alternate constructor for CUSTOM type of TrustZone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def custom(cls, family: str, customizations: dict, revision: str = None) -&gt; &#34;TrustZone&#34;:
    &#34;&#34;&#34;Alternate constructor for CUSTOM type of TrustZone.&#34;&#34;&#34;
    return cls(tz_type=TrustZoneType.CUSTOM, family=family, revision=revision,
               customizations=customizations)</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.disabled"><code class="name flex">
<span>def <span class="ident">disabled</span></span>(<span>) ‑> <a title="spsdk.image.trustzone.TrustZone" href="trustzone.html#spsdk.image.trustzone.TrustZone">TrustZone</a></span>
</code></dt>
<dd>
<div class="desc"><p>Alternate constructor for DISABLED type of TrustZone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def disabled(cls) -&gt; &#34;TrustZone&#34;:
    &#34;&#34;&#34;Alternate constructor for DISABLED type of TrustZone.&#34;&#34;&#34;
    return cls(tz_type=TrustZoneType.DISABLED)</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.enabled"><code class="name flex">
<span>def <span class="ident">enabled</span></span>(<span>) ‑> <a title="spsdk.image.trustzone.TrustZone" href="trustzone.html#spsdk.image.trustzone.TrustZone">TrustZone</a></span>
</code></dt>
<dd>
<div class="desc"><p>Alternate constructor for ENABLED type of TrustZone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def enabled(cls) -&gt; &#34;TrustZone&#34;:
    &#34;&#34;&#34;Alternate constructor for ENABLED type of TrustZone.&#34;&#34;&#34;
    return cls(tz_type=TrustZoneType.ENABLED)</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.validate_custom_data"><code class="name flex">
<span>def <span class="ident">validate_custom_data</span></span>(<span>data: dict, customizations: dict) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether all register names in custom data are valid (present in presets).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_custom_data(data: dict, customizations: dict) -&gt; bool:
    &#34;&#34;&#34;Check whether all register names in custom data are valid (present in presets).&#34;&#34;&#34;
    return all(item in data for item in customizations)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.TrustZone.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Return the TrustZone data as bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Return the TrustZone data as bytes.&#34;&#34;&#34;
    return self._custom_export() if self.type == TrustZoneType.CUSTOM else bytes()</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.get_families"><code class="name flex">
<span>def <span class="ident">get_families</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of supported chip families.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_families(self) -&gt; list:
    &#34;&#34;&#34;Return list of supported chip families.&#34;&#34;&#34;
    return list(self.config.keys())</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.get_latest_revision"><code class="name flex">
<span>def <span class="ident">get_latest_revision</span></span>(<span>self, family: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return latest revision for given family.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latest_revision(self, family: str = None) -&gt; str:
    &#34;&#34;&#34;Return latest revision for given family.&#34;&#34;&#34;
    return self.config[family or self.family][&#34;latest&#34;]</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.get_revisions"><code class="name flex">
<span>def <span class="ident">get_revisions</span></span>(<span>self, family: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of revisions for given family.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_revisions(self, family: str = None) -&gt; list:
    &#34;&#34;&#34;Return a list of revisions for given family.&#34;&#34;&#34;
    return list(self.config[family or self.family][&#34;revisions&#34;].keys())</code></pre>
</details>
</dd>
<dt id="spsdk.image.TrustZone.sanitize_revision"><code class="name flex">
<span>def <span class="ident">sanitize_revision</span></span>(<span>self, family: str, revision: Union[str, NoneType]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sanitize revision.</p>
<p>if the 'revision' is None return the latest revision
if the 'revision' is provided return it as lower-case</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanitize_revision(self, family: str, revision: Optional[str]) -&gt; str:
    &#34;&#34;&#34;Sanitize revision.

    if the &#39;revision&#39; is None return the latest revision
    if the &#39;revision&#39; is provided return it as lower-case
    &#34;&#34;&#34;
    return revision.lower() if revision else self.get_latest_revision(family)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.TrustZoneType"><code class="flex name class">
<span>class <span class="ident">TrustZoneType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum defining various types of TrustZone types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrustZoneType(Enum):
    &#34;&#34;&#34;Enum defining various types of TrustZone types.&#34;&#34;&#34;
    ENABLED = (0x00, &#34;TrustZone enabled with default settings&#34;)
    CUSTOM = (0x20, &#34;TrustZone enabled with custom settings&#34;)
    DISABLED = (0x40, &#34;Disabled&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.TrustZoneType.CUSTOM"><code class="name">var <span class="ident">CUSTOM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.TrustZoneType.DISABLED"><code class="name">var <span class="ident">DISABLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.TrustZoneType.ENABLED"><code class="name">var <span class="ident">ENABLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk" href="../index.html">spsdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="spsdk.image.bee" href="bee.html">spsdk.image.bee</a></code></li>
<li><code><a title="spsdk.image.commands" href="commands.html">spsdk.image.commands</a></code></li>
<li><code><a title="spsdk.image.hab_audit_log" href="hab_audit_log.html">spsdk.image.hab_audit_log</a></code></li>
<li><code><a title="spsdk.image.header" href="header.html">spsdk.image.header</a></code></li>
<li><code><a title="spsdk.image.images" href="images.html">spsdk.image.images</a></code></li>
<li><code><a title="spsdk.image.keystore" href="keystore.html">spsdk.image.keystore</a></code></li>
<li><code><a title="spsdk.image.mbimg" href="mbimg.html">spsdk.image.mbimg</a></code></li>
<li><code><a title="spsdk.image.misc" href="misc.html">spsdk.image.misc</a></code></li>
<li><code><a title="spsdk.image.pfr" href="pfr.html">spsdk.image.pfr</a></code></li>
<li><code><a title="spsdk.image.secret" href="secret.html">spsdk.image.secret</a></code></li>
<li><code><a title="spsdk.image.segments" href="segments.html">spsdk.image.segments</a></code></li>
<li><code><a title="spsdk.image.trustzone" href="trustzone.html">spsdk.image.trustzone</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spsdk.image.parse" href="#spsdk.image.parse">parse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.image.BeeFacRegion" href="#spsdk.image.BeeFacRegion">BeeFacRegion</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.BeeFacRegion.end_addr" href="#spsdk.image.BeeFacRegion.end_addr">end_addr</a></code></li>
<li><code><a title="spsdk.image.BeeFacRegion.export" href="#spsdk.image.BeeFacRegion.export">export</a></code></li>
<li><code><a title="spsdk.image.BeeFacRegion.info" href="#spsdk.image.BeeFacRegion.info">info</a></code></li>
<li><code><a title="spsdk.image.BeeFacRegion.parse" href="#spsdk.image.BeeFacRegion.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BeeFacRegion.validate" href="#spsdk.image.BeeFacRegion.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BeeKIB" href="#spsdk.image.BeeKIB">BeeKIB</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.BeeKIB.export" href="#spsdk.image.BeeKIB.export">export</a></code></li>
<li><code><a title="spsdk.image.BeeKIB.info" href="#spsdk.image.BeeKIB.info">info</a></code></li>
<li><code><a title="spsdk.image.BeeKIB.parse" href="#spsdk.image.BeeKIB.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BeeKIB.validate" href="#spsdk.image.BeeKIB.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BeeProtectRegionBlock" href="#spsdk.image.BeeProtectRegionBlock">BeeProtectRegionBlock</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.BeeProtectRegionBlock.FAC_REGIONS" href="#spsdk.image.BeeProtectRegionBlock.FAC_REGIONS">FAC_REGIONS</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.SIZE" href="#spsdk.image.BeeProtectRegionBlock.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.TAGH" href="#spsdk.image.BeeProtectRegionBlock.TAGH">TAGH</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.TAGL" href="#spsdk.image.BeeProtectRegionBlock.TAGL">TAGL</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.VERSION" href="#spsdk.image.BeeProtectRegionBlock.VERSION">VERSION</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.add_fac" href="#spsdk.image.BeeProtectRegionBlock.add_fac">add_fac</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.encrypt_block" href="#spsdk.image.BeeProtectRegionBlock.encrypt_block">encrypt_block</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.fac_count" href="#spsdk.image.BeeProtectRegionBlock.fac_count">fac_count</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.info" href="#spsdk.image.BeeProtectRegionBlock.info">info</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.parse" href="#spsdk.image.BeeProtectRegionBlock.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.update" href="#spsdk.image.BeeProtectRegionBlock.update">update</a></code></li>
<li><code><a title="spsdk.image.BeeProtectRegionBlock.validate" href="#spsdk.image.BeeProtectRegionBlock.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BeeRegionHeader" href="#spsdk.image.BeeRegionHeader">BeeRegionHeader</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.BeeRegionHeader.PRDB_OFFSET" href="#spsdk.image.BeeRegionHeader.PRDB_OFFSET">PRDB_OFFSET</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.SIZE" href="#spsdk.image.BeeRegionHeader.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.add_fac" href="#spsdk.image.BeeRegionHeader.add_fac">add_fac</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.encrypt_block" href="#spsdk.image.BeeRegionHeader.encrypt_block">encrypt_block</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.export" href="#spsdk.image.BeeRegionHeader.export">export</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.fac_regions" href="#spsdk.image.BeeRegionHeader.fac_regions">fac_regions</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.info" href="#spsdk.image.BeeRegionHeader.info">info</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.parse" href="#spsdk.image.BeeRegionHeader.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.sw_key_fuses" href="#spsdk.image.BeeRegionHeader.sw_key_fuses">sw_key_fuses</a></code></li>
<li><code><a title="spsdk.image.BeeRegionHeader.validate" href="#spsdk.image.BeeRegionHeader.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BootImg2" href="#spsdk.image.BootImg2">BootImg2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.BootImg2.APP_ALIGN" href="#spsdk.image.BootImg2.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.BootImg2.CSF_SIZE" href="#spsdk.image.BootImg2.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg2.HEAD_SIZE" href="#spsdk.image.BootImg2.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg2.add_image" href="#spsdk.image.BootImg2.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.BootImg2.app" href="#spsdk.image.BootImg2.app">app</a></code></li>
<li><code><a title="spsdk.image.BootImg2.bdt" href="#spsdk.image.BootImg2.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.BootImg2.csf" href="#spsdk.image.BootImg2.csf">csf</a></code></li>
<li><code><a title="spsdk.image.BootImg2.export" href="#spsdk.image.BootImg2.export">export</a></code></li>
<li><code><a title="spsdk.image.BootImg2.info" href="#spsdk.image.BootImg2.info">info</a></code></li>
<li><code><a title="spsdk.image.BootImg2.ivt" href="#spsdk.image.BootImg2.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.BootImg2.parse" href="#spsdk.image.BootImg2.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BootImg2.plugin" href="#spsdk.image.BootImg2.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.BootImg2.size" href="#spsdk.image.BootImg2.size">size</a></code></li>
<li><code><a title="spsdk.image.BootImg2.version" href="#spsdk.image.BootImg2.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BootImg3a" href="#spsdk.image.BootImg3a">BootImg3a</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.BootImg3a.APP_ALIGN" href="#spsdk.image.BootImg3a.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.COUNT_OF_CONTAINERS" href="#spsdk.image.BootImg3a.COUNT_OF_CONTAINERS">COUNT_OF_CONTAINERS</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.CSF_SIZE" href="#spsdk.image.BootImg3a.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.HEAD_SIZE" href="#spsdk.image.BootImg3a.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.IMG_AUTO_ALIGN" href="#spsdk.image.BootImg3a.IMG_AUTO_ALIGN">IMG_AUTO_ALIGN</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.IMG_TYPE_CSF" href="#spsdk.image.BootImg3a.IMG_TYPE_CSF">IMG_TYPE_CSF</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.IMG_TYPE_DATA" href="#spsdk.image.BootImg3a.IMG_TYPE_DATA">IMG_TYPE_DATA</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.IMG_TYPE_EXEC" href="#spsdk.image.BootImg3a.IMG_TYPE_EXEC">IMG_TYPE_EXEC</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.IMG_TYPE_SCD" href="#spsdk.image.BootImg3a.IMG_TYPE_SCD">IMG_TYPE_SCD</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_AP_ROM" href="#spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_AP_ROM">INITIAL_LOAD_ADDR_AP_ROM</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_FLEXSPI" href="#spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_FLEXSPI">INITIAL_LOAD_ADDR_FLEXSPI</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_SCU_ROM" href="#spsdk.image.BootImg3a.INITIAL_LOAD_ADDR_SCU_ROM">INITIAL_LOAD_ADDR_SCU_ROM</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.PADDING_VAL" href="#spsdk.image.BootImg3a.PADDING_VAL">PADDING_VAL</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.SCFW_FLAGS_APP" href="#spsdk.image.BootImg3a.SCFW_FLAGS_APP">SCFW_FLAGS_APP</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.SCFW_FLAGS_M4_0" href="#spsdk.image.BootImg3a.SCFW_FLAGS_M4_0">SCFW_FLAGS_M4_0</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.SCFW_FLAGS_M4_1" href="#spsdk.image.BootImg3a.SCFW_FLAGS_M4_1">SCFW_FLAGS_M4_1</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.SCFW_FLAGS_SCFW" href="#spsdk.image.BootImg3a.SCFW_FLAGS_SCFW">SCFW_FLAGS_SCFW</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.SECTOR_SIZE" href="#spsdk.image.BootImg3a.SECTOR_SIZE">SECTOR_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.add_image" href="#spsdk.image.BootImg3a.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.bdt" href="#spsdk.image.BootImg3a.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.csf" href="#spsdk.image.BootImg3a.csf">csf</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.export" href="#spsdk.image.BootImg3a.export">export</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.info" href="#spsdk.image.BootImg3a.info">info</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.ivt" href="#spsdk.image.BootImg3a.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.parse" href="#spsdk.image.BootImg3a.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BootImg3a.plg" href="#spsdk.image.BootImg3a.plg">plg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BootImg3b" href="#spsdk.image.BootImg3b">BootImg3b</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.BootImg3b.APP_ALIGN" href="#spsdk.image.BootImg3b.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.COUNT_OF_CONTAINERS" href="#spsdk.image.BootImg3b.COUNT_OF_CONTAINERS">COUNT_OF_CONTAINERS</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.CSF_SIZE" href="#spsdk.image.BootImg3b.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.HEAD_SIZE" href="#spsdk.image.BootImg3b.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.IMG_AUTO_ALIGN" href="#spsdk.image.BootImg3b.IMG_AUTO_ALIGN">IMG_AUTO_ALIGN</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.IMG_TYPE_CSF" href="#spsdk.image.BootImg3b.IMG_TYPE_CSF">IMG_TYPE_CSF</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.IMG_TYPE_DATA" href="#spsdk.image.BootImg3b.IMG_TYPE_DATA">IMG_TYPE_DATA</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.IMG_TYPE_EXEC" href="#spsdk.image.BootImg3b.IMG_TYPE_EXEC">IMG_TYPE_EXEC</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.IMG_TYPE_SCD" href="#spsdk.image.BootImg3b.IMG_TYPE_SCD">IMG_TYPE_SCD</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_AP_ROM" href="#spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_AP_ROM">INITIAL_LOAD_ADDR_AP_ROM</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_FLEXSPI" href="#spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_FLEXSPI">INITIAL_LOAD_ADDR_FLEXSPI</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_SCU_ROM" href="#spsdk.image.BootImg3b.INITIAL_LOAD_ADDR_SCU_ROM">INITIAL_LOAD_ADDR_SCU_ROM</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.PADDING_VAL" href="#spsdk.image.BootImg3b.PADDING_VAL">PADDING_VAL</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.SCFW_FLAGS_A53" href="#spsdk.image.BootImg3b.SCFW_FLAGS_A53">SCFW_FLAGS_A53</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.SCFW_FLAGS_A72" href="#spsdk.image.BootImg3b.SCFW_FLAGS_A72">SCFW_FLAGS_A72</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.SCFW_FLAGS_M4_0" href="#spsdk.image.BootImg3b.SCFW_FLAGS_M4_0">SCFW_FLAGS_M4_0</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.SCFW_FLAGS_M4_1" href="#spsdk.image.BootImg3b.SCFW_FLAGS_M4_1">SCFW_FLAGS_M4_1</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.SCFW_FLAGS_SCFW" href="#spsdk.image.BootImg3b.SCFW_FLAGS_SCFW">SCFW_FLAGS_SCFW</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.SECTOR_SIZE" href="#spsdk.image.BootImg3b.SECTOR_SIZE">SECTOR_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.add_image" href="#spsdk.image.BootImg3b.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.bdt" href="#spsdk.image.BootImg3b.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.csf" href="#spsdk.image.BootImg3b.csf">csf</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.export" href="#spsdk.image.BootImg3b.export">export</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.info" href="#spsdk.image.BootImg3b.info">info</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.ivt" href="#spsdk.image.BootImg3b.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.parse" href="#spsdk.image.BootImg3b.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BootImg3b.plg" href="#spsdk.image.BootImg3b.plg">plg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BootImg4" href="#spsdk.image.BootImg4">BootImg4</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.BootImg4.add_image" href="#spsdk.image.BootImg4.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.BootImg4.export" href="#spsdk.image.BootImg4.export">export</a></code></li>
<li><code><a title="spsdk.image.BootImg4.info" href="#spsdk.image.BootImg4.info">info</a></code></li>
<li><code><a title="spsdk.image.BootImg4.parse" href="#spsdk.image.BootImg4.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.BootImgRT" href="#spsdk.image.BootImgRT">BootImgRT</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.BootImgRT.BDT_SIZE" href="#spsdk.image.BootImgRT.BDT_SIZE">BDT_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.BEE_OFFSET" href="#spsdk.image.BootImgRT.BEE_OFFSET">BEE_OFFSET</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.CSF_SIZE" href="#spsdk.image.BootImgRT.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.DEK_SIZE" href="#spsdk.image.BootImgRT.DEK_SIZE">DEK_SIZE</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.IVT_OFFSETS" href="#spsdk.image.BootImgRT.IVT_OFFSETS">IVT_OFFSETS</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.IVT_OFFSET_NOR_FLASH" href="#spsdk.image.BootImgRT.IVT_OFFSET_NOR_FLASH">IVT_OFFSET_NOR_FLASH</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.IVT_OFFSET_OTHER" href="#spsdk.image.BootImgRT.IVT_OFFSET_OTHER">IVT_OFFSET_OTHER</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.NON_XIP_APP_OFFSET" href="#spsdk.image.BootImgRT.NON_XIP_APP_OFFSET">NON_XIP_APP_OFFSET</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.VERSIONS" href="#spsdk.image.BootImgRT.VERSIONS">VERSIONS</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.XIP_APP_OFFSET" href="#spsdk.image.BootImgRT.XIP_APP_OFFSET">XIP_APP_OFFSET</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.add_csf_encrypted" href="#spsdk.image.BootImgRT.add_csf_encrypted">add_csf_encrypted</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.add_csf_standard_auth" href="#spsdk.image.BootImgRT.add_csf_standard_auth">add_csf_standard_auth</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.add_dcd_bin" href="#spsdk.image.BootImgRT.add_dcd_bin">add_dcd_bin</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.add_image" href="#spsdk.image.BootImgRT.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.aead_nonce_len" href="#spsdk.image.BootImgRT.aead_nonce_len">aead_nonce_len</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.app" href="#spsdk.image.BootImgRT.app">app</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.app_offset" href="#spsdk.image.BootImgRT.app_offset">app_offset</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.bdt" href="#spsdk.image.BootImgRT.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.bee" href="#spsdk.image.BootImgRT.bee">bee</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.bee_encrypted" href="#spsdk.image.BootImgRT.bee_encrypted">bee_encrypted</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.csf" href="#spsdk.image.BootImgRT.csf">csf</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.decrypted_app_data" href="#spsdk.image.BootImgRT.decrypted_app_data">decrypted_app_data</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.dek_img_offset" href="#spsdk.image.BootImgRT.dek_img_offset">dek_img_offset</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.dek_key" href="#spsdk.image.BootImgRT.dek_key">dek_key</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.dek_ram_address" href="#spsdk.image.BootImgRT.dek_ram_address">dek_ram_address</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.enabled_csf" href="#spsdk.image.BootImgRT.enabled_csf">enabled_csf</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.export" href="#spsdk.image.BootImgRT.export">export</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.fcb" href="#spsdk.image.BootImgRT.fcb">fcb</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.hab_encrypted" href="#spsdk.image.BootImgRT.hab_encrypted">hab_encrypted</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.ivt" href="#spsdk.image.BootImgRT.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.ivt_offset" href="#spsdk.image.BootImgRT.ivt_offset">ivt_offset</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.parse" href="#spsdk.image.BootImgRT.parse">parse</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.plugin" href="#spsdk.image.BootImgRT.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.set_flexspi_fcb" href="#spsdk.image.BootImgRT.set_flexspi_fcb">set_flexspi_fcb</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.size" href="#spsdk.image.BootImgRT.size">size</a></code></li>
<li><code><a title="spsdk.image.BootImgRT.version" href="#spsdk.image.BootImgRT.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CFPA" href="#spsdk.image.CFPA">CFPA</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CFPA.CONFIG_DIR" href="#spsdk.image.CFPA.CONFIG_DIR">CONFIG_DIR</a></code></li>
<li><code><a title="spsdk.image.CFPA.HAS_ROTKH" href="#spsdk.image.CFPA.HAS_ROTKH">HAS_ROTKH</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CMPA" href="#spsdk.image.CMPA">CMPA</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CMPA.CONFIG_DIR" href="#spsdk.image.CMPA.CONFIG_DIR">CONFIG_DIR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CertificateImg" href="#spsdk.image.CertificateImg">CertificateImg</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CertificateImg.export" href="#spsdk.image.CertificateImg.export">export</a></code></li>
<li><code><a title="spsdk.image.CertificateImg.info" href="#spsdk.image.CertificateImg.info">info</a></code></li>
<li><code><a title="spsdk.image.CertificateImg.parse" href="#spsdk.image.CertificateImg.parse">parse</a></code></li>
<li><code><a title="spsdk.image.CertificateImg.size" href="#spsdk.image.CertificateImg.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdAuthData" href="#spsdk.image.CmdAuthData">CmdAuthData</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdAuthData.append" href="#spsdk.image.CmdAuthData.append">append</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.clear" href="#spsdk.image.CmdAuthData.clear">clear</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.cmd_data_offset" href="#spsdk.image.CmdAuthData.cmd_data_offset">cmd_data_offset</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.cmd_data_reference" href="#spsdk.image.CmdAuthData.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.engine" href="#spsdk.image.CmdAuthData.engine">engine</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.flags" href="#spsdk.image.CmdAuthData.flags">flags</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.info" href="#spsdk.image.CmdAuthData.info">info</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.key_index" href="#spsdk.image.CmdAuthData.key_index">key_index</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.needs_cmd_data_reference" href="#spsdk.image.CmdAuthData.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.parse" href="#spsdk.image.CmdAuthData.parse">parse</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.parse_cmd_data" href="#spsdk.image.CmdAuthData.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.pop" href="#spsdk.image.CmdAuthData.pop">pop</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.signature" href="#spsdk.image.CmdAuthData.signature">signature</a></code></li>
<li><code><a title="spsdk.image.CmdAuthData.update_signature" href="#spsdk.image.CmdAuthData.update_signature">update_signature</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdCheckData" href="#spsdk.image.CmdCheckData">CmdCheckData</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdCheckData.info" href="#spsdk.image.CmdCheckData.info">info</a></code></li>
<li><code><a title="spsdk.image.CmdCheckData.num_bytes" href="#spsdk.image.CmdCheckData.num_bytes">num_bytes</a></code></li>
<li><code><a title="spsdk.image.CmdCheckData.ops" href="#spsdk.image.CmdCheckData.ops">ops</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdInitialize" href="#spsdk.image.CmdInitialize">CmdInitialize</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdInitialize.append" href="#spsdk.image.CmdInitialize.append">append</a></code></li>
<li><code><a title="spsdk.image.CmdInitialize.clear" href="#spsdk.image.CmdInitialize.clear">clear</a></code></li>
<li><code><a title="spsdk.image.CmdInitialize.engine" href="#spsdk.image.CmdInitialize.engine">engine</a></code></li>
<li><code><a title="spsdk.image.CmdInitialize.info" href="#spsdk.image.CmdInitialize.info">info</a></code></li>
<li><code><a title="spsdk.image.CmdInitialize.pop" href="#spsdk.image.CmdInitialize.pop">pop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdInstallKey" href="#spsdk.image.CmdInstallKey">CmdInstallKey</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdInstallKey.certificate_format" href="#spsdk.image.CmdInstallKey.certificate_format">certificate_format</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.certificate_ref" href="#spsdk.image.CmdInstallKey.certificate_ref">certificate_ref</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.cmd_data_reference" href="#spsdk.image.CmdInstallKey.cmd_data_reference">cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.flags" href="#spsdk.image.CmdInstallKey.flags">flags</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.hash_algorithm" href="#spsdk.image.CmdInstallKey.hash_algorithm">hash_algorithm</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.info" href="#spsdk.image.CmdInstallKey.info">info</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.needs_cmd_data_reference" href="#spsdk.image.CmdInstallKey.needs_cmd_data_reference">needs_cmd_data_reference</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.parse" href="#spsdk.image.CmdInstallKey.parse">parse</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.parse_cmd_data" href="#spsdk.image.CmdInstallKey.parse_cmd_data">parse_cmd_data</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.source_index" href="#spsdk.image.CmdInstallKey.source_index">source_index</a></code></li>
<li><code><a title="spsdk.image.CmdInstallKey.target_index" href="#spsdk.image.CmdInstallKey.target_index">target_index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdNop" href="#spsdk.image.CmdNop">CmdNop</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdNop.info" href="#spsdk.image.CmdNop.info">info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdSet" href="#spsdk.image.CmdSet">CmdSet</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdSet.engine" href="#spsdk.image.CmdSet.engine">engine</a></code></li>
<li><code><a title="spsdk.image.CmdSet.hash_algorithm" href="#spsdk.image.CmdSet.hash_algorithm">hash_algorithm</a></code></li>
<li><code><a title="spsdk.image.CmdSet.info" href="#spsdk.image.CmdSet.info">info</a></code></li>
<li><code><a title="spsdk.image.CmdSet.itm" href="#spsdk.image.CmdSet.itm">itm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdUnlock" href="#spsdk.image.CmdUnlock">CmdUnlock</a></code></h4>
</li>
<li>
<h4><code><a title="spsdk.image.CmdUnlockCAAM" href="#spsdk.image.CmdUnlockCAAM">CmdUnlockCAAM</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_MFG" href="#spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_MFG">FEATURE_UNLOCK_MFG</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_MID" href="#spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_MID">FEATURE_UNLOCK_MID</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_RNG" href="#spsdk.image.CmdUnlockCAAM.FEATURE_UNLOCK_RNG">FEATURE_UNLOCK_RNG</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockCAAM.unlock_mfg" href="#spsdk.image.CmdUnlockCAAM.unlock_mfg">unlock_mfg</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockCAAM.unlock_mid" href="#spsdk.image.CmdUnlockCAAM.unlock_mid">unlock_mid</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockCAAM.unlock_rng" href="#spsdk.image.CmdUnlockCAAM.unlock_rng">unlock_rng</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdUnlockOCOTP" href="#spsdk.image.CmdUnlockOCOTP">CmdUnlockOCOTP</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_FLD_RTN" href="#spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_FLD_RTN">FEATURE_UNLOCK_FLD_RTN</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_JTAG" href="#spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_JTAG">FEATURE_UNLOCK_JTAG</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_SCS" href="#spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_SCS">FEATURE_UNLOCK_SCS</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_SRK_RVK" href="#spsdk.image.CmdUnlockOCOTP.FEATURE_UNLOCK_SRK_RVK">FEATURE_UNLOCK_SRK_RVK</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.unlock_csc" href="#spsdk.image.CmdUnlockOCOTP.unlock_csc">unlock_csc</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.unlock_fld_rtn" href="#spsdk.image.CmdUnlockOCOTP.unlock_fld_rtn">unlock_fld_rtn</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.unlock_jtag" href="#spsdk.image.CmdUnlockOCOTP.unlock_jtag">unlock_jtag</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockOCOTP.unlock_srk_rvk" href="#spsdk.image.CmdUnlockOCOTP.unlock_srk_rvk">unlock_srk_rvk</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdUnlockSNVS" href="#spsdk.image.CmdUnlockSNVS">CmdUnlockSNVS</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR" href="#spsdk.image.CmdUnlockSNVS.FEATURE_UNLOCK_LP_SWR">FEATURE_UNLOCK_LP_SWR</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE" href="#spsdk.image.CmdUnlockSNVS.FEATURE_UNLOCK_ZMK_WRITE">FEATURE_UNLOCK_ZMK_WRITE</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockSNVS.unlock_lp_swr" href="#spsdk.image.CmdUnlockSNVS.unlock_lp_swr">unlock_lp_swr</a></code></li>
<li><code><a title="spsdk.image.CmdUnlockSNVS.unlock_zmk_write" href="#spsdk.image.CmdUnlockSNVS.unlock_zmk_write">unlock_zmk_write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.CmdWriteData" href="#spsdk.image.CmdWriteData">CmdWriteData</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.CmdWriteData.append" href="#spsdk.image.CmdWriteData.append">append</a></code></li>
<li><code><a title="spsdk.image.CmdWriteData.clear" href="#spsdk.image.CmdWriteData.clear">clear</a></code></li>
<li><code><a title="spsdk.image.CmdWriteData.info" href="#spsdk.image.CmdWriteData.info">info</a></code></li>
<li><code><a title="spsdk.image.CmdWriteData.num_bytes" href="#spsdk.image.CmdWriteData.num_bytes">num_bytes</a></code></li>
<li><code><a title="spsdk.image.CmdWriteData.ops" href="#spsdk.image.CmdWriteData.ops">ops</a></code></li>
<li><code><a title="spsdk.image.CmdWriteData.pop" href="#spsdk.image.CmdWriteData.pop">pop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumAlgorithm" href="#spsdk.image.EnumAlgorithm">EnumAlgorithm</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.EnumAlgorithm.AES" href="#spsdk.image.EnumAlgorithm.AES">AES</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.ANY" href="#spsdk.image.EnumAlgorithm.ANY">ANY</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.BLOB" href="#spsdk.image.EnumAlgorithm.BLOB">BLOB</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.CCM" href="#spsdk.image.EnumAlgorithm.CCM">CCM</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.CIPHER" href="#spsdk.image.EnumAlgorithm.CIPHER">CIPHER</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.EC" href="#spsdk.image.EnumAlgorithm.EC">EC</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.F" href="#spsdk.image.EnumAlgorithm.F">F</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.HASH" href="#spsdk.image.EnumAlgorithm.HASH">HASH</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.MODE" href="#spsdk.image.EnumAlgorithm.MODE">MODE</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.PKCS1" href="#spsdk.image.EnumAlgorithm.PKCS1">PKCS1</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.SHA1" href="#spsdk.image.EnumAlgorithm.SHA1">SHA1</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.SHA256" href="#spsdk.image.EnumAlgorithm.SHA256">SHA256</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.SHA512" href="#spsdk.image.EnumAlgorithm.SHA512">SHA512</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.SIG" href="#spsdk.image.EnumAlgorithm.SIG">SIG</a></code></li>
<li><code><a title="spsdk.image.EnumAlgorithm.WRAP" href="#spsdk.image.EnumAlgorithm.WRAP">WRAP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumAppType" href="#spsdk.image.EnumAppType">EnumAppType</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.EnumAppType.A72" href="#spsdk.image.EnumAppType.A72">A72</a></code></li>
<li><code><a title="spsdk.image.EnumAppType.APP" href="#spsdk.image.EnumAppType.APP">APP</a></code></li>
<li><code><a title="spsdk.image.EnumAppType.M4_0" href="#spsdk.image.EnumAppType.M4_0">M4_0</a></code></li>
<li><code><a title="spsdk.image.EnumAppType.M4_1" href="#spsdk.image.EnumAppType.M4_1">M4_1</a></code></li>
<li><code><a title="spsdk.image.EnumAppType.SCD" href="#spsdk.image.EnumAppType.SCD">SCD</a></code></li>
<li><code><a title="spsdk.image.EnumAppType.SCFW" href="#spsdk.image.EnumAppType.SCFW">SCFW</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumAuthDat" href="#spsdk.image.EnumAuthDat">EnumAuthDat</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.EnumAuthDat.ABS" href="#spsdk.image.EnumAuthDat.ABS">ABS</a></code></li>
<li><code><a title="spsdk.image.EnumAuthDat.CLR" href="#spsdk.image.EnumAuthDat.CLR">CLR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumCertFormat" href="#spsdk.image.EnumCertFormat">EnumCertFormat</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.EnumCertFormat.AEAD" href="#spsdk.image.EnumCertFormat.AEAD">AEAD</a></code></li>
<li><code><a title="spsdk.image.EnumCertFormat.BLOB" href="#spsdk.image.EnumCertFormat.BLOB">BLOB</a></code></li>
<li><code><a title="spsdk.image.EnumCertFormat.CMS" href="#spsdk.image.EnumCertFormat.CMS">CMS</a></code></li>
<li><code><a title="spsdk.image.EnumCertFormat.SRK" href="#spsdk.image.EnumCertFormat.SRK">SRK</a></code></li>
<li><code><a title="spsdk.image.EnumCertFormat.X509" href="#spsdk.image.EnumCertFormat.X509">X509</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumCheckOps" href="#spsdk.image.EnumCheckOps">EnumCheckOps</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.EnumCheckOps.ALL_CLEAR" href="#spsdk.image.EnumCheckOps.ALL_CLEAR">ALL_CLEAR</a></code></li>
<li><code><a title="spsdk.image.EnumCheckOps.ALL_SET" href="#spsdk.image.EnumCheckOps.ALL_SET">ALL_SET</a></code></li>
<li><code><a title="spsdk.image.EnumCheckOps.ANY_CLEAR" href="#spsdk.image.EnumCheckOps.ANY_CLEAR">ANY_CLEAR</a></code></li>
<li><code><a title="spsdk.image.EnumCheckOps.ANY_SET" href="#spsdk.image.EnumCheckOps.ANY_SET">ANY_SET</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumEngine" href="#spsdk.image.EnumEngine">EnumEngine</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.EnumEngine.ANY" href="#spsdk.image.EnumEngine.ANY">ANY</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.CAAM" href="#spsdk.image.EnumEngine.CAAM">CAAM</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.CSU" href="#spsdk.image.EnumEngine.CSU">CSU</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.DCP" href="#spsdk.image.EnumEngine.DCP">DCP</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.DTCP" href="#spsdk.image.EnumEngine.DTCP">DTCP</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.HDCP" href="#spsdk.image.EnumEngine.HDCP">HDCP</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.OCOTP" href="#spsdk.image.EnumEngine.OCOTP">OCOTP</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.ROM" href="#spsdk.image.EnumEngine.ROM">ROM</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.RTIC" href="#spsdk.image.EnumEngine.RTIC">RTIC</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.SAHARA" href="#spsdk.image.EnumEngine.SAHARA">SAHARA</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.SCC" href="#spsdk.image.EnumEngine.SCC">SCC</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.SNVS" href="#spsdk.image.EnumEngine.SNVS">SNVS</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.SRTC" href="#spsdk.image.EnumEngine.SRTC">SRTC</a></code></li>
<li><code><a title="spsdk.image.EnumEngine.SW" href="#spsdk.image.EnumEngine.SW">SW</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumInsKey" href="#spsdk.image.EnumInsKey">EnumInsKey</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.EnumInsKey.ABS" href="#spsdk.image.EnumInsKey.ABS">ABS</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.CFG" href="#spsdk.image.EnumInsKey.CFG">CFG</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.CID" href="#spsdk.image.EnumInsKey.CID">CID</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.CLR" href="#spsdk.image.EnumInsKey.CLR">CLR</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.CSF" href="#spsdk.image.EnumInsKey.CSF">CSF</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.DAT" href="#spsdk.image.EnumInsKey.DAT">DAT</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.FID" href="#spsdk.image.EnumInsKey.FID">FID</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.HSH" href="#spsdk.image.EnumInsKey.HSH">HSH</a></code></li>
<li><code><a title="spsdk.image.EnumInsKey.MID" href="#spsdk.image.EnumInsKey.MID">MID</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumItm" href="#spsdk.image.EnumItm">EnumItm</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.EnumItm.ENG" href="#spsdk.image.EnumItm.ENG">ENG</a></code></li>
<li><code><a title="spsdk.image.EnumItm.MID" href="#spsdk.image.EnumItm.MID">MID</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.EnumWriteOps" href="#spsdk.image.EnumWriteOps">EnumWriteOps</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.EnumWriteOps.CLEAR_BITMASK" href="#spsdk.image.EnumWriteOps.CLEAR_BITMASK">CLEAR_BITMASK</a></code></li>
<li><code><a title="spsdk.image.EnumWriteOps.SET_BITMASK" href="#spsdk.image.EnumWriteOps.SET_BITMASK">SET_BITMASK</a></code></li>
<li><code><a title="spsdk.image.EnumWriteOps.WRITE_CLEAR_BITS" href="#spsdk.image.EnumWriteOps.WRITE_CLEAR_BITS">WRITE_CLEAR_BITS</a></code></li>
<li><code><a title="spsdk.image.EnumWriteOps.WRITE_VALUE" href="#spsdk.image.EnumWriteOps.WRITE_VALUE">WRITE_VALUE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.FlexSPIConfBlockFCB" href="#spsdk.image.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.FORMAT" href="#spsdk.image.FlexSPIConfBlockFCB.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.TAG" href="#spsdk.image.FlexSPIConfBlockFCB.TAG">TAG</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.VERSION" href="#spsdk.image.FlexSPIConfBlockFCB.VERSION">VERSION</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.export" href="#spsdk.image.FlexSPIConfBlockFCB.export">export</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.export_header" href="#spsdk.image.FlexSPIConfBlockFCB.export_header">export_header</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.info" href="#spsdk.image.FlexSPIConfBlockFCB.info">info</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.parse" href="#spsdk.image.FlexSPIConfBlockFCB.parse">parse</a></code></li>
<li><code><a title="spsdk.image.FlexSPIConfBlockFCB.size" href="#spsdk.image.FlexSPIConfBlockFCB.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.KeySourceType" href="#spsdk.image.KeySourceType">KeySourceType</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.KeySourceType.KEYSTORE" href="#spsdk.image.KeySourceType.KEYSTORE">KEYSTORE</a></code></li>
<li><code><a title="spsdk.image.KeySourceType.OTP" href="#spsdk.image.KeySourceType.OTP">OTP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.KeyStore" href="#spsdk.image.KeyStore">KeyStore</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.KeyStore.KEY_STORE_SIZE" href="#spsdk.image.KeyStore.KEY_STORE_SIZE">KEY_STORE_SIZE</a></code></li>
<li><code><a title="spsdk.image.KeyStore.derive_enc_image_key" href="#spsdk.image.KeyStore.derive_enc_image_key">derive_enc_image_key</a></code></li>
<li><code><a title="spsdk.image.KeyStore.derive_hmac_key" href="#spsdk.image.KeyStore.derive_hmac_key">derive_hmac_key</a></code></li>
<li><code><a title="spsdk.image.KeyStore.derive_otfad_kek_key" href="#spsdk.image.KeyStore.derive_otfad_kek_key">derive_otfad_kek_key</a></code></li>
<li><code><a title="spsdk.image.KeyStore.derive_sb_kek_key" href="#spsdk.image.KeyStore.derive_sb_kek_key">derive_sb_kek_key</a></code></li>
<li><code><a title="spsdk.image.KeyStore.export" href="#spsdk.image.KeyStore.export">export</a></code></li>
<li><code><a title="spsdk.image.KeyStore.info" href="#spsdk.image.KeyStore.info">info</a></code></li>
<li><code><a title="spsdk.image.KeyStore.key_source" href="#spsdk.image.KeyStore.key_source">key_source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.MAC" href="#spsdk.image.MAC">MAC</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.MAC.AES128_BLK_LEN" href="#spsdk.image.MAC.AES128_BLK_LEN">AES128_BLK_LEN</a></code></li>
<li><code><a title="spsdk.image.MAC.data" href="#spsdk.image.MAC.data">data</a></code></li>
<li><code><a title="spsdk.image.MAC.export" href="#spsdk.image.MAC.export">export</a></code></li>
<li><code><a title="spsdk.image.MAC.info" href="#spsdk.image.MAC.info">info</a></code></li>
<li><code><a title="spsdk.image.MAC.mac" href="#spsdk.image.MAC.mac">mac</a></code></li>
<li><code><a title="spsdk.image.MAC.nonce" href="#spsdk.image.MAC.nonce">nonce</a></code></li>
<li><code><a title="spsdk.image.MAC.parse" href="#spsdk.image.MAC.parse">parse</a></code></li>
<li><code><a title="spsdk.image.MAC.size" href="#spsdk.image.MAC.size">size</a></code></li>
<li><code><a title="spsdk.image.MAC.update_aead_encryption_params" href="#spsdk.image.MAC.update_aead_encryption_params">update_aead_encryption_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.MasterBootImage" href="#spsdk.image.MasterBootImage">MasterBootImage</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.MasterBootImage.CERTIFICATE_OFFSET" href="#spsdk.image.MasterBootImage.CERTIFICATE_OFFSET">CERTIFICATE_OFFSET</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.CRC_BLOCK_OFFSET" href="#spsdk.image.MasterBootImage.CRC_BLOCK_OFFSET">CRC_BLOCK_OFFSET</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.HMAC_OFFSET" href="#spsdk.image.MasterBootImage.HMAC_OFFSET">HMAC_OFFSET</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.HMAC_SIZE" href="#spsdk.image.MasterBootImage.HMAC_SIZE">HMAC_SIZE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.IMAGE_FLAGS_OFFSET" href="#spsdk.image.MasterBootImage.IMAGE_FLAGS_OFFSET">IMAGE_FLAGS_OFFSET</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.IMAGE_LENGTH_OFFSET" href="#spsdk.image.MasterBootImage.IMAGE_LENGTH_OFFSET">IMAGE_LENGTH_OFFSET</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.LOAD_ADDR_OFFSET" href="#spsdk.image.MasterBootImage.LOAD_ADDR_OFFSET">LOAD_ADDR_OFFSET</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.app_len" href="#spsdk.image.MasterBootImage.app_len">app_len</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.data" href="#spsdk.image.MasterBootImage.data">data</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.export" href="#spsdk.image.MasterBootImage.export">export</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.info" href="#spsdk.image.MasterBootImage.info">info</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.parse" href="#spsdk.image.MasterBootImage.parse">parse</a></code></li>
<li><code><a title="spsdk.image.MasterBootImage.total_len" href="#spsdk.image.MasterBootImage.total_len">total_len</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.MasterBootImageType" href="#spsdk.image.MasterBootImageType">MasterBootImageType</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.MasterBootImageType.CRC_RAM_IMAGE" href="#spsdk.image.MasterBootImageType.CRC_RAM_IMAGE">CRC_RAM_IMAGE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.CRC_XIP_IMAGE" href="#spsdk.image.MasterBootImageType.CRC_XIP_IMAGE">CRC_XIP_IMAGE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.ENCRYPTED_RAM_IMAGE" href="#spsdk.image.MasterBootImageType.ENCRYPTED_RAM_IMAGE">ENCRYPTED_RAM_IMAGE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.PLAIN_IMAGE" href="#spsdk.image.MasterBootImageType.PLAIN_IMAGE">PLAIN_IMAGE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.SIGNED_RAM_IMAGE" href="#spsdk.image.MasterBootImageType.SIGNED_RAM_IMAGE">SIGNED_RAM_IMAGE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.SIGNED_XIP_IMAGE" href="#spsdk.image.MasterBootImageType.SIGNED_XIP_IMAGE">SIGNED_XIP_IMAGE</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.has_crc" href="#spsdk.image.MasterBootImageType.has_crc">has_crc</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.has_hmac" href="#spsdk.image.MasterBootImageType.has_hmac">has_hmac</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.is_copied_to_ram" href="#spsdk.image.MasterBootImageType.is_copied_to_ram">is_copied_to_ram</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.is_encrypted" href="#spsdk.image.MasterBootImageType.is_encrypted">is_encrypted</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.is_signed" href="#spsdk.image.MasterBootImageType.is_signed">is_signed</a></code></li>
<li><code><a title="spsdk.image.MasterBootImageType.is_xip" href="#spsdk.image.MasterBootImageType.is_xip">is_xip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.MultipleImageEntry" href="#spsdk.image.MultipleImageEntry">MultipleImageEntry</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.MultipleImageEntry.LTI_LOAD" href="#spsdk.image.MultipleImageEntry.LTI_LOAD">LTI_LOAD</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.dst_addr" href="#spsdk.image.MultipleImageEntry.dst_addr">dst_addr</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.export_entry" href="#spsdk.image.MultipleImageEntry.export_entry">export_entry</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.export_image" href="#spsdk.image.MultipleImageEntry.export_image">export_image</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.flags" href="#spsdk.image.MultipleImageEntry.flags">flags</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.image" href="#spsdk.image.MultipleImageEntry.image">image</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.is_load" href="#spsdk.image.MultipleImageEntry.is_load">is_load</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.size" href="#spsdk.image.MultipleImageEntry.size">size</a></code></li>
<li><code><a title="spsdk.image.MultipleImageEntry.src_addr" href="#spsdk.image.MultipleImageEntry.src_addr">src_addr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.MultipleImageTable" href="#spsdk.image.MultipleImageTable">MultipleImageTable</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.MultipleImageTable.add_entry" href="#spsdk.image.MultipleImageTable.add_entry">add_entry</a></code></li>
<li><code><a title="spsdk.image.MultipleImageTable.entries" href="#spsdk.image.MultipleImageTable.entries">entries</a></code></li>
<li><code><a title="spsdk.image.MultipleImageTable.export" href="#spsdk.image.MultipleImageTable.export">export</a></code></li>
<li><code><a title="spsdk.image.MultipleImageTable.header_version" href="#spsdk.image.MultipleImageTable.header_version">header_version</a></code></li>
<li><code><a title="spsdk.image.MultipleImageTable.reloc_table" href="#spsdk.image.MultipleImageTable.reloc_table">reloc_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.PaddingFCB" href="#spsdk.image.PaddingFCB">PaddingFCB</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.PaddingFCB.export" href="#spsdk.image.PaddingFCB.export">export</a></code></li>
<li><code><a title="spsdk.image.PaddingFCB.info" href="#spsdk.image.PaddingFCB.info">info</a></code></li>
<li><code><a title="spsdk.image.PaddingFCB.size" href="#spsdk.image.PaddingFCB.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SecretKeyBlob" href="#spsdk.image.SecretKeyBlob">SecretKeyBlob</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.SecretKeyBlob.blob" href="#spsdk.image.SecretKeyBlob.blob">blob</a></code></li>
<li><code><a title="spsdk.image.SecretKeyBlob.export" href="#spsdk.image.SecretKeyBlob.export">export</a></code></li>
<li><code><a title="spsdk.image.SecretKeyBlob.info" href="#spsdk.image.SecretKeyBlob.info">info</a></code></li>
<li><code><a title="spsdk.image.SecretKeyBlob.parse" href="#spsdk.image.SecretKeyBlob.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SecretKeyBlob.size" href="#spsdk.image.SecretKeyBlob.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegAPP" href="#spsdk.image.SegAPP">SegAPP</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.SegAPP.data" href="#spsdk.image.SegAPP.data">data</a></code></li>
<li><code><a title="spsdk.image.SegAPP.export" href="#spsdk.image.SegAPP.export">export</a></code></li>
<li><code><a title="spsdk.image.SegAPP.info" href="#spsdk.image.SegAPP.info">info</a></code></li>
<li><code><a title="spsdk.image.SegAPP.size" href="#spsdk.image.SegAPP.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegBDT" href="#spsdk.image.SegBDT">SegBDT</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SegBDT.FORMAT" href="#spsdk.image.SegBDT.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.SegBDT.SIZE" href="#spsdk.image.SegBDT.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.SegBDT.export" href="#spsdk.image.SegBDT.export">export</a></code></li>
<li><code><a title="spsdk.image.SegBDT.info" href="#spsdk.image.SegBDT.info">info</a></code></li>
<li><code><a title="spsdk.image.SegBDT.parse" href="#spsdk.image.SegBDT.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SegBDT.plugin" href="#spsdk.image.SegBDT.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.SegBDT.size" href="#spsdk.image.SegBDT.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegCSF" href="#spsdk.image.SegCSF">SegCSF</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SegCSF.append_command" href="#spsdk.image.SegCSF.append_command">append_command</a></code></li>
<li><code><a title="spsdk.image.SegCSF.clear_commands" href="#spsdk.image.SegCSF.clear_commands">clear_commands</a></code></li>
<li><code><a title="spsdk.image.SegCSF.commands" href="#spsdk.image.SegCSF.commands">commands</a></code></li>
<li><code><a title="spsdk.image.SegCSF.export" href="#spsdk.image.SegCSF.export">export</a></code></li>
<li><code><a title="spsdk.image.SegCSF.info" href="#spsdk.image.SegCSF.info">info</a></code></li>
<li><code><a title="spsdk.image.SegCSF.macs" href="#spsdk.image.SegCSF.macs">macs</a></code></li>
<li><code><a title="spsdk.image.SegCSF.parse" href="#spsdk.image.SegCSF.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SegCSF.size" href="#spsdk.image.SegCSF.size">size</a></code></li>
<li><code><a title="spsdk.image.SegCSF.space" href="#spsdk.image.SegCSF.space">space</a></code></li>
<li><code><a title="spsdk.image.SegCSF.update" href="#spsdk.image.SegCSF.update">update</a></code></li>
<li><code><a title="spsdk.image.SegCSF.update_signatures" href="#spsdk.image.SegCSF.update_signatures">update_signatures</a></code></li>
<li><code><a title="spsdk.image.SegCSF.version" href="#spsdk.image.SegCSF.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegDCD" href="#spsdk.image.SegDCD">SegDCD</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SegDCD.append" href="#spsdk.image.SegDCD.append">append</a></code></li>
<li><code><a title="spsdk.image.SegDCD.clear" href="#spsdk.image.SegDCD.clear">clear</a></code></li>
<li><code><a title="spsdk.image.SegDCD.commands" href="#spsdk.image.SegDCD.commands">commands</a></code></li>
<li><code><a title="spsdk.image.SegDCD.export" href="#spsdk.image.SegDCD.export">export</a></code></li>
<li><code><a title="spsdk.image.SegDCD.export_txt" href="#spsdk.image.SegDCD.export_txt">export_txt</a></code></li>
<li><code><a title="spsdk.image.SegDCD.header" href="#spsdk.image.SegDCD.header">header</a></code></li>
<li><code><a title="spsdk.image.SegDCD.info" href="#spsdk.image.SegDCD.info">info</a></code></li>
<li><code><a title="spsdk.image.SegDCD.parse" href="#spsdk.image.SegDCD.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SegDCD.parse_txt" href="#spsdk.image.SegDCD.parse_txt">parse_txt</a></code></li>
<li><code><a title="spsdk.image.SegDCD.pop" href="#spsdk.image.SegDCD.pop">pop</a></code></li>
<li><code><a title="spsdk.image.SegDCD.size" href="#spsdk.image.SegDCD.size">size</a></code></li>
<li><code><a title="spsdk.image.SegDCD.space" href="#spsdk.image.SegDCD.space">space</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegIVT2" href="#spsdk.image.SegIVT2">SegIVT2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SegIVT2.FORMAT" href="#spsdk.image.SegIVT2.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.SIZE" href="#spsdk.image.SegIVT2.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.export" href="#spsdk.image.SegIVT2.export">export</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.info" href="#spsdk.image.SegIVT2.info">info</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.parse" href="#spsdk.image.SegIVT2.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.size" href="#spsdk.image.SegIVT2.size">size</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.validate" href="#spsdk.image.SegIVT2.validate">validate</a></code></li>
<li><code><a title="spsdk.image.SegIVT2.version" href="#spsdk.image.SegIVT2.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegIVT3a" href="#spsdk.image.SegIVT3a">SegIVT3a</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SegIVT3a.FORMAT" href="#spsdk.image.SegIVT3a.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.SIZE" href="#spsdk.image.SegIVT3a.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.export" href="#spsdk.image.SegIVT3a.export">export</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.header" href="#spsdk.image.SegIVT3a.header">header</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.info" href="#spsdk.image.SegIVT3a.info">info</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.parse" href="#spsdk.image.SegIVT3a.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.size" href="#spsdk.image.SegIVT3a.size">size</a></code></li>
<li><code><a title="spsdk.image.SegIVT3a.validate" href="#spsdk.image.SegIVT3a.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SegIVT3b" href="#spsdk.image.SegIVT3b">SegIVT3b</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SegIVT3b.FORMAT" href="#spsdk.image.SegIVT3b.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.SIZE" href="#spsdk.image.SegIVT3b.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.export" href="#spsdk.image.SegIVT3b.export">export</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.header" href="#spsdk.image.SegIVT3b.header">header</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.info" href="#spsdk.image.SegIVT3b.info">info</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.parse" href="#spsdk.image.SegIVT3b.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.size" href="#spsdk.image.SegIVT3b.size">size</a></code></li>
<li><code><a title="spsdk.image.SegIVT3b.validate" href="#spsdk.image.SegIVT3b.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.Signature" href="#spsdk.image.Signature">Signature</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.Signature.data" href="#spsdk.image.Signature.data">data</a></code></li>
<li><code><a title="spsdk.image.Signature.export" href="#spsdk.image.Signature.export">export</a></code></li>
<li><code><a title="spsdk.image.Signature.info" href="#spsdk.image.Signature.info">info</a></code></li>
<li><code><a title="spsdk.image.Signature.parse" href="#spsdk.image.Signature.parse">parse</a></code></li>
<li><code><a title="spsdk.image.Signature.size" href="#spsdk.image.Signature.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SrkItem" href="#spsdk.image.SrkItem">SrkItem</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SrkItem.SRK_TAG" href="#spsdk.image.SrkItem.SRK_TAG">SRK_TAG</a></code></li>
<li><code><a title="spsdk.image.SrkItem.algorithm" href="#spsdk.image.SrkItem.algorithm">algorithm</a></code></li>
<li><code><a title="spsdk.image.SrkItem.export" href="#spsdk.image.SrkItem.export">export</a></code></li>
<li><code><a title="spsdk.image.SrkItem.flag" href="#spsdk.image.SrkItem.flag">flag</a></code></li>
<li><code><a title="spsdk.image.SrkItem.from_certificate" href="#spsdk.image.SrkItem.from_certificate">from_certificate</a></code></li>
<li><code><a title="spsdk.image.SrkItem.info" href="#spsdk.image.SrkItem.info">info</a></code></li>
<li><code><a title="spsdk.image.SrkItem.key_length" href="#spsdk.image.SrkItem.key_length">key_length</a></code></li>
<li><code><a title="spsdk.image.SrkItem.parse" href="#spsdk.image.SrkItem.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SrkItem.size" href="#spsdk.image.SrkItem.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.SrkTable" href="#spsdk.image.SrkTable">SrkTable</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.SrkTable.append" href="#spsdk.image.SrkTable.append">append</a></code></li>
<li><code><a title="spsdk.image.SrkTable.export" href="#spsdk.image.SrkTable.export">export</a></code></li>
<li><code><a title="spsdk.image.SrkTable.export_fuses" href="#spsdk.image.SrkTable.export_fuses">export_fuses</a></code></li>
<li><code><a title="spsdk.image.SrkTable.get_fuse" href="#spsdk.image.SrkTable.get_fuse">get_fuse</a></code></li>
<li><code><a title="spsdk.image.SrkTable.info" href="#spsdk.image.SrkTable.info">info</a></code></li>
<li><code><a title="spsdk.image.SrkTable.parse" href="#spsdk.image.SrkTable.parse">parse</a></code></li>
<li><code><a title="spsdk.image.SrkTable.size" href="#spsdk.image.SrkTable.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.TrustZone" href="#spsdk.image.TrustZone">TrustZone</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.TrustZone.CONFIG_FILE" href="#spsdk.image.TrustZone.CONFIG_FILE">CONFIG_FILE</a></code></li>
<li><code><a title="spsdk.image.TrustZone.PRESET_DIR" href="#spsdk.image.TrustZone.PRESET_DIR">PRESET_DIR</a></code></li>
<li><code><a title="spsdk.image.TrustZone.custom" href="#spsdk.image.TrustZone.custom">custom</a></code></li>
<li><code><a title="spsdk.image.TrustZone.disabled" href="#spsdk.image.TrustZone.disabled">disabled</a></code></li>
<li><code><a title="spsdk.image.TrustZone.enabled" href="#spsdk.image.TrustZone.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.TrustZone.export" href="#spsdk.image.TrustZone.export">export</a></code></li>
<li><code><a title="spsdk.image.TrustZone.get_families" href="#spsdk.image.TrustZone.get_families">get_families</a></code></li>
<li><code><a title="spsdk.image.TrustZone.get_latest_revision" href="#spsdk.image.TrustZone.get_latest_revision">get_latest_revision</a></code></li>
<li><code><a title="spsdk.image.TrustZone.get_revisions" href="#spsdk.image.TrustZone.get_revisions">get_revisions</a></code></li>
<li><code><a title="spsdk.image.TrustZone.sanitize_revision" href="#spsdk.image.TrustZone.sanitize_revision">sanitize_revision</a></code></li>
<li><code><a title="spsdk.image.TrustZone.validate_custom_data" href="#spsdk.image.TrustZone.validate_custom_data">validate_custom_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.TrustZoneType" href="#spsdk.image.TrustZoneType">TrustZoneType</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.TrustZoneType.CUSTOM" href="#spsdk.image.TrustZoneType.CUSTOM">CUSTOM</a></code></li>
<li><code><a title="spsdk.image.TrustZoneType.DISABLED" href="#spsdk.image.TrustZoneType.DISABLED">DISABLED</a></code></li>
<li><code><a title="spsdk.image.TrustZoneType.ENABLED" href="#spsdk.image.TrustZoneType.ENABLED">ENABLED</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>