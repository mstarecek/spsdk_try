<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.image.images API documentation</title>
<meta name="description" content="Image." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.image.images</code></h1>
</header>
<section id="section-intro">
<p>Image.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2017-2018 Martin Olejar
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

&#34;&#34;&#34;Image.&#34;&#34;&#34;

from datetime import datetime, timezone
from io import BytesIO, BufferedReader, SEEK_END, SEEK_CUR
from struct import unpack_from
from typing import Optional, Tuple, Union, Any, List

from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers.aead import AESCCM
from cryptography.hazmat.primitives.serialization import Encoding

from spsdk.utils.crypto import crypto_backend
from spsdk.utils.easy_enum import Enum
from spsdk.utils.misc import DebugInfo
from spsdk.utils.misc import align, align_block, extend_block
from .commands import CmdAuthData, CmdInstallKey
from .commands import EnumInsKey, EnumCertFormat, EnumAlgorithm, EnumAuthDat, EnumEngine
from .header import Header, Header2, UnparsedException
from .misc import read_raw_data, read_raw_segment
from .secret import Signature, CertificateImg, MAC, SrkTable
from .segments import SegTag, SegIVT2, SegBDT, SegAPP, SegDCD, SegCSF, SegIVT3a, SegIVT3b, SegBDS3a, SegBDS3b, \
    SegBIC1, AbstractFCB, FlexSPIConfBlockFCB, PaddingFCB, SegBEE


########################################################################################################################
# i.MX Boot Image Classes
########################################################################################################################

class EnumAppType(Enum):
    &#34;&#34;&#34;Type of the application image.&#34;&#34;&#34;
    SCFW = 1
    M4_0 = 2
    M4_1 = 3
    APP = 4  # actually this means APP or A35 or A53
    A72 = 5
    SCD = 6


class BootImgBase:
    &#34;&#34;&#34;IMX Boot Image Base.&#34;&#34;&#34;

    def __init__(self, address: int, offset: int) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        &#34;&#34;&#34;
        self.address = address
        self.offset = offset
        self._dcd: Optional[SegDCD] = None

    @property
    def dcd(self) -&gt; Optional[SegDCD]:
        &#34;&#34;&#34;Device configuration data (DCD) segment; None if not assigned.&#34;&#34;&#34;
        return self._dcd

    @dcd.setter
    def dcd(self, value: SegDCD) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new DCD segment
        &#34;&#34;&#34;
        assert isinstance(value, SegDCD)
        self._dcd = value

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        raise NotImplementedError()

    def add_image(self, data: bytes, img_type: EnumAppType, address: int) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw binary data of the application image
        :param img_type: see EnumAppType
        :param address: TBD
        &#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Binary representation of the instance (serialization).&#34;&#34;&#34;
        raise NotImplementedError()

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0x100,
              size: Optional[int] = None) -&gt; &#39;BootImgBase&#39;:
        &#34;&#34;&#34;Parse of IMX Boot Image Base.&#34;&#34;&#34;
        raise NotImplementedError()


########################################################################################################################
# Boot Image V1 Segments (i.MX5)
########################################################################################################################

# Obsolete, will not be implemented

########################################################################################################################
# Boot Image V2 (i.MX-RT)
########################################################################################################################

# pylint: disable=too-many-public-methods
class BootImgRT(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v2.&#34;&#34;&#34;

    # offset of the BEE PRDB Header segment
    BEE_OFFSET = 0x400
    # IVT offset for NOR flash
    IVT_OFFSET_NOR_FLASH = 0x1000
    # IVT offset for other memories
    IVT_OFFSET_OTHER = 0x400
    # supported IVT offsets
    IVT_OFFSETS = (IVT_OFFSET_OTHER, IVT_OFFSET_NOR_FLASH)
    # list of supported versions
    VERSIONS = (0x40, 0x41, 0x42, 0x43)
    # The offset and align value of APP segment (for XIP and non-XIP image)
    XIP_APP_OFFSET = 0x2000
    NON_XIP_APP_OFFSET = 0x1000
    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The length of BDT segment
    BDT_SIZE = 0x20
    # The length of DEK key section; Note: Dek key is just 16 bytes
    DEK_SIZE = 0x200  # TODO this is sector size alignment???

    def __init__(self, address: int, offset: int = IVT_OFFSET_NOR_FLASH, version: int = 0x40,
                 plugin: bool = False):
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory, where the image is executed
        :param offset: The IVT offset; use IVT_OFFSET_NOR_FLASH for NOR-FLASH or IVT_OFFSET_OTHER
        :param version: The version of boot img format; default value should be used
        :param plugin: Do not use; see `self.plugin` property
        &#34;&#34;&#34;
        assert offset in BootImgRT.IVT_OFFSETS
        assert version in self.VERSIONS
        assert plugin is False  # not supported yet
        super().__init__(address, offset)
        self._nonce: Optional[bytes] = None
        self._dek_key: Optional[bytes] = None
        self._mac: Optional[bytes] = None
        self._fcb: AbstractFCB = PaddingFCB(self.IVT_OFFSET_OTHER)
        self._bee: SegBEE = SegBEE([])
        self._ivt: SegIVT2 = SegIVT2(version)
        self._bdt: SegBDT = SegBDT(plugin=int(plugin))
        self._app: SegAPP = SegAPP()
        self._dcd: Optional[SegDCD] = None
        self._csf: Optional[SegCSF] = None

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of the image format; must be from BootImgRT.VERSIONS.&#34;&#34;&#34;
        return self._ivt.version

    @property
    def dek_key(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;DEK key for encrypted images; None for non-encrypted images.&#34;&#34;&#34;
        return self._dek_key

    @dek_key.setter
    def dek_key(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: DEK key for encrypted images
        &#34;&#34;&#34;
        assert len(value) == MAC.AES128_BLK_LEN
        self._dek_key = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Flag whether it is plugin image type; It is not fully supported by SPSDK yet.

        Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.
        &#34;&#34;&#34;
        return bool(self._bdt.plugin)

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;Image Vector Table (IVT) segment.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new value
        &#34;&#34;&#34;
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def ivt_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of the Image Vector Table (IVT) in the image.&#34;&#34;&#34;
        return self.offset

    @ivt_offset.setter
    def ivt_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new IVT offset
        &#34;&#34;&#34;
        assert value in self.IVT_OFFSETS
        self.offset = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;Boot Data Table.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new BDT value
        &#34;&#34;&#34;
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;Segment with application image.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new application image
        &#34;&#34;&#34;
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; Optional[SegCSF]:
        &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new CSF
        &#34;&#34;&#34;
        assert isinstance(value, SegCSF)
        self._csf = value
        self._update()

    @property
    def enabled_csf(self) -&gt; Optional[SegCSF]:
        &#34;&#34;&#34;Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.&#34;&#34;&#34;
        return None if (self.csf is None) or not self.csf.enabled else self.csf

    @property
    def fcb(self) -&gt; AbstractFCB:
        &#34;&#34;&#34;Flash Configuration(Control) Block, binary data; content depends on FLASH type.&#34;&#34;&#34;
        return self._fcb

    @fcb.setter
    def fcb(self, fcb: AbstractFCB) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param fcb: FCB instance to be set
        &#34;&#34;&#34;
        assert isinstance(fcb, AbstractFCB)
        self._fcb = fcb

    def set_flexspi_fcb(self, data: Union[bytes, FlexSPIConfBlockFCB]) -&gt; None:
        &#34;&#34;&#34;Set FlexSPI external FLASH configuration.

        :param data: FlexSPIConfBlockFCB or binary data representing
        :raise ValueError: if data are not valid Flex SPI configuration block
        &#34;&#34;&#34;
        self.fcb = data if isinstance(data, FlexSPIConfBlockFCB) else FlexSPIConfBlockFCB.parse(data)

    @property
    def bee(self) -&gt; SegBEE:
        &#34;&#34;&#34;:return: BEE segment that contains configuration of encrypted XIP.

        By default, BEE segment is empty. PRDB regions may be specified only for XIP images.
        &#34;&#34;&#34;
        return self._bee

    @property
    def app_offset(self) -&gt; int:
        &#34;&#34;&#34;:return: offset in the binary image, where the application starts.

        Please mind: the offset include FCB block (even the FCB block is not exported)
        The offset is 0x2000 for XIP images and 0x1000 for non-XIP images
        &#34;&#34;&#34;
        return BootImgRT.XIP_APP_OFFSET if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) \
            else BootImgRT.NON_XIP_APP_OFFSET

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the exported binary data.

        Please mind, FCB is exported optionally, but it is always included in the size
        &#34;&#34;&#34;
        if self.fcb.enabled:
            result = self.app_offset + self.app.space
        else:
            result = self.app_offset + self.app.space - self.ivt_offset
        if (self.csf is not None) and self.csf.enabled:
            result += self.csf.space
        return result

    def _update(self) -&gt; None:
        &#34;&#34;&#34;Update Image Object.&#34;&#34;&#34;
        # fcb
        self.fcb.padding_len = self.BEE_OFFSET - self.fcb.size if self.fcb.enabled else 0
        # bee
        if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) and self.fcb.enabled:
            self.bee.padding_len = self.ivt_offset - self.BEE_OFFSET - self.bee.size
        else:
            self.bee.padding_len = 0
        self.bee.update()
        # padding for APP sections
        self.app.padding_len = 0
        # Set IVT section
        self.ivt.padding_len = 0
        self.ivt.ivt_address = self.address + self.ivt_offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        self.ivt.dcd_address = 0
        self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.address
        self.bdt.app_length = self.app_offset + self.app.size
        self.bdt.plugin = 1 if self.plugin else 0
        self.bdt.padding_len = self.BDT_SIZE - self.bdt.size
        if self.dcd is not None:
            self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
            self.dcd.padding_len = 0
        csf = self.enabled_csf
        if csf:
            self._update_csf(csf)

    @property
    def dek_ram_address(self) -&gt; int:
        &#34;&#34;&#34;Address of the DEK key in the RAM memory retrieved from the corresponding command.

        -1 if the image does not contain command for DEK key installation
        &#34;&#34;&#34;
        csf = self.enabled_csf
        if csf:
            for cmd in csf.commands:
                if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                    return cmd.cmd_data_location
        return -1

    @property
    def dek_img_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of the DEK key in the image; -1 if DEK key address is available (see `dek_ram_address`).&#34;&#34;&#34;
        result = self.dek_ram_address
        return result if result &lt; 0 else result - self.address

    def _update_csf(self, csf: SegCSF) -&gt; None:
        &#34;&#34;&#34;Update CSF segment.

        :param csf: CSF segment tu be updated
        &#34;&#34;&#34;
        self.app.padding_len = align(self.app.size, 0x1000) - self.app.size
        csf.update(True)
        self.ivt.csf_address = self.address + self.app_offset + self.app.space
        csf.padding_len = self.CSF_SIZE - csf.size
        self.bdt.app_length = self.app_offset + self.app.space + csf.space
        if self.hab_encrypted:
            # calculate address of a DEK key
            for cmd in csf.commands:
                if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                    cmd.cmd_data_location = self.address + self.bdt.app_length
            #
            self.bdt.app_length += self.DEK_SIZE  # to include DEK
            # update encryption signature
            assert self._nonce
            assert self._mac
            for mac in csf.macs:
                mac.update_aead_encryption_params(self._nonce, self._mac)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        self._update()
        # Print FCB
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# FCB (Flash Configuration Block)\n&#34;
        msg += self.fcb.info()
        # Print BEE
        if self.bee_encrypted:
            msg = &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# BEE (Encrypted XIP configuration)\n&#34;
            msg += self.bee.info()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if (self.dcd is not None) and self.dcd.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        csf = self.enabled_csf
        if csf:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = -1,
                  dek_key: Optional[bytes] = None, nonce: Optional[bytes] = None) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: value must be EnumAppType.APP, no other options supported in this class
        :param address: start address of the application (entry point); Use -1 to detect the address from the image
        :param dek_key: key for AES128 image HAB encryption [16 bytes],
                    - use None for non-encrypted images;
                    - use empty bytes to create random key (recommended)
                    - use fixed key for testing to produce stable output
        :param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
                        For non-encrypted image use `None`
                        The parameter should be used only for testing to produce stable output
        :raise ValueError: if any parameter is not valid
        &#34;&#34;&#34;
        assert img_type == EnumAppType.APP
        if self.app.data:
            raise ValueError(&#39;Image was already added&#39;)
        entry_addr = unpack_from(&#39;&lt;I&#39;, data, 4)[0]
        if entry_addr == 0:  # there can be padding for images located in RAM, see flashloader
            entry_addr = address
            assert entry_addr &gt; 0, &#39;entry_addr not detected from image, must be specified explicitly&#39;
        elif (address &gt;= 0) and (address != entry_addr):
            raise ValueError(&#39;entry_address does not match with the image&#39;)
        self._ivt.app_address = entry_addr
        self.app.data = data
        if dek_key is not None:  # encrypted?
            # initialize DEK key
            self._dek_key = bytes([0]) * MAC.AES128_BLK_LEN if len(dek_key) == 0 else dek_key
            if len(self._dek_key) != MAC.AES128_BLK_LEN:
                raise ValueError(f&#39;Invalid dek_key length, expected {MAC.AES128_BLK_LEN} bytes&#39;)
            # initialize NONCE
            if nonce:
                self._nonce = nonce
            nonce_len = BootImgRT.aead_nonce_len(self.app.size)
            if self._nonce is None:
                self._nonce = crypto_backend().random_bytes(nonce_len)
            elif len(self._nonce) != nonce_len:
                raise ValueError(f&#39;Invalid nonce length, expected {nonce_len} bytes&#39;)
            # encrypt APP
            assert self.hab_encrypted
            self.app.data = self._hab_encrypt_app_data(align_block(data, MAC.AES128_BLK_LEN))
        else:
            assert nonce is None

    def add_dcd_bin(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;Add DCD binary data.

        :param data: DCD binary data to be added
        &#34;&#34;&#34;
        assert self.dcd is None
        self.dcd = SegDCD.parse(data)
        assert self.dcd  # must be enabled to include DCD into export

    def add_csf_standard_auth(self, version: int, srk_table: SrkTable, src_key_index: int,
                              csf_cert: bytes, csf_priv_key: bytes,
                              img_cert: bytes, img_priv_key: bytes) -&gt; None:
        &#34;&#34;&#34;Add CSF with standard authentication.

        Before calling, application image and address must be assigned

        :param version: CSF segment version
        :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
        :param src_key_index: index of selected SRK key used for authentication
        :param csf_cert: CSF certificate
        :param csf_priv_key: CSF private key; decrypted binary data in PEM format
        :param img_cert: IMG certificate
        :param img_priv_key: IMG private key; decrypted binary data in PEM format
        &#34;&#34;&#34;
        assert 1 &lt;= len(srk_table) &lt;= 4
        assert 0 &lt;= src_key_index &lt; len(srk_table)
        csf = SegCSF(version=version, enabled=True)
        # install SRK
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
        cmd_ins.cmd_data_reference = srk_table
        csf.append_command(cmd_ins)
        # install CSF certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
        cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate content of the CSF segment
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=csf_priv_key)
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install image certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
        cert = x509.load_pem_x509_certificate(img_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate image data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=img_priv_key)
        cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
        if self.dcd:
            cmd_auth.append(self.address + self.ivt_offset + SegIVT2.SIZE + BootImgRT.BDT_SIZE, self.dcd.size)
        app_data = self.app.data
        assert app_data is not None
        cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        self.csf = csf

    @property
    def bee_encrypted(self) -&gt; bool:
        &#34;&#34;&#34;True if BEE encrypted XIP image (with SW keys); False otherwise; see also `hab_encrypted`.&#34;&#34;&#34;
        return self.bee.size &gt; 0

    @property
    def hab_encrypted(self) -&gt; bool:
        &#34;&#34;&#34;True if HAB encrypted; False otherwise; see also `bee_encrypted`.&#34;&#34;&#34;
        return self._dek_key is not None

    @staticmethod
    def aead_nonce_len(app_data_len: int) -&gt; int:
        &#34;&#34;&#34;Nonce len for AEAD encryption.

        Note: The code was taken from CST tool
        &#34;&#34;&#34;
        if app_data_len &lt; 0x10000:
            len_bytes = 2
        elif app_data_len &lt; 0x1000000:
            len_bytes = 3
        else:
            len_bytes = 4
        return 16 - 1 - len_bytes  # AES_BLOCK_BYTES - FLAG_BYTES - len_bytes

    def _hab_encrypt_app_data(self, app_data: bytes) -&gt; bytes:
        &#34;&#34;&#34;HAB Encrypt application data.

        :param app_data: application data to be encrypted
        :return: encrypted application data (using HAB encryption)
        &#34;&#34;&#34;
        assert self._nonce is not None
        assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
        dek = self.dek_key
        assert dek is not None
        aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
        encr = aesccm.encrypt(self._nonce, app_data, b&#39;&#39;)
        assert len(encr) == len(app_data) + 16
        self._mac = encr[-16:]
        return encr[:-16]

    @property
    def decrypted_app_data(self) -&gt; bytes:
        &#34;&#34;&#34;Return decrypted binary application data.

        Note: dek key, mac and nonce must be assigned for decryption
        &#34;&#34;&#34;
        app_data = self.app.data
        assert app_data
        if not self.hab_encrypted:
            return app_data

        assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
        mac = self._mac
        dek = self.dek_key
        assert mac and self._nonce and dek
        aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
        res = aesccm.decrypt(self._nonce, app_data + mac, b&#39;&#39;)
        return res

    def add_csf_encrypted(self, version: int, srk_table: SrkTable, src_key_index: int,
                          csf_cert: bytes, csf_priv_key: bytes,
                          img_cert: bytes, img_priv_key: bytes) -&gt; None:
        &#34;&#34;&#34;Add CSF with image encryption.

        Before calling, application image and address must be assigned

        :param version: CSF segment version
        :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
        :param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
        :param csf_cert: CSF certificate
        :param csf_priv_key: CSF private key; decrypted binary data in PEM format
        :param img_cert: IMG certificate
        :param img_priv_key: IMG private key; decrypted binary data in PEM format
        &#34;&#34;&#34;
        assert 1 &lt;= len(srk_table) &lt;= 4
        assert 0 &lt;= src_key_index &lt; len(srk_table)
        csf = SegCSF(version=version, enabled=True)
        # install SRK
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
        cmd_ins.cmd_data_reference = srk_table
        csf.append_command(cmd_ins)
        # install CSF certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
        cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate content of the CSF segment
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=csf_priv_key)
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install image certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
        cert = x509.load_pem_x509_certificate(img_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate image data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS,
                               EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
        cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
        app_data = self.app.data
        assert app_data is not None
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install DEK key
        cmd_ins = CmdInstallKey(EnumInsKey.ABS, EnumCertFormat.BLOB, EnumAlgorithm.ANY, 0, 0)
        csf.append_command(cmd_ins)
        # check encrypted data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 0, EnumCertFormat.AEAD,
                               EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
        assert app_data is not None
        cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
        cmd_auth.cmd_data_reference = MAC(version=version, nonce_len=0xD, mac_len=16)
        csf.append_command(cmd_auth)
        #
        self.csf = csf

    def _export_fcb_bee(self, dbg_info: DebugInfo) -&gt; bytes:
        &#34;&#34;&#34;Export FCB and BEE segments.

        :param dbg_info: optional instance to provide info about exported data
        :return: binary FCB segment and BEE regions
        :raise ValueError: if any BEE region is configured for images not located in the FLASH
        &#34;&#34;&#34;
        if not self.fcb.enabled:
            return b&#39;&#39;
        data = self.fcb.export(dbg_info=dbg_info)
        assert len(data) == self.fcb.space
        if self.ivt_offset == self.IVT_OFFSET_NOR_FLASH:
            data += self.bee.export(dbg_info=dbg_info)
        elif self.bee.space &gt; 0:
            raise ValueError(&#39;BEE can be configured only for XIP images located in FLASH&#39;)
        return data

    def _bee_encrypt_img_data(self, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt data located in BEE regions.

        :param data: image data (including IVT offset) to be encrypted
        :return: the image with encrypted regions
        :raise ValueError: if image configuration is invalid and BEE encryption cannot be applied
        &#34;&#34;&#34;
        if not self.bee_encrypted:
            return data

        if self.ivt_offset != self.IVT_OFFSET_NOR_FLASH:
            raise ValueError(&#39;BEE encryption is supported only for NOR FLASH&#39;)
        if self.hab_encrypted:
            raise ValueError(&#39;BEE encryption cannot be used for HAB encrypted images&#39;)

        # encrypt
        return data[:self.ivt_offset] + self.bee.encrypt_data(self.address + self.ivt_offset, data[self.ivt_offset:])

    def export(self, zulu: datetime = datetime.now(timezone.utc),
               dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export image as bytes array.

        :param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
                Note: the parameter is applied to CSF only, so it is not used for unsigned images
        :param dbg_info: optional instance to provide info about exported data
        :raises ValueError: If the image is not encrypted
        :return: bytes
        &#34;&#34;&#34;
        csf = self.enabled_csf
        if csf:
            csf.update_signatures(zulu, b&#39;&#39;, 0)  # dummy call to provide size of the CSF section
        elif self.dek_key is not None:
            raise ValueError(&#39;CSF must be assigned for encrypted images&#39;)

        self._update()
        dbg_info.append_section(&#39;RT10xxBootableImage&#39;)
        # FCB + BEE
        data = self._export_fcb_bee(dbg_info)

        # IVT
        ivt_data = self.ivt.export()
        data += ivt_data
        dbg_info.append_binary_section(&#39;IVT&#39;, ivt_data)
        # BDT
        bdt_data = self.bdt.export()
        data += bdt_data
        dbg_info.append_binary_section(&#39;BDT&#39;, bdt_data)
        # DCD
        if (self.dcd is not None) and self.dcd.enabled:
            assert self.dcd.padding_len == 0  # no padding
            dcd_data = self.dcd.export()
            data += dcd_data
            dbg_info.append_binary_section(&#39;DCD&#39;, dcd_data)
        # padding before APP
        app_alignment = self.app_offset if self.fcb.enabled else self.app_offset - self.ivt_offset
        assert app_alignment &gt;= len(data)
        data = extend_block(data, app_alignment)
        # APP
        app_data = self.app.export()
        data += app_data
        dbg_info.append_binary_section(&#39;APP&#39;, app_data)
        # CSF
        if csf:
            if dbg_info:
                dbg_info.append_section(&#39;CSF&#39;)
            base_data_addr = self.address if self.fcb.enabled else self.address + self.ivt_offset
            csf.update_signatures(zulu, data, base_data_addr)
            data += csf.export(dbg_info=dbg_info)

        return self._bee_encrypt_img_data(data)

    @classmethod
    def _find_ivt_pos(cls, strm: Union[BufferedReader, BytesIO], size: Optional[int] = None) -&gt; Tuple[Header, int, int]:
        &#34;&#34;&#34;Search IVT start position in the image; used by parser.

        :param strm: of image data; start seeking from current position
        :param size: maximum length
        :raise ValueError: Raised when IVT is not found
        :return: tuple with: Header, start position, end position
        &#34;&#34;&#34;
        start_pos = strm.tell()
        end_pos = strm.seek(0, SEEK_END)

        if size:
            end_pos = min(start_pos + size, end_pos)

        for ivt_ofs in [0] + list(cls.IVT_OFFSETS):

            if start_pos + ivt_ofs &gt; end_pos:
                break
            strm.seek(start_pos + ivt_ofs)
            header_data = read_raw_data(strm, Header.SIZE, no_seek=True)
            try:
                header = Header.parse(header_data, required_tag=SegTag.IVT2)
                if (header.length == SegIVT2.SIZE) and (header.param in cls.VERSIONS):
                    return header, start_pos + ivt_ofs, end_pos
            except UnparsedException:  # ignore different header tags
                pass

        raise ValueError(&#34;IVT not found&#34;)

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0,
              size: Optional[int] = None) -&gt; &#39;BootImgRT&#39;:
        &#34;&#34;&#34;Parse bootable RT image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step (this parameter is not used for RT)
        :param size: parsing size; None to parse till the end of the stream
        :raises TypeError: Raised when the value type is incorrect
        :return: BootImgRT object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

        header, start_pos, end_pos = cls._find_ivt_pos(stream, size)

        obj = BootImgRT(0, version=header.param)
        img_size = end_pos - start_pos
        if start_pos &gt; 0:
            obj.ivt_offset = start_pos

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        stream.seek(start_pos + obj.ivt.bdt_address - obj.ivt.ivt_address)
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.ivt_offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        # Parse DCD
        if obj.ivt.dcd_address:
            stream.seek(start_pos + obj.ivt.dcd_address - obj.ivt.ivt_address)
            dcd_obj = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd = dcd_obj
            dcd_obj.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - dcd_obj.size
        # Parse APP
        if obj.ivt.csf_address &gt; 0:
            app_size = obj.ivt.csf_address - obj.ivt.ivt_address - (obj.app_offset - obj.ivt_offset)
        else:
            app_size = img_size - (obj.app_offset - obj.ivt_offset)
        obj.app.data = read_raw_data(stream, app_size, obj.app_offset - obj.ivt_offset + start_pos)
        obj.app.padding = 0
        # Parse CSF
        if obj.ivt.csf_address:
            csf_start = start_pos + (obj.ivt.csf_address - obj.ivt.ivt_address)
            obj.csf = SegCSF.parse(read_raw_data(stream, cls.CSF_SIZE, csf_start))
            # detect encrypted image using MAC section
            mac = next(obj.csf.macs, None)
            if mac:
                obj._nonce = mac.nonce
                obj._mac = mac.mac
                obj._dek_key = bytes([0]) * MAC.AES128_BLK_LEN  # dek key is not known

        # Parse FCB
        fcb_size = FlexSPIConfBlockFCB().size
        if start_pos &gt;= fcb_size:
            fcb_data = read_raw_data(stream, fcb_size, 0)
            if fcb_data == b&#39;\x00&#39; * fcb_size:  # test if empty
                obj.fcb = PaddingFCB(fcb_size)
            else:
                obj.set_flexspi_fcb(fcb_data)
        else:
            obj.fcb = PaddingFCB(0, enabled=False)

        return obj


########################################################################################################################
# Boot Image V2 (i.MX6, i.MX7)
########################################################################################################################

class BootImg2(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v2.&#34;&#34;&#34;

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    APP_ALIGN = 0x1000
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC00,
                 0x100: 0x300}

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of IMX Boot Image v2.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plg

    @plugin.setter
    def plugin(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IMX Boot Image v2..&#34;&#34;&#34;
        result = self.ivt.space
        result += self.bdt.space
        if self.dcd:
            result += self.dcd.space
        result += self.app.space
        result += self.csf.space
        return result

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x41, plugin: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        :param plugin: if plugin
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = SegIVT2(version)
        self._bdt = SegBDT()
        self._app = SegAPP()
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = plugin

    def _update(self) -&gt; None:
        &#34;&#34;&#34;Update Image Object.&#34;&#34;&#34;
        # Set zero padding for IVT and BDT sections
        self.ivt.padding = 0
        self.bdt.padding = 0
        # Calculate padding for DCD, APP and CSF sections
        tmp_val = self.ivt.space + self.bdt.space
        if self.dcd:
            tmp_val += self.dcd.size
        head_size = 0xC00 if self.offset not in self.HEAD_SIZE else self.HEAD_SIZE[self.offset]
        if self.dcd:
            self.dcd.padding = head_size - tmp_val
        tmp_val = self.app.size % self.APP_ALIGN
        self.app.padding = self.APP_ALIGN - tmp_val if tmp_val &gt; 0 else 0
        # Set IVT section
        self.ivt.ivt_address = self.address + self.offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        if self.dcd:
            self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
            self.ivt.app_address = self.ivt.dcd_address + self.dcd.space
        else:
            self.ivt.dcd_address = 0
            self.ivt.app_address = self.ivt.bdt_address + self.bdt.space
        if self.csf.enabled:
            self.ivt.csf_address = self.ivt.app_address + self.app.space
            self.csf.padding = self.CSF_SIZE - self.csf.size
        else:
            self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.ivt.ivt_address - self.offset
        self.bdt.app_length = self.size + self.offset
        self.bdt.plugin = 1 if self.plugin else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image v2.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print DBI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: Type of img
        :param address: address in RAM
        :raises Exception: Raised when the data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            self.app.data = data
            if address != 0:
                self.address = address
        else:
            raise Exception(&#39;Unknown data type !&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export image as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self._update()
        data = self.ivt.export()
        data += self.bdt.export()
        if self.dcd:
            data += self.dcd.export()
        data += self.app.export()
        data += self.csf.export()
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; &#39;BootImg2&#39;:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when value type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg2 object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)} !&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or \
                    header.length == SegIVT2.SIZE or \
                    header.param in (0x40, 0x41, 0x42, 0x43):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = BootImg2()
        if header.param:
            obj.version = header.param

        img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        obj.plugin = bool(obj.bdt.plugin)
        # Parse DCD
        if obj.ivt.dcd_address:
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
        # Parse APP
        app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
        app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
            obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
        app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
        obj.app.data = read_raw_data(stream, app_size, app_start)
        obj.app.padding = 0
        # Parse CSF
        if obj.ivt.csf_address:
            csf_start = start_index + (obj.ivt.csf_address - obj.ivt.ivt_address)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF, csf_start))
            # obj.csf.padding = csf_start + obj.csf.size

        return obj


########################################################################################################################
# Boot Image V2b (i.MX8M)
########################################################################################################################

class BootImg8m(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image.&#34;&#34;&#34;

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    APP_ALIGN = 0x1000
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC00,
                 0x100: 0x300}

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of IMX Boot Image.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plg

    @plugin.setter
    def plugin(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IMX Boot Image.&#34;&#34;&#34;
        result = self.ivt.space
        result += self.bdt.space
        if self.dcd:
            result += self.dcd.space
        result += self.app.space
        result += self.csf.space
        return result

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x41, plugin: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        :param plugin: if plugin
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = SegIVT2(version)
        self._bdt = SegBDT()
        self._app = SegAPP()
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = plugin

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        self.ivt.padding = 0
        self.bdt.padding = 0
        # Calculate padding for DCD, APP and CSF sections
        tmp_val = self.ivt.space + self.bdt.space
        if self.dcd:
            tmp_val += self.dcd.size
        head_size = 0xC00 if self.offset not in self.HEAD_SIZE else self.HEAD_SIZE[self.offset]
        if self.dcd:
            self.dcd.padding = head_size - tmp_val
        tmp_val = self.app.size % self.APP_ALIGN
        self.app.padding = self.APP_ALIGN - tmp_val if tmp_val &gt; 0 else 0
        # Set IVT section
        self.ivt.ivt_address = self.address + self.offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        if self.dcd:
            if self.dcd.enabled:
                self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
                self.ivt.app_address = self.ivt.dcd_address + self.dcd.space
            else:
                self.ivt.dcd_address = 0
                self.ivt.app_address = self.ivt.bdt_address + self.bdt.space
        if self.csf.enabled:
            self.ivt.csf_address = self.ivt.app_address + self.app.space
            self.csf.padding = self.CSF_SIZE - self.csf.size
        else:
            self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.ivt.ivt_address - self.offset
        self.bdt.app_length = self.size + self.offset
        self.bdt.plugin = 1 if self.plugin else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print DBI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: Type of img
        :param address: address in RAM
        :raises Exception: raised when data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            self.app.data = data
            if address != 0:
                self.address = address
        else:
            raise Exception(&#39;Unknown data type !&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export Image as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self._update()
        data = self.ivt.export()
        data += self.bdt.export()
        if self.dcd:
            data += self.dcd.export()
        data += self.app.export()
        data += self.csf.export()
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when the value type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg2 object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or \
                    header.length == SegIVT2.SIZE or \
                    header.param in (0x40, 0x41, 0x42, 0x43):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        obj.plugin = bool(obj.bdt.plugin)
        # Parse DCD
        if obj.ivt.dcd_address:
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
        # Parse APP
        app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
        app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
            obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
        app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
        obj.app.data = read_raw_data(stream, app_size, app_start)
        obj.app.padding = 0
        # Parse CSF
        # TODO finalize the code below
        # if obj.ivt.csf_address:
        #    obj.csf = SegCSF.parse(buffer)
        #    obj.csf.padding = obj.bdt.length - ((obj.ivt.csf_address - obj.ivt.ivt_address) + obj.csf.size)

        return obj


########################################################################################################################
# Boot Image V3a: i.MX8QXP-A0
########################################################################################################################

class BootImg3a(BootImgBase):
    &#34;&#34;&#34;i.MX Boot Image v3a.&#34;&#34;&#34;

    IMG_TYPE_CSF = 0x01
    IMG_TYPE_SCD = 0x02
    IMG_TYPE_EXEC = 0x03
    IMG_TYPE_DATA = 0x04

    SCFW_FLAGS_APP = 0x01355FC4
    SCFW_FLAGS_M4_0 = 0x4a5162
    SCFW_FLAGS_M4_1 = 0x4f52a3
    SCFW_FLAGS_SCFW = 0x1

    INITIAL_LOAD_ADDR_SCU_ROM = 0x2000e000
    INITIAL_LOAD_ADDR_AP_ROM = 0x00110000
    INITIAL_LOAD_ADDR_FLEXSPI = 0x08000000

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    IMG_AUTO_ALIGN = 0x10
    SECTOR_SIZE = 0x200
    APP_ALIGN = 0x1200
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC400,
                 0x1000: 0x1400}

    PADDING_VAL = 0x00

    COUNT_OF_CONTAINERS = 2

    @property
    def plg(self) -&gt; bool:
        &#34;&#34;&#34;PLG.&#34;&#34;&#34;
        return self._plg

    @plg.setter
    def plg(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; List[SegIVT3a]:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: List) -&gt; None:
        assert isinstance(value, list) and isinstance(value[0], SegIVT3a)
        self._ivt = value

    @property
    def bdt(self) -&gt; List[SegBDS3a]:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: List) -&gt; None:
        assert isinstance(value, list) and isinstance(value[0], SegBDS3a)
        self._bdt = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x43) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = [SegIVT3a(version), SegIVT3a(version)]
        self._ivt[0].next = self._ivt[0].size
        self._ivt[0].version = 0x01
        self._ivt[1].version = 0x01
        self._bdt = [SegBDS3a(), SegBDS3a()]
        self.app = [[SegAPP() for _ in range(SegBDS3a.IMAGES_MAX_COUNT)],
                    [SegAPP() for _ in range(SegBDS3a.IMAGES_MAX_COUNT)]]
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = False
        if not isinstance(self.address, list):
            self.address = [self.INITIAL_LOAD_ADDR_SCU_ROM, self.INITIAL_LOAD_ADDR_AP_ROM]  # type: ignore
        self._sdc_address = 0

    @staticmethod
    def _compute_padding(size: int, sector_size: int) -&gt; int:
        return ((size // sector_size + (size % sector_size &gt; 0)) * sector_size) - size

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        for container in range(self.COUNT_OF_CONTAINERS):
            self.ivt[container].padding = 0
            self.bdt[container].padding = 0

            # Set IVT section
            self.ivt[container].ivt_address = (self.address[container] + self.offset +  # type: ignore
                                               container * self.ivt[container].size)
            self.ivt[container].bdt_address = (self.ivt[container].ivt_address +
                                               self.ivt[container].space * (self.COUNT_OF_CONTAINERS - container) +
                                               container * self.bdt[container].size)

            if container == 0:
                if self.dcd:
                    self.ivt[container].dcd_address = self.ivt[container].bdt_address + self.bdt[container].space * 2
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].dcd_address + self.dcd.space
                    else:
                        self.ivt[container].csf_address = 0
                else:
                    self.ivt[container].dcd_address = 0
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].bdt_address + \
                                                          self.bdt[container].space * 2
                    else:
                        self.ivt[container].csf_address = 0
            else:
                self.ivt[container].dcd_address = 0
                self.ivt[container].csf_address = 0

            self.app[container][0].padding = self._compute_padding(self.bdt[container].images[0].image_size,
                                                                   self.SECTOR_SIZE)
            if self.bdt[container].images_count != 0:
                self.bdt[container].boot_data_size = self.bdt[container].size
                if container == 0:
                    self.bdt[container].images[0].image_source = self.APP_ALIGN
                else:
                    last_image_index = self.bdt[container - 1].images_count - 1
                    last_image_address = self.bdt[container - 1].images[last_image_index].image_source
                    self.bdt[container].images[0].image_source = (last_image_address +
                                                                  self.app[container - 1][last_image_index].space)
            for i in range(self.bdt[container].images_count - 1):
                self.bdt[container].images[i + 1].image_source = self.bdt[container].images[i].image_source + \
                                                                 self.app[container][i].space
                self.app[container][i + 1].padding = self._compute_padding(self.bdt[container].images[i + 1].image_size,
                                                                           self.SECTOR_SIZE)
            if container == self.COUNT_OF_CONTAINERS - 1:
                self.app[container][self.bdt[container].images_count - 1].padding = 0
                # Set BDT section

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the i.MX Boot Image v3a.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, ivt in enumerate(self.ivt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- IVT[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, bdi in enumerate(self.bdt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- BDI[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += bdi.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of image
        :param img_type: Type of image
        :param address: address in RAM
        :raises Exception: raised when data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            image_index = self.bdt[1].images_count
            self.bdt[1].images[image_index].image_destination = address
            self.bdt[1].images[image_index].image_entry = address
            self.bdt[1].images[image_index].image_size = len(data)
            self.bdt[1].images[image_index].rom_flags = 0
            self.bdt[1].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[1].images[image_index].scfw_flags = self.SCFW_FLAGS_APP
            self.bdt[1].images_count += 1

            self.app[1][image_index].data = data
            self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = address
            self.bdt[0].images[image_index].image_entry = address
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_M4_0 if img_type == EnumAppType.M4_0 else \
                self.SCFW_FLAGS_M4_1
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type == EnumAppType.SCFW:
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = 0x1ffe0000
            self.bdt[0].images[image_index].image_entry = 0x1ffe0000
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_SCFW
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self._sdc_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                                 self._compute_padding(len(data), self.IMG_AUTO_ALIGN))

        elif img_type == EnumAppType.SCD:
            if self._sdc_address == 0:
                raise Exception(&#39;SCFW have to be define before SCD!&#39;)
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = self._sdc_address
            self.bdt[0].images[image_index].image_entry = 0
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_SCD
            self.bdt[0].images[image_index].scfw_flags = 0x1
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        else:
            raise Exception(&#39;Unknown data type!&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export Image as binary blob.&#34;&#34;&#34;
        self._update()
        data = bytes()
        data += self.ivt[0].export()
        data += self.ivt[1].export()
        data += self.bdt[0].export()
        data += self.bdt[1].export()
        if self.dcd:
            data += self.dcd.export()
        data += self.csf.export()
        data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

        for container in range(self.COUNT_OF_CONTAINERS):
            for image in range(self.bdt[container].images_count):
                data += self.app[container][image].export()

        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when the values type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg3a object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT3 or header.length == SegIVT3a.SIZE or \
                    header.param in (0x43,):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        # TODO: not used right now: img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index
        # Parse IVT
        obj.ivt[0] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
        obj.ivt[1] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
        # Parse BDT
        obj.bdt[0] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
        obj.bdt[1] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
        # Parse DCD
        if obj.ivt[0].dcd_address:
            stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        # Parse CSF
        if obj.ivt[0].csf_address:
            stream.seek(start_index + (obj.ivt[0].csf_address - obj.ivt[0].ivt_address), 0)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))
        # Parse IMAGES
        for container in range(obj.COUNT_OF_CONTAINERS):
            for i in range(obj.bdt[container].images_count):
                stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
                obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)

        return obj


########################################################################################################################
# Boot Image V3b: i.MX8QM-A0
########################################################################################################################

class BootImg3b(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v3b.&#34;&#34;&#34;

    IMG_TYPE_CSF = 0x01
    IMG_TYPE_SCD = 0x02
    IMG_TYPE_EXEC = 0x03
    IMG_TYPE_DATA = 0x04

    SCFW_FLAGS_A53 = 0x1354014
    SCFW_FLAGS_A72 = 0x1354065
    SCFW_FLAGS_M4_0 = 0x4a5162
    SCFW_FLAGS_M4_1 = 0x4f52a3
    SCFW_FLAGS_SCFW = 0x1

    INITIAL_LOAD_ADDR_SCU_ROM = 0x2000e000
    INITIAL_LOAD_ADDR_AP_ROM = 0x00110000
    INITIAL_LOAD_ADDR_FLEXSPI = 0x08000000

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value for img
    IMG_AUTO_ALIGN = 0x10
    # The align value for sector
    SECTOR_SIZE = 0x200
    # The align value of APP segment
    APP_ALIGN = 0x1200

    PADDING_VAL = 0x00
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC400,
                 0x1000: 0x1400}

    COUNT_OF_CONTAINERS = 2

    @property
    def plg(self) -&gt; bool:
        &#34;&#34;&#34;PLG.&#34;&#34;&#34;
        return self._plg

    @plg.setter
    def plg(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; List[SegIVT3b]:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: List) -&gt; None:
        assert isinstance(value, list)
        assert len(value) == self.COUNT_OF_CONTAINERS
        assert isinstance(value[0], SegIVT3b)
        self._ivt = value

    @property
    def bdt(self) -&gt; List[SegBDS3b]:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: List) -&gt; None:
        assert isinstance(value, list)
        assert len(value) == self.COUNT_OF_CONTAINERS
        assert isinstance(value[0], SegBDS3b)
        self._bdt = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x43) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = [SegIVT3b(version), SegIVT3b(version)]
        self._bdt = [SegBDS3b(), SegBDS3b()]
        self.app = [[SegAPP() for _ in range(SegBDS3b.IMAGES_MAX_COUNT)],
                    [SegAPP() for _ in range(SegBDS3b.IMAGES_MAX_COUNT)]]
        self._dcd = SegDCD()
        self.scd = SegAPP()
        self._csf = SegCSF()
        self._plg = False
        self._scd_address = 0
        if not isinstance(self.address, int):
            self.address = [self.INITIAL_LOAD_ADDR_SCU_ROM, self.INITIAL_LOAD_ADDR_AP_ROM]  # type: ignore

    @staticmethod
    def _compute_padding(image_size: int, sector_size: int) -&gt; int:
        return ((image_size // sector_size + (image_size % sector_size &gt; 0)) * sector_size) - image_size

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        for container in range(self.COUNT_OF_CONTAINERS):
            self.ivt[container].padding = 0
            self.bdt[container].padding = 0

            # Set IVT section
            self.ivt[container].ivt_address = (self.address[container] + self.offset +  # type: ignore
                                               container * self.ivt[container].size)
            self.ivt[container].bdt_address = (self.ivt[container].ivt_address +
                                               self.ivt[container].space * (2 - container) +
                                               container * self.bdt[container].size)
            if container == 0:
                if self.dcd:
                    self.ivt[container].dcd_address = self.ivt[container].bdt_address + self.bdt[container].space * 2
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].dcd_address + self.dcd.space
                    else:
                        self.ivt[container].csf_address = 0
                else:
                    self.ivt[container].dcd_address = 0
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].bdt_address + \
                                                          self.bdt[container].space * 2
                    else:
                        self.ivt[container].csf_address = 0
            else:
                self.ivt[container].dcd_address = 0
                self.ivt[container].csf_address = 0

            self.app[container][0].padding = self._compute_padding(self.bdt[container].images[0].image_size,
                                                                   self.SECTOR_SIZE)
            if self.bdt[container].images_count != 0:
                self.bdt[container].boot_data_size = self.bdt[container].size
                if container == 0:
                    self.bdt[container].images[0].image_source = self.APP_ALIGN
                else:
                    last_image_index = self.bdt[container - 1].images_count - 1
                    last_image_address = self.bdt[container - 1].images[last_image_index].image_source
                    self.bdt[container].images[0].image_source = (last_image_address +
                                                                  self.app[container - 1][last_image_index].space)
            next_image_address = 0
            for i in range(self.bdt[container].images_count - 1):
                self.bdt[container].images[i + 1].image_source = self.bdt[container].images[i].image_source + \
                                                                 self.app[container][i].space
                self.app[container][i + 1].padding = self._compute_padding(
                    self.bdt[container].images[i + 1].image_size, self.SECTOR_SIZE)
                next_image_address = self.bdt[container].images[i + 1].image_source + self.app[container][i + 1].space

            if container == 0:
                if self.bdt[container].scd.image_destination != 0:
                    self.bdt[container].scd.image_source = next_image_address
                    self.scd.padding = self._compute_padding(self.bdt[0].scd.image_size, self.SECTOR_SIZE)
                    next_image_address += self.scd.space
                    # Set BDT section

                if self.csf.enabled:
                    self.bdt[container].csf.image_source = next_image_address
                    self.csf.padding = self._compute_padding(self.bdt[0].csf.image_size, self.SECTOR_SIZE)
                    next_image_address += self.csf.space
                    # Set BDT section

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image v3b.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, ivt in enumerate(self.ivt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- IVT[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, bdi in enumerate(self.bdt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- BDI[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += bdi.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of image
        :param img_type: Type of image
        :param address: address in RAM
        :raises Exception: raised SCFW is not defined before SCD
        :raises Exception: raised when there is unknown image type
        &#34;&#34;&#34;
        if img_type in (EnumAppType.APP, EnumAppType.A72):
            image_index = self.bdt[1].images_count
            self.app[1][image_index].data = data

            self.bdt[1].images[image_index].image_destination = address
            self.bdt[1].images[image_index].image_entry = address
            self.bdt[1].images[image_index].image_size = len(data)

            if img_type == EnumAppType.APP:
                self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A53
            elif img_type == EnumAppType.A72:
                self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A72

            self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self.bdt[1].images_count += 1

        elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
            image_index = self.bdt[0].images_count
            self.app[0][image_index].data = data

            self.bdt[0].images[image_index].image_destination = address
            self.bdt[0].images[image_index].image_entry = address
            self.bdt[0].images[image_index].image_size = len(data)

            if img_type == EnumAppType.M4_0:
                self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_0
            elif img_type == EnumAppType.M4_1:
                self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_1

            self.app[0][image_index].padding = ((len(data) // self.SECTOR_SIZE +
                                                 (len(data) % self.SECTOR_SIZE &gt; 0)) * self.SECTOR_SIZE) - len(data)
            self.bdt[0].images_count += 1

        elif img_type == EnumAppType.SCFW:
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = 0x30fe0000
            self.bdt[0].images[image_index].image_entry = 0x1ffe0000
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_SCFW
            self._scd_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                                 self._compute_padding(len(data), self.IMG_AUTO_ALIGN))
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type == EnumAppType.SCD:
            if self._scd_address == 0:
                raise Exception(&#39;SCFW have to be define before SCD!&#39;)
            self.scd.data = data
            self.scd.padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self.bdt[0].scd.image_destination = self._scd_address
            self.bdt[0].scd.image_entry = 0
            self.bdt[0].scd.image_size = len(data)
            self.ivt[0].scd_address = self.bdt[0].scd.image_destination

        else:
            raise Exception(&#39;Unknown image type!&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        # data = bytearray(self._offset)
        data = bytes()
        data += self.ivt[0].export()
        data += self.ivt[1].export()
        data += self.bdt[0].export()
        data += self.bdt[1].export()
        if self.dcd:
            data += self.dcd.export()
        data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

        for container in range(self.COUNT_OF_CONTAINERS):
            for i in range(self.bdt[container].images_count):
                data += self.app[container][i].export()

        if self.bdt[0].scd.image_source != 0:
            data += self.scd.export()

        if self.bdt[0].csf.image_source != 0:
            data += self.csf.export()

        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: When the value is incorrect
        :raises Exception: If there is not an i.MX Boot Image
        :return: BootImg3b object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or header.length == SegIVT3b.SIZE or \
                    header.param in (0x43,):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        # TODO: not used right now: img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index
        # Parse IVT
        obj.ivt[0] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
        obj.ivt[1] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt[0] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
        obj.bdt[1] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
        # Parse DCD
        if obj.ivt[0].dcd_address:
            stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        # Parse IMAGES
        for container in range(obj.COUNT_OF_CONTAINERS):
            for i in range(obj.bdt[container].images_count):
                stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
                obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)
        # Parse SCD
        if obj.bdt[0].scd.image_source != 0:
            stream.seek(obj.bdt[0].scd.image_source - obj.offset, 0)
            obj.scd.data = read_raw_data(stream, obj.bdt[0].scd.image_size)
        # Parse CSF
        if obj.bdt[0].csf.image_source != 0:
            stream.seek(obj.bdt[0].csf.image_source - obj.offset, 0)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))

        return obj


########################################################################################################################
# Boot Image V4: i.MX8DM, i.MX8QM_B0, i.MX8QXP_B0
########################################################################################################################

class BootImg4(BootImgBase):
    &#34;&#34;&#34;i.MX Boot Image v4.&#34;&#34;&#34;

    def __init__(self, address: int = 0, offset: int = 0x400) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of image in target memory
        :param offset: The image offset
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._dcd = SegDCD()
        self._cont1_header = SegBIC1()
        self._cont2_header = SegBIC1()

    def _update(self) -&gt; None:
        pass

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the i.MX Boot Image v4.&#34;&#34;&#34;
        self._update()
        msg = &#34;&#34;
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# Boot Images Container 1\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self._cont1_header.info()
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# Boot Images Container 2\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self._cont2_header.info()
        if self.dcd:
            if self.dcd.enabled:
                msg += &#34;#&#34; * 60 + &#34;\n&#34;
                msg += &#34;# DCD (Device Config Data)\n&#34;
                msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
                msg += self.dcd.info()
        return msg

    def add_image(self, data: bytes, img_type: int, address: int) -&gt; None:
        &#34;&#34;&#34;Not implemented.&#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        data = bytes()
        data += self._cont1_header.export()
        data += self._cont2_header.export()
        # TODO: Complete Implementation
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :return: BootImg4 object
        :raises TypeError: Raised when the value type is incorrect
        :raises Exception: If there is not an i.MX Boot Image
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header2.SIZE, no_seek=True))
            if header.tag == SegTag.BIC1:
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39; Not an i.MX Boot Image !&#39;)

        # TODO: not used right now: img_size = last_index - start_index
        obj = cls()
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse Containers
        obj._cont1_header = SegBIC1.parse(read_raw_data(stream, 0x400))
        obj._cont2_header = SegBIC1.parse(read_raw_data(stream, 0x400))
        # TODO: Complete Implementation
        return obj


########################################################################################################################
# i.MX Kernel Image Classes
########################################################################################################################

class KernelImg:
    &#34;&#34;&#34;IMX Kernel Image.&#34;&#34;&#34;

    IMAGE_MIN_SIZE = 0x1000

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Address.&#34;&#34;&#34;
        return self._ivt.app_address

    @address.setter
    def address(self, value: int) -&gt; None:
        self._ivt.app_address = value

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def app(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app.data

    @app.setter
    def app(self, value: Union[bytes, bytearray]) -&gt; None:
        assert isinstance(value, (bytes, bytearray))
        self._app.data = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, app: Optional[bytes] = None,
                 csf: Union[SegCSF, Any] = None, version: int = 0x41) -&gt; None:
        &#34;&#34;&#34;Initialize the IMX Kernel Image.&#34;&#34;&#34;
        self._ivt = SegIVT2(version)
        self._ivt.app_address = address
        self._app = SegAPP(app)
        self._csf = SegCSF() if csf is None else csf

    def __str__(self) -&gt; str:
        return &#39;&#39;

    def __repr__(self) -&gt; str:
        return &#39;&#39;

    def _update(self) -&gt; None:
        pass

    def info(self) -&gt; None:
        &#34;&#34;&#34;String representation of the IMX Kernel Image.&#34;&#34;&#34;
        pass

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        data = self._app.export()
        data += self._ivt.export()
        data += self._csf.export()
        return data

    @classmethod
    def parse(cls, data: Union[str, bytes]) -&gt; None:
        &#34;&#34;&#34;Parse.&#34;&#34;&#34;
        assert isinstance(data, (bytes, str))
        assert len(data) &gt; cls.IMAGE_MIN_SIZE


########################################################################################################################
# i.MX Image Public Methods
########################################################################################################################

def parse(stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Common parser for all versions of i.MX boot images.

    :param stream: stream buffer to image
    :raises TypeError: raised when the format of string is incorrect
    :param step: Image searching step
    :param size: parsing size
    :return: the object of boot image
    :raises Exception: when not i.MX Boot Image is passed
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    # calculate stream size
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    while start_index &lt; (last_index - Header.SIZE):
        raw = read_raw_data(stream, Header.SIZE, no_seek=True)

        if raw[0] == SegTag.IVT2 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT2.SIZE and raw[3] in (0x40, 0x41, 0x42):
            return BootImg2.parse(stream)

        if raw[0] == SegTag.IVT2 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT3b.SIZE and raw[3] in (0x43,):
            return BootImg3b.parse(stream)

        if raw[0] == SegTag.IVT3 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT3a.SIZE and raw[3] in (0x43,):
            return BootImg3a.parse(stream)

        if raw[3] == SegTag.BIC1:
            return BootImg4.parse(stream)

        start_index = stream.seek(step, SEEK_CUR)

    raise Exception(&#39; Not an i.MX Boot Image !&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spsdk.image.images.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:int=None) ><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Common parser for all versions of i.MX boot images.</p>
<p>:param stream: stream buffer to image
:raises TypeError: raised when the format of string is incorrect
:param step: Image searching step
:param size: parsing size
:return: the object of boot image
:raises Exception: when not i.MX Boot Image is passed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Common parser for all versions of i.MX boot images.

    :param stream: stream buffer to image
    :raises TypeError: raised when the format of string is incorrect
    :param step: Image searching step
    :param size: parsing size
    :return: the object of boot image
    :raises Exception: when not i.MX Boot Image is passed
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    # calculate stream size
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    while start_index &lt; (last_index - Header.SIZE):
        raw = read_raw_data(stream, Header.SIZE, no_seek=True)

        if raw[0] == SegTag.IVT2 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT2.SIZE and raw[3] in (0x40, 0x41, 0x42):
            return BootImg2.parse(stream)

        if raw[0] == SegTag.IVT2 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT3b.SIZE and raw[3] in (0x43,):
            return BootImg3b.parse(stream)

        if raw[0] == SegTag.IVT3 and ((raw[1] &lt;&lt; 8) | raw[2]) == SegIVT3a.SIZE and raw[3] in (0x43,):
            return BootImg3a.parse(stream)

        if raw[3] == SegTag.BIC1:
            return BootImg4.parse(stream)

        start_index = stream.seek(step, SEEK_CUR)

    raise Exception(&#39; Not an i.MX Boot Image !&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.image.images.BootImg2"><code class="flex name class">
<span>class <span class="ident">BootImg2</span></span>
<span>(</span><span>address:int=0, offset:int=1024, version:int=65, plugin:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image v2.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format
:param plugin: if plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg2(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v2.&#34;&#34;&#34;

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    APP_ALIGN = 0x1000
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC00,
                 0x100: 0x300}

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of IMX Boot Image v2.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plg

    @plugin.setter
    def plugin(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IMX Boot Image v2..&#34;&#34;&#34;
        result = self.ivt.space
        result += self.bdt.space
        if self.dcd:
            result += self.dcd.space
        result += self.app.space
        result += self.csf.space
        return result

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x41, plugin: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        :param plugin: if plugin
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = SegIVT2(version)
        self._bdt = SegBDT()
        self._app = SegAPP()
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = plugin

    def _update(self) -&gt; None:
        &#34;&#34;&#34;Update Image Object.&#34;&#34;&#34;
        # Set zero padding for IVT and BDT sections
        self.ivt.padding = 0
        self.bdt.padding = 0
        # Calculate padding for DCD, APP and CSF sections
        tmp_val = self.ivt.space + self.bdt.space
        if self.dcd:
            tmp_val += self.dcd.size
        head_size = 0xC00 if self.offset not in self.HEAD_SIZE else self.HEAD_SIZE[self.offset]
        if self.dcd:
            self.dcd.padding = head_size - tmp_val
        tmp_val = self.app.size % self.APP_ALIGN
        self.app.padding = self.APP_ALIGN - tmp_val if tmp_val &gt; 0 else 0
        # Set IVT section
        self.ivt.ivt_address = self.address + self.offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        if self.dcd:
            self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
            self.ivt.app_address = self.ivt.dcd_address + self.dcd.space
        else:
            self.ivt.dcd_address = 0
            self.ivt.app_address = self.ivt.bdt_address + self.bdt.space
        if self.csf.enabled:
            self.ivt.csf_address = self.ivt.app_address + self.app.space
            self.csf.padding = self.CSF_SIZE - self.csf.size
        else:
            self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.ivt.ivt_address - self.offset
        self.bdt.app_length = self.size + self.offset
        self.bdt.plugin = 1 if self.plugin else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image v2.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print DBI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: Type of img
        :param address: address in RAM
        :raises Exception: Raised when the data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            self.app.data = data
            if address != 0:
                self.address = address
        else:
            raise Exception(&#39;Unknown data type !&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export image as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self._update()
        data = self.ivt.export()
        data += self.bdt.export()
        if self.dcd:
            data += self.dcd.export()
        data += self.app.export()
        data += self.csf.export()
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; &#39;BootImg2&#39;:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when value type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg2 object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)} !&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or \
                    header.length == SegIVT2.SIZE or \
                    header.param in (0x40, 0x41, 0x42, 0x43):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = BootImg2()
        if header.param:
            obj.version = header.param

        img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        obj.plugin = bool(obj.bdt.plugin)
        # Parse DCD
        if obj.ivt.dcd_address:
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
        # Parse APP
        app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
        app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
            obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
        app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
        obj.app.data = read_raw_data(stream, app_size, app_start)
        obj.app.padding = 0
        # Parse CSF
        if obj.ivt.csf_address:
            csf_start = start_index + (obj.ivt.csf_address - obj.ivt.ivt_address)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF, csf_start))
            # obj.csf.padding = csf_start + obj.csf.size

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg2.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg2.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg2.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:int=None) ><a title="spsdk.image.images.BootImg2" href="#spsdk.image.images.BootImg2">BootImg2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: raised when value type is incorrect
:raises Exception: raised when there is not an i.MX Boot Image
:return: BootImg2 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; &#39;BootImg2&#39;:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: raised when value type is incorrect
    :raises Exception: raised when there is not an i.MX Boot Image
    :return: BootImg2 object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)} !&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT2 or \
                header.length == SegIVT2.SIZE or \
                header.param in (0x40, 0x41, 0x42, 0x43):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = BootImg2()
    if header.param:
        obj.version = header.param

    img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index

    # Parse IVT
    obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
    obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
    obj.address = obj.bdt.app_start
    obj.plugin = bool(obj.bdt.plugin)
    # Parse DCD
    if obj.ivt.dcd_address:
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
    # Parse APP
    app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
    app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
        obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
    app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
    obj.app.data = read_raw_data(stream, app_size, app_start)
    obj.app.padding = 0
    # Parse CSF
    if obj.ivt.csf_address:
        csf_start = start_index + (obj.ivt.csf_address - obj.ivt.ivt_address)
        obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF, csf_start))
        # obj.csf.padding = csf_start + obj.csf.size

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg2.app"><code class="name">var <span class="ident">app</span> :<a title="spsdk.image.segments.SegAPP" href="segments.html#spsdk.image.segments.SegAPP">SegAPP</a></code></dt>
<dd>
<div class="desc"><p>APP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app(self) -&gt; SegAPP:
    &#34;&#34;&#34;APP.&#34;&#34;&#34;
    return self._app</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.bdt"><code class="name">var <span class="ident">bdt</span> :<a title="spsdk.image.segments.SegBDT" href="segments.html#spsdk.image.segments.SegBDT">SegBDT</a></code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; SegBDT:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.csf"><code class="name">var <span class="ident">csf</span> :<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.ivt"><code class="name">var <span class="ident">ivt</span> :<a title="spsdk.image.segments.SegIVT2" href="segments.html#spsdk.image.segments.SegIVT2">SegIVT2</a></code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; SegIVT2:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.plugin"><code class="name">var <span class="ident">plugin</span> :bool</code></dt>
<dd>
<div class="desc"><p>Plugin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; bool:
    &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.size"><code class="name">var <span class="ident">size</span> :int</code></dt>
<dd>
<div class="desc"><p>Size of IMX Boot Image v2..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IMX Boot Image v2..&#34;&#34;&#34;
    result = self.ivt.space
    result += self.bdt.space
    if self.dcd:
        result += self.dcd.space
    result += self.app.space
    result += self.csf.space
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.version"><code class="name">var <span class="ident">version</span> :int</code></dt>
<dd>
<div class="desc"><p>Version of IMX Boot Image v2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of IMX Boot Image v2.&#34;&#34;&#34;
    return self._ivt.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg2.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:<a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a>=4, address:int=0) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of img
:param img_type: Type of img
:param address: address in RAM
:raises Exception: Raised when the data type is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of img
    :param img_type: Type of img
    :param address: address in RAM
    :raises Exception: Raised when the data type is unknown
    &#34;&#34;&#34;
    if img_type == EnumAppType.APP:
        self.app.data = data
        if address != 0:
            self.address = address
    else:
        raise Exception(&#39;Unknown data type !&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export image as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export image as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self._update()
    data = self.ivt.export()
    data += self.bdt.export()
    if self.dcd:
        data += self.dcd.export()
    data += self.app.export()
    data += self.csf.export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the IMX Boot Image v2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the IMX Boot Image v2.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self.ivt.info()
    # Print DBI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self.bdt.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.BootImg3a"><code class="flex name class">
<span>class <span class="ident">BootImg3a</span></span>
<span>(</span><span>address:int=0, offset:int=1024, version:int=67)</span>
</code></dt>
<dd>
<div class="desc"><p>i.MX Boot Image v3a.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg3a(BootImgBase):
    &#34;&#34;&#34;i.MX Boot Image v3a.&#34;&#34;&#34;

    IMG_TYPE_CSF = 0x01
    IMG_TYPE_SCD = 0x02
    IMG_TYPE_EXEC = 0x03
    IMG_TYPE_DATA = 0x04

    SCFW_FLAGS_APP = 0x01355FC4
    SCFW_FLAGS_M4_0 = 0x4a5162
    SCFW_FLAGS_M4_1 = 0x4f52a3
    SCFW_FLAGS_SCFW = 0x1

    INITIAL_LOAD_ADDR_SCU_ROM = 0x2000e000
    INITIAL_LOAD_ADDR_AP_ROM = 0x00110000
    INITIAL_LOAD_ADDR_FLEXSPI = 0x08000000

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    IMG_AUTO_ALIGN = 0x10
    SECTOR_SIZE = 0x200
    APP_ALIGN = 0x1200
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC400,
                 0x1000: 0x1400}

    PADDING_VAL = 0x00

    COUNT_OF_CONTAINERS = 2

    @property
    def plg(self) -&gt; bool:
        &#34;&#34;&#34;PLG.&#34;&#34;&#34;
        return self._plg

    @plg.setter
    def plg(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; List[SegIVT3a]:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: List) -&gt; None:
        assert isinstance(value, list) and isinstance(value[0], SegIVT3a)
        self._ivt = value

    @property
    def bdt(self) -&gt; List[SegBDS3a]:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: List) -&gt; None:
        assert isinstance(value, list) and isinstance(value[0], SegBDS3a)
        self._bdt = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x43) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = [SegIVT3a(version), SegIVT3a(version)]
        self._ivt[0].next = self._ivt[0].size
        self._ivt[0].version = 0x01
        self._ivt[1].version = 0x01
        self._bdt = [SegBDS3a(), SegBDS3a()]
        self.app = [[SegAPP() for _ in range(SegBDS3a.IMAGES_MAX_COUNT)],
                    [SegAPP() for _ in range(SegBDS3a.IMAGES_MAX_COUNT)]]
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = False
        if not isinstance(self.address, list):
            self.address = [self.INITIAL_LOAD_ADDR_SCU_ROM, self.INITIAL_LOAD_ADDR_AP_ROM]  # type: ignore
        self._sdc_address = 0

    @staticmethod
    def _compute_padding(size: int, sector_size: int) -&gt; int:
        return ((size // sector_size + (size % sector_size &gt; 0)) * sector_size) - size

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        for container in range(self.COUNT_OF_CONTAINERS):
            self.ivt[container].padding = 0
            self.bdt[container].padding = 0

            # Set IVT section
            self.ivt[container].ivt_address = (self.address[container] + self.offset +  # type: ignore
                                               container * self.ivt[container].size)
            self.ivt[container].bdt_address = (self.ivt[container].ivt_address +
                                               self.ivt[container].space * (self.COUNT_OF_CONTAINERS - container) +
                                               container * self.bdt[container].size)

            if container == 0:
                if self.dcd:
                    self.ivt[container].dcd_address = self.ivt[container].bdt_address + self.bdt[container].space * 2
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].dcd_address + self.dcd.space
                    else:
                        self.ivt[container].csf_address = 0
                else:
                    self.ivt[container].dcd_address = 0
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].bdt_address + \
                                                          self.bdt[container].space * 2
                    else:
                        self.ivt[container].csf_address = 0
            else:
                self.ivt[container].dcd_address = 0
                self.ivt[container].csf_address = 0

            self.app[container][0].padding = self._compute_padding(self.bdt[container].images[0].image_size,
                                                                   self.SECTOR_SIZE)
            if self.bdt[container].images_count != 0:
                self.bdt[container].boot_data_size = self.bdt[container].size
                if container == 0:
                    self.bdt[container].images[0].image_source = self.APP_ALIGN
                else:
                    last_image_index = self.bdt[container - 1].images_count - 1
                    last_image_address = self.bdt[container - 1].images[last_image_index].image_source
                    self.bdt[container].images[0].image_source = (last_image_address +
                                                                  self.app[container - 1][last_image_index].space)
            for i in range(self.bdt[container].images_count - 1):
                self.bdt[container].images[i + 1].image_source = self.bdt[container].images[i].image_source + \
                                                                 self.app[container][i].space
                self.app[container][i + 1].padding = self._compute_padding(self.bdt[container].images[i + 1].image_size,
                                                                           self.SECTOR_SIZE)
            if container == self.COUNT_OF_CONTAINERS - 1:
                self.app[container][self.bdt[container].images_count - 1].padding = 0
                # Set BDT section

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the i.MX Boot Image v3a.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, ivt in enumerate(self.ivt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- IVT[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, bdi in enumerate(self.bdt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- BDI[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += bdi.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of image
        :param img_type: Type of image
        :param address: address in RAM
        :raises Exception: raised when data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            image_index = self.bdt[1].images_count
            self.bdt[1].images[image_index].image_destination = address
            self.bdt[1].images[image_index].image_entry = address
            self.bdt[1].images[image_index].image_size = len(data)
            self.bdt[1].images[image_index].rom_flags = 0
            self.bdt[1].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[1].images[image_index].scfw_flags = self.SCFW_FLAGS_APP
            self.bdt[1].images_count += 1

            self.app[1][image_index].data = data
            self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = address
            self.bdt[0].images[image_index].image_entry = address
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_M4_0 if img_type == EnumAppType.M4_0 else \
                self.SCFW_FLAGS_M4_1
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type == EnumAppType.SCFW:
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = 0x1ffe0000
            self.bdt[0].images[image_index].image_entry = 0x1ffe0000
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
            self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_SCFW
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self._sdc_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                                 self._compute_padding(len(data), self.IMG_AUTO_ALIGN))

        elif img_type == EnumAppType.SCD:
            if self._sdc_address == 0:
                raise Exception(&#39;SCFW have to be define before SCD!&#39;)
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = self._sdc_address
            self.bdt[0].images[image_index].image_entry = 0
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].rom_flags = 0
            self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_SCD
            self.bdt[0].images[image_index].scfw_flags = 0x1
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        else:
            raise Exception(&#39;Unknown data type!&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export Image as binary blob.&#34;&#34;&#34;
        self._update()
        data = bytes()
        data += self.ivt[0].export()
        data += self.ivt[1].export()
        data += self.bdt[0].export()
        data += self.bdt[1].export()
        if self.dcd:
            data += self.dcd.export()
        data += self.csf.export()
        data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

        for container in range(self.COUNT_OF_CONTAINERS):
            for image in range(self.bdt[container].images_count):
                data += self.app[container][image].export()

        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when the values type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg3a object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT3 or header.length == SegIVT3a.SIZE or \
                    header.param in (0x43,):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        # TODO: not used right now: img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index
        # Parse IVT
        obj.ivt[0] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
        obj.ivt[1] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
        # Parse BDT
        obj.bdt[0] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
        obj.bdt[1] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
        # Parse DCD
        if obj.ivt[0].dcd_address:
            stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        # Parse CSF
        if obj.ivt[0].csf_address:
            stream.seek(start_index + (obj.ivt[0].csf_address - obj.ivt[0].ivt_address), 0)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))
        # Parse IMAGES
        for container in range(obj.COUNT_OF_CONTAINERS):
            for i in range(obj.bdt[container].images_count):
                stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
                obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg3a.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.COUNT_OF_CONTAINERS"><code class="name">var <span class="ident">COUNT_OF_CONTAINERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.IMG_AUTO_ALIGN"><code class="name">var <span class="ident">IMG_AUTO_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.IMG_TYPE_CSF"><code class="name">var <span class="ident">IMG_TYPE_CSF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.IMG_TYPE_DATA"><code class="name">var <span class="ident">IMG_TYPE_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.IMG_TYPE_EXEC"><code class="name">var <span class="ident">IMG_TYPE_EXEC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.IMG_TYPE_SCD"><code class="name">var <span class="ident">IMG_TYPE_SCD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_AP_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_AP_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_FLEXSPI"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_FLEXSPI</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_SCU_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_SCU_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.PADDING_VAL"><code class="name">var <span class="ident">PADDING_VAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.SCFW_FLAGS_APP"><code class="name">var <span class="ident">SCFW_FLAGS_APP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.SCFW_FLAGS_M4_0"><code class="name">var <span class="ident">SCFW_FLAGS_M4_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.SCFW_FLAGS_M4_1"><code class="name">var <span class="ident">SCFW_FLAGS_M4_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.SCFW_FLAGS_SCFW"><code class="name">var <span class="ident">SCFW_FLAGS_SCFW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3a.SECTOR_SIZE"><code class="name">var <span class="ident">SECTOR_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg3a.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:int=None) ><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: raised when the values type is incorrect
:raises Exception: raised when there is not an i.MX Boot Image
:return: BootImg3a object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: raised when the values type is incorrect
    :raises Exception: raised when there is not an i.MX Boot Image
    :return: BootImg3a object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT3 or header.length == SegIVT3a.SIZE or \
                header.param in (0x43,):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = cls(version=header.param)
    # TODO: not used right now: img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index
    # Parse IVT
    obj.ivt[0] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
    obj.ivt[1] = SegIVT3a.parse(read_raw_segment(stream, SegTag.IVT3))
    # Parse BDT
    obj.bdt[0] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
    obj.bdt[1] = SegBDS3a.parse(read_raw_data(stream, SegBDS3a.SIZE))
    # Parse DCD
    if obj.ivt[0].dcd_address:
        stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
    # Parse CSF
    if obj.ivt[0].csf_address:
        stream.seek(start_index + (obj.ivt[0].csf_address - obj.ivt[0].ivt_address), 0)
        obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))
    # Parse IMAGES
    for container in range(obj.COUNT_OF_CONTAINERS):
        for i in range(obj.bdt[container].images_count):
            stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
            obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg3a.bdt"><code class="name">var <span class="ident">bdt</span> :List[<a title="spsdk.image.segments.SegBDS3a" href="segments.html#spsdk.image.segments.SegBDS3a">SegBDS3a</a>]</code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; List[SegBDS3a]:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3a.csf"><code class="name">var <span class="ident">csf</span> :<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3a.ivt"><code class="name">var <span class="ident">ivt</span> :List[<a title="spsdk.image.segments.SegIVT3a" href="segments.html#spsdk.image.segments.SegIVT3a">SegIVT3a</a>]</code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; List[SegIVT3a]:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3a.plg"><code class="name">var <span class="ident">plg</span> :bool</code></dt>
<dd>
<div class="desc"><p>PLG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plg(self) -&gt; bool:
    &#34;&#34;&#34;PLG.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg3a.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:<a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a>=4, address:int=0) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of image
:param img_type: Type of image
:param address: address in RAM
:raises Exception: raised when data type is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of image
    :param img_type: Type of image
    :param address: address in RAM
    :raises Exception: raised when data type is unknown
    &#34;&#34;&#34;
    if img_type == EnumAppType.APP:
        image_index = self.bdt[1].images_count
        self.bdt[1].images[image_index].image_destination = address
        self.bdt[1].images[image_index].image_entry = address
        self.bdt[1].images[image_index].image_size = len(data)
        self.bdt[1].images[image_index].rom_flags = 0
        self.bdt[1].images[image_index].hab_flags = self.IMG_TYPE_EXEC
        self.bdt[1].images[image_index].scfw_flags = self.SCFW_FLAGS_APP
        self.bdt[1].images_count += 1

        self.app[1][image_index].data = data
        self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = address
        self.bdt[0].images[image_index].image_entry = address
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].rom_flags = 0
        self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
        self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_M4_0 if img_type == EnumAppType.M4_0 else \
            self.SCFW_FLAGS_M4_1
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    elif img_type == EnumAppType.SCFW:
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = 0x1ffe0000
        self.bdt[0].images[image_index].image_entry = 0x1ffe0000
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].rom_flags = 0
        self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_EXEC
        self.bdt[0].images[image_index].scfw_flags = self.SCFW_FLAGS_SCFW
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
        self._sdc_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                             self._compute_padding(len(data), self.IMG_AUTO_ALIGN))

    elif img_type == EnumAppType.SCD:
        if self._sdc_address == 0:
            raise Exception(&#39;SCFW have to be define before SCD!&#39;)
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = self._sdc_address
        self.bdt[0].images[image_index].image_entry = 0
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].rom_flags = 0
        self.bdt[0].images[image_index].hab_flags = self.IMG_TYPE_SCD
        self.bdt[0].images[image_index].scfw_flags = 0x1
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    else:
        raise Exception(&#39;Unknown data type!&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3a.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export Image as binary blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export Image as binary blob.&#34;&#34;&#34;
    self._update()
    data = bytes()
    data += self.ivt[0].export()
    data += self.ivt[1].export()
    data += self.bdt[0].export()
    data += self.bdt[1].export()
    if self.dcd:
        data += self.dcd.export()
    data += self.csf.export()
    data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

    for container in range(self.COUNT_OF_CONTAINERS):
        for image in range(self.bdt[container].images_count):
            data += self.app[container][image].export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3a.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the i.MX Boot Image v3a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the i.MX Boot Image v3a.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, ivt in enumerate(self.ivt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- IVT[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += ivt.info()
    # Print BDI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, bdi in enumerate(self.bdt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- BDI[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += bdi.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.BootImg3b"><code class="flex name class">
<span>class <span class="ident">BootImg3b</span></span>
<span>(</span><span>address:int=0, offset:int=1024, version:int=67)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image v3b.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg3b(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v3b.&#34;&#34;&#34;

    IMG_TYPE_CSF = 0x01
    IMG_TYPE_SCD = 0x02
    IMG_TYPE_EXEC = 0x03
    IMG_TYPE_DATA = 0x04

    SCFW_FLAGS_A53 = 0x1354014
    SCFW_FLAGS_A72 = 0x1354065
    SCFW_FLAGS_M4_0 = 0x4a5162
    SCFW_FLAGS_M4_1 = 0x4f52a3
    SCFW_FLAGS_SCFW = 0x1

    INITIAL_LOAD_ADDR_SCU_ROM = 0x2000e000
    INITIAL_LOAD_ADDR_AP_ROM = 0x00110000
    INITIAL_LOAD_ADDR_FLEXSPI = 0x08000000

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value for img
    IMG_AUTO_ALIGN = 0x10
    # The align value for sector
    SECTOR_SIZE = 0x200
    # The align value of APP segment
    APP_ALIGN = 0x1200

    PADDING_VAL = 0x00
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC400,
                 0x1000: 0x1400}

    COUNT_OF_CONTAINERS = 2

    @property
    def plg(self) -&gt; bool:
        &#34;&#34;&#34;PLG.&#34;&#34;&#34;
        return self._plg

    @plg.setter
    def plg(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; List[SegIVT3b]:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: List) -&gt; None:
        assert isinstance(value, list)
        assert len(value) == self.COUNT_OF_CONTAINERS
        assert isinstance(value[0], SegIVT3b)
        self._ivt = value

    @property
    def bdt(self) -&gt; List[SegBDS3b]:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: List) -&gt; None:
        assert isinstance(value, list)
        assert len(value) == self.COUNT_OF_CONTAINERS
        assert isinstance(value[0], SegBDS3b)
        self._bdt = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x43) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = [SegIVT3b(version), SegIVT3b(version)]
        self._bdt = [SegBDS3b(), SegBDS3b()]
        self.app = [[SegAPP() for _ in range(SegBDS3b.IMAGES_MAX_COUNT)],
                    [SegAPP() for _ in range(SegBDS3b.IMAGES_MAX_COUNT)]]
        self._dcd = SegDCD()
        self.scd = SegAPP()
        self._csf = SegCSF()
        self._plg = False
        self._scd_address = 0
        if not isinstance(self.address, int):
            self.address = [self.INITIAL_LOAD_ADDR_SCU_ROM, self.INITIAL_LOAD_ADDR_AP_ROM]  # type: ignore

    @staticmethod
    def _compute_padding(image_size: int, sector_size: int) -&gt; int:
        return ((image_size // sector_size + (image_size % sector_size &gt; 0)) * sector_size) - image_size

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        for container in range(self.COUNT_OF_CONTAINERS):
            self.ivt[container].padding = 0
            self.bdt[container].padding = 0

            # Set IVT section
            self.ivt[container].ivt_address = (self.address[container] + self.offset +  # type: ignore
                                               container * self.ivt[container].size)
            self.ivt[container].bdt_address = (self.ivt[container].ivt_address +
                                               self.ivt[container].space * (2 - container) +
                                               container * self.bdt[container].size)
            if container == 0:
                if self.dcd:
                    self.ivt[container].dcd_address = self.ivt[container].bdt_address + self.bdt[container].space * 2
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].dcd_address + self.dcd.space
                    else:
                        self.ivt[container].csf_address = 0
                else:
                    self.ivt[container].dcd_address = 0
                    if self.csf.enabled:
                        self.ivt[container].csf_address = self.ivt[container].bdt_address + \
                                                          self.bdt[container].space * 2
                    else:
                        self.ivt[container].csf_address = 0
            else:
                self.ivt[container].dcd_address = 0
                self.ivt[container].csf_address = 0

            self.app[container][0].padding = self._compute_padding(self.bdt[container].images[0].image_size,
                                                                   self.SECTOR_SIZE)
            if self.bdt[container].images_count != 0:
                self.bdt[container].boot_data_size = self.bdt[container].size
                if container == 0:
                    self.bdt[container].images[0].image_source = self.APP_ALIGN
                else:
                    last_image_index = self.bdt[container - 1].images_count - 1
                    last_image_address = self.bdt[container - 1].images[last_image_index].image_source
                    self.bdt[container].images[0].image_source = (last_image_address +
                                                                  self.app[container - 1][last_image_index].space)
            next_image_address = 0
            for i in range(self.bdt[container].images_count - 1):
                self.bdt[container].images[i + 1].image_source = self.bdt[container].images[i].image_source + \
                                                                 self.app[container][i].space
                self.app[container][i + 1].padding = self._compute_padding(
                    self.bdt[container].images[i + 1].image_size, self.SECTOR_SIZE)
                next_image_address = self.bdt[container].images[i + 1].image_source + self.app[container][i + 1].space

            if container == 0:
                if self.bdt[container].scd.image_destination != 0:
                    self.bdt[container].scd.image_source = next_image_address
                    self.scd.padding = self._compute_padding(self.bdt[0].scd.image_size, self.SECTOR_SIZE)
                    next_image_address += self.scd.space
                    # Set BDT section

                if self.csf.enabled:
                    self.bdt[container].csf.image_source = next_image_address
                    self.csf.padding = self._compute_padding(self.bdt[0].csf.image_size, self.SECTOR_SIZE)
                    next_image_address += self.csf.space
                    # Set BDT section

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image v3b.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, ivt in enumerate(self.ivt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- IVT[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        for index, bdi in enumerate(self.bdt):
            msg += &#34;-&#34; * 60 + &#34;\n&#34;
            msg += &#34;- BDI[{}]\n&#34;.format(index)
            msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
            msg += bdi.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of image
        :param img_type: Type of image
        :param address: address in RAM
        :raises Exception: raised SCFW is not defined before SCD
        :raises Exception: raised when there is unknown image type
        &#34;&#34;&#34;
        if img_type in (EnumAppType.APP, EnumAppType.A72):
            image_index = self.bdt[1].images_count
            self.app[1][image_index].data = data

            self.bdt[1].images[image_index].image_destination = address
            self.bdt[1].images[image_index].image_entry = address
            self.bdt[1].images[image_index].image_size = len(data)

            if img_type == EnumAppType.APP:
                self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A53
            elif img_type == EnumAppType.A72:
                self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A72

            self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self.bdt[1].images_count += 1

        elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
            image_index = self.bdt[0].images_count
            self.app[0][image_index].data = data

            self.bdt[0].images[image_index].image_destination = address
            self.bdt[0].images[image_index].image_entry = address
            self.bdt[0].images[image_index].image_size = len(data)

            if img_type == EnumAppType.M4_0:
                self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_0
            elif img_type == EnumAppType.M4_1:
                self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_1

            self.app[0][image_index].padding = ((len(data) // self.SECTOR_SIZE +
                                                 (len(data) % self.SECTOR_SIZE &gt; 0)) * self.SECTOR_SIZE) - len(data)
            self.bdt[0].images_count += 1

        elif img_type == EnumAppType.SCFW:
            image_index = self.bdt[0].images_count
            self.bdt[0].images[image_index].image_destination = 0x30fe0000
            self.bdt[0].images[image_index].image_entry = 0x1ffe0000
            self.bdt[0].images[image_index].image_size = len(data)
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_SCFW
            self._scd_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                                 self._compute_padding(len(data), self.IMG_AUTO_ALIGN))
            self.bdt[0].images_count += 1

            self.app[0][image_index].data = data
            self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

        elif img_type == EnumAppType.SCD:
            if self._scd_address == 0:
                raise Exception(&#39;SCFW have to be define before SCD!&#39;)
            self.scd.data = data
            self.scd.padding = self._compute_padding(len(data), self.SECTOR_SIZE)
            self.bdt[0].scd.image_destination = self._scd_address
            self.bdt[0].scd.image_entry = 0
            self.bdt[0].scd.image_size = len(data)
            self.ivt[0].scd_address = self.bdt[0].scd.image_destination

        else:
            raise Exception(&#39;Unknown image type!&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        # data = bytearray(self._offset)
        data = bytes()
        data += self.ivt[0].export()
        data += self.ivt[1].export()
        data += self.bdt[0].export()
        data += self.bdt[1].export()
        if self.dcd:
            data += self.dcd.export()
        data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

        for container in range(self.COUNT_OF_CONTAINERS):
            for i in range(self.bdt[container].images_count):
                data += self.app[container][i].export()

        if self.bdt[0].scd.image_source != 0:
            data += self.scd.export()

        if self.bdt[0].csf.image_source != 0:
            data += self.csf.export()

        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: When the value is incorrect
        :raises Exception: If there is not an i.MX Boot Image
        :return: BootImg3b object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or header.length == SegIVT3b.SIZE or \
                    header.param in (0x43,):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        # TODO: not used right now: img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index
        # Parse IVT
        obj.ivt[0] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
        obj.ivt[1] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt[0] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
        obj.bdt[1] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
        # Parse DCD
        if obj.ivt[0].dcd_address:
            stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        # Parse IMAGES
        for container in range(obj.COUNT_OF_CONTAINERS):
            for i in range(obj.bdt[container].images_count):
                stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
                obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)
        # Parse SCD
        if obj.bdt[0].scd.image_source != 0:
            stream.seek(obj.bdt[0].scd.image_source - obj.offset, 0)
            obj.scd.data = read_raw_data(stream, obj.bdt[0].scd.image_size)
        # Parse CSF
        if obj.bdt[0].csf.image_source != 0:
            stream.seek(obj.bdt[0].csf.image_source - obj.offset, 0)
            obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg3b.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.COUNT_OF_CONTAINERS"><code class="name">var <span class="ident">COUNT_OF_CONTAINERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.IMG_AUTO_ALIGN"><code class="name">var <span class="ident">IMG_AUTO_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.IMG_TYPE_CSF"><code class="name">var <span class="ident">IMG_TYPE_CSF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.IMG_TYPE_DATA"><code class="name">var <span class="ident">IMG_TYPE_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.IMG_TYPE_EXEC"><code class="name">var <span class="ident">IMG_TYPE_EXEC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.IMG_TYPE_SCD"><code class="name">var <span class="ident">IMG_TYPE_SCD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_AP_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_AP_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_FLEXSPI"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_FLEXSPI</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_SCU_ROM"><code class="name">var <span class="ident">INITIAL_LOAD_ADDR_SCU_ROM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.PADDING_VAL"><code class="name">var <span class="ident">PADDING_VAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.SCFW_FLAGS_A53"><code class="name">var <span class="ident">SCFW_FLAGS_A53</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.SCFW_FLAGS_A72"><code class="name">var <span class="ident">SCFW_FLAGS_A72</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.SCFW_FLAGS_M4_0"><code class="name">var <span class="ident">SCFW_FLAGS_M4_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.SCFW_FLAGS_M4_1"><code class="name">var <span class="ident">SCFW_FLAGS_M4_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.SCFW_FLAGS_SCFW"><code class="name">var <span class="ident">SCFW_FLAGS_SCFW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg3b.SECTOR_SIZE"><code class="name">var <span class="ident">SECTOR_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg3b.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:int=None) ><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: When the value is incorrect
:raises Exception: If there is not an i.MX Boot Image
:return: BootImg3b object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: When the value is incorrect
    :raises Exception: If there is not an i.MX Boot Image
    :return: BootImg3b object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT2 or header.length == SegIVT3b.SIZE or \
                header.param in (0x43,):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = cls(version=header.param)
    # TODO: not used right now: img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index
    # Parse IVT
    obj.ivt[0] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
    obj.ivt[1] = SegIVT3b.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    obj.bdt[0] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
    obj.bdt[1] = SegBDS3b.parse(read_raw_data(stream, SegBDS3b.SIZE))
    # Parse DCD
    if obj.ivt[0].dcd_address:
        stream.seek(start_index + (obj.ivt[0].dcd_address - obj.ivt[0].ivt_address), 0)
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
    # Parse IMAGES
    for container in range(obj.COUNT_OF_CONTAINERS):
        for i in range(obj.bdt[container].images_count):
            stream.seek(obj.bdt[container].images[i].image_source - obj.offset, 0)
            obj.app[container][i].data = read_raw_data(stream, obj.bdt[container].images[i].image_size)
    # Parse SCD
    if obj.bdt[0].scd.image_source != 0:
        stream.seek(obj.bdt[0].scd.image_source - obj.offset, 0)
        obj.scd.data = read_raw_data(stream, obj.bdt[0].scd.image_size)
    # Parse CSF
    if obj.bdt[0].csf.image_source != 0:
        stream.seek(obj.bdt[0].csf.image_source - obj.offset, 0)
        obj.csf = SegCSF.parse(read_raw_segment(stream, SegTag.CSF))

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg3b.bdt"><code class="name">var <span class="ident">bdt</span> :List[<a title="spsdk.image.segments.SegBDS3b" href="segments.html#spsdk.image.segments.SegBDS3b">SegBDS3b</a>]</code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; List[SegBDS3b]:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3b.csf"><code class="name">var <span class="ident">csf</span> :<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3b.ivt"><code class="name">var <span class="ident">ivt</span> :List[<a title="spsdk.image.segments.SegIVT3b" href="segments.html#spsdk.image.segments.SegIVT3b">SegIVT3b</a>]</code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; List[SegIVT3b]:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3b.plg"><code class="name">var <span class="ident">plg</span> :bool</code></dt>
<dd>
<div class="desc"><p>PLG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plg(self) -&gt; bool:
    &#34;&#34;&#34;PLG.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg3b.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:<a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a>=4, address:int=0) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of image
:param img_type: Type of image
:param address: address in RAM
:raises Exception: raised SCFW is not defined before SCD
:raises Exception: raised when there is unknown image type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of image
    :param img_type: Type of image
    :param address: address in RAM
    :raises Exception: raised SCFW is not defined before SCD
    :raises Exception: raised when there is unknown image type
    &#34;&#34;&#34;
    if img_type in (EnumAppType.APP, EnumAppType.A72):
        image_index = self.bdt[1].images_count
        self.app[1][image_index].data = data

        self.bdt[1].images[image_index].image_destination = address
        self.bdt[1].images[image_index].image_entry = address
        self.bdt[1].images[image_index].image_size = len(data)

        if img_type == EnumAppType.APP:
            self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A53
        elif img_type == EnumAppType.A72:
            self.bdt[1].images[image_index].flags = self.SCFW_FLAGS_A72

        self.app[1][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)
        self.bdt[1].images_count += 1

    elif img_type in (EnumAppType.M4_0, EnumAppType.M4_1):
        image_index = self.bdt[0].images_count
        self.app[0][image_index].data = data

        self.bdt[0].images[image_index].image_destination = address
        self.bdt[0].images[image_index].image_entry = address
        self.bdt[0].images[image_index].image_size = len(data)

        if img_type == EnumAppType.M4_0:
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_0
        elif img_type == EnumAppType.M4_1:
            self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_M4_1

        self.app[0][image_index].padding = ((len(data) // self.SECTOR_SIZE +
                                             (len(data) % self.SECTOR_SIZE &gt; 0)) * self.SECTOR_SIZE) - len(data)
        self.bdt[0].images_count += 1

    elif img_type == EnumAppType.SCFW:
        image_index = self.bdt[0].images_count
        self.bdt[0].images[image_index].image_destination = 0x30fe0000
        self.bdt[0].images[image_index].image_entry = 0x1ffe0000
        self.bdt[0].images[image_index].image_size = len(data)
        self.bdt[0].images[image_index].flags = self.SCFW_FLAGS_SCFW
        self._scd_address = (self.bdt[0].images[image_index].image_destination + len(data) +
                             self._compute_padding(len(data), self.IMG_AUTO_ALIGN))
        self.bdt[0].images_count += 1

        self.app[0][image_index].data = data
        self.app[0][image_index].padding = self._compute_padding(len(data), self.SECTOR_SIZE)

    elif img_type == EnumAppType.SCD:
        if self._scd_address == 0:
            raise Exception(&#39;SCFW have to be define before SCD!&#39;)
        self.scd.data = data
        self.scd.padding = self._compute_padding(len(data), self.SECTOR_SIZE)
        self.bdt[0].scd.image_destination = self._scd_address
        self.bdt[0].scd.image_entry = 0
        self.bdt[0].scd.image_size = len(data)
        self.ivt[0].scd_address = self.bdt[0].scd.image_destination

    else:
        raise Exception(&#39;Unknown image type!&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3b.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._update()
    # data = bytearray(self._offset)
    data = bytes()
    data += self.ivt[0].export()
    data += self.ivt[1].export()
    data += self.bdt[0].export()
    data += self.bdt[1].export()
    if self.dcd:
        data += self.dcd.export()
    data += bytes([self.PADDING_VAL] * self._compute_padding(len(data), self.APP_ALIGN - self.offset))

    for container in range(self.COUNT_OF_CONTAINERS):
        for i in range(self.bdt[container].images_count):
            data += self.app[container][i].export()

    if self.bdt[0].scd.image_source != 0:
        data += self.scd.export()

    if self.bdt[0].csf.image_source != 0:
        data += self.csf.export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg3b.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the IMX Boot Image v3b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the IMX Boot Image v3b.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, ivt in enumerate(self.ivt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- IVT[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += ivt.info()
    # Print BDI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    for index, bdi in enumerate(self.bdt):
        msg += &#34;-&#34; * 60 + &#34;\n&#34;
        msg += &#34;- BDI[{}]\n&#34;.format(index)
        msg += &#34;-&#34; * 60 + &#34;\n\n&#34;
        msg += bdi.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.BootImg4"><code class="flex name class">
<span>class <span class="ident">BootImg4</span></span>
<span>(</span><span>address:int=0, offset:int=1024)</span>
</code></dt>
<dd>
<div class="desc"><p>i.MX Boot Image v4.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of image in target memory
:param offset: The image offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg4(BootImgBase):
    &#34;&#34;&#34;i.MX Boot Image v4.&#34;&#34;&#34;

    def __init__(self, address: int = 0, offset: int = 0x400) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of image in target memory
        :param offset: The image offset
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._dcd = SegDCD()
        self._cont1_header = SegBIC1()
        self._cont2_header = SegBIC1()

    def _update(self) -&gt; None:
        pass

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the i.MX Boot Image v4.&#34;&#34;&#34;
        self._update()
        msg = &#34;&#34;
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# Boot Images Container 1\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self._cont1_header.info()
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# Boot Images Container 2\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self._cont2_header.info()
        if self.dcd:
            if self.dcd.enabled:
                msg += &#34;#&#34; * 60 + &#34;\n&#34;
                msg += &#34;# DCD (Device Config Data)\n&#34;
                msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
                msg += self.dcd.info()
        return msg

    def add_image(self, data: bytes, img_type: int, address: int) -&gt; None:
        &#34;&#34;&#34;Not implemented.&#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        data = bytes()
        data += self._cont1_header.export()
        data += self._cont2_header.export()
        # TODO: Complete Implementation
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :return: BootImg4 object
        :raises TypeError: Raised when the value type is incorrect
        :raises Exception: If there is not an i.MX Boot Image
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header2.SIZE, no_seek=True))
            if header.tag == SegTag.BIC1:
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39; Not an i.MX Boot Image !&#39;)

        # TODO: not used right now: img_size = last_index - start_index
        obj = cls()
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse Containers
        obj._cont1_header = SegBIC1.parse(read_raw_data(stream, 0x400))
        obj._cont2_header = SegBIC1.parse(read_raw_data(stream, 0x400))
        # TODO: Complete Implementation
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg4.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:int=None) ><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:return: BootImg4 object
:raises TypeError: Raised when the value type is incorrect
:raises Exception: If there is not an i.MX Boot Image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :return: BootImg4 object
    :raises TypeError: Raised when the value type is incorrect
    :raises Exception: If there is not an i.MX Boot Image
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header2.SIZE, no_seek=True))
        if header.tag == SegTag.BIC1:
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39; Not an i.MX Boot Image !&#39;)

    # TODO: not used right now: img_size = last_index - start_index
    obj = cls()
    if start_index &gt; 0:
        obj.offset = start_index

    # Parse Containers
    obj._cont1_header = SegBIC1.parse(read_raw_data(stream, 0x400))
    obj._cont2_header = SegBIC1.parse(read_raw_data(stream, 0x400))
    # TODO: Complete Implementation
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg4.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:int, address:int) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Not implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: int, address: int) -&gt; None:
    &#34;&#34;&#34;Not implemented.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg4.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._update()
    data = bytes()
    data += self._cont1_header.export()
    data += self._cont2_header.export()
    # TODO: Complete Implementation
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg4.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the i.MX Boot Image v4.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the i.MX Boot Image v4.&#34;&#34;&#34;
    self._update()
    msg = &#34;&#34;
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# Boot Images Container 1\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self._cont1_header.info()
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# Boot Images Container 2\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self._cont2_header.info()
    if self.dcd:
        if self.dcd.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.BootImg8m"><code class="flex name class">
<span>class <span class="ident">BootImg8m</span></span>
<span>(</span><span>address:int=0, offset:int=1024, version:int=65, plugin:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset
:param version: The version of boot img format
:param plugin: if plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImg8m(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image.&#34;&#34;&#34;

    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The align value of APP segment
    APP_ALIGN = 0x1000
    # The value of img head size
    #           offset | size
    HEAD_SIZE = {0x400: 0xC00,
                 0x100: 0x300}

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of IMX Boot Image.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plg

    @plugin.setter
    def plugin(self, value: bool) -&gt; None:
        assert isinstance(value, bool)
        self._plg = value

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;IVT.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;BDT.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IMX Boot Image.&#34;&#34;&#34;
        result = self.ivt.space
        result += self.bdt.space
        if self.dcd:
            result += self.dcd.space
        result += self.app.space
        result += self.csf.space
        return result

    def __init__(self, address: int = 0, offset: int = 0x400, version: int = 0x41, plugin: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        :param version: The version of boot img format
        :param plugin: if plugin
        &#34;&#34;&#34;
        super().__init__(address, offset)
        self._ivt = SegIVT2(version)
        self._bdt = SegBDT()
        self._app = SegAPP()
        self._dcd = SegDCD()
        self._csf = SegCSF()
        self._plg = plugin

    def _update(self) -&gt; None:
        # Set zero padding for IVT and BDT sections
        self.ivt.padding = 0
        self.bdt.padding = 0
        # Calculate padding for DCD, APP and CSF sections
        tmp_val = self.ivt.space + self.bdt.space
        if self.dcd:
            tmp_val += self.dcd.size
        head_size = 0xC00 if self.offset not in self.HEAD_SIZE else self.HEAD_SIZE[self.offset]
        if self.dcd:
            self.dcd.padding = head_size - tmp_val
        tmp_val = self.app.size % self.APP_ALIGN
        self.app.padding = self.APP_ALIGN - tmp_val if tmp_val &gt; 0 else 0
        # Set IVT section
        self.ivt.ivt_address = self.address + self.offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        if self.dcd:
            if self.dcd.enabled:
                self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
                self.ivt.app_address = self.ivt.dcd_address + self.dcd.space
            else:
                self.ivt.dcd_address = 0
                self.ivt.app_address = self.ivt.bdt_address + self.bdt.space
        if self.csf.enabled:
            self.ivt.csf_address = self.ivt.app_address + self.app.space
            self.csf.padding = self.CSF_SIZE - self.csf.size
        else:
            self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.ivt.ivt_address - self.offset
        self.bdt.app_length = self.size + self.offset
        self.bdt.plugin = 1 if self.plugin else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the IMX Boot Image.&#34;&#34;&#34;
        self._update()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print DBI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if self.dcd:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        if self.csf.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: Type of img
        :param address: address in RAM
        :raises Exception: raised when data type is unknown
        &#34;&#34;&#34;
        if img_type == EnumAppType.APP:
            self.app.data = data
            if address != 0:
                self.address = address
        else:
            raise Exception(&#39;Unknown data type !&#39;)

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export Image as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self._update()
        data = self.ivt.export()
        data += self.bdt.export()
        if self.dcd:
            data += self.dcd.export()
        data += self.app.export()
        data += self.csf.export()
        return data

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
              step: int = 0x100, size: int = None) -&gt; BootImgBase:
        &#34;&#34;&#34;Parse image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step
        :param size: parsing size
        :raises TypeError: raised when the value type is incorrect
        :raises Exception: raised when there is not an i.MX Boot Image
        :return: BootImg2 object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

        header = Header()
        start_index = stream.tell()
        last_index = stream.seek(0, SEEK_END)
        stream.seek(start_index)

        if size:
            last_index = min(start_index + size, last_index)

        imx_image = False
        while start_index &lt; (last_index - Header.SIZE):
            header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
            if header.tag == SegTag.IVT2 or \
                    header.length == SegIVT2.SIZE or \
                    header.param in (0x40, 0x41, 0x42, 0x43):
                imx_image = True
                break

            start_index = stream.seek(step, SEEK_CUR)

        if not imx_image:
            raise Exception(&#39;Not an i.MX Boot Image!&#39;)

        obj = cls(version=header.param)
        img_size = last_index - start_index
        if start_index &gt; 0:
            obj.offset = start_index

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        obj.plugin = bool(obj.bdt.plugin)
        # Parse DCD
        if obj.ivt.dcd_address:
            obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
        # Parse APP
        app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
        app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
            obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
        app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
        obj.app.data = read_raw_data(stream, app_size, app_start)
        obj.app.padding = 0
        # Parse CSF
        # TODO finalize the code below
        # if obj.ivt.csf_address:
        #    obj.csf = SegCSF.parse(buffer)
        #    obj.csf.padding = obj.bdt.length - ((obj.ivt.csf_address - obj.ivt.ivt_address) + obj.csf.size)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg8m.APP_ALIGN"><code class="name">var <span class="ident">APP_ALIGN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg8m.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImg8m.HEAD_SIZE"><code class="name">var <span class="ident">HEAD_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg8m.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:int=None) ><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step
:param size: parsing size
:raises TypeError: raised when the value type is incorrect
:raises Exception: raised when there is not an i.MX Boot Image
:return: BootImg2 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO],
          step: int = 0x100, size: int = None) -&gt; BootImgBase:
    &#34;&#34;&#34;Parse image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step
    :param size: parsing size
    :raises TypeError: raised when the value type is incorrect
    :raises Exception: raised when there is not an i.MX Boot Image
    :return: BootImg2 object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(f&#34;Not correct value type: {type(stream)}!&#34;)

    header = Header()
    start_index = stream.tell()
    last_index = stream.seek(0, SEEK_END)
    stream.seek(start_index)

    if size:
        last_index = min(start_index + size, last_index)

    imx_image = False
    while start_index &lt; (last_index - Header.SIZE):
        header = Header.parse(read_raw_data(stream, Header.SIZE, no_seek=True))
        if header.tag == SegTag.IVT2 or \
                header.length == SegIVT2.SIZE or \
                header.param in (0x40, 0x41, 0x42, 0x43):
            imx_image = True
            break

        start_index = stream.seek(step, SEEK_CUR)

    if not imx_image:
        raise Exception(&#39;Not an i.MX Boot Image!&#39;)

    obj = cls(version=header.param)
    img_size = last_index - start_index
    if start_index &gt; 0:
        obj.offset = start_index

    # Parse IVT
    obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
    obj.offset = obj.ivt.ivt_address - obj.bdt.app_start
    obj.address = obj.bdt.app_start
    obj.plugin = bool(obj.bdt.plugin)
    # Parse DCD
    if obj.ivt.dcd_address:
        obj.dcd = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        obj.dcd.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - obj.dcd.size
    # Parse APP
    app_start = start_index + (obj.ivt.app_address - obj.ivt.ivt_address)
    app_size = obj.ivt.csf_address - obj.ivt.app_address if obj.ivt.csf_address else \
        obj.bdt.app_length - (obj.bdt.app_start - obj.ivt.app_address)
    app_size = img_size - app_start if app_size &gt; (img_size - app_start) else app_size
    obj.app.data = read_raw_data(stream, app_size, app_start)
    obj.app.padding = 0
    # Parse CSF
    # TODO finalize the code below
    # if obj.ivt.csf_address:
    #    obj.csf = SegCSF.parse(buffer)
    #    obj.csf.padding = obj.bdt.length - ((obj.ivt.csf_address - obj.ivt.ivt_address) + obj.csf.size)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.BootImg8m.app"><code class="name">var <span class="ident">app</span> :<a title="spsdk.image.segments.SegAPP" href="segments.html#spsdk.image.segments.SegAPP">SegAPP</a></code></dt>
<dd>
<div class="desc"><p>APP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app(self) -&gt; SegAPP:
    &#34;&#34;&#34;APP.&#34;&#34;&#34;
    return self._app</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.bdt"><code class="name">var <span class="ident">bdt</span> :<a title="spsdk.image.segments.SegBDT" href="segments.html#spsdk.image.segments.SegBDT">SegBDT</a></code></dt>
<dd>
<div class="desc"><p>BDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; SegBDT:
    &#34;&#34;&#34;BDT.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.csf"><code class="name">var <span class="ident">csf</span> :<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.ivt"><code class="name">var <span class="ident">ivt</span> :<a title="spsdk.image.segments.SegIVT2" href="segments.html#spsdk.image.segments.SegIVT2">SegIVT2</a></code></dt>
<dd>
<div class="desc"><p>IVT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; SegIVT2:
    &#34;&#34;&#34;IVT.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.plugin"><code class="name">var <span class="ident">plugin</span> :bool</code></dt>
<dd>
<div class="desc"><p>Plugin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; bool:
    &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
    return self._plg</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.size"><code class="name">var <span class="ident">size</span> :int</code></dt>
<dd>
<div class="desc"><p>Size of IMX Boot Image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IMX Boot Image.&#34;&#34;&#34;
    result = self.ivt.space
    result += self.bdt.space
    if self.dcd:
        result += self.dcd.space
    result += self.app.space
    result += self.csf.space
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.version"><code class="name">var <span class="ident">version</span> :int</code></dt>
<dd>
<div class="desc"><p>Version of IMX Boot Image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of IMX Boot Image.&#34;&#34;&#34;
    return self._ivt.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImg8m.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:<a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a>=4, address:int=0) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of img
:param img_type: Type of img
:param address: address in RAM
:raises Exception: raised when data type is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = 0) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of img
    :param img_type: Type of img
    :param address: address in RAM
    :raises Exception: raised when data type is unknown
    &#34;&#34;&#34;
    if img_type == EnumAppType.APP:
        self.app.data = data
        if address != 0:
            self.address = address
    else:
        raise Exception(&#39;Unknown data type !&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export Image as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export Image as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self._update()
    data = self.ivt.export()
    data += self.bdt.export()
    if self.dcd:
        data += self.dcd.export()
    data += self.app.export()
    data += self.csf.export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImg8m.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the IMX Boot Image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the IMX Boot Image.&#34;&#34;&#34;
    self._update()
    # Print IVT
    msg = &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# IVT (Image Vector Table)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self.ivt.info()
    # Print DBI
    msg += &#34;#&#34; * 60 + &#34;\n&#34;
    msg += &#34;# BDI (Boot Data Info)\n&#34;
    msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
    msg += self.bdt.info()
    # Print DCD
    if self.dcd:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# DCD (Device Config Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.dcd.info()
    # Print CSF
    if self.csf.enabled:
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# CSF (Code Signing Data)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.csf.info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.BootImgBase"><code class="flex name class">
<span>class <span class="ident">BootImgBase</span></span>
<span>(</span><span>address:int, offset:int)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image Base.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory
:param offset: The IVT offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImgBase:
    &#34;&#34;&#34;IMX Boot Image Base.&#34;&#34;&#34;

    def __init__(self, address: int, offset: int) -&gt; None:
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory
        :param offset: The IVT offset
        &#34;&#34;&#34;
        self.address = address
        self.offset = offset
        self._dcd: Optional[SegDCD] = None

    @property
    def dcd(self) -&gt; Optional[SegDCD]:
        &#34;&#34;&#34;Device configuration data (DCD) segment; None if not assigned.&#34;&#34;&#34;
        return self._dcd

    @dcd.setter
    def dcd(self, value: SegDCD) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new DCD segment
        &#34;&#34;&#34;
        assert isinstance(value, SegDCD)
        self._dcd = value

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        raise NotImplementedError()

    def add_image(self, data: bytes, img_type: EnumAppType, address: int) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw binary data of the application image
        :param img_type: see EnumAppType
        :param address: TBD
        &#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Binary representation of the instance (serialization).&#34;&#34;&#34;
        raise NotImplementedError()

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0x100,
              size: Optional[int] = None) -&gt; &#39;BootImgBase&#39;:
        &#34;&#34;&#34;Parse of IMX Boot Image Base.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImg2" href="#spsdk.image.images.BootImg2">BootImg2</a></li>
<li><a title="spsdk.image.images.BootImg3a" href="#spsdk.image.images.BootImg3a">BootImg3a</a></li>
<li><a title="spsdk.image.images.BootImg3b" href="#spsdk.image.images.BootImg3b">BootImg3b</a></li>
<li><a title="spsdk.image.images.BootImg4" href="#spsdk.image.images.BootImg4">BootImg4</a></li>
<li><a title="spsdk.image.images.BootImg8m" href="#spsdk.image.images.BootImg8m">BootImg8m</a></li>
<li><a title="spsdk.image.images.BootImgRT" href="#spsdk.image.images.BootImgRT">BootImgRT</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImgBase.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=256, size:Union[int,NoneType]=None) ><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse of IMX Boot Image Base.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0x100,
          size: Optional[int] = None) -&gt; &#39;BootImgBase&#39;:
    &#34;&#34;&#34;Parse of IMX Boot Image Base.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.BootImgBase.dcd"><code class="name">var <span class="ident">dcd</span> :Union[<a title="spsdk.image.segments.SegDCD" href="segments.html#spsdk.image.segments.SegDCD">SegDCD</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Device configuration data (DCD) segment; None if not assigned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dcd(self) -&gt; Optional[SegDCD]:
    &#34;&#34;&#34;Device configuration data (DCD) segment; None if not assigned.&#34;&#34;&#34;
    return self._dcd</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImgBase.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:<a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a>, address:int) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw binary data of the application image
:param img_type: see EnumAppType
:param address: TBD</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType, address: int) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw binary data of the application image
    :param img_type: see EnumAppType
    :param address: TBD
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgBase.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Binary representation of the instance (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Binary representation of the instance (serialization).&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgBase.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Text info about the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.images.BootImgRT"><code class="flex name class">
<span>class <span class="ident">BootImgRT</span></span>
<span>(</span><span>address:int, offset:int=4096, version:int=64, plugin:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Boot Image v2.</p>
<p>Initialize boot image object.</p>
<p>:param address: The start address of img in target memory, where the image is executed
:param offset: The IVT offset; use IVT_OFFSET_NOR_FLASH for NOR-FLASH or IVT_OFFSET_OTHER
:param version: The version of boot img format; default value should be used
:param plugin: Do not use; see <code>self.plugin</code> property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BootImgRT(BootImgBase):
    &#34;&#34;&#34;IMX Boot Image v2.&#34;&#34;&#34;

    # offset of the BEE PRDB Header segment
    BEE_OFFSET = 0x400
    # IVT offset for NOR flash
    IVT_OFFSET_NOR_FLASH = 0x1000
    # IVT offset for other memories
    IVT_OFFSET_OTHER = 0x400
    # supported IVT offsets
    IVT_OFFSETS = (IVT_OFFSET_OTHER, IVT_OFFSET_NOR_FLASH)
    # list of supported versions
    VERSIONS = (0x40, 0x41, 0x42, 0x43)
    # The offset and align value of APP segment (for XIP and non-XIP image)
    XIP_APP_OFFSET = 0x2000
    NON_XIP_APP_OFFSET = 0x1000
    # The value of CSF segment size
    CSF_SIZE = 0x2000
    # The length of BDT segment
    BDT_SIZE = 0x20
    # The length of DEK key section; Note: Dek key is just 16 bytes
    DEK_SIZE = 0x200  # TODO this is sector size alignment???

    def __init__(self, address: int, offset: int = IVT_OFFSET_NOR_FLASH, version: int = 0x40,
                 plugin: bool = False):
        &#34;&#34;&#34;Initialize boot image object.

        :param address: The start address of img in target memory, where the image is executed
        :param offset: The IVT offset; use IVT_OFFSET_NOR_FLASH for NOR-FLASH or IVT_OFFSET_OTHER
        :param version: The version of boot img format; default value should be used
        :param plugin: Do not use; see `self.plugin` property
        &#34;&#34;&#34;
        assert offset in BootImgRT.IVT_OFFSETS
        assert version in self.VERSIONS
        assert plugin is False  # not supported yet
        super().__init__(address, offset)
        self._nonce: Optional[bytes] = None
        self._dek_key: Optional[bytes] = None
        self._mac: Optional[bytes] = None
        self._fcb: AbstractFCB = PaddingFCB(self.IVT_OFFSET_OTHER)
        self._bee: SegBEE = SegBEE([])
        self._ivt: SegIVT2 = SegIVT2(version)
        self._bdt: SegBDT = SegBDT(plugin=int(plugin))
        self._app: SegAPP = SegAPP()
        self._dcd: Optional[SegDCD] = None
        self._csf: Optional[SegCSF] = None

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of the image format; must be from BootImgRT.VERSIONS.&#34;&#34;&#34;
        return self._ivt.version

    @property
    def dek_key(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;DEK key for encrypted images; None for non-encrypted images.&#34;&#34;&#34;
        return self._dek_key

    @dek_key.setter
    def dek_key(self, value: bytes) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: DEK key for encrypted images
        &#34;&#34;&#34;
        assert len(value) == MAC.AES128_BLK_LEN
        self._dek_key = value

    @property
    def plugin(self) -&gt; bool:
        &#34;&#34;&#34;Flag whether it is plugin image type; It is not fully supported by SPSDK yet.

        Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.
        &#34;&#34;&#34;
        return bool(self._bdt.plugin)

    @property
    def ivt(self) -&gt; SegIVT2:
        &#34;&#34;&#34;Image Vector Table (IVT) segment.&#34;&#34;&#34;
        return self._ivt

    @ivt.setter
    def ivt(self, value: SegIVT2) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new value
        &#34;&#34;&#34;
        assert isinstance(value, SegIVT2)
        self._ivt = value

    @property
    def ivt_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of the Image Vector Table (IVT) in the image.&#34;&#34;&#34;
        return self.offset

    @ivt_offset.setter
    def ivt_offset(self, value: int) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new IVT offset
        &#34;&#34;&#34;
        assert value in self.IVT_OFFSETS
        self.offset = value

    @property
    def bdt(self) -&gt; SegBDT:
        &#34;&#34;&#34;Boot Data Table.&#34;&#34;&#34;
        return self._bdt

    @bdt.setter
    def bdt(self, value: SegBDT) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new BDT value
        &#34;&#34;&#34;
        assert isinstance(value, SegBDT)
        self._bdt = value

    @property
    def app(self) -&gt; SegAPP:
        &#34;&#34;&#34;Segment with application image.&#34;&#34;&#34;
        return self._app

    @app.setter
    def app(self, value: SegAPP) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new application image
        &#34;&#34;&#34;
        assert isinstance(value, SegAPP)
        self._app = value

    @property
    def csf(self) -&gt; Optional[SegCSF]:
        &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: new CSF
        &#34;&#34;&#34;
        assert isinstance(value, SegCSF)
        self._csf = value
        self._update()

    @property
    def enabled_csf(self) -&gt; Optional[SegCSF]:
        &#34;&#34;&#34;Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.&#34;&#34;&#34;
        return None if (self.csf is None) or not self.csf.enabled else self.csf

    @property
    def fcb(self) -&gt; AbstractFCB:
        &#34;&#34;&#34;Flash Configuration(Control) Block, binary data; content depends on FLASH type.&#34;&#34;&#34;
        return self._fcb

    @fcb.setter
    def fcb(self, fcb: AbstractFCB) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param fcb: FCB instance to be set
        &#34;&#34;&#34;
        assert isinstance(fcb, AbstractFCB)
        self._fcb = fcb

    def set_flexspi_fcb(self, data: Union[bytes, FlexSPIConfBlockFCB]) -&gt; None:
        &#34;&#34;&#34;Set FlexSPI external FLASH configuration.

        :param data: FlexSPIConfBlockFCB or binary data representing
        :raise ValueError: if data are not valid Flex SPI configuration block
        &#34;&#34;&#34;
        self.fcb = data if isinstance(data, FlexSPIConfBlockFCB) else FlexSPIConfBlockFCB.parse(data)

    @property
    def bee(self) -&gt; SegBEE:
        &#34;&#34;&#34;:return: BEE segment that contains configuration of encrypted XIP.

        By default, BEE segment is empty. PRDB regions may be specified only for XIP images.
        &#34;&#34;&#34;
        return self._bee

    @property
    def app_offset(self) -&gt; int:
        &#34;&#34;&#34;:return: offset in the binary image, where the application starts.

        Please mind: the offset include FCB block (even the FCB block is not exported)
        The offset is 0x2000 for XIP images and 0x1000 for non-XIP images
        &#34;&#34;&#34;
        return BootImgRT.XIP_APP_OFFSET if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) \
            else BootImgRT.NON_XIP_APP_OFFSET

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the exported binary data.

        Please mind, FCB is exported optionally, but it is always included in the size
        &#34;&#34;&#34;
        if self.fcb.enabled:
            result = self.app_offset + self.app.space
        else:
            result = self.app_offset + self.app.space - self.ivt_offset
        if (self.csf is not None) and self.csf.enabled:
            result += self.csf.space
        return result

    def _update(self) -&gt; None:
        &#34;&#34;&#34;Update Image Object.&#34;&#34;&#34;
        # fcb
        self.fcb.padding_len = self.BEE_OFFSET - self.fcb.size if self.fcb.enabled else 0
        # bee
        if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) and self.fcb.enabled:
            self.bee.padding_len = self.ivt_offset - self.BEE_OFFSET - self.bee.size
        else:
            self.bee.padding_len = 0
        self.bee.update()
        # padding for APP sections
        self.app.padding_len = 0
        # Set IVT section
        self.ivt.padding_len = 0
        self.ivt.ivt_address = self.address + self.ivt_offset
        self.ivt.bdt_address = self.ivt.ivt_address + self.ivt.space
        self.ivt.dcd_address = 0
        self.ivt.csf_address = 0
        # Set BDT section
        self.bdt.app_start = self.address
        self.bdt.app_length = self.app_offset + self.app.size
        self.bdt.plugin = 1 if self.plugin else 0
        self.bdt.padding_len = self.BDT_SIZE - self.bdt.size
        if self.dcd is not None:
            self.ivt.dcd_address = self.ivt.bdt_address + self.bdt.space
            self.dcd.padding_len = 0
        csf = self.enabled_csf
        if csf:
            self._update_csf(csf)

    @property
    def dek_ram_address(self) -&gt; int:
        &#34;&#34;&#34;Address of the DEK key in the RAM memory retrieved from the corresponding command.

        -1 if the image does not contain command for DEK key installation
        &#34;&#34;&#34;
        csf = self.enabled_csf
        if csf:
            for cmd in csf.commands:
                if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                    return cmd.cmd_data_location
        return -1

    @property
    def dek_img_offset(self) -&gt; int:
        &#34;&#34;&#34;Offset of the DEK key in the image; -1 if DEK key address is available (see `dek_ram_address`).&#34;&#34;&#34;
        result = self.dek_ram_address
        return result if result &lt; 0 else result - self.address

    def _update_csf(self, csf: SegCSF) -&gt; None:
        &#34;&#34;&#34;Update CSF segment.

        :param csf: CSF segment tu be updated
        &#34;&#34;&#34;
        self.app.padding_len = align(self.app.size, 0x1000) - self.app.size
        csf.update(True)
        self.ivt.csf_address = self.address + self.app_offset + self.app.space
        csf.padding_len = self.CSF_SIZE - csf.size
        self.bdt.app_length = self.app_offset + self.app.space + csf.space
        if self.hab_encrypted:
            # calculate address of a DEK key
            for cmd in csf.commands:
                if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                    cmd.cmd_data_location = self.address + self.bdt.app_length
            #
            self.bdt.app_length += self.DEK_SIZE  # to include DEK
            # update encryption signature
            assert self._nonce
            assert self._mac
            for mac in csf.macs:
                mac.update_aead_encryption_params(self._nonce, self._mac)

    def info(self) -&gt; str:
        &#34;&#34;&#34;Text info about the instance.&#34;&#34;&#34;
        self._update()
        # Print FCB
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# FCB (Flash Configuration Block)\n&#34;
        msg += self.fcb.info()
        # Print BEE
        if self.bee_encrypted:
            msg = &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# BEE (Encrypted XIP configuration)\n&#34;
            msg += self.bee.info()
        # Print IVT
        msg = &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# IVT (Image Vector Table)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.ivt.info()
        # Print BDI
        msg += &#34;#&#34; * 60 + &#34;\n&#34;
        msg += &#34;# BDI (Boot Data Info)\n&#34;
        msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
        msg += self.bdt.info()
        # Print DCD
        if (self.dcd is not None) and self.dcd.enabled:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# DCD (Device Config Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += self.dcd.info()
        # Print CSF
        csf = self.enabled_csf
        if csf:
            msg += &#34;#&#34; * 60 + &#34;\n&#34;
            msg += &#34;# CSF (Code Signing Data)\n&#34;
            msg += &#34;#&#34; * 60 + &#34;\n\n&#34;
            msg += csf.info()
        return msg

    def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = -1,
                  dek_key: Optional[bytes] = None, nonce: Optional[bytes] = None) -&gt; None:
        &#34;&#34;&#34;Add specific image into the main boot image.

        :param data: Raw data of img
        :param img_type: value must be EnumAppType.APP, no other options supported in this class
        :param address: start address of the application (entry point); Use -1 to detect the address from the image
        :param dek_key: key for AES128 image HAB encryption [16 bytes],
                    - use None for non-encrypted images;
                    - use empty bytes to create random key (recommended)
                    - use fixed key for testing to produce stable output
        :param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
                        For non-encrypted image use `None`
                        The parameter should be used only for testing to produce stable output
        :raise ValueError: if any parameter is not valid
        &#34;&#34;&#34;
        assert img_type == EnumAppType.APP
        if self.app.data:
            raise ValueError(&#39;Image was already added&#39;)
        entry_addr = unpack_from(&#39;&lt;I&#39;, data, 4)[0]
        if entry_addr == 0:  # there can be padding for images located in RAM, see flashloader
            entry_addr = address
            assert entry_addr &gt; 0, &#39;entry_addr not detected from image, must be specified explicitly&#39;
        elif (address &gt;= 0) and (address != entry_addr):
            raise ValueError(&#39;entry_address does not match with the image&#39;)
        self._ivt.app_address = entry_addr
        self.app.data = data
        if dek_key is not None:  # encrypted?
            # initialize DEK key
            self._dek_key = bytes([0]) * MAC.AES128_BLK_LEN if len(dek_key) == 0 else dek_key
            if len(self._dek_key) != MAC.AES128_BLK_LEN:
                raise ValueError(f&#39;Invalid dek_key length, expected {MAC.AES128_BLK_LEN} bytes&#39;)
            # initialize NONCE
            if nonce:
                self._nonce = nonce
            nonce_len = BootImgRT.aead_nonce_len(self.app.size)
            if self._nonce is None:
                self._nonce = crypto_backend().random_bytes(nonce_len)
            elif len(self._nonce) != nonce_len:
                raise ValueError(f&#39;Invalid nonce length, expected {nonce_len} bytes&#39;)
            # encrypt APP
            assert self.hab_encrypted
            self.app.data = self._hab_encrypt_app_data(align_block(data, MAC.AES128_BLK_LEN))
        else:
            assert nonce is None

    def add_dcd_bin(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;Add DCD binary data.

        :param data: DCD binary data to be added
        &#34;&#34;&#34;
        assert self.dcd is None
        self.dcd = SegDCD.parse(data)
        assert self.dcd  # must be enabled to include DCD into export

    def add_csf_standard_auth(self, version: int, srk_table: SrkTable, src_key_index: int,
                              csf_cert: bytes, csf_priv_key: bytes,
                              img_cert: bytes, img_priv_key: bytes) -&gt; None:
        &#34;&#34;&#34;Add CSF with standard authentication.

        Before calling, application image and address must be assigned

        :param version: CSF segment version
        :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
        :param src_key_index: index of selected SRK key used for authentication
        :param csf_cert: CSF certificate
        :param csf_priv_key: CSF private key; decrypted binary data in PEM format
        :param img_cert: IMG certificate
        :param img_priv_key: IMG private key; decrypted binary data in PEM format
        &#34;&#34;&#34;
        assert 1 &lt;= len(srk_table) &lt;= 4
        assert 0 &lt;= src_key_index &lt; len(srk_table)
        csf = SegCSF(version=version, enabled=True)
        # install SRK
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
        cmd_ins.cmd_data_reference = srk_table
        csf.append_command(cmd_ins)
        # install CSF certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
        cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate content of the CSF segment
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=csf_priv_key)
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install image certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
        cert = x509.load_pem_x509_certificate(img_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate image data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=img_priv_key)
        cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
        if self.dcd:
            cmd_auth.append(self.address + self.ivt_offset + SegIVT2.SIZE + BootImgRT.BDT_SIZE, self.dcd.size)
        app_data = self.app.data
        assert app_data is not None
        cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        self.csf = csf

    @property
    def bee_encrypted(self) -&gt; bool:
        &#34;&#34;&#34;True if BEE encrypted XIP image (with SW keys); False otherwise; see also `hab_encrypted`.&#34;&#34;&#34;
        return self.bee.size &gt; 0

    @property
    def hab_encrypted(self) -&gt; bool:
        &#34;&#34;&#34;True if HAB encrypted; False otherwise; see also `bee_encrypted`.&#34;&#34;&#34;
        return self._dek_key is not None

    @staticmethod
    def aead_nonce_len(app_data_len: int) -&gt; int:
        &#34;&#34;&#34;Nonce len for AEAD encryption.

        Note: The code was taken from CST tool
        &#34;&#34;&#34;
        if app_data_len &lt; 0x10000:
            len_bytes = 2
        elif app_data_len &lt; 0x1000000:
            len_bytes = 3
        else:
            len_bytes = 4
        return 16 - 1 - len_bytes  # AES_BLOCK_BYTES - FLAG_BYTES - len_bytes

    def _hab_encrypt_app_data(self, app_data: bytes) -&gt; bytes:
        &#34;&#34;&#34;HAB Encrypt application data.

        :param app_data: application data to be encrypted
        :return: encrypted application data (using HAB encryption)
        &#34;&#34;&#34;
        assert self._nonce is not None
        assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
        dek = self.dek_key
        assert dek is not None
        aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
        encr = aesccm.encrypt(self._nonce, app_data, b&#39;&#39;)
        assert len(encr) == len(app_data) + 16
        self._mac = encr[-16:]
        return encr[:-16]

    @property
    def decrypted_app_data(self) -&gt; bytes:
        &#34;&#34;&#34;Return decrypted binary application data.

        Note: dek key, mac and nonce must be assigned for decryption
        &#34;&#34;&#34;
        app_data = self.app.data
        assert app_data
        if not self.hab_encrypted:
            return app_data

        assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
        mac = self._mac
        dek = self.dek_key
        assert mac and self._nonce and dek
        aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
        res = aesccm.decrypt(self._nonce, app_data + mac, b&#39;&#39;)
        return res

    def add_csf_encrypted(self, version: int, srk_table: SrkTable, src_key_index: int,
                          csf_cert: bytes, csf_priv_key: bytes,
                          img_cert: bytes, img_priv_key: bytes) -&gt; None:
        &#34;&#34;&#34;Add CSF with image encryption.

        Before calling, application image and address must be assigned

        :param version: CSF segment version
        :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
        :param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
        :param csf_cert: CSF certificate
        :param csf_priv_key: CSF private key; decrypted binary data in PEM format
        :param img_cert: IMG certificate
        :param img_priv_key: IMG private key; decrypted binary data in PEM format
        &#34;&#34;&#34;
        assert 1 &lt;= len(srk_table) &lt;= 4
        assert 0 &lt;= src_key_index &lt; len(srk_table)
        csf = SegCSF(version=version, enabled=True)
        # install SRK
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
        cmd_ins.cmd_data_reference = srk_table
        csf.append_command(cmd_ins)
        # install CSF certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
        cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate content of the CSF segment
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                               certificate=cert, private_key_pem_data=csf_priv_key)
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install image certificate
        cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
        cert = x509.load_pem_x509_certificate(img_cert, default_backend())
        cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
        csf.append_command(cmd_ins)
        # authenticate image data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS,
                               EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
        cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
        app_data = self.app.data
        assert app_data is not None
        cmd_auth.cmd_data_reference = Signature(version=version)
        csf.append_command(cmd_auth)
        # install DEK key
        cmd_ins = CmdInstallKey(EnumInsKey.ABS, EnumCertFormat.BLOB, EnumAlgorithm.ANY, 0, 0)
        csf.append_command(cmd_ins)
        # check encrypted data
        cmd_auth = CmdAuthData(EnumAuthDat.CLR, 0, EnumCertFormat.AEAD,
                               EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
        assert app_data is not None
        cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
        cmd_auth.cmd_data_reference = MAC(version=version, nonce_len=0xD, mac_len=16)
        csf.append_command(cmd_auth)
        #
        self.csf = csf

    def _export_fcb_bee(self, dbg_info: DebugInfo) -&gt; bytes:
        &#34;&#34;&#34;Export FCB and BEE segments.

        :param dbg_info: optional instance to provide info about exported data
        :return: binary FCB segment and BEE regions
        :raise ValueError: if any BEE region is configured for images not located in the FLASH
        &#34;&#34;&#34;
        if not self.fcb.enabled:
            return b&#39;&#39;
        data = self.fcb.export(dbg_info=dbg_info)
        assert len(data) == self.fcb.space
        if self.ivt_offset == self.IVT_OFFSET_NOR_FLASH:
            data += self.bee.export(dbg_info=dbg_info)
        elif self.bee.space &gt; 0:
            raise ValueError(&#39;BEE can be configured only for XIP images located in FLASH&#39;)
        return data

    def _bee_encrypt_img_data(self, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt data located in BEE regions.

        :param data: image data (including IVT offset) to be encrypted
        :return: the image with encrypted regions
        :raise ValueError: if image configuration is invalid and BEE encryption cannot be applied
        &#34;&#34;&#34;
        if not self.bee_encrypted:
            return data

        if self.ivt_offset != self.IVT_OFFSET_NOR_FLASH:
            raise ValueError(&#39;BEE encryption is supported only for NOR FLASH&#39;)
        if self.hab_encrypted:
            raise ValueError(&#39;BEE encryption cannot be used for HAB encrypted images&#39;)

        # encrypt
        return data[:self.ivt_offset] + self.bee.encrypt_data(self.address + self.ivt_offset, data[self.ivt_offset:])

    def export(self, zulu: datetime = datetime.now(timezone.utc),
               dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export image as bytes array.

        :param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
                Note: the parameter is applied to CSF only, so it is not used for unsigned images
        :param dbg_info: optional instance to provide info about exported data
        :raises ValueError: If the image is not encrypted
        :return: bytes
        &#34;&#34;&#34;
        csf = self.enabled_csf
        if csf:
            csf.update_signatures(zulu, b&#39;&#39;, 0)  # dummy call to provide size of the CSF section
        elif self.dek_key is not None:
            raise ValueError(&#39;CSF must be assigned for encrypted images&#39;)

        self._update()
        dbg_info.append_section(&#39;RT10xxBootableImage&#39;)
        # FCB + BEE
        data = self._export_fcb_bee(dbg_info)

        # IVT
        ivt_data = self.ivt.export()
        data += ivt_data
        dbg_info.append_binary_section(&#39;IVT&#39;, ivt_data)
        # BDT
        bdt_data = self.bdt.export()
        data += bdt_data
        dbg_info.append_binary_section(&#39;BDT&#39;, bdt_data)
        # DCD
        if (self.dcd is not None) and self.dcd.enabled:
            assert self.dcd.padding_len == 0  # no padding
            dcd_data = self.dcd.export()
            data += dcd_data
            dbg_info.append_binary_section(&#39;DCD&#39;, dcd_data)
        # padding before APP
        app_alignment = self.app_offset if self.fcb.enabled else self.app_offset - self.ivt_offset
        assert app_alignment &gt;= len(data)
        data = extend_block(data, app_alignment)
        # APP
        app_data = self.app.export()
        data += app_data
        dbg_info.append_binary_section(&#39;APP&#39;, app_data)
        # CSF
        if csf:
            if dbg_info:
                dbg_info.append_section(&#39;CSF&#39;)
            base_data_addr = self.address if self.fcb.enabled else self.address + self.ivt_offset
            csf.update_signatures(zulu, data, base_data_addr)
            data += csf.export(dbg_info=dbg_info)

        return self._bee_encrypt_img_data(data)

    @classmethod
    def _find_ivt_pos(cls, strm: Union[BufferedReader, BytesIO], size: Optional[int] = None) -&gt; Tuple[Header, int, int]:
        &#34;&#34;&#34;Search IVT start position in the image; used by parser.

        :param strm: of image data; start seeking from current position
        :param size: maximum length
        :raise ValueError: Raised when IVT is not found
        :return: tuple with: Header, start position, end position
        &#34;&#34;&#34;
        start_pos = strm.tell()
        end_pos = strm.seek(0, SEEK_END)

        if size:
            end_pos = min(start_pos + size, end_pos)

        for ivt_ofs in [0] + list(cls.IVT_OFFSETS):

            if start_pos + ivt_ofs &gt; end_pos:
                break
            strm.seek(start_pos + ivt_ofs)
            header_data = read_raw_data(strm, Header.SIZE, no_seek=True)
            try:
                header = Header.parse(header_data, required_tag=SegTag.IVT2)
                if (header.length == SegIVT2.SIZE) and (header.param in cls.VERSIONS):
                    return header, start_pos + ivt_ofs, end_pos
            except UnparsedException:  # ignore different header tags
                pass

        raise ValueError(&#34;IVT not found&#34;)

    @classmethod
    def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0,
              size: Optional[int] = None) -&gt; &#39;BootImgRT&#39;:
        &#34;&#34;&#34;Parse bootable RT image from stream buffer or bytes array.

        :param stream: The stream buffer or bytes array
        :param step: Image searching step (this parameter is not used for RT)
        :param size: parsing size; None to parse till the end of the stream
        :raises TypeError: Raised when the value type is incorrect
        :return: BootImgRT object
        &#34;&#34;&#34;
        if isinstance(stream, (bytes, bytearray)):
            stream = BytesIO(stream)

        if not isinstance(stream, (BufferedReader, BytesIO)):
            raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

        header, start_pos, end_pos = cls._find_ivt_pos(stream, size)

        obj = BootImgRT(0, version=header.param)
        img_size = end_pos - start_pos
        if start_pos &gt; 0:
            obj.ivt_offset = start_pos

        # Parse IVT
        obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
        # Parse BDT
        stream.seek(start_pos + obj.ivt.bdt_address - obj.ivt.ivt_address)
        obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
        obj.ivt_offset = obj.ivt.ivt_address - obj.bdt.app_start
        obj.address = obj.bdt.app_start
        # Parse DCD
        if obj.ivt.dcd_address:
            stream.seek(start_pos + obj.ivt.dcd_address - obj.ivt.ivt_address)
            dcd_obj = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
            obj.dcd = dcd_obj
            dcd_obj.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - dcd_obj.size
        # Parse APP
        if obj.ivt.csf_address &gt; 0:
            app_size = obj.ivt.csf_address - obj.ivt.ivt_address - (obj.app_offset - obj.ivt_offset)
        else:
            app_size = img_size - (obj.app_offset - obj.ivt_offset)
        obj.app.data = read_raw_data(stream, app_size, obj.app_offset - obj.ivt_offset + start_pos)
        obj.app.padding = 0
        # Parse CSF
        if obj.ivt.csf_address:
            csf_start = start_pos + (obj.ivt.csf_address - obj.ivt.ivt_address)
            obj.csf = SegCSF.parse(read_raw_data(stream, cls.CSF_SIZE, csf_start))
            # detect encrypted image using MAC section
            mac = next(obj.csf.macs, None)
            if mac:
                obj._nonce = mac.nonce
                obj._mac = mac.mac
                obj._dek_key = bytes([0]) * MAC.AES128_BLK_LEN  # dek key is not known

        # Parse FCB
        fcb_size = FlexSPIConfBlockFCB().size
        if start_pos &gt;= fcb_size:
            fcb_data = read_raw_data(stream, fcb_size, 0)
            if fcb_data == b&#39;\x00&#39; * fcb_size:  # test if empty
                obj.fcb = PaddingFCB(fcb_size)
            else:
                obj.set_flexspi_fcb(fcb_data)
        else:
            obj.fcb = PaddingFCB(0, enabled=False)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.BootImgRT.BDT_SIZE"><code class="name">var <span class="ident">BDT_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.BEE_OFFSET"><code class="name">var <span class="ident">BEE_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.CSF_SIZE"><code class="name">var <span class="ident">CSF_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.DEK_SIZE"><code class="name">var <span class="ident">DEK_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.IVT_OFFSETS"><code class="name">var <span class="ident">IVT_OFFSETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.IVT_OFFSET_NOR_FLASH"><code class="name">var <span class="ident">IVT_OFFSET_NOR_FLASH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.IVT_OFFSET_OTHER"><code class="name">var <span class="ident">IVT_OFFSET_OTHER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.NON_XIP_APP_OFFSET"><code class="name">var <span class="ident">NON_XIP_APP_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.VERSIONS"><code class="name">var <span class="ident">VERSIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.BootImgRT.XIP_APP_OFFSET"><code class="name">var <span class="ident">XIP_APP_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.BootImgRT.aead_nonce_len"><code class="name flex">
<span>def <span class="ident">aead_nonce_len</span></span>(<span>app_data_len:int) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Nonce len for AEAD encryption.</p>
<p>Note: The code was taken from CST tool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def aead_nonce_len(app_data_len: int) -&gt; int:
    &#34;&#34;&#34;Nonce len for AEAD encryption.

    Note: The code was taken from CST tool
    &#34;&#34;&#34;
    if app_data_len &lt; 0x10000:
        len_bytes = 2
    elif app_data_len &lt; 0x1000000:
        len_bytes = 3
    else:
        len_bytes = 4
    return 16 - 1 - len_bytes  # AES_BLOCK_BYTES - FLAG_BYTES - len_bytes</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>stream:Union[bytes,bytearray,_io.BufferedReader,_io.BytesIO], step:int=0, size:Union[int,NoneType]=None) ><a title="spsdk.image.images.BootImgRT" href="#spsdk.image.images.BootImgRT">BootImgRT</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse bootable RT image from stream buffer or bytes array.</p>
<p>:param stream: The stream buffer or bytes array
:param step: Image searching step (this parameter is not used for RT)
:param size: parsing size; None to parse till the end of the stream
:raises TypeError: Raised when the value type is incorrect
:return: BootImgRT object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, stream: Union[bytes, bytearray, BufferedReader, BytesIO], step: int = 0,
          size: Optional[int] = None) -&gt; &#39;BootImgRT&#39;:
    &#34;&#34;&#34;Parse bootable RT image from stream buffer or bytes array.

    :param stream: The stream buffer or bytes array
    :param step: Image searching step (this parameter is not used for RT)
    :param size: parsing size; None to parse till the end of the stream
    :raises TypeError: Raised when the value type is incorrect
    :return: BootImgRT object
    &#34;&#34;&#34;
    if isinstance(stream, (bytes, bytearray)):
        stream = BytesIO(stream)

    if not isinstance(stream, (BufferedReader, BytesIO)):
        raise TypeError(&#34; Not correct value type: \&#34;{}\&#34; !&#34;.format(type(stream)))

    header, start_pos, end_pos = cls._find_ivt_pos(stream, size)

    obj = BootImgRT(0, version=header.param)
    img_size = end_pos - start_pos
    if start_pos &gt; 0:
        obj.ivt_offset = start_pos

    # Parse IVT
    obj.ivt = SegIVT2.parse(read_raw_segment(stream, SegTag.IVT2))
    # Parse BDT
    stream.seek(start_pos + obj.ivt.bdt_address - obj.ivt.ivt_address)
    obj.bdt = SegBDT.parse(read_raw_data(stream, SegBDT.SIZE))
    obj.ivt_offset = obj.ivt.ivt_address - obj.bdt.app_start
    obj.address = obj.bdt.app_start
    # Parse DCD
    if obj.ivt.dcd_address:
        stream.seek(start_pos + obj.ivt.dcd_address - obj.ivt.ivt_address)
        dcd_obj = SegDCD.parse(read_raw_segment(stream, SegTag.DCD))
        obj.dcd = dcd_obj
        dcd_obj.padding = (obj.ivt.app_address - obj.ivt.dcd_address) - dcd_obj.size
    # Parse APP
    if obj.ivt.csf_address &gt; 0:
        app_size = obj.ivt.csf_address - obj.ivt.ivt_address - (obj.app_offset - obj.ivt_offset)
    else:
        app_size = img_size - (obj.app_offset - obj.ivt_offset)
    obj.app.data = read_raw_data(stream, app_size, obj.app_offset - obj.ivt_offset + start_pos)
    obj.app.padding = 0
    # Parse CSF
    if obj.ivt.csf_address:
        csf_start = start_pos + (obj.ivt.csf_address - obj.ivt.ivt_address)
        obj.csf = SegCSF.parse(read_raw_data(stream, cls.CSF_SIZE, csf_start))
        # detect encrypted image using MAC section
        mac = next(obj.csf.macs, None)
        if mac:
            obj._nonce = mac.nonce
            obj._mac = mac.mac
            obj._dek_key = bytes([0]) * MAC.AES128_BLK_LEN  # dek key is not known

    # Parse FCB
    fcb_size = FlexSPIConfBlockFCB().size
    if start_pos &gt;= fcb_size:
        fcb_data = read_raw_data(stream, fcb_size, 0)
        if fcb_data == b&#39;\x00&#39; * fcb_size:  # test if empty
            obj.fcb = PaddingFCB(fcb_size)
        else:
            obj.set_flexspi_fcb(fcb_data)
    else:
        obj.fcb = PaddingFCB(0, enabled=False)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.BootImgRT.app"><code class="name">var <span class="ident">app</span> :<a title="spsdk.image.segments.SegAPP" href="segments.html#spsdk.image.segments.SegAPP">SegAPP</a></code></dt>
<dd>
<div class="desc"><p>Segment with application image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app(self) -&gt; SegAPP:
    &#34;&#34;&#34;Segment with application image.&#34;&#34;&#34;
    return self._app</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.app_offset"><code class="name">var <span class="ident">app_offset</span> :int</code></dt>
<dd>
<div class="desc"><p>:return: offset in the binary image, where the application starts.</p>
<p>Please mind: the offset include FCB block (even the FCB block is not exported)
The offset is 0x2000 for XIP images and 0x1000 for non-XIP images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app_offset(self) -&gt; int:
    &#34;&#34;&#34;:return: offset in the binary image, where the application starts.

    Please mind: the offset include FCB block (even the FCB block is not exported)
    The offset is 0x2000 for XIP images and 0x1000 for non-XIP images
    &#34;&#34;&#34;
    return BootImgRT.XIP_APP_OFFSET if (self.ivt_offset == self.IVT_OFFSET_NOR_FLASH) \
        else BootImgRT.NON_XIP_APP_OFFSET</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.bdt"><code class="name">var <span class="ident">bdt</span> :<a title="spsdk.image.segments.SegBDT" href="segments.html#spsdk.image.segments.SegBDT">SegBDT</a></code></dt>
<dd>
<div class="desc"><p>Boot Data Table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bdt(self) -&gt; SegBDT:
    &#34;&#34;&#34;Boot Data Table.&#34;&#34;&#34;
    return self._bdt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.bee"><code class="name">var <span class="ident">bee</span> :<a title="spsdk.image.segments.SegBEE" href="segments.html#spsdk.image.segments.SegBEE">SegBEE</a></code></dt>
<dd>
<div class="desc"><p>:return: BEE segment that contains configuration of encrypted XIP.</p>
<p>By default, BEE segment is empty. PRDB regions may be specified only for XIP images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bee(self) -&gt; SegBEE:
    &#34;&#34;&#34;:return: BEE segment that contains configuration of encrypted XIP.

    By default, BEE segment is empty. PRDB regions may be specified only for XIP images.
    &#34;&#34;&#34;
    return self._bee</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.bee_encrypted"><code class="name">var <span class="ident">bee_encrypted</span> :bool</code></dt>
<dd>
<div class="desc"><p>True if BEE encrypted XIP image (with SW keys); False otherwise; see also <code>hab_encrypted</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bee_encrypted(self) -&gt; bool:
    &#34;&#34;&#34;True if BEE encrypted XIP image (with SW keys); False otherwise; see also `hab_encrypted`.&#34;&#34;&#34;
    return self.bee.size &gt; 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.csf"><code class="name">var <span class="ident">csf</span> :Union[<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Command Sequence File (CSF), signature block for Secure Boot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; Optional[SegCSF]:
    &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.decrypted_app_data"><code class="name">var <span class="ident">decrypted_app_data</span> :bytes</code></dt>
<dd>
<div class="desc"><p>Return decrypted binary application data.</p>
<p>Note: dek key, mac and nonce must be assigned for decryption</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def decrypted_app_data(self) -&gt; bytes:
    &#34;&#34;&#34;Return decrypted binary application data.

    Note: dek key, mac and nonce must be assigned for decryption
    &#34;&#34;&#34;
    app_data = self.app.data
    assert app_data
    if not self.hab_encrypted:
        return app_data

    assert len(app_data) &amp; (MAC.AES128_BLK_LEN - 1) == 0
    mac = self._mac
    dek = self.dek_key
    assert mac and self._nonce and dek
    aesccm = AESCCM(dek, tag_length=MAC.AES128_BLK_LEN)
    res = aesccm.decrypt(self._nonce, app_data + mac, b&#39;&#39;)
    return res</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.dek_img_offset"><code class="name">var <span class="ident">dek_img_offset</span> :int</code></dt>
<dd>
<div class="desc"><p>Offset of the DEK key in the image; -1 if DEK key address is available (see <code>dek_ram_address</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek_img_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of the DEK key in the image; -1 if DEK key address is available (see `dek_ram_address`).&#34;&#34;&#34;
    result = self.dek_ram_address
    return result if result &lt; 0 else result - self.address</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.dek_key"><code class="name">var <span class="ident">dek_key</span> :Union[bytes,NoneType]</code></dt>
<dd>
<div class="desc"><p>DEK key for encrypted images; None for non-encrypted images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek_key(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;DEK key for encrypted images; None for non-encrypted images.&#34;&#34;&#34;
    return self._dek_key</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.dek_ram_address"><code class="name">var <span class="ident">dek_ram_address</span> :int</code></dt>
<dd>
<div class="desc"><p>Address of the DEK key in the RAM memory retrieved from the corresponding command.</p>
<p>-1 if the image does not contain command for DEK key installation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dek_ram_address(self) -&gt; int:
    &#34;&#34;&#34;Address of the DEK key in the RAM memory retrieved from the corresponding command.

    -1 if the image does not contain command for DEK key installation
    &#34;&#34;&#34;
    csf = self.enabled_csf
    if csf:
        for cmd in csf.commands:
            if isinstance(cmd, CmdInstallKey) and (cmd.certificate_format == EnumCertFormat.BLOB):
                return cmd.cmd_data_location
    return -1</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.enabled_csf"><code class="name">var <span class="ident">enabled_csf</span> :Union[<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a>,NoneType]</code></dt>
<dd>
<div class="desc"><p>Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled_csf(self) -&gt; Optional[SegCSF]:
    &#34;&#34;&#34;Enabled Command Sequence File (CSF) segment; None if CSF is not defined or it is not enabled.&#34;&#34;&#34;
    return None if (self.csf is None) or not self.csf.enabled else self.csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.fcb"><code class="name">var <span class="ident">fcb</span> :<a title="spsdk.image.segments.AbstractFCB" href="segments.html#spsdk.image.segments.AbstractFCB">AbstractFCB</a></code></dt>
<dd>
<div class="desc"><p>Flash Configuration(Control) Block, binary data; content depends on FLASH type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fcb(self) -&gt; AbstractFCB:
    &#34;&#34;&#34;Flash Configuration(Control) Block, binary data; content depends on FLASH type.&#34;&#34;&#34;
    return self._fcb</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.hab_encrypted"><code class="name">var <span class="ident">hab_encrypted</span> :bool</code></dt>
<dd>
<div class="desc"><p>True if HAB encrypted; False otherwise; see also <code>bee_encrypted</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hab_encrypted(self) -&gt; bool:
    &#34;&#34;&#34;True if HAB encrypted; False otherwise; see also `bee_encrypted`.&#34;&#34;&#34;
    return self._dek_key is not None</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.ivt"><code class="name">var <span class="ident">ivt</span> :<a title="spsdk.image.segments.SegIVT2" href="segments.html#spsdk.image.segments.SegIVT2">SegIVT2</a></code></dt>
<dd>
<div class="desc"><p>Image Vector Table (IVT) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt(self) -&gt; SegIVT2:
    &#34;&#34;&#34;Image Vector Table (IVT) segment.&#34;&#34;&#34;
    return self._ivt</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.ivt_offset"><code class="name">var <span class="ident">ivt_offset</span> :int</code></dt>
<dd>
<div class="desc"><p>Offset of the Image Vector Table (IVT) in the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ivt_offset(self) -&gt; int:
    &#34;&#34;&#34;Offset of the Image Vector Table (IVT) in the image.&#34;&#34;&#34;
    return self.offset</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.plugin"><code class="name">var <span class="ident">plugin</span> :bool</code></dt>
<dd>
<div class="desc"><p>Flag whether it is plugin image type; It is not fully supported by SPSDK yet.</p>
<p>Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; bool:
    &#34;&#34;&#34;Flag whether it is plugin image type; It is not fully supported by SPSDK yet.

    Plugin is designed to load a boot image from devices that are not natively supported by boot ROM.
    &#34;&#34;&#34;
    return bool(self._bdt.plugin)</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.size"><code class="name">var <span class="ident">size</span> :int</code></dt>
<dd>
<div class="desc"><p>Size of the exported binary data.</p>
<p>Please mind, FCB is exported optionally, but it is always included in the size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the exported binary data.

    Please mind, FCB is exported optionally, but it is always included in the size
    &#34;&#34;&#34;
    if self.fcb.enabled:
        result = self.app_offset + self.app.space
    else:
        result = self.app_offset + self.app.space - self.ivt_offset
    if (self.csf is not None) and self.csf.enabled:
        result += self.csf.space
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.version"><code class="name">var <span class="ident">version</span> :int</code></dt>
<dd>
<div class="desc"><p>Version of the image format; must be from BootImgRT.VERSIONS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of the image format; must be from BootImgRT.VERSIONS.&#34;&#34;&#34;
    return self._ivt.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.BootImgRT.add_csf_encrypted"><code class="name flex">
<span>def <span class="ident">add_csf_encrypted</span></span>(<span>self, version:int, srk_table:<a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, src_key_index:int, csf_cert:bytes, csf_priv_key:bytes, img_cert:bytes, img_priv_key:bytes) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add CSF with image encryption.</p>
<p>Before calling, application image and address must be assigned</p>
<p>:param version: CSF segment version
:param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
:param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
:param csf_cert: CSF certificate
:param csf_priv_key: CSF private key; decrypted binary data in PEM format
:param img_cert: IMG certificate
:param img_priv_key: IMG private key; decrypted binary data in PEM format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_csf_encrypted(self, version: int, srk_table: SrkTable, src_key_index: int,
                      csf_cert: bytes, csf_priv_key: bytes,
                      img_cert: bytes, img_priv_key: bytes) -&gt; None:
    &#34;&#34;&#34;Add CSF with image encryption.

    Before calling, application image and address must be assigned

    :param version: CSF segment version
    :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
    :param src_key_index: index of selected SRK key used for authentication, 0..srk_table.len - 1
    :param csf_cert: CSF certificate
    :param csf_priv_key: CSF private key; decrypted binary data in PEM format
    :param img_cert: IMG certificate
    :param img_priv_key: IMG private key; decrypted binary data in PEM format
    &#34;&#34;&#34;
    assert 1 &lt;= len(srk_table) &lt;= 4
    assert 0 &lt;= src_key_index &lt; len(srk_table)
    csf = SegCSF(version=version, enabled=True)
    # install SRK
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
    cmd_ins.cmd_data_reference = srk_table
    csf.append_command(cmd_ins)
    # install CSF certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
    cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate content of the CSF segment
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                           certificate=cert, private_key_pem_data=csf_priv_key)
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    # install image certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
    cert = x509.load_pem_x509_certificate(img_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate image data
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS,
                           EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
    cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
    app_data = self.app.data
    assert app_data is not None
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    # install DEK key
    cmd_ins = CmdInstallKey(EnumInsKey.ABS, EnumCertFormat.BLOB, EnumAlgorithm.ANY, 0, 0)
    csf.append_command(cmd_ins)
    # check encrypted data
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 0, EnumCertFormat.AEAD,
                           EnumEngine.DCP, certificate=cert, private_key_pem_data=img_priv_key)
    assert app_data is not None
    cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
    cmd_auth.cmd_data_reference = MAC(version=version, nonce_len=0xD, mac_len=16)
    csf.append_command(cmd_auth)
    #
    self.csf = csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.add_csf_standard_auth"><code class="name flex">
<span>def <span class="ident">add_csf_standard_auth</span></span>(<span>self, version:int, srk_table:<a title="spsdk.image.secret.SrkTable" href="secret.html#spsdk.image.secret.SrkTable">SrkTable</a>, src_key_index:int, csf_cert:bytes, csf_priv_key:bytes, img_cert:bytes, img_priv_key:bytes) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add CSF with standard authentication.</p>
<p>Before calling, application image and address must be assigned</p>
<p>:param version: CSF segment version
:param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
:param src_key_index: index of selected SRK key used for authentication
:param csf_cert: CSF certificate
:param csf_priv_key: CSF private key; decrypted binary data in PEM format
:param img_cert: IMG certificate
:param img_priv_key: IMG private key; decrypted binary data in PEM format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_csf_standard_auth(self, version: int, srk_table: SrkTable, src_key_index: int,
                          csf_cert: bytes, csf_priv_key: bytes,
                          img_cert: bytes, img_priv_key: bytes) -&gt; None:
    &#34;&#34;&#34;Add CSF with standard authentication.

    Before calling, application image and address must be assigned

    :param version: CSF segment version
    :param srk_table: SRK table of root certificates; must contain min 1, max 4 certificates
    :param src_key_index: index of selected SRK key used for authentication
    :param csf_cert: CSF certificate
    :param csf_priv_key: CSF private key; decrypted binary data in PEM format
    :param img_cert: IMG certificate
    :param img_priv_key: IMG private key; decrypted binary data in PEM format
    &#34;&#34;&#34;
    assert 1 &lt;= len(srk_table) &lt;= 4
    assert 0 &lt;= src_key_index &lt; len(srk_table)
    csf = SegCSF(version=version, enabled=True)
    # install SRK
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.SRK, EnumAlgorithm.SHA256, src_key_index, 0)
    cmd_ins.cmd_data_reference = srk_table
    csf.append_command(cmd_ins)
    # install CSF certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CSF, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 1)
    cert = x509.load_pem_x509_certificate(csf_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate content of the CSF segment
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 1, EnumCertFormat.CMS, EnumEngine.DCP,
                           certificate=cert, private_key_pem_data=csf_priv_key)
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    # install image certificate
    cmd_ins = CmdInstallKey(EnumInsKey.CLR, EnumCertFormat.X509, EnumAlgorithm.ANY, 0, 2)
    cert = x509.load_pem_x509_certificate(img_cert, default_backend())
    cmd_ins.cmd_data_reference = CertificateImg(version=version, data=cert.public_bytes(Encoding.DER))
    csf.append_command(cmd_ins)
    # authenticate image data
    cmd_auth = CmdAuthData(EnumAuthDat.CLR, 2, EnumCertFormat.CMS, EnumEngine.DCP,
                           certificate=cert, private_key_pem_data=img_priv_key)
    cmd_auth.append(self.address + self.ivt_offset, SegIVT2.SIZE + BootImgRT.BDT_SIZE)
    if self.dcd:
        cmd_auth.append(self.address + self.ivt_offset + SegIVT2.SIZE + BootImgRT.BDT_SIZE, self.dcd.size)
    app_data = self.app.data
    assert app_data is not None
    cmd_auth.append(self.address + self.app_offset, align(len(app_data), 16))
    cmd_auth.cmd_data_reference = Signature(version=version)
    csf.append_command(cmd_auth)
    self.csf = csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.add_dcd_bin"><code class="name flex">
<span>def <span class="ident">add_dcd_bin</span></span>(<span>self, data:bytes) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add DCD binary data.</p>
<p>:param data: DCD binary data to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dcd_bin(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;Add DCD binary data.

    :param data: DCD binary data to be added
    &#34;&#34;&#34;
    assert self.dcd is None
    self.dcd = SegDCD.parse(data)
    assert self.dcd  # must be enabled to include DCD into export</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.add_image"><code class="name flex">
<span>def <span class="ident">add_image</span></span>(<span>self, data:bytes, img_type:<a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a>=4, address:int=-1, dek_key:Union[bytes,NoneType]=None, nonce:Union[bytes,NoneType]=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add specific image into the main boot image.</p>
<p>:param data: Raw data of img
:param img_type: value must be EnumAppType.APP, no other options supported in this class
:param address: start address of the application (entry point); Use -1 to detect the address from the image
:param dek_key: key for AES128 image HAB encryption [16 bytes],
- use None for non-encrypted images;
- use empty bytes to create random key (recommended)
- use fixed key for testing to produce stable output
:param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
For non-encrypted image use <code>None</code>
The parameter should be used only for testing to produce stable output
:raise ValueError: if any parameter is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_image(self, data: bytes, img_type: EnumAppType = EnumAppType.APP, address: int = -1,
              dek_key: Optional[bytes] = None, nonce: Optional[bytes] = None) -&gt; None:
    &#34;&#34;&#34;Add specific image into the main boot image.

    :param data: Raw data of img
    :param img_type: value must be EnumAppType.APP, no other options supported in this class
    :param address: start address of the application (entry point); Use -1 to detect the address from the image
    :param dek_key: key for AES128 image HAB encryption [16 bytes],
                - use None for non-encrypted images;
                - use empty bytes to create random key (recommended)
                - use fixed key for testing to produce stable output
    :param nonce: initial vector for AEAD HAB encryption, if not specified random value is used;
                    For non-encrypted image use `None`
                    The parameter should be used only for testing to produce stable output
    :raise ValueError: if any parameter is not valid
    &#34;&#34;&#34;
    assert img_type == EnumAppType.APP
    if self.app.data:
        raise ValueError(&#39;Image was already added&#39;)
    entry_addr = unpack_from(&#39;&lt;I&#39;, data, 4)[0]
    if entry_addr == 0:  # there can be padding for images located in RAM, see flashloader
        entry_addr = address
        assert entry_addr &gt; 0, &#39;entry_addr not detected from image, must be specified explicitly&#39;
    elif (address &gt;= 0) and (address != entry_addr):
        raise ValueError(&#39;entry_address does not match with the image&#39;)
    self._ivt.app_address = entry_addr
    self.app.data = data
    if dek_key is not None:  # encrypted?
        # initialize DEK key
        self._dek_key = bytes([0]) * MAC.AES128_BLK_LEN if len(dek_key) == 0 else dek_key
        if len(self._dek_key) != MAC.AES128_BLK_LEN:
            raise ValueError(f&#39;Invalid dek_key length, expected {MAC.AES128_BLK_LEN} bytes&#39;)
        # initialize NONCE
        if nonce:
            self._nonce = nonce
        nonce_len = BootImgRT.aead_nonce_len(self.app.size)
        if self._nonce is None:
            self._nonce = crypto_backend().random_bytes(nonce_len)
        elif len(self._nonce) != nonce_len:
            raise ValueError(f&#39;Invalid nonce length, expected {nonce_len} bytes&#39;)
        # encrypt APP
        assert self.hab_encrypted
        self.app.data = self._hab_encrypt_app_data(align_block(data, MAC.AES128_BLK_LEN))
    else:
        assert nonce is None</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, zulu:datetime.datetime=datetime.datetime(2020, 10, 30, 7, 52, 42, 186926, tzinfo=datetime.timezone.utc), dbg_info:<a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a>=&lt;spsdk.utils.misc.DebugInfo object&gt;) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export image as bytes array.</p>
<p>:param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
Note: the parameter is applied to CSF only, so it is not used for unsigned images
:param dbg_info: optional instance to provide info about exported data
:raises ValueError: If the image is not encrypted
:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, zulu: datetime = datetime.now(timezone.utc),
           dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export image as bytes array.

    :param zulu: optional UTC datetime; should be used only if you need fixed datetime for the test
            Note: the parameter is applied to CSF only, so it is not used for unsigned images
    :param dbg_info: optional instance to provide info about exported data
    :raises ValueError: If the image is not encrypted
    :return: bytes
    &#34;&#34;&#34;
    csf = self.enabled_csf
    if csf:
        csf.update_signatures(zulu, b&#39;&#39;, 0)  # dummy call to provide size of the CSF section
    elif self.dek_key is not None:
        raise ValueError(&#39;CSF must be assigned for encrypted images&#39;)

    self._update()
    dbg_info.append_section(&#39;RT10xxBootableImage&#39;)
    # FCB + BEE
    data = self._export_fcb_bee(dbg_info)

    # IVT
    ivt_data = self.ivt.export()
    data += ivt_data
    dbg_info.append_binary_section(&#39;IVT&#39;, ivt_data)
    # BDT
    bdt_data = self.bdt.export()
    data += bdt_data
    dbg_info.append_binary_section(&#39;BDT&#39;, bdt_data)
    # DCD
    if (self.dcd is not None) and self.dcd.enabled:
        assert self.dcd.padding_len == 0  # no padding
        dcd_data = self.dcd.export()
        data += dcd_data
        dbg_info.append_binary_section(&#39;DCD&#39;, dcd_data)
    # padding before APP
    app_alignment = self.app_offset if self.fcb.enabled else self.app_offset - self.ivt_offset
    assert app_alignment &gt;= len(data)
    data = extend_block(data, app_alignment)
    # APP
    app_data = self.app.export()
    data += app_data
    dbg_info.append_binary_section(&#39;APP&#39;, app_data)
    # CSF
    if csf:
        if dbg_info:
            dbg_info.append_section(&#39;CSF&#39;)
        base_data_addr = self.address if self.fcb.enabled else self.address + self.ivt_offset
        csf.update_signatures(zulu, data, base_data_addr)
        data += csf.export(dbg_info=dbg_info)

    return self._bee_encrypt_img_data(data)</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.BootImgRT.set_flexspi_fcb"><code class="name flex">
<span>def <span class="ident">set_flexspi_fcb</span></span>(<span>self, data:Union[bytes,<a title="spsdk.image.segments.FlexSPIConfBlockFCB" href="segments.html#spsdk.image.segments.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a>]) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set FlexSPI external FLASH configuration.</p>
<p>:param data: FlexSPIConfBlockFCB or binary data representing
:raise ValueError: if data are not valid Flex SPI configuration block</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_flexspi_fcb(self, data: Union[bytes, FlexSPIConfBlockFCB]) -&gt; None:
    &#34;&#34;&#34;Set FlexSPI external FLASH configuration.

    :param data: FlexSPIConfBlockFCB or binary data representing
    :raise ValueError: if data are not valid Flex SPI configuration block
    &#34;&#34;&#34;
    self.fcb = data if isinstance(data, FlexSPIConfBlockFCB) else FlexSPIConfBlockFCB.parse(data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
<li><code><a title="spsdk.image.images.BootImgBase.info" href="#spsdk.image.images.BootImgBase.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.EnumAppType"><code class="flex name class">
<span>class <span class="ident">EnumAppType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Type of the application image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumAppType(Enum):
    &#34;&#34;&#34;Type of the application image.&#34;&#34;&#34;
    SCFW = 1
    M4_0 = 2
    M4_1 = 3
    APP = 4  # actually this means APP or A35 or A53
    A72 = 5
    SCD = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.EnumAppType.A72"><code class="name">var <span class="ident">A72</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.EnumAppType.APP"><code class="name">var <span class="ident">APP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.EnumAppType.M4_0"><code class="name">var <span class="ident">M4_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.EnumAppType.M4_1"><code class="name">var <span class="ident">M4_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.EnumAppType.SCD"><code class="name">var <span class="ident">SCD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.images.EnumAppType.SCFW"><code class="name">var <span class="ident">SCFW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.images.KernelImg"><code class="flex name class">
<span>class <span class="ident">KernelImg</span></span>
<span>(</span><span>address:int=0, app:Union[bytes,NoneType]=None, csf:Union[<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a>,Any]=None, version:int=65)</span>
</code></dt>
<dd>
<div class="desc"><p>IMX Kernel Image.</p>
<p>Initialize the IMX Kernel Image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KernelImg:
    &#34;&#34;&#34;IMX Kernel Image.&#34;&#34;&#34;

    IMAGE_MIN_SIZE = 0x1000

    @property
    def address(self) -&gt; int:
        &#34;&#34;&#34;Address.&#34;&#34;&#34;
        return self._ivt.app_address

    @address.setter
    def address(self, value: int) -&gt; None:
        self._ivt.app_address = value

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version.&#34;&#34;&#34;
        return self._ivt.version

    @version.setter
    def version(self, value: int) -&gt; None:
        self._ivt.version = value

    @property
    def app(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;APP.&#34;&#34;&#34;
        return self._app.data

    @app.setter
    def app(self, value: Union[bytes, bytearray]) -&gt; None:
        assert isinstance(value, (bytes, bytearray))
        self._app.data = value

    @property
    def csf(self) -&gt; SegCSF:
        &#34;&#34;&#34;CSF.&#34;&#34;&#34;
        return self._csf

    @csf.setter
    def csf(self, value: SegCSF) -&gt; None:
        assert isinstance(value, SegCSF)
        self._csf = value

    def __init__(self, address: int = 0, app: Optional[bytes] = None,
                 csf: Union[SegCSF, Any] = None, version: int = 0x41) -&gt; None:
        &#34;&#34;&#34;Initialize the IMX Kernel Image.&#34;&#34;&#34;
        self._ivt = SegIVT2(version)
        self._ivt.app_address = address
        self._app = SegAPP(app)
        self._csf = SegCSF() if csf is None else csf

    def __str__(self) -&gt; str:
        return &#39;&#39;

    def __repr__(self) -&gt; str:
        return &#39;&#39;

    def _update(self) -&gt; None:
        pass

    def info(self) -&gt; None:
        &#34;&#34;&#34;String representation of the IMX Kernel Image.&#34;&#34;&#34;
        pass

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export.&#34;&#34;&#34;
        self._update()
        data = self._app.export()
        data += self._ivt.export()
        data += self._csf.export()
        return data

    @classmethod
    def parse(cls, data: Union[str, bytes]) -&gt; None:
        &#34;&#34;&#34;Parse.&#34;&#34;&#34;
        assert isinstance(data, (bytes, str))
        assert len(data) &gt; cls.IMAGE_MIN_SIZE</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.images.KernelImg.IMAGE_MIN_SIZE"><code class="name">var <span class="ident">IMAGE_MIN_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.images.KernelImg.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data:Union[str,bytes]) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: Union[str, bytes]) -&gt; None:
    &#34;&#34;&#34;Parse.&#34;&#34;&#34;
    assert isinstance(data, (bytes, str))
    assert len(data) &gt; cls.IMAGE_MIN_SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.images.KernelImg.address"><code class="name">var <span class="ident">address</span> :int</code></dt>
<dd>
<div class="desc"><p>Address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; int:
    &#34;&#34;&#34;Address.&#34;&#34;&#34;
    return self._ivt.app_address</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.KernelImg.app"><code class="name">var <span class="ident">app</span> :Union[bytes,NoneType]</code></dt>
<dd>
<div class="desc"><p>APP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def app(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;APP.&#34;&#34;&#34;
    return self._app.data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.KernelImg.csf"><code class="name">var <span class="ident">csf</span> :<a title="spsdk.image.segments.SegCSF" href="segments.html#spsdk.image.segments.SegCSF">SegCSF</a></code></dt>
<dd>
<div class="desc"><p>CSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def csf(self) -&gt; SegCSF:
    &#34;&#34;&#34;CSF.&#34;&#34;&#34;
    return self._csf</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.KernelImg.version"><code class="name">var <span class="ident">version</span> :int</code></dt>
<dd>
<div class="desc"><p>Version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version.&#34;&#34;&#34;
    return self._ivt.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.images.KernelImg.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export.&#34;&#34;&#34;
    self._update()
    data = self._app.export()
    data += self._ivt.export()
    data += self._csf.export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.images.KernelImg.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the IMX Kernel Image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; None:
    &#34;&#34;&#34;String representation of the IMX Kernel Image.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.image" href="index.html">spsdk.image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spsdk.image.images.parse" href="#spsdk.image.images.parse">parse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.image.images.BootImg2" href="#spsdk.image.images.BootImg2">BootImg2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.images.BootImg2.APP_ALIGN" href="#spsdk.image.images.BootImg2.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.CSF_SIZE" href="#spsdk.image.images.BootImg2.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.HEAD_SIZE" href="#spsdk.image.images.BootImg2.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.add_image" href="#spsdk.image.images.BootImg2.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.app" href="#spsdk.image.images.BootImg2.app">app</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.bdt" href="#spsdk.image.images.BootImg2.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.csf" href="#spsdk.image.images.BootImg2.csf">csf</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.export" href="#spsdk.image.images.BootImg2.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.info" href="#spsdk.image.images.BootImg2.info">info</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.ivt" href="#spsdk.image.images.BootImg2.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.parse" href="#spsdk.image.images.BootImg2.parse">parse</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.plugin" href="#spsdk.image.images.BootImg2.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.size" href="#spsdk.image.images.BootImg2.size">size</a></code></li>
<li><code><a title="spsdk.image.images.BootImg2.version" href="#spsdk.image.images.BootImg2.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.BootImg3a" href="#spsdk.image.images.BootImg3a">BootImg3a</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.images.BootImg3a.APP_ALIGN" href="#spsdk.image.images.BootImg3a.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.COUNT_OF_CONTAINERS" href="#spsdk.image.images.BootImg3a.COUNT_OF_CONTAINERS">COUNT_OF_CONTAINERS</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.CSF_SIZE" href="#spsdk.image.images.BootImg3a.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.HEAD_SIZE" href="#spsdk.image.images.BootImg3a.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.IMG_AUTO_ALIGN" href="#spsdk.image.images.BootImg3a.IMG_AUTO_ALIGN">IMG_AUTO_ALIGN</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.IMG_TYPE_CSF" href="#spsdk.image.images.BootImg3a.IMG_TYPE_CSF">IMG_TYPE_CSF</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.IMG_TYPE_DATA" href="#spsdk.image.images.BootImg3a.IMG_TYPE_DATA">IMG_TYPE_DATA</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.IMG_TYPE_EXEC" href="#spsdk.image.images.BootImg3a.IMG_TYPE_EXEC">IMG_TYPE_EXEC</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.IMG_TYPE_SCD" href="#spsdk.image.images.BootImg3a.IMG_TYPE_SCD">IMG_TYPE_SCD</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_AP_ROM" href="#spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_AP_ROM">INITIAL_LOAD_ADDR_AP_ROM</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_FLEXSPI" href="#spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_FLEXSPI">INITIAL_LOAD_ADDR_FLEXSPI</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_SCU_ROM" href="#spsdk.image.images.BootImg3a.INITIAL_LOAD_ADDR_SCU_ROM">INITIAL_LOAD_ADDR_SCU_ROM</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.PADDING_VAL" href="#spsdk.image.images.BootImg3a.PADDING_VAL">PADDING_VAL</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.SCFW_FLAGS_APP" href="#spsdk.image.images.BootImg3a.SCFW_FLAGS_APP">SCFW_FLAGS_APP</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.SCFW_FLAGS_M4_0" href="#spsdk.image.images.BootImg3a.SCFW_FLAGS_M4_0">SCFW_FLAGS_M4_0</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.SCFW_FLAGS_M4_1" href="#spsdk.image.images.BootImg3a.SCFW_FLAGS_M4_1">SCFW_FLAGS_M4_1</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.SCFW_FLAGS_SCFW" href="#spsdk.image.images.BootImg3a.SCFW_FLAGS_SCFW">SCFW_FLAGS_SCFW</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.SECTOR_SIZE" href="#spsdk.image.images.BootImg3a.SECTOR_SIZE">SECTOR_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.add_image" href="#spsdk.image.images.BootImg3a.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.bdt" href="#spsdk.image.images.BootImg3a.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.csf" href="#spsdk.image.images.BootImg3a.csf">csf</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.export" href="#spsdk.image.images.BootImg3a.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.info" href="#spsdk.image.images.BootImg3a.info">info</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.ivt" href="#spsdk.image.images.BootImg3a.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.parse" href="#spsdk.image.images.BootImg3a.parse">parse</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3a.plg" href="#spsdk.image.images.BootImg3a.plg">plg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.BootImg3b" href="#spsdk.image.images.BootImg3b">BootImg3b</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.images.BootImg3b.APP_ALIGN" href="#spsdk.image.images.BootImg3b.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.COUNT_OF_CONTAINERS" href="#spsdk.image.images.BootImg3b.COUNT_OF_CONTAINERS">COUNT_OF_CONTAINERS</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.CSF_SIZE" href="#spsdk.image.images.BootImg3b.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.HEAD_SIZE" href="#spsdk.image.images.BootImg3b.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.IMG_AUTO_ALIGN" href="#spsdk.image.images.BootImg3b.IMG_AUTO_ALIGN">IMG_AUTO_ALIGN</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.IMG_TYPE_CSF" href="#spsdk.image.images.BootImg3b.IMG_TYPE_CSF">IMG_TYPE_CSF</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.IMG_TYPE_DATA" href="#spsdk.image.images.BootImg3b.IMG_TYPE_DATA">IMG_TYPE_DATA</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.IMG_TYPE_EXEC" href="#spsdk.image.images.BootImg3b.IMG_TYPE_EXEC">IMG_TYPE_EXEC</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.IMG_TYPE_SCD" href="#spsdk.image.images.BootImg3b.IMG_TYPE_SCD">IMG_TYPE_SCD</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_AP_ROM" href="#spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_AP_ROM">INITIAL_LOAD_ADDR_AP_ROM</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_FLEXSPI" href="#spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_FLEXSPI">INITIAL_LOAD_ADDR_FLEXSPI</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_SCU_ROM" href="#spsdk.image.images.BootImg3b.INITIAL_LOAD_ADDR_SCU_ROM">INITIAL_LOAD_ADDR_SCU_ROM</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.PADDING_VAL" href="#spsdk.image.images.BootImg3b.PADDING_VAL">PADDING_VAL</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.SCFW_FLAGS_A53" href="#spsdk.image.images.BootImg3b.SCFW_FLAGS_A53">SCFW_FLAGS_A53</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.SCFW_FLAGS_A72" href="#spsdk.image.images.BootImg3b.SCFW_FLAGS_A72">SCFW_FLAGS_A72</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.SCFW_FLAGS_M4_0" href="#spsdk.image.images.BootImg3b.SCFW_FLAGS_M4_0">SCFW_FLAGS_M4_0</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.SCFW_FLAGS_M4_1" href="#spsdk.image.images.BootImg3b.SCFW_FLAGS_M4_1">SCFW_FLAGS_M4_1</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.SCFW_FLAGS_SCFW" href="#spsdk.image.images.BootImg3b.SCFW_FLAGS_SCFW">SCFW_FLAGS_SCFW</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.SECTOR_SIZE" href="#spsdk.image.images.BootImg3b.SECTOR_SIZE">SECTOR_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.add_image" href="#spsdk.image.images.BootImg3b.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.bdt" href="#spsdk.image.images.BootImg3b.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.csf" href="#spsdk.image.images.BootImg3b.csf">csf</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.export" href="#spsdk.image.images.BootImg3b.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.info" href="#spsdk.image.images.BootImg3b.info">info</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.ivt" href="#spsdk.image.images.BootImg3b.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.parse" href="#spsdk.image.images.BootImg3b.parse">parse</a></code></li>
<li><code><a title="spsdk.image.images.BootImg3b.plg" href="#spsdk.image.images.BootImg3b.plg">plg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.BootImg4" href="#spsdk.image.images.BootImg4">BootImg4</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.images.BootImg4.add_image" href="#spsdk.image.images.BootImg4.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImg4.export" href="#spsdk.image.images.BootImg4.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImg4.info" href="#spsdk.image.images.BootImg4.info">info</a></code></li>
<li><code><a title="spsdk.image.images.BootImg4.parse" href="#spsdk.image.images.BootImg4.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.BootImg8m" href="#spsdk.image.images.BootImg8m">BootImg8m</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.images.BootImg8m.APP_ALIGN" href="#spsdk.image.images.BootImg8m.APP_ALIGN">APP_ALIGN</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.CSF_SIZE" href="#spsdk.image.images.BootImg8m.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.HEAD_SIZE" href="#spsdk.image.images.BootImg8m.HEAD_SIZE">HEAD_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.add_image" href="#spsdk.image.images.BootImg8m.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.app" href="#spsdk.image.images.BootImg8m.app">app</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.bdt" href="#spsdk.image.images.BootImg8m.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.csf" href="#spsdk.image.images.BootImg8m.csf">csf</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.export" href="#spsdk.image.images.BootImg8m.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.info" href="#spsdk.image.images.BootImg8m.info">info</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.ivt" href="#spsdk.image.images.BootImg8m.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.parse" href="#spsdk.image.images.BootImg8m.parse">parse</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.plugin" href="#spsdk.image.images.BootImg8m.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.size" href="#spsdk.image.images.BootImg8m.size">size</a></code></li>
<li><code><a title="spsdk.image.images.BootImg8m.version" href="#spsdk.image.images.BootImg8m.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.BootImgBase" href="#spsdk.image.images.BootImgBase">BootImgBase</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.images.BootImgBase.add_image" href="#spsdk.image.images.BootImgBase.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImgBase.dcd" href="#spsdk.image.images.BootImgBase.dcd">dcd</a></code></li>
<li><code><a title="spsdk.image.images.BootImgBase.export" href="#spsdk.image.images.BootImgBase.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImgBase.info" href="#spsdk.image.images.BootImgBase.info">info</a></code></li>
<li><code><a title="spsdk.image.images.BootImgBase.parse" href="#spsdk.image.images.BootImgBase.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.BootImgRT" href="#spsdk.image.images.BootImgRT">BootImgRT</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.images.BootImgRT.BDT_SIZE" href="#spsdk.image.images.BootImgRT.BDT_SIZE">BDT_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.BEE_OFFSET" href="#spsdk.image.images.BootImgRT.BEE_OFFSET">BEE_OFFSET</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.CSF_SIZE" href="#spsdk.image.images.BootImgRT.CSF_SIZE">CSF_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.DEK_SIZE" href="#spsdk.image.images.BootImgRT.DEK_SIZE">DEK_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.IVT_OFFSETS" href="#spsdk.image.images.BootImgRT.IVT_OFFSETS">IVT_OFFSETS</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.IVT_OFFSET_NOR_FLASH" href="#spsdk.image.images.BootImgRT.IVT_OFFSET_NOR_FLASH">IVT_OFFSET_NOR_FLASH</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.IVT_OFFSET_OTHER" href="#spsdk.image.images.BootImgRT.IVT_OFFSET_OTHER">IVT_OFFSET_OTHER</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.NON_XIP_APP_OFFSET" href="#spsdk.image.images.BootImgRT.NON_XIP_APP_OFFSET">NON_XIP_APP_OFFSET</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.VERSIONS" href="#spsdk.image.images.BootImgRT.VERSIONS">VERSIONS</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.XIP_APP_OFFSET" href="#spsdk.image.images.BootImgRT.XIP_APP_OFFSET">XIP_APP_OFFSET</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.add_csf_encrypted" href="#spsdk.image.images.BootImgRT.add_csf_encrypted">add_csf_encrypted</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.add_csf_standard_auth" href="#spsdk.image.images.BootImgRT.add_csf_standard_auth">add_csf_standard_auth</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.add_dcd_bin" href="#spsdk.image.images.BootImgRT.add_dcd_bin">add_dcd_bin</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.add_image" href="#spsdk.image.images.BootImgRT.add_image">add_image</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.aead_nonce_len" href="#spsdk.image.images.BootImgRT.aead_nonce_len">aead_nonce_len</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.app" href="#spsdk.image.images.BootImgRT.app">app</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.app_offset" href="#spsdk.image.images.BootImgRT.app_offset">app_offset</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.bdt" href="#spsdk.image.images.BootImgRT.bdt">bdt</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.bee" href="#spsdk.image.images.BootImgRT.bee">bee</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.bee_encrypted" href="#spsdk.image.images.BootImgRT.bee_encrypted">bee_encrypted</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.csf" href="#spsdk.image.images.BootImgRT.csf">csf</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.decrypted_app_data" href="#spsdk.image.images.BootImgRT.decrypted_app_data">decrypted_app_data</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.dek_img_offset" href="#spsdk.image.images.BootImgRT.dek_img_offset">dek_img_offset</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.dek_key" href="#spsdk.image.images.BootImgRT.dek_key">dek_key</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.dek_ram_address" href="#spsdk.image.images.BootImgRT.dek_ram_address">dek_ram_address</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.enabled_csf" href="#spsdk.image.images.BootImgRT.enabled_csf">enabled_csf</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.export" href="#spsdk.image.images.BootImgRT.export">export</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.fcb" href="#spsdk.image.images.BootImgRT.fcb">fcb</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.hab_encrypted" href="#spsdk.image.images.BootImgRT.hab_encrypted">hab_encrypted</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.ivt" href="#spsdk.image.images.BootImgRT.ivt">ivt</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.ivt_offset" href="#spsdk.image.images.BootImgRT.ivt_offset">ivt_offset</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.parse" href="#spsdk.image.images.BootImgRT.parse">parse</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.plugin" href="#spsdk.image.images.BootImgRT.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.set_flexspi_fcb" href="#spsdk.image.images.BootImgRT.set_flexspi_fcb">set_flexspi_fcb</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.size" href="#spsdk.image.images.BootImgRT.size">size</a></code></li>
<li><code><a title="spsdk.image.images.BootImgRT.version" href="#spsdk.image.images.BootImgRT.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.EnumAppType" href="#spsdk.image.images.EnumAppType">EnumAppType</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.images.EnumAppType.A72" href="#spsdk.image.images.EnumAppType.A72">A72</a></code></li>
<li><code><a title="spsdk.image.images.EnumAppType.APP" href="#spsdk.image.images.EnumAppType.APP">APP</a></code></li>
<li><code><a title="spsdk.image.images.EnumAppType.M4_0" href="#spsdk.image.images.EnumAppType.M4_0">M4_0</a></code></li>
<li><code><a title="spsdk.image.images.EnumAppType.M4_1" href="#spsdk.image.images.EnumAppType.M4_1">M4_1</a></code></li>
<li><code><a title="spsdk.image.images.EnumAppType.SCD" href="#spsdk.image.images.EnumAppType.SCD">SCD</a></code></li>
<li><code><a title="spsdk.image.images.EnumAppType.SCFW" href="#spsdk.image.images.EnumAppType.SCFW">SCFW</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.images.KernelImg" href="#spsdk.image.images.KernelImg">KernelImg</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.images.KernelImg.IMAGE_MIN_SIZE" href="#spsdk.image.images.KernelImg.IMAGE_MIN_SIZE">IMAGE_MIN_SIZE</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.address" href="#spsdk.image.images.KernelImg.address">address</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.app" href="#spsdk.image.images.KernelImg.app">app</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.csf" href="#spsdk.image.images.KernelImg.csf">csf</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.export" href="#spsdk.image.images.KernelImg.export">export</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.info" href="#spsdk.image.images.KernelImg.info">info</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.parse" href="#spsdk.image.images.KernelImg.parse">parse</a></code></li>
<li><code><a title="spsdk.image.images.KernelImg.version" href="#spsdk.image.images.KernelImg.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>