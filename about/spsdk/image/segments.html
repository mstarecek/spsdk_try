<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.image.segments API documentation</title>
<meta name="description" content="Segments within image module." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.image.segments</code></h1>
</header>
<section id="section-intro">
<p>Segments within image module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2017-2018 Martin Olejar
# Copyright 2019-2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause
&#34;&#34;&#34;Segments within image module.&#34;&#34;&#34;

import logging
from abc import ABC
from datetime import datetime
from struct import pack, unpack_from, calcsize
from typing import Dict, List, Optional, Iterator, Sequence, Tuple, Union

from spsdk.utils.misc import align, align_block, extend_block, DebugInfo
from .bee import BeeRegionHeader, BEE_ENCR_BLOCK_SIZE
from .commands import CmdBase, CmdWriteData, CmdCheckData, CmdUnlock, \
    CmdNop, CmdAuthData, EnumWriteOps, EnumCheckOps, EnumEngine, CmdTag, parse_command
from .header import Header, Header2, SegTag, CorruptedException
from .misc import size_fmt
from .secret import BaseClass, MAC

logger = logging.getLogger(&#34;IMAGE:SEGMENTS&#34;)


########################################################################################################################
# Base Segment Class
########################################################################################################################

class BaseSegment(ABC):
    &#34;&#34;&#34;Base segment.&#34;&#34;&#34;

    # padding fill value
    PADDING_VALUE = 0x00

    @property
    def padding_len(self) -&gt; int:
        &#34;&#34;&#34;Length of padding data in bytes (zero for no padding).&#34;&#34;&#34;
        return self.padding

    @padding_len.setter
    def padding_len(self, value: int) -&gt; None:
        &#34;&#34;&#34;New length (in bytes) of padding applied at the end of exported data.&#34;&#34;&#34;
        assert value &gt;= 0
        self.padding = value

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Return length (in bytes) of the exported data including padding (if any).

        Please mind, padding is exported optionally.
        &#34;&#34;&#34;
        return self.size + self.padding_len

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of base segment.&#34;&#34;&#34;
        return 0

    def _padding_export(self) -&gt; bytes:
        &#34;&#34;&#34;Padding binary data, see `padding_len` for length.&#34;&#34;&#34;
        return bytes([self.PADDING_VALUE] * self.padding_len) if self.padding_len &gt; 0 else b&#39;&#39;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize the base  segment.&#34;&#34;&#34;
        self.padding = 0

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, self.__class__) and vars(other) == vars(self)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the BaseSegment.&#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export interface.&#34;&#34;&#34;
        raise NotImplementedError()

    @classmethod
    def parse(cls, buffer: bytes) -&gt; &#39;BaseSegment&#39;:
        &#34;&#34;&#34;Parse interfaces.&#34;&#34;&#34;
        raise NotImplementedError()


########################################################################################################################
# Boot Image V1 Segments (i.MX5)
########################################################################################################################

# Obsolete, will not be implemented


########################################################################################################################
# Boot Image V2 Extra Segments for i.MX-RT
########################################################################################################################
class AbstractFCB(BaseSegment):
    &#34;&#34;&#34;Abstract class, predecessor for all FCB classes.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
        super().__init__()
        self._enabled = True

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34;Whether FCB is enabled. Note: it is not generated to output is disabled.&#34;&#34;&#34;
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: whether FCB is enabled
        &#34;&#34;&#34;
        self._enabled = value

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Return length (in bytes) of the exported data including padding (if any).&#34;&#34;&#34;
        return super(AbstractFCB, self).space if self.enabled else 0

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary representation (serialization).

        :param dbg_info: instance allowing to debug output
        :return: binary representation
        &#34;&#34;&#34;
        raise NotImplementedError()


class SegFCB(AbstractFCB, ABC):
    &#34;&#34;&#34;FCB.&#34;&#34;&#34;
    SIZE = 1024
    FINGERPRINT = b&#39;NFCB&#39;

    @property
    def crc(self) -&gt; int:
        &#34;&#34;&#34;Cyclic redundancy check.&#34;&#34;&#34;
        return 0

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize FCB segment.&#34;&#34;&#34;
        super().__init__()
        self.version = 1
        self.search_start_page = 0
        self.search_stride = 0
        self.search_count = 0
        self.firmware_copies = 0
        self.firmware_info_table = None
        self.config_block = None

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form.&#34;&#34;&#34;
        data = pack(&#39;&lt;Is2I2HI&#39;, self.crc, self.FINGERPRINT, self.version, self.search_start_page, self.search_stride,
                    self.search_count, self.firmware_copies)
        # Reserved 40 bytes for future use, must be set to 0
        data += b&#39;\x00&#39; * 40
        if self.firmware_info_table:
            data += self.firmware_info_table
        # Reserved 128 bytes, must be set to 0
        data += b&#39;\x00&#39; * 128
        if self.config_block:
            data += self.config_block
        # Reserved 256 bytes, must be set to 0
        data += b&#39;\x00&#39; * 256
        return data


class PaddingFCB(AbstractFCB):
    &#34;&#34;&#34;Padding FCB.&#34;&#34;&#34;

    def __init__(self, size: int, padding_value: int = 0, enabled: bool = True):
        &#34;&#34;&#34;Constructor.

        :param size: of the exported padding
        :param padding_value: byte value used as padding; 0 by default
        :param enabled: whether enabled
        &#34;&#34;&#34;
        super().__init__()
        assert 0 &lt;= size &lt;= 0xFFFF
        assert 0 &lt;= padding_value &lt;= 0xFF
        self._size = size
        self._padding_byte = bytes([padding_value])
        self.enabled = enabled

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return size of the exported data in bytes.&#34;&#34;&#34;
        return self._size if self.enabled else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        return f&#39;PaddingFCB: {self.size} bytes&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: instance allowing to debug output format
        :return: binary representation
        &#34;&#34;&#34;
        if not self.enabled:
            return b&#39;&#39;

        result = self._padding_byte * self._size + self._padding_export()
        dbg_info.append_section(f&#39;FCB-padding: {len(result)} bytes&#39;)
        return result


# pylint: disable=too-many-instance-attributes
class FlexSPIConfBlockFCB(AbstractFCB):
    &#34;&#34;&#34;Flex SPI configuration block; FCB.&#34;&#34;&#34;
    # tag used in header to be able identify the block
    TAG = b&#39;FCFB&#39;
    # default version
    VERSION = b&#39;V\x01\x00\x00&#39;
    # format for the export
    FORMAT = &#39;&lt;6BH7I5I4B2I4I6I4H&#39;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize FlexSPIConfBlockFCB.&#34;&#34;&#34;
        super().__init__()
        self.version = self.VERSION
        # ### Fields descriptions are taken from RT1050 manual ###

        # [00C:8-bit] 0 = internal loopback; 1 = loopback from DQS pad; 3 = Flash provided DQS
        self.read_sample_clk_src = 0
        # [00D:8-bit] Serial Flash CS Hold Time Recommend default value is 0x03
        self.cs_hold_time = 3
        # [00E:8-bit] Serial Flash CS setup time. Recommended default value is 0x03
        self.cs_setup_time = 3
        # [00F:8-bit] 3 = For HyperFlash; 12/13 = For Serial NAND, see datasheet to find correct value; 0=Other devices
        self.column_address_width = 0
        # [010:8-bit] Device Mode Configuration Enable feature (0 – Disabled, 1 – Enabled)
        self.device_mode_cfg_enable = 0
        # [011:8-bit] Reserved
        self.device_mode_type = 0
        # [012:16-bit] Wait time for all configuration commands, unit 100us.
        # Available for device that support v1.1.0 FlexSPI configuration block. If it is greater than 0, ROM will wait
        # waitTimeCfgCommands * 100us for all device memory configuration commands instead of using read status to wait
        # until these commands complete.
        self.wait_time_cfg_commands = 0
        # [014:32-bit] Sequence parameter for device mode configuration
        # Bit[7:0] - number of LUT sequences for Device mode configuration command
        # Bit[15:8] - starting LUT index of Device mode configuration command
        # Bit[31:16] - must be 0
        self.device_mode_seq = 0
        # [018:32-bit] Device Mode argument, effective only when device_mode_cfg_enable = 1
        self.device_mode_arg = 0
        # [01C:32-bit] Config Command Enable feature (0 – Disabled, 1 – Enabled)
        self.config_cmd_enable = 0
        # [020:3 x 32-bit] Sequences for Config Command, allow 3 separate configuration command sequences.
        self.config_cmd_0 = 0
        self.config_cmd_1 = 0
        self.config_cmd_2 = 0
        # [02C:32-bit] reserved
        # [030:3 x 32-bit] Arguments for each separate configuration command sequence
        self.cfg_cmd_arg_0 = 0
        self.cfg_cmd_arg_1 = 0
        self.cfg_cmd_arg_2 = 0
        # [03C:32-bit] reserved
        # [040:32-bit]
        # Bit0 – differential clock enable
        # Bit1 – CK2 enable, must set to 0 in this silicon
        # Bit2 – ParallelModeEnable, must set to 0 for this silicon
        # Bit3 – wordAddressableEnable
        # Bit4 – Safe Configuration Frequency enable set to 1 for the devices that support DDR Read instructions
        # Bit5 – Pad Setting Override Enable
        # Bit6 – DDR Mode Enable, set to 1 for device supports DDR read command
        self.controller_misc_option = 0
        # [044:8-bit] 1 – Serial NOR, 2 – Serial NAND
        self.device_type = 0
        # [045:8-bit] 1 – Single pad; 2 – Dual pads; 4 – Quad pads; 8 – Octal pads
        self.sflash_pad_type = 0
        # [046:8-bit] Chip specific value, for RT1050
        # 1 – 30 MHz; 2 – 50 MHz; 3 – 60 MHz; 4 – 75 MHz; 5 – 80 MHz; 6 – 100 MHz; 7 – 133 MHz; 8 – 166 MHz;
        # Other value: 30 MHz
        self.serial_clk_freq = 0
        # [047:8-bit] 0=Use predefined LUT sequence index and number;
        #             1=Use LUT sequence parameters provided in this block
        self.lut_custom_seq_enable = 0
        # [048:8B] reserverd
        # [050:4x32-bit] For SPI NOR, need to fill with actual size; For SPI NAND, need to fill with actual size * 2
        self.sflash_a1_size = 0
        self.sflash_a2_size = 0
        self.sflash_b1_size = 0
        self.sflash_b2_size = 0
        # [060:4x32-bit] Set to 0 if it is not supported
        self.cs_pad_setting_override = 0
        self.sclk_pad_setting_override = 0
        self.data_pad_setting_override = 0
        self.dqs_pad_setting_override = 0
        # [070:32-bit] Maximum wait time during read busy status
        # 0 – Disabled timeout checking feature; Other value – Timeout if the wait time exceeds this value.
        self.timeout_in_ms = 0
        # [074:32-bit] Unit: ns; RT1050: Currently, it is used for SPI NAND only at high frequency
        self.command_interval = 0
        # [078:2x16-bit] Time from clock edge to data valid edge. unit 0.1 ns. This field is used when the FlexSPI Root
        # clock is less than 100 MHz and the read sample clock source is device provided DQS signal without CK2 support.
        self.data_valid_time_dlla = 0
        self.data_valid_time_dllb = 0
        # [07C:16-bit] busy bit offset, valid range 0-31
        self.busy_offset = 0
        # [07E:16-bit] 0 – busy bit is 1 if device is busy; 1 – busy bit is 0 if device is busy
        self.busy_bit_polarity = 0
        # [080:256B] Lookup table
        self.lookup_table = b&#39;\x00&#39; * 256
        # [180:48B] Customized LUT sequence
        self.lut_custom_seq = b&#39;\x00&#39; * 48
        # [1B0:16B] reserved
        self.reserved_padding1 = b&#39;\x00&#39; * 16
        self.reserved_padding2 = b&#39;\x00&#39; * 64

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Length of the binary exported data without padding.&#34;&#34;&#34;
        if not self.enabled:
            return 0

        return len(self.export_header()) + calcsize(self.FORMAT) + len(self.lookup_table) + len(self.lut_custom_seq) + \
               len(self.reserved_padding1) + len(self.reserved_padding2)

    def export_header(self) -&gt; bytes:
        &#34;&#34;&#34;Export FCB header info binary form.&#34;&#34;&#34;
        return self.TAG + self.version[::-1] + b&#39;\x00\x00\x00\x00&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export into binary form.

        :param dbg_info: instance allowing to debug output
        :return: binary representation used in the bootable image
        &#34;&#34;&#34;
        if not self.enabled:
            return b&#39;&#39;

        data = self.export_header()
        data += pack(self.FORMAT,
                     # B
                     self.read_sample_clk_src, self.cs_hold_time, self.cs_setup_time, self.column_address_width,
                     self.device_mode_cfg_enable, self.device_mode_type,
                     # H
                     self.wait_time_cfg_commands,
                     # I
                     self.device_mode_seq, self.device_mode_arg, self.config_cmd_enable,
                     self.config_cmd_0, self.config_cmd_1, self.config_cmd_2, 0,
                     # I
                     self.cfg_cmd_arg_0, self.cfg_cmd_arg_1, self.cfg_cmd_arg_2, 0,
                     self.controller_misc_option,
                     # B
                     self.device_type, self.sflash_pad_type, self.serial_clk_freq, self.lut_custom_seq_enable,
                     # I
                     0, 0,
                     # I
                     self.sflash_a1_size, self.sflash_a2_size, self.sflash_b1_size, self.sflash_b2_size,
                     # I
                     self.cs_pad_setting_override, self.sclk_pad_setting_override, self.data_pad_setting_override,
                     self.dqs_pad_setting_override, self.timeout_in_ms, self.command_interval,
                     # H
                     self.data_valid_time_dlla, self.data_valid_time_dllb, self.busy_offset, self.busy_bit_polarity)
        data += self.lookup_table + self.lut_custom_seq + self.reserved_padding1 + self.reserved_padding2

        dbg_info.append_binary_section(&#39;FCB&#39;, data)

        if self.padding_len &gt; 0:
            data += self._padding_export()
            dbg_info.append_section(f&#39;FCB-padding: {self.padding_len} bytes&#39;)

        return data

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the FlexSPIConfBlockFCB.&#34;&#34;&#34;
        return &#34;[FCB]\n&#34; + f&#39;{self.size} bytes\n&#39; if self.enabled else &#34;No FCB\n&#34;

    @classmethod
    def parse(cls, buffer: bytes) -&gt; &#39;FlexSPIConfBlockFCB&#39;:
        &#34;&#34;&#34;Parse binary data and creates instance of the class.

        :param buffer: data to be parsed
        :return: instance of the class representing the data
        :raise ValueError: if data are not valid Flex SPI configuration block
        &#34;&#34;&#34;
        if buffer[:4] != FlexSPIConfBlockFCB.TAG:
            raise ValueError(&#39;TAG does not match: &#39; + buffer[:4].hex())

        version = buffer[7:3:-1]
        if (version[0] != ord(&#39;V&#39;)) or (version[1] != 1) or (version[2] not in range(0, 9)) or \
                (version[3] not in range(0, 9)):
            raise ValueError(&#39;Invalid version number format&#39;)

        result = FlexSPIConfBlockFCB()
        if len(buffer) &lt; result.size:
            raise ValueError(&#39;Insufficient data length&#39;)

        offset = len(result.export_header())
        result.version = version
        (  # B
            result.read_sample_clk_src, result.cs_hold_time, result.cs_setup_time, result.column_address_width,
            result.device_mode_cfg_enable, result.device_mode_type,
            # H
            result.wait_time_cfg_commands,
            # I
            result.device_mode_seq, result.device_mode_arg, result.config_cmd_enable,
            result.config_cmd_0, result.config_cmd_1, result.config_cmd_2, _reserved1,
            # I
            result.cfg_cmd_arg_0, result.cfg_cmd_arg_1, result.cfg_cmd_arg_2, _reserved2,
            result.controller_misc_option,
            # B
            result.device_type, result.sflash_pad_type, result.serial_clk_freq, result.lut_custom_seq_enable,
            # I
            _reserved3, _reserved4,
            # I
            result.sflash_a1_size, result.sflash_a2_size, result.sflash_b1_size, result.sflash_b2_size,
            # I
            result.cs_pad_setting_override, result.sclk_pad_setting_override, result.data_pad_setting_override,
            result.dqs_pad_setting_override, result.timeout_in_ms, result.command_interval,
            # H
            result.data_valid_time_dlla, result.data_valid_time_dllb, result.busy_offset, result.busy_bit_polarity
        ) = unpack_from(FlexSPIConfBlockFCB.FORMAT, buffer, offset)
        offset += calcsize(FlexSPIConfBlockFCB.FORMAT)
        # lookup table
        result.lookup_table = buffer[offset:offset + len(result.lookup_table)]
        offset += len(result.lookup_table)
        # lookup table
        result.lut_custom_seq = buffer[offset:offset + len(result.lut_custom_seq)]
        offset += len(result.lut_custom_seq)
        # reserved padding
        result.reserved_padding1 = buffer[offset:offset + len(result.reserved_padding1)]
        offset += len(result.reserved_padding1)
        result.reserved_padding2 = buffer[offset:offset + len(result.reserved_padding2)]

        return result


########################################################################################################################
# KIB and PRDB (i.MX-RT) for BEE Encrypted XIP mode
########################################################################################################################

class SegBEE(BaseSegment):
    &#34;&#34;&#34;BEE keys and regions segment.&#34;&#34;&#34;

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        result = 0
        for region in self._regions:
            result += region.size
        return result

    def __init__(self, regions: Sequence[BeeRegionHeader], max_facs: int = 3):
        &#34;&#34;&#34;Constructor.

        :param regions: list of regions
        :param max_facs: maximum total number of FAC in all regions, used for validation
        &#34;&#34;&#34;
        super().__init__()
        self._regions = list(regions)
        self.max_facs = max_facs

    def add_region(self, region: BeeRegionHeader) -&gt; None:
        &#34;&#34;&#34;Add region.

        :param region: to be added
        &#34;&#34;&#34;
        self._regions.append(region)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = f&#39;BEE Segment, with {len(self._regions)} regions\n&#39;
        for region in self._regions:
            result += region.info()
        return result

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        for region in self._regions:
            region.update()

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        :raises ValueError: if number of FAC regions exceeds the limit
        &#34;&#34;&#34;
        total_facs = 0
        for region in self._regions:
            region.validate()
            total_facs += len(region.fac_regions)
        if total_facs &gt; self.max_facs:
            raise ValueError(f&#39;Totally {total_facs} FAC regions, but only {self.max_facs} supported&#39;)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Serialization to binary representation.

        :param dbg_info: instance allowing to provide debug info about exported data
        :return:binary representation of the region (serialization).
        &#34;&#34;&#34;
        self.update()
        self.validate()
        result = b&#39;&#39;
        for index, region in enumerate(self._regions):
            dbg_info.append_section(f&#39;BEE Region {index}&#39;)
            result += region.export(dbg_info=dbg_info)
        if self.padding_len:
            result += self._padding_export()
            if self.size == 0:
                dbg_info.append_section(f&#39;BEE-padding {self.padding_len} bytes&#39;)

        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0, decrypt_keys: List[bytes] = list()) -&gt; &#39;SegBEE&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :param decrypt_keys: list of SW_GP keys used to decrypt EKIB
                The number of keys must match number of regions to be parsed
        :return: instance created from binary data
        &#34;&#34;&#34;
        regions: List[BeeRegionHeader] = list()
        for sw_gp_key in decrypt_keys:
            region = BeeRegionHeader.parse(data, offset, sw_gp_key)
            regions.append(region)
            offset += region.size
        return SegBEE(regions)

    def encrypt_data(self, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt image data located in any PRDB block.

        :param start_addr: start address of the data; must be aligned to block size
        :param data: to be encrypted
        :return: encrypted data, aligned to block size; blocks outside any FAC region kept untouched
        &#34;&#34;&#34;
        assert align(start_addr, BEE_ENCR_BLOCK_SIZE) == start_addr
        orig_len = len(data)
        data = align_block(data, BEE_ENCR_BLOCK_SIZE)
        result = bytes()
        offset = 0
        while offset &lt; len(data):
            blck = data[offset:offset + BEE_ENCR_BLOCK_SIZE]
            for region in self._regions:
                blck = region.encrypt_block(start_addr + offset, blck)
            result += blck
            offset += BEE_ENCR_BLOCK_SIZE
        return result[:orig_len]


########################################################################################################################
# Boot Image V2 Segments (i.MX-RT, i.MX6, i.MX7, i.MX8M)
########################################################################################################################
class SegIVT2(BaseSegment):
    &#34;&#34;&#34;Image Vector Table, IVT2 segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;7L&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
        assert 0x40 &lt;= value &lt; 0x4F
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary data.&#34;&#34;&#34;
        return self._header.length

    def __init__(self, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT2 segment.

        :param version: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT2, version)
        self._header.length = self.SIZE
        self.app_address = 0
        self.rs1 = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.rs2 = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT2 &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, APP:0x{:X}, CSF:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.app_address, self.csf_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT2.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; format version   : 0x{:02X}\n&#34;.format(self.version)
        msg += &#34; IVT start address: 0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT start address: 0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD start address: 0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; APP entry point  : 0x{:08X}\n&#34;.format(self.app_address)
        msg += &#34; CSF start address: 0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validate settings of the segment.

        :raises ValueError: if there is configuration problem
        &#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X} &lt; 0x{:X}&#34;.format(self.dcd_address, self.ivt_address))
        # TODO: resolve commented code: if self.app_address and self.app_address &lt; self.ivt_address:
        #  raise ValueError(&#34;Not valid APP address: 0x{:X} &lt; 0x{:X}&#34;.format(self.app_address, self.ivt_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X} &lt; 0x{:X}&#34;.format(self.csf_address, self.ivt_address))
        if self.padding &gt; 0:
            raise ValueError(&#34;IVT padding should be zero: {}&#34;.format(self.padding))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export to binary representation (serialization).

        :return: segment exported as binary data
        &#34;&#34;&#34;
        self.validate()

        data = self._header.export()
        data += pack(self.FORMAT, self.app_address, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address,
                     self.csf_address, self.rs2)

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT2&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT2 segment
        :return: SegIVT2 object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT2)
        obj = cls(header.param)
        # Parse IVT items
        (obj.app_address,
         obj.rs1,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.rs2) = unpack_from(cls.FORMAT, data, header.size)
        # Calculate IVT padding (should be zero)
        obj.padding = obj.bdt_address - obj.ivt_address - obj.size
        # Validate parsed values
        obj.validate()
        return obj


class SegBDT(BaseSegment):
    &#34;&#34;&#34;Boot Data Table segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;3L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def plugin(self) -&gt; int:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plugin

    @plugin.setter
    def plugin(self, value: int) -&gt; None:
        assert value in (0, 1, 2), &#34;Plugin value must be 0 .. 2&#34;
        self._plugin = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the exported binary data (without padding).&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, app_start: int = 0, app_length: int = 0, plugin: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize BDT segment.

        :param app_start: first address of the application
        :param app_length: length of the application
        :param plugin: 0 .. 2
        &#34;&#34;&#34;
        super().__init__()
        self.app_start = app_start
        self.app_length = app_length
        self.plugin = plugin

    def __repr__(self) -&gt; str:
        return &#34;BDT &lt;ADDR: 0x{:X}, LEN: {} Bytes, Plugin: {}&gt;&#34;.format(self.app_start, self.app_length, self.plugin)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDT.&#34;&#34;&#34;
        msg = f&#34; Start      :  0x{self.app_start:08X}\n&#34;
        msg += f&#34; App Length : {size_fmt(self.app_length)} ({self.app_length} Bytes)\n&#34;
        msg += f&#34; Plugin     : {&#39;YES&#39; if self.plugin else &#39;NO&#39;}\n&#34;
        msg += &#34;\n&#34;

        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT, self.app_start, self.app_length, self.plugin)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDT&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDT segment
        :return: SegBDT object
        &#34;&#34;&#34;
        return cls(*unpack_from(cls.FORMAT, data))


class SegAPP(BaseSegment):
    &#34;&#34;&#34;APP segment.&#34;&#34;&#34;

    def __init__(self, data: Optional[bytes] = None) -&gt; None:
        &#34;&#34;&#34;Initialize APP segment.

        :param data: application binary data
        &#34;&#34;&#34;
        super().__init__()
        self._data = data

    @property
    def data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
        return self._data

    @data.setter
    def data(self, value: Union[bytearray, bytes]) -&gt; None:
        &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
        assert isinstance(value, (bytes, bytearray))
        self._data = bytes(value)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of APP segment.&#34;&#34;&#34;
        return 0 if (self._data is None) else len(self._data)

    def __repr__(self) -&gt; str:
        return &#34;APP &lt;LEN: {} Bytes&gt;&#34;.format(self.size)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegAPP.&#34;&#34;&#34;
        msg = &#34; Size: {0:d} Bytes\n&#34;.format(self.size)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self._data:
            data += bytes(self._data)
        data += self._padding_export()
        return data


_SEG_DCD_COMMANDS = {
    &#39;WriteValue&#39;: (&#39;write&#39;, EnumWriteOps.WRITE_VALUE),
    &#39;WriteClearBits&#39;: (&#39;write&#39;, EnumWriteOps.WRITE_CLEAR_BITS),
    &#39;ClearBitMask&#39;: (&#39;write&#39;, EnumWriteOps.CLEAR_BITMASK),
    &#39;SetBitMask&#39;: (&#39;write&#39;, EnumWriteOps.SET_BITMASK),
    &#39;CheckAllClear&#39;: (&#39;check&#39;, EnumCheckOps.ALL_CLEAR),
    &#39;CheckAllSet&#39;: (&#39;check&#39;, EnumCheckOps.ALL_SET),
    &#39;CheckAnyClear&#39;: (&#39;check&#39;, EnumCheckOps.ANY_CLEAR),
    &#39;CheckAnySet&#39;: (&#39;check&#39;, EnumCheckOps.ANY_SET),
    &#39;Unlock&#39;: None,
    &#39;Nop&#39;: None
}


class SegDCD(BaseSegment):
    &#34;&#34;&#34;Device configuration data (DCD) segment.

    IC configuration data, usually is used to configure DDR/SDRAM memory. Typically this is optional
    &#34;&#34;&#34;

    # list of supported DCD commands
    _COMMANDS: Tuple[CmdTag, ...] = (CmdTag.WRT_DAT, CmdTag.CHK_DAT, CmdTag.NOP, CmdTag.UNLK)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._header

    @property
    def commands(self) -&gt; List[CmdBase]:
        &#34;&#34;&#34;Commands of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._commands

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._header.length if self.enabled else 0

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Add space.&#34;&#34;&#34;
        return self.size + self.padding if self.enabled else 0

    def __init__(self, param: int = 0x41, enabled: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize DCD segment.&#34;&#34;&#34;
        super().__init__()
        self.enabled = enabled
        self._header = Header(SegTag.DCD, param)
        self._header.length = self._header.size
        self._commands: List[CmdBase] = []

    def __repr__(self) -&gt; str:
        return &#34;DCD &lt;Commands: {}&gt;&#34;.format(len(self._commands))

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBase:
        return self._commands[key]

    def __setitem__(self, key: int, value: CmdBase) -&gt; None:
        assert value.tag in self._COMMANDS
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator:
        return self._commands.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegDCD.&#34;&#34;&#34;
        msg = &#34;&#34;
        for cmd in self._commands:
            msg += cmd.info()
            msg += &#34;\n&#34;
        return msg

    def append(self, cmd: CmdBase) -&gt; None:
        &#34;&#34;&#34;Appending of Device configuration data (DCD) segment.&#34;&#34;&#34;
        assert isinstance(cmd, CmdBase) and (cmd.tag in self._COMMANDS)
        self._commands.append(cmd)
        self._header.length += cmd.size

    def pop(self, index: int) -&gt; CmdBase:
        &#34;&#34;&#34;Popping of Device configuration data (DCD) segment.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._commands)
        cmd = self._commands.pop(index)
        self._header.length -= cmd.size
        return cmd

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Device configuration data (DCD) segment.&#34;&#34;&#34;
        self._commands.clear()
        self._header.length = self._header.size

    def export_txt(self, txt_data: str = None) -&gt; str:
        &#34;&#34;&#34;Export txt of Device configuration data (DCD) segment.&#34;&#34;&#34;
        write_ops = (&#39;WriteValue&#39;, &#39;WriteClearBits&#39;, &#39;ClearBitMask&#39;, &#39;SetBitMask&#39;)
        check_ops = (&#39;CheckAllClear&#39;, &#39;CheckAllSet&#39;, &#39;CheckAnyClear&#39;, &#39;CheckAnySet&#39;)
        if txt_data is None:
            txt_data = &#34;&#34;

        for cmd in self._commands:
            if isinstance(cmd, CmdWriteData):
                for (address, value) in cmd:
                    txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}\n&#34;.format(write_ops[cmd.ops], cmd.num_bytes, address,
                                                                           value)
            elif isinstance(cmd, CmdCheckData):
                txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}&#34;.format(check_ops[cmd.ops], cmd.num_bytes, cmd.address,
                                                                     cmd.mask)
                txt_data += &#34; {0:d}\n&#34;.format(cmd.count) if cmd.count else &#34;\n&#34;

            elif isinstance(cmd, CmdUnlock):
                txt_data += &#34;Unlock {0:s}&#34;.format(EnumEngine[cmd.engine]) # type: ignore
                cnt = 1
                for value in cmd:
                    if cnt &gt; 6:
                        txt_data += &#34; \\\n&#34;
                        cnt = 0
                    txt_data += &#34; 0x{0:08X}&#34;.format(value)
                    cnt += 1

                txt_data += &#39;\n&#39;

            else:
                txt_data += &#34;Nop\n&#34;

            # Split with new line every group of commands
            txt_data += &#39;\n&#39;

        return txt_data

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self.enabled:
            data = self._header.export()
            for command in self._commands:
                data += command.export()
            # padding
            data += self._padding_export()

        return data

    @classmethod
    def parse_txt(cls, text: str) -&gt; &#39;SegDCD&#39;:
        &#34;&#34;&#34;Parse segment from text file.

        :param text: The string with DCD commands
        :return: SegDCD object
        &#34;&#34;&#34;
        return SegDcdBuilder().build(text)

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegDCD&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of DCD segment
        :raises CorruptedException: Exception caused by corrupted data
        :return: SegDCD object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.DCD)
        index = header.size
        obj = cls(header.param, True)
        while index &lt; header.length:
            try:
                cmd_obj = parse_command(data, index)
            except ValueError:
                raise CorruptedException(&#34;Unknown command at position: &#34; + hex(index))

            obj.append(cmd_obj)
            index += cmd_obj.size
        return obj


class SegDcdBuilder:
    &#34;&#34;&#34;Builder to create SegDCD from text input.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize SegDcdBuilder.&#34;&#34;&#34;
        self.line_cnt = 0  # current line number to be displayed in the error message
        self.cmd_write: Optional[CmdWriteData] = None  # this is cache to merge several write commands of same type

    def _parse_cmd(self, dcd_obj: SegDCD, cmd: List[str]) -&gt; None:
        &#34;&#34;&#34;Parse one command.

        :param dcd_obj: result of the builder
        :param cmd: command with arguments
        :raises SyntaxError: command is corrupted
        &#34;&#34;&#34;
        # ----------------------------
        # Parse command
        # ----------------------------
        cmd_tuple = _SEG_DCD_COMMANDS[cmd[0]]
        if cmd_tuple is None:
            if cmd[0] == &#39;Nop&#39;:
                if self.cmd_write is not None:
                    dcd_obj.append(self.cmd_write)
                    self.cmd_write = None

                dcd_obj.append(CmdNop())

            elif cmd[0] == &#39;Unlock&#39;:
                if self.cmd_write is not None:
                    dcd_obj.append(self.cmd_write)
                    self.cmd_write = None

                if cmd[1] not in EnumEngine:
                    raise SyntaxError(&#34;Unlock CMD: wrong engine parameter at line %d&#34; % (self.line_cnt - 1))

                engine = EnumEngine.from_int(EnumEngine[cmd[1]])
                args = [int(value, 0) for value in cmd[2:]]
                dcd_obj.append(CmdUnlock(engine, *args))
            else:
                assert False, &#34;unknown command&#34;

        elif cmd_tuple[0] == &#39;write&#39;:
            if len(cmd) &lt; 4:
                raise SyntaxError(&#34;Write CMD: not enough arguments at line %d&#34; % (self.line_cnt - 1))

            ops = cmd_tuple[1]
            numbytes = int(cmd[1])
            addr = int(cmd[2], 0)
            value = int(cmd[3], 0)

            if self.cmd_write is not None:
                if (self.cmd_write.ops != ops) or (self.cmd_write.num_bytes != numbytes):
                    dcd_obj.append(self.cmd_write)
                    self.cmd_write = None

            if self.cmd_write is None:
                self.cmd_write = CmdWriteData(numbytes, ops)

            self.cmd_write.append(addr, value)

        else:
            if len(cmd) &lt; 4:
                raise SyntaxError(&#34;Check CMD: not enough arguments at line %d&#34; % (self.line_cnt - 1))

            if self.cmd_write is not None:
                dcd_obj.append(self.cmd_write)
                self.cmd_write = None

            ops = cmd_tuple[1]
            numbytes = int(cmd[1])
            addr = int(cmd[2], 0)
            mask = int(cmd[3], 0)
            count = int(cmd[4], 0) if len(cmd) &gt; 4 else None
            dcd_obj.append(CmdCheckData(numbytes, ops, addr, mask, count))

    def build(self, text: str) -&gt; SegDCD:
        &#34;&#34;&#34;Parse segment from text file and build SegDCD.

        :param text: input text to import
        :return: SegDCD object
        :raise SyntaxError: if input format is not valid
        &#34;&#34;&#34;
        dcd_obj = SegDCD(enabled=True)
        cmd_mline = False
        cmd: List[str] = []
        for line in text.split(&#39;\n&#39;):
            line = line.rstrip(&#39;\0&#39;)
            line = line.lstrip()
            # increment line counter
            self.line_cnt += 1
            # ignore comments
            if not line or line.startswith(&#39;#&#39;):
                continue
            # check if multi-line command
            if cmd_mline:
                cmd += line.split()
                cmd_mline = False
            else:
                cmd = line.split()
                if cmd[0] not in _SEG_DCD_COMMANDS:
                    logger.error(f&#39;Unknown DCD command ignored: {cmd}&#39;)
                    continue
            #
            if cmd[-1] == &#39;\\&#39;:
                cmd = cmd[:-1]
                cmd_mline = True
                continue

            self._parse_cmd(dcd_obj, cmd)

        if self.cmd_write is not None:
            dcd_obj.append(self.cmd_write)

        return dcd_obj


class SegCSF(BaseSegment):
    &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.

    A script of commands used to guide image authentication and device configuration operations.
    &#34;&#34;&#34;

    # list of supported CSF commands
    _COMMANDS: Tuple[CmdTag, ...] = (
        CmdTag.WRT_DAT, CmdTag.CHK_DAT, CmdTag.NOP, CmdTag.SET, CmdTag.INIT, CmdTag.UNLK, CmdTag.INS_KEY, CmdTag.AUT_DAT
    )

    @classmethod
    def _is_csf_command(cls, cmd: object) -&gt; bool:
        &#34;&#34;&#34;Test whether given class is instance of supported CSF command.

        :param cmd: instance to be tested
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return isinstance(cmd, CmdBase) and (cmd.tag in cls._COMMANDS)

    def __init__(self, version: int = 0x40, enabled: bool = False):
        &#34;&#34;&#34;Initialize CSF segment.&#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.CSF, version)
        self.enabled = enabled
        self._commands: List[CmdBase] = []
        # additional command data: keys and certificates; these data are stored after the commands
        #   - key is an offset of the data section in segment
        #   - value is an instance of the data section
        self._cmd_data: Dict[int, BaseClass] = dict()
        # this allows to export segment, that was parsered, but certificate and private keys are not available
        self.no_signature_updates = False

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of CSF segment.&#34;&#34;&#34;
        return self._header.param

    @property
    def commands(self) -&gt; List[CmdBase]:
        &#34;&#34;&#34;List of CSF commands in the segment.&#34;&#34;&#34;
        return self._commands

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary representation of the segment; 0 is not enabled.&#34;&#34;&#34;
        if not self.enabled:
            return 0

        result = self._header.length
        for offset, cmd_data in self._cmd_data.items():
            result = max(result, offset + cmd_data.size)
        return result

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary representation of the segment including padding; 0 is not enabled.&#34;&#34;&#34;
        return self.size + self.padding_len if self.enabled else 0

    @property
    def macs(self) -&gt; Iterator[MAC]:
        &#34;&#34;&#34;Iterator of all MAC sections.&#34;&#34;&#34;
        # noinspection PyTypeChecker
        return filter(lambda m: isinstance(m, MAC), self._cmd_data.values())  # type: ignore

    def __repr__(self) -&gt; str:
        return &#34;CSF &lt;Commands: {}&gt;&#34;.format(len(self.commands))

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBase:
        return self.commands[key]

    def __setitem__(self, key: int, value: CmdBase) -&gt; None:
        assert SegCSF._is_csf_command(value)
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator[CmdBase]:
        return self.commands.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegCSF.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += f&#34;CSF Version        : {hex(self.version)}\n&#34;
        msg += f&#34;Number of commands : {len(self.commands)}\n&#34;
        for cmd in self.commands:
            msg += cmd.info()
            msg += &#34;\n&#34;

        # certificates and signatures
        msg += &#34;[CMD-DATA]\n&#34;
        for offset, cmd_data in self._cmd_data.items():
            msg += f&#34;- OFFSET : {offset}\n&#34;
            msg += cmd_data.info()

        return msg

    def append_command(self, cmd: CmdBase) -&gt; None:
        &#34;&#34;&#34;Append CSF command to the segment.

        :param cmd: to be added
        &#34;&#34;&#34;
        assert SegCSF._is_csf_command(cmd)
        self._commands.append(cmd)
        self._header.length += cmd.size
        self.update(False)

    def clear_commands(self) -&gt; None:
        &#34;&#34;&#34;Removes= all commands.&#34;&#34;&#34;
        self._commands.clear()
        self._header.length = self._header.size
        self.update(True)

    def update(self, reset_cmddata_offsets: bool) -&gt; None:
        &#34;&#34;&#34;Update the offsets for the export.

        :param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
                                    False to avoid any reset;
                                    Note: reset should be done during parsing process as the data are incomplete

        &#34;&#34;&#34;
        cur_ofs = self._header.length
        new_cmd_data: Dict[int, BaseClass] = dict()
        for cmd in filter(lambda c: c.needs_cmd_data_reference, self.commands):
            key = cmd.cmd_data_reference
            if key is not None:
                cmd.cmd_data_offset = cur_ofs
                new_cmd_data[cur_ofs] = key
                cur_ofs += align(key.size, 4)
            elif reset_cmddata_offsets and (cmd.cmd_data_offset &gt; 0):
                cmd.cmd_data_offset = 0

        self._cmd_data = new_cmd_data

    def _export_base(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export base part of the CSF section (header and commands) without keys and signatures.

        :param dbg_info: optional instance allowing to produce deung information about exported data
        :return: exported binary data
        &#34;&#34;&#34;
        self.update(True)
        data = self._header.export()
        dbg_info.append_binary_section(&#39;header&#39;, data)
        for command in self.commands:
            dbg_info.append_section(f&#39;COMMAND: {CmdTag.desc(command.tag)}&#39;)
            cmd_data = command.export(dbg_info)
            data += cmd_data
        return data

    def update_signatures(self, zulu: datetime, data: bytes, base_data_addr: int) -&gt; None:
        &#34;&#34;&#34;Update signatures in all CmdAuthData commands.

        :param zulu: current UTC time+date
        :param data: currently generated binary data; empty to create &#34;fake&#34; signature to update size of the segment
        :param base_data_addr: base address of the generated data
        &#34;&#34;&#34;
        if self.no_signature_updates:
            return

        for cmd in self.commands:
            if isinstance(cmd, CmdAuthData):
                if len(cmd) &gt; 0:  # any blocks defined? =&gt; sign image data
                    if not cmd.update_signature(zulu, data, base_data_addr):
                        assert len(data) == 0
                else:  # sign CSF section
                    if not cmd.update_signature(zulu, self._export_base()):
                        assert len(data) == 0

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array (serialization).

        :param dbg_info: optional list of strings to produce debug information about exported data
        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self.enabled:
            data = self._export_base(dbg_info)
            dbg_info.append_section(&#39;CSF-DATA: CERTIFICATES and SIGNATURES&#39;)
            cmd_data_by_offset = sorted(self._cmd_data.items(), key=lambda t: str(t[0]).zfill(8))
            for offset, cmd_data in cmd_data_by_offset:
                data = extend_block(data, offset)
                dbg_info.append_section(f&#39;CMD-DATA: {type(cmd_data).__name__}&#39;)
                data += cmd_data.export(dbg_info=dbg_info)
            # padding
            data += self._padding_export()

        return data

    def _parse_cmd_data(self, cmd: CmdBase, data: bytes) -&gt; None:
        &#34;&#34;&#34;Parse data for key installation or key authentication commands (certificate or signature).

        :param cmd: command with reference to a cmd-data
        :param data: binary data array to be parsed
        :return: parsed instance, either Certificate or Signature
        &#34;&#34;&#34;
        assert cmd.needs_cmd_data_reference
        assert self._cmd_data.get(cmd.cmd_data_offset) is None
        result = cmd.parse_cmd_data(data, cmd.cmd_data_offset)
        self._cmd_data[cmd.cmd_data_offset] = result

        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SegCSF&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of CSF segment
        :param offset: to start parsing the data
        :raises CorruptedException: When there is unknown command
        :raises CorruptedException: When command can not be parsed
        :return: SegCSF instance
        &#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.CSF)
        index = header.size
        obj = cls(header.param, True)
        obj.no_signature_updates = True
        while index &lt; header.length:
            try:
                cmd_obj = parse_command(data, offset + index)
                obj.append_command(cmd_obj)
            except ValueError:
                raise CorruptedException(&#34;Failed to parse command at position: &#34; + hex(offset + index))
            index += cmd_obj.size

        for cmd in obj.commands:
            if cmd.needs_cmd_data_reference:
                obj._parse_cmd_data(cmd, data)

        obj.update(True)
        return obj


########################################################################################################################
# Boot Image V3 Segments (i.MX8QM-Ax, i.MX8QXP-Ax)
########################################################################################################################

class SegIVT3a(BaseSegment):
    &#34;&#34;&#34;IVT3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;1L5Q&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of IVT3a segment.&#34;&#34;&#34;
        return self._header

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IVT3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, param: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT segment.

        :param param: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT3, param)
        self._header.length = self.SIZE
        self.version = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.next = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT3a &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, CSF:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.csf_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT3a.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; VER:  {}\n&#34;.format(self.version)
        msg += &#34; IVT:  0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT:  0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD:  0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; CSF:  0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34; NEXT: 0x{:08X}\n&#34;.format(self.next)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validation of IVT3a segment.&#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self.header.export()
        data += pack(self.FORMAT, self.version, self.dcd_address, self.bdt_address, self.ivt_address,
                     self.csf_address, self.next)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT3a segment
        :return: SegIVT3a object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT3)
        obj = cls(header.param)

        (obj.version,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.next) = unpack_from(cls.FORMAT, data, header.size)

        obj.validate()

        return obj


class SegIVT3b(BaseSegment):
    &#34;&#34;&#34;IVT3b segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;1L7Q&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of IVT3b segment.&#34;&#34;&#34;
        return self._header

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IVT3b segment.

        :return size
        &#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT segment.

        :param version: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT2, version)
        self._header.length = self.SIZE
        self.rs1 = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.scd_address = 0
        self.rs2h = 0
        self.rs2l = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT3b &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, CSF:0x{:X}, SCD:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.csf_address, self.scd_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT3b.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; IVT: 0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT: 0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD: 0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; SCD: 0x{:08X}\n&#34;.format(self.scd_address)
        msg += &#34; CSF: 0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validation of IVT3b segment.&#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))
        if self.scd_address and self.scd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid SCD address: 0x{:X}&#34;.format(self.scd_address))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self.header.export()
        data += pack(self.FORMAT, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address, self.csf_address,
                     self.scd_address, self.rs2h, self.rs2l)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT3b segment
        :return: SegIVT3b object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT2)
        obj = cls(header.param)

        (obj.rs1,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.scd_address,
         obj.rs2h,
         obj.rs2l) = unpack_from(cls.FORMAT, data, header.size)

        obj.validate()

        return obj


class SegIDS3a(BaseSegment):
    &#34;&#34;&#34;IDS3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;3Q4L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IDS3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize IDS3a segment.&#34;&#34;&#34;
        super().__init__()
        self.image_source = 0
        self.image_destination = 0
        self.image_entry = 0
        self.image_size = 0
        self.hab_flags = 0
        self.scfw_flags = 0
        self.rom_flags = 0

    def __repr__(self) -&gt; str:
        return &#34;IDS3a &lt;IN:0x{:X}, OUT:0x{:X}, ENTRY:0x{:X}, SIZE:{}B, HAB:0x{:X}, SCFW:0x{:X}, ROM:0x{:X}&gt;&#34;.format(
            self.image_source, self.image_destination, self.image_entry, self.image_size, self.hab_flags,
            self.scfw_flags, self.rom_flags
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIDS3a.&#34;&#34;&#34;
        msg = &#34; Source: 0x{:08X}\n&#34;.format(self.image_source)
        msg += &#34; Dest:   0x{:08X}\n&#34;.format(self.image_destination)
        msg += &#34; Entry:  0x{:08X}\n&#34;.format(self.image_entry)
        msg += &#34; Size:   {:s} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
        msg += &#34; &lt;Flags&gt;\n&#34;
        msg += &#34; SCFW:   0x{:08X}\n&#34;.format(self.scfw_flags)
        msg += &#34; HAB:    0x{:08X}\n&#34;.format(self.hab_flags)
        msg += &#34; ROM:    0x{:08X}\n&#34;.format(self.rom_flags)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.image_source,
                    self.image_destination,
                    self.image_entry,
                    self.image_size,
                    self.hab_flags,
                    self.scfw_flags,
                    self.rom_flags)
        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIDS3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IDS3a segment
        :return: SegIDS3a object
        &#34;&#34;&#34;
        obj = cls()
        (obj.image_source,
         obj.image_destination,
         obj.image_entry,
         obj.image_size,
         obj.hab_flags,
         obj.scfw_flags,
         obj.rom_flags) = unpack_from(obj.FORMAT, data)

        return obj


class SegBDS3a(BaseSegment):
    &#34;&#34;&#34;BDS3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;4L&#39;
    HEADER_SIZE = calcsize(FORMAT)
    IMAGES_MAX_COUNT = 6
    SIZE = HEADER_SIZE + SegIDS3a.SIZE * IMAGES_MAX_COUNT

    @property
    def header_size(self) -&gt; int:
        &#34;&#34;&#34;Header&#39;s size of BDS3a segment.&#34;&#34;&#34;
        return self.HEADER_SIZE

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of BDS3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize BDS3a segment.&#34;&#34;&#34;
        super().__init__()
        self.images_count = 0
        self.boot_data_size = 0
        self.boot_data_flag = 0
        self.images = [SegIDS3a() for _ in range(self.IMAGES_MAX_COUNT)]
        self.reserved = 0

    def __repr__(self) -&gt; str:
        return &#34;BDS3a &lt;IMAGES: {}, SIZE: {}B, FLAG: 0x{:X}&gt;&#34;.format(
            self.images_count, self.boot_data_size, self.boot_data_flag
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDS3a.&#34;&#34;&#34;
        msg = &#34; IMAGES: {}\n&#34;.format(self.images_count)
        # TODO: why the code commented-out?   msg += &#34; Data size: {}\n&#34;.format(self.boot_data_size)
        msg += &#34; DFLAGS: 0x{0:08X}\n&#34;.format(self.boot_data_flag)
        msg += &#34;\n&#34;
        for i in range(self.images_count):
            msg += &#34; IMAGE[{}] \n&#34;.format(i)
            msg += self.images[i].info()
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.images_count,
                    self.boot_data_size,
                    self.boot_data_flag,
                    self.reserved)

        for i in range(self.IMAGES_MAX_COUNT):
            data += self.images[i].export()

        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDS3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDS3a segment
        :return: SegBDS3a object
        &#34;&#34;&#34;
        obj = cls()
        (obj.images_count,
         obj.boot_data_size,
         obj.boot_data_flag,
         obj.reserved) = unpack_from(cls.FORMAT, data)

        for i in range(obj.images_count):
            obj.images[i] = SegIDS3a.parse(data[cls.HEADER_SIZE + i * SegIDS3a.SIZE:])

        return obj


class SegIDS3b(BaseSegment):
    &#34;&#34;&#34;IDS3b segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;3Q2L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IDS3b segment.&#34;&#34;&#34;
        return calcsize(self.FORMAT)

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize IDS3b segment.&#34;&#34;&#34;
        super().__init__()
        self.image_source = 0
        self.image_destination = 0
        self.image_entry = 0
        self.image_size = 0
        self.flags = 0

    def __repr__(self) -&gt; str:
        return &#34;IDS3b &lt;IN:0x{:X}, OUT:0x{:X}, ENTRY:0x{:X}, SIZE:{}B, FLAGS:0x{:X}&gt;&#34;.format(
            self.image_source, self.image_destination, self.image_entry, self.image_size, self.flags
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIDS3b.&#34;&#34;&#34;
        msg = &#34; Source: 0x{:08X}\n&#34;.format(self.image_source)
        msg += &#34; Dest:   0x{:08X}\n&#34;.format(self.image_destination)
        msg += &#34; Entry:  0x{:08X}\n&#34;.format(self.image_entry)
        msg += &#34; Flags:  0x{:08X}\n&#34;.format(self.flags)
        msg += &#34; Size:   {:s} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.image_source, self.image_destination, self.image_entry, self.image_size, self.flags)
        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIDS3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IDS3b segment
        :return: SegIDS3b object
        &#34;&#34;&#34;
        ids = cls()
        (ids.image_source,
         ids.image_destination,
         ids.image_entry,
         ids.image_size,
         ids.flags) = unpack_from(cls.FORMAT, data)

        return ids


class SegBDS3b(BaseSegment):
    &#34;&#34;&#34;BDS3b segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;4L&#39;
    HEADER_SIZE = calcsize(FORMAT)
    IMAGES_MAX_COUNT = 4
    SIZE = calcsize(FORMAT) + SegIDS3b.SIZE * (IMAGES_MAX_COUNT + 3)

    @property
    def header_size(self) -&gt; int:
        &#34;&#34;&#34;Size of header of BDS3b segment.&#34;&#34;&#34;
        return self.HEADER_SIZE

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of BDS3b segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize BDS3b segment.&#34;&#34;&#34;
        super().__init__()
        self.images_count = 0
        self.boot_data_size = 0
        self.boot_data_flag = 0
        self.reserved = 0

        self.images = [SegIDS3b() for _ in range(self.IMAGES_MAX_COUNT)]

        self.scd = SegIDS3b()
        self.csf = SegIDS3b()
        self.rs_img = SegIDS3b()

    def __repr__(self) -&gt; str:
        return &#34;BDS3b &lt;IMAGES: {}, SIZE: {}B, FLAG: 0x{:X}&gt;&#34;.format(
            self.images_count, self.boot_data_size, self.boot_data_flag
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDS3b.&#34;&#34;&#34;
        msg = &#34; IMAGES: {}\n&#34;.format(self.images_count)
        # TODO: why the code commented-out? msg += &#34; Data size: {}\n&#34;.format(self.boot_data_size)
        msg += &#34; DFLAGS: 0x{0:08X}\n&#34;.format(self.boot_data_flag)
        msg += &#34;\n&#34;
        for i in range(self.images_count):
            msg += &#34; IMAGE[{}] \n&#34;.format(i)
            msg += self.images[i].info()
        if self.scd.image_source != 0:
            msg += &#34; SCD:\n&#34;
            msg += self.scd.info()
        if self.csf.image_source != 0:
            msg += &#34; CSF:\n&#34;
            msg += self.csf.info()

        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.images_count,
                    self.boot_data_size,
                    self.boot_data_flag,
                    self.reserved)

        for i in range(self.IMAGES_MAX_COUNT):
            data += self.images[i].export()

        data += self.scd.export()
        data += self.csf.export()
        data += self.rs_img.export()

        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDS3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDS3b segment
        :return: SegBDS3b object
        &#34;&#34;&#34;
        obj = cls()
        (obj.images_count,
         obj.boot_data_size,
         obj.boot_data_flag,
         obj.reserved) = unpack_from(obj.FORMAT, data)

        offset = cls.HEADER_SIZE
        for i in range(obj.images_count):
            obj.images[i] = SegIDS3b.parse(data[offset:])
            offset += SegIDS3b.SIZE

        obj.scd = SegIDS3b.parse(data[offset:])
        offset += SegIDS3b.SIZE
        obj.csf = SegIDS3b.parse(data[offset:])
        offset += SegIDS3b.SIZE
        obj.rs_img = SegIDS3b.parse(data[offset:])

        return obj


########################################################################################################################
# Boot Image V4 Segments (i.MX8DM, i.MX8QM-Bx, i.MX8QXP-Bx)
########################################################################################################################

class SegBIM(BaseSegment):
    &#34;&#34;&#34;BootImage segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;2L2Q2L&#39;
    SIZE = calcsize(FORMAT) + 64 + 32

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of BootImage segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize BootImage segment.&#34;&#34;&#34;
        super().__init__()
        self.image_offset = 0
        self.image_size = 0
        self.load_address = 0
        self.entry_address = 0
        self.hab_flags = 0
        self.meta_data = 0
        self.image_hash: Optional[bytes] = None
        self.image_iv: Optional[bytes] = None

    def __repr__(self) -&gt; str:
        return &#34;BIM &lt;OFFSET:{}, SIZE:{}B, LOAD:0x{:X}, ENTRY:0x{:X}, FLAGS:0x{:X}&gt;&#34;.format(
            self.image_offset, self.image_size, self.load_address, self.entry_address, self.hab_flags
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBIM.&#34;&#34;&#34;
        msg = &#34; Offset:     0x{:X}\n&#34;.format(self.image_offset)
        msg += &#34; Size:       {} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
        msg += &#34; Load:       0x{:X}\n&#34;.format(self.load_address)
        msg += &#34; Entry:      0x{:X}\n&#34;.format(self.entry_address)
        if self.image_hash:
            msg += &#34; HASH:       {}\n&#34;.format(&#39;&#39;.join([&#39;{:02X}&#39;.format(i) for i in self.image_hash]))
        if self.image_iv:
            msg += &#34; IV:         {}\n&#34;.format(&#39;&#39;.join([&#39;{:02X}&#39;.format(i) for i in self.image_iv]))
        msg += &#34; Hash Flags: 0x{:08X}\n&#34;.format(self.hab_flags)
        msg += &#34; Meta Data:  0x{:08X}\n&#34;.format(self.meta_data)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.image_offset,
                    self.image_size,
                    self.load_address,
                    self.entry_address,
                    self.hab_flags,
                    self.meta_data)

        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBIM&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BootImage segment
        :return: SegBootImage object
        &#34;&#34;&#34;
        obj = cls()
        (obj.image_offset,
         obj.image_size,
         obj.load_address,
         obj.entry_address,
         obj.hab_flags,
         obj.meta_data) = unpack_from(obj.FORMAT, data)

        offset = calcsize(cls.FORMAT)
        obj.image_hash = data[offset:offset + 64]
        offset += 64
        obj.image_iv = data[offset:offset + 32]

        return obj


class SegSIGB(BaseSegment):
    &#34;&#34;&#34;SignatureBlock segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;4HL&#39;
    SIZE = Header2.SIZE + calcsize(FORMAT)

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of Signature Block segment.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Signature Block segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize SignatureBlock segment.&#34;&#34;&#34;
        super().__init__()
        self._header = Header2(SegTag.SIGB, version)
        self._header.length = self.SIZE
        self.srk_table_offset = 0
        self.cert_offset = 0
        self.blob_offset = 0
        self.signature_offset = 0
        self.reserved = 0

    def __repr__(self) -&gt; str:
        return &#34;SIGB &lt;SRK:0x{:X}, CERT:0x{:X}, BLOB:0x{:X}, SIG:0x{:X}&gt;&#34;.format(
            self.srk_table_offset, self.cert_offset, self.blob_offset, self.signature_offset
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegSIGB.&#34;&#34;&#34;
        msg = &#34; SRK Table Offset:   0x{:X}\n&#34;.format(self.srk_table_offset)
        msg += &#34; Certificate Offset: 0x{:X}\n&#34;.format(self.cert_offset)
        msg += &#34; Signature Offset:   0x{:X}\n&#34;.format(self.signature_offset)
        msg += &#34; Blob Offset:        0x{:X}\n&#34;.format(self.blob_offset)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = self._header.export()
        data += pack(self.FORMAT,
                     self.srk_table_offset, self.cert_offset, self.blob_offset, self.signature_offset, self.reserved)
        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegSIGB&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of SignatureBlock segment
        :return: SegSigBlk object
        &#34;&#34;&#34;
        header = Header2.parse(data, 0, SegTag.SIGB)
        obj = cls(header.param)

        (obj.srk_table_offset,
         obj.cert_offset,
         obj.blob_offset,
         obj.signature_offset,
         obj.reserved) = unpack_from(obj.FORMAT, data)

        return obj

# pylint: disable=too-many-instance-attributes
class SegBIC1(BaseSegment):
    &#34;&#34;&#34;Boot Images Container segment.&#34;&#34;&#34;

    MAX_NUM_IMGS = 6

    FORMAT = &#39;&lt;LH2B2H&#39;
    SIZE = Header.SIZE + calcsize(FORMAT) + MAX_NUM_IMGS * SegBIM.SIZE + SegSIGB.SIZE + 8

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of Boot Images Container segment.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        &#34;&#34;&#34;Version of Boot Images Container segment.&#34;&#34;&#34;
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize Boot Images Container segment.

        :param version: The version of Header for Boot Images Container
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header2(SegTag.BIC1, version)
        self._header.length = self.SIZE
        self.flags = 0
        self.sw_version = 0
        self.fuse_version = 0
        self.images_count = 0
        self.sig_blk_offset = 0
        self.reserved = 0
        self.images = [SegBIM() for _ in range(self.MAX_NUM_IMGS)]
        self.sig_blk_hdr = SegSIGB()
        self.sig_blk_size = 0
        self.padding = 8

    def __repr__(self) -&gt; str:
        return &#34;BIC1 &lt;FLAGS:0x{:X}, SWV:0x{:X}, FUSEV:0x{:X}, COUNT:{}, SBO:0x{:X}&gt;&#34;.format(
            self.flags, self.sw_version, self.fuse_version, self.images_count, self.sig_blk_offset
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBIC1.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; Flags:        0x{:08X}\n&#34;.format(self.flags)
        msg += &#34; SW Version:   {}\n&#34;.format(self.sw_version)
        msg += &#34; Fuse Version: {}\n&#34;.format(self.fuse_version)
        msg += &#34; Images Count: {}\n&#34;.format(self.images_count)
        msg += &#34; SigBlkOffset: 0x{:08X}\n&#34;.format(self.sig_blk_offset)
        msg += &#34;\n&#34;
        for i in range(self.images_count):
            msg += &#34; IMAGE[{}] \n&#34;.format(i)
            msg += self.images[i].info()
        msg += &#34; [ Signature Block Header ]\n&#34;
        msg += self.sig_blk_hdr.info()
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validate segment.&#34;&#34;&#34;
        return None

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self._header.export()
        data += pack(self.FORMAT,
                     self.flags,
                     self.sw_version,
                     self.fuse_version,
                     self.images_count,
                     self.sig_blk_offset,
                     self.reserved)
        for image in self.images:
            data += image.export()
        data += self.sig_blk_hdr.export()
        data += pack(&#39;&lt;L&#39;, self.sig_blk_size)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBIC1&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BIC1 segment
        :return: SegBIC1 object
        &#34;&#34;&#34;
        header = Header2.parse(data, 0, SegTag.BIC1)
        offset = header.size
        obj = cls(header.param)

        (obj.flags,
         obj.sw_version,
         obj.fuse_version,
         obj.images_count,
         obj.sig_blk_offset,
         obj.reserved) = unpack_from(cls.FORMAT, data, offset)

        offset += calcsize(cls.FORMAT)
        for i in range(obj.images_count):
            obj.images[i] = SegBIM.parse(data[offset:])
            offset += SegBIM.SIZE

        obj.sig_blk_hdr = SegSIGB.parse(data[offset:])
        offset += SegSIGB.SIZE
        obj.sig_blk_size = unpack_from(&#39;&lt;L&#39;, data, offset)[0]

        obj.validate()

        return obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.image.segments.AbstractFCB"><code class="flex name class">
<span>class <span class="ident">AbstractFCB</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class, predecessor for all FCB classes.</p>
<p>Constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractFCB(BaseSegment):
    &#34;&#34;&#34;Abstract class, predecessor for all FCB classes.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
        super().__init__()
        self._enabled = True

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34;Whether FCB is enabled. Note: it is not generated to output is disabled.&#34;&#34;&#34;
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Setter.

        :param value: whether FCB is enabled
        &#34;&#34;&#34;
        self._enabled = value

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Return length (in bytes) of the exported data including padding (if any).&#34;&#34;&#34;
        return super(AbstractFCB, self).space if self.enabled else 0

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary representation (serialization).

        :param dbg_info: instance allowing to debug output
        :return: binary representation
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.FlexSPIConfBlockFCB" href="#spsdk.image.segments.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a></li>
<li><a title="spsdk.image.segments.PaddingFCB" href="#spsdk.image.segments.PaddingFCB">PaddingFCB</a></li>
<li><a title="spsdk.image.segments.SegFCB" href="#spsdk.image.segments.SegFCB">SegFCB</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.AbstractFCB.enabled"><code class="name">var <span class="ident">enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether FCB is enabled. Note: it is not generated to output is disabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    &#34;&#34;&#34;Whether FCB is enabled. Note: it is not generated to output is disabled.&#34;&#34;&#34;
    return self._enabled</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.AbstractFCB.space"><code class="name">var <span class="ident">space</span> : int</code></dt>
<dd>
<div class="desc"><p>Return length (in bytes) of the exported data including padding (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def space(self) -&gt; int:
    &#34;&#34;&#34;Return length (in bytes) of the exported data including padding (if any).&#34;&#34;&#34;
    return super(AbstractFCB, self).space if self.enabled else 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.AbstractFCB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary representation (serialization).</p>
<p>:param dbg_info: instance allowing to debug output
:return: binary representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export to binary representation (serialization).

    :param dbg_info: instance allowing to debug output
    :return: binary representation
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.info" href="#spsdk.image.segments.BaseSegment.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.parse" href="#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.size" href="#spsdk.image.segments.BaseSegment.size">size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.BaseSegment"><code class="flex name class">
<span>class <span class="ident">BaseSegment</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base segment.</p>
<p>Initialize the base
segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSegment(ABC):
    &#34;&#34;&#34;Base segment.&#34;&#34;&#34;

    # padding fill value
    PADDING_VALUE = 0x00

    @property
    def padding_len(self) -&gt; int:
        &#34;&#34;&#34;Length of padding data in bytes (zero for no padding).&#34;&#34;&#34;
        return self.padding

    @padding_len.setter
    def padding_len(self, value: int) -&gt; None:
        &#34;&#34;&#34;New length (in bytes) of padding applied at the end of exported data.&#34;&#34;&#34;
        assert value &gt;= 0
        self.padding = value

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Return length (in bytes) of the exported data including padding (if any).

        Please mind, padding is exported optionally.
        &#34;&#34;&#34;
        return self.size + self.padding_len

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of base segment.&#34;&#34;&#34;
        return 0

    def _padding_export(self) -&gt; bytes:
        &#34;&#34;&#34;Padding binary data, see `padding_len` for length.&#34;&#34;&#34;
        return bytes([self.PADDING_VALUE] * self.padding_len) if self.padding_len &gt; 0 else b&#39;&#39;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize the base  segment.&#34;&#34;&#34;
        self.padding = 0

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, self.__class__) and vars(other) == vars(self)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the BaseSegment.&#34;&#34;&#34;
        raise NotImplementedError()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export interface.&#34;&#34;&#34;
        raise NotImplementedError()

    @classmethod
    def parse(cls, buffer: bytes) -&gt; &#39;BaseSegment&#39;:
        &#34;&#34;&#34;Parse interfaces.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></li>
<li><a title="spsdk.image.segments.SegAPP" href="#spsdk.image.segments.SegAPP">SegAPP</a></li>
<li><a title="spsdk.image.segments.SegBDS3a" href="#spsdk.image.segments.SegBDS3a">SegBDS3a</a></li>
<li><a title="spsdk.image.segments.SegBDS3b" href="#spsdk.image.segments.SegBDS3b">SegBDS3b</a></li>
<li><a title="spsdk.image.segments.SegBDT" href="#spsdk.image.segments.SegBDT">SegBDT</a></li>
<li><a title="spsdk.image.segments.SegBEE" href="#spsdk.image.segments.SegBEE">SegBEE</a></li>
<li><a title="spsdk.image.segments.SegBIC1" href="#spsdk.image.segments.SegBIC1">SegBIC1</a></li>
<li><a title="spsdk.image.segments.SegBIM" href="#spsdk.image.segments.SegBIM">SegBIM</a></li>
<li><a title="spsdk.image.segments.SegCSF" href="#spsdk.image.segments.SegCSF">SegCSF</a></li>
<li><a title="spsdk.image.segments.SegDCD" href="#spsdk.image.segments.SegDCD">SegDCD</a></li>
<li><a title="spsdk.image.segments.SegIDS3a" href="#spsdk.image.segments.SegIDS3a">SegIDS3a</a></li>
<li><a title="spsdk.image.segments.SegIDS3b" href="#spsdk.image.segments.SegIDS3b">SegIDS3b</a></li>
<li><a title="spsdk.image.segments.SegIVT2" href="#spsdk.image.segments.SegIVT2">SegIVT2</a></li>
<li><a title="spsdk.image.segments.SegIVT3a" href="#spsdk.image.segments.SegIVT3a">SegIVT3a</a></li>
<li><a title="spsdk.image.segments.SegIVT3b" href="#spsdk.image.segments.SegIVT3b">SegIVT3b</a></li>
<li><a title="spsdk.image.segments.SegSIGB" href="#spsdk.image.segments.SegSIGB">SegSIGB</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.BaseSegment.PADDING_VALUE"><code class="name">var <span class="ident">PADDING_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.BaseSegment.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>buffer: bytes) ‑> <a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse interfaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, buffer: bytes) -&gt; &#39;BaseSegment&#39;:
    &#34;&#34;&#34;Parse interfaces.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.BaseSegment.padding_len"><code class="name">var <span class="ident">padding_len</span> : int</code></dt>
<dd>
<div class="desc"><p>Length of padding data in bytes (zero for no padding).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def padding_len(self) -&gt; int:
    &#34;&#34;&#34;Length of padding data in bytes (zero for no padding).&#34;&#34;&#34;
    return self.padding</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.BaseSegment.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of base segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of base segment.&#34;&#34;&#34;
    return 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.BaseSegment.space"><code class="name">var <span class="ident">space</span> : int</code></dt>
<dd>
<div class="desc"><p>Return length (in bytes) of the exported data including padding (if any).</p>
<p>Please mind, padding is exported optionally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def space(self) -&gt; int:
    &#34;&#34;&#34;Return length (in bytes) of the exported data including padding (if any).

    Please mind, padding is exported optionally.
    &#34;&#34;&#34;
    return self.size + self.padding_len</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.BaseSegment.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export interface.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.BaseSegment.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the BaseSegment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the BaseSegment.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB"><code class="flex name class">
<span>class <span class="ident">FlexSPIConfBlockFCB</span></span>
</code></dt>
<dd>
<div class="desc"><p>Flex SPI configuration block; FCB.</p>
<p>Initialize FlexSPIConfBlockFCB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlexSPIConfBlockFCB(AbstractFCB):
    &#34;&#34;&#34;Flex SPI configuration block; FCB.&#34;&#34;&#34;
    # tag used in header to be able identify the block
    TAG = b&#39;FCFB&#39;
    # default version
    VERSION = b&#39;V\x01\x00\x00&#39;
    # format for the export
    FORMAT = &#39;&lt;6BH7I5I4B2I4I6I4H&#39;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize FlexSPIConfBlockFCB.&#34;&#34;&#34;
        super().__init__()
        self.version = self.VERSION
        # ### Fields descriptions are taken from RT1050 manual ###

        # [00C:8-bit] 0 = internal loopback; 1 = loopback from DQS pad; 3 = Flash provided DQS
        self.read_sample_clk_src = 0
        # [00D:8-bit] Serial Flash CS Hold Time Recommend default value is 0x03
        self.cs_hold_time = 3
        # [00E:8-bit] Serial Flash CS setup time. Recommended default value is 0x03
        self.cs_setup_time = 3
        # [00F:8-bit] 3 = For HyperFlash; 12/13 = For Serial NAND, see datasheet to find correct value; 0=Other devices
        self.column_address_width = 0
        # [010:8-bit] Device Mode Configuration Enable feature (0 – Disabled, 1 – Enabled)
        self.device_mode_cfg_enable = 0
        # [011:8-bit] Reserved
        self.device_mode_type = 0
        # [012:16-bit] Wait time for all configuration commands, unit 100us.
        # Available for device that support v1.1.0 FlexSPI configuration block. If it is greater than 0, ROM will wait
        # waitTimeCfgCommands * 100us for all device memory configuration commands instead of using read status to wait
        # until these commands complete.
        self.wait_time_cfg_commands = 0
        # [014:32-bit] Sequence parameter for device mode configuration
        # Bit[7:0] - number of LUT sequences for Device mode configuration command
        # Bit[15:8] - starting LUT index of Device mode configuration command
        # Bit[31:16] - must be 0
        self.device_mode_seq = 0
        # [018:32-bit] Device Mode argument, effective only when device_mode_cfg_enable = 1
        self.device_mode_arg = 0
        # [01C:32-bit] Config Command Enable feature (0 – Disabled, 1 – Enabled)
        self.config_cmd_enable = 0
        # [020:3 x 32-bit] Sequences for Config Command, allow 3 separate configuration command sequences.
        self.config_cmd_0 = 0
        self.config_cmd_1 = 0
        self.config_cmd_2 = 0
        # [02C:32-bit] reserved
        # [030:3 x 32-bit] Arguments for each separate configuration command sequence
        self.cfg_cmd_arg_0 = 0
        self.cfg_cmd_arg_1 = 0
        self.cfg_cmd_arg_2 = 0
        # [03C:32-bit] reserved
        # [040:32-bit]
        # Bit0 – differential clock enable
        # Bit1 – CK2 enable, must set to 0 in this silicon
        # Bit2 – ParallelModeEnable, must set to 0 for this silicon
        # Bit3 – wordAddressableEnable
        # Bit4 – Safe Configuration Frequency enable set to 1 for the devices that support DDR Read instructions
        # Bit5 – Pad Setting Override Enable
        # Bit6 – DDR Mode Enable, set to 1 for device supports DDR read command
        self.controller_misc_option = 0
        # [044:8-bit] 1 – Serial NOR, 2 – Serial NAND
        self.device_type = 0
        # [045:8-bit] 1 – Single pad; 2 – Dual pads; 4 – Quad pads; 8 – Octal pads
        self.sflash_pad_type = 0
        # [046:8-bit] Chip specific value, for RT1050
        # 1 – 30 MHz; 2 – 50 MHz; 3 – 60 MHz; 4 – 75 MHz; 5 – 80 MHz; 6 – 100 MHz; 7 – 133 MHz; 8 – 166 MHz;
        # Other value: 30 MHz
        self.serial_clk_freq = 0
        # [047:8-bit] 0=Use predefined LUT sequence index and number;
        #             1=Use LUT sequence parameters provided in this block
        self.lut_custom_seq_enable = 0
        # [048:8B] reserverd
        # [050:4x32-bit] For SPI NOR, need to fill with actual size; For SPI NAND, need to fill with actual size * 2
        self.sflash_a1_size = 0
        self.sflash_a2_size = 0
        self.sflash_b1_size = 0
        self.sflash_b2_size = 0
        # [060:4x32-bit] Set to 0 if it is not supported
        self.cs_pad_setting_override = 0
        self.sclk_pad_setting_override = 0
        self.data_pad_setting_override = 0
        self.dqs_pad_setting_override = 0
        # [070:32-bit] Maximum wait time during read busy status
        # 0 – Disabled timeout checking feature; Other value – Timeout if the wait time exceeds this value.
        self.timeout_in_ms = 0
        # [074:32-bit] Unit: ns; RT1050: Currently, it is used for SPI NAND only at high frequency
        self.command_interval = 0
        # [078:2x16-bit] Time from clock edge to data valid edge. unit 0.1 ns. This field is used when the FlexSPI Root
        # clock is less than 100 MHz and the read sample clock source is device provided DQS signal without CK2 support.
        self.data_valid_time_dlla = 0
        self.data_valid_time_dllb = 0
        # [07C:16-bit] busy bit offset, valid range 0-31
        self.busy_offset = 0
        # [07E:16-bit] 0 – busy bit is 1 if device is busy; 1 – busy bit is 0 if device is busy
        self.busy_bit_polarity = 0
        # [080:256B] Lookup table
        self.lookup_table = b&#39;\x00&#39; * 256
        # [180:48B] Customized LUT sequence
        self.lut_custom_seq = b&#39;\x00&#39; * 48
        # [1B0:16B] reserved
        self.reserved_padding1 = b&#39;\x00&#39; * 16
        self.reserved_padding2 = b&#39;\x00&#39; * 64

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Length of the binary exported data without padding.&#34;&#34;&#34;
        if not self.enabled:
            return 0

        return len(self.export_header()) + calcsize(self.FORMAT) + len(self.lookup_table) + len(self.lut_custom_seq) + \
               len(self.reserved_padding1) + len(self.reserved_padding2)

    def export_header(self) -&gt; bytes:
        &#34;&#34;&#34;Export FCB header info binary form.&#34;&#34;&#34;
        return self.TAG + self.version[::-1] + b&#39;\x00\x00\x00\x00&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export into binary form.

        :param dbg_info: instance allowing to debug output
        :return: binary representation used in the bootable image
        &#34;&#34;&#34;
        if not self.enabled:
            return b&#39;&#39;

        data = self.export_header()
        data += pack(self.FORMAT,
                     # B
                     self.read_sample_clk_src, self.cs_hold_time, self.cs_setup_time, self.column_address_width,
                     self.device_mode_cfg_enable, self.device_mode_type,
                     # H
                     self.wait_time_cfg_commands,
                     # I
                     self.device_mode_seq, self.device_mode_arg, self.config_cmd_enable,
                     self.config_cmd_0, self.config_cmd_1, self.config_cmd_2, 0,
                     # I
                     self.cfg_cmd_arg_0, self.cfg_cmd_arg_1, self.cfg_cmd_arg_2, 0,
                     self.controller_misc_option,
                     # B
                     self.device_type, self.sflash_pad_type, self.serial_clk_freq, self.lut_custom_seq_enable,
                     # I
                     0, 0,
                     # I
                     self.sflash_a1_size, self.sflash_a2_size, self.sflash_b1_size, self.sflash_b2_size,
                     # I
                     self.cs_pad_setting_override, self.sclk_pad_setting_override, self.data_pad_setting_override,
                     self.dqs_pad_setting_override, self.timeout_in_ms, self.command_interval,
                     # H
                     self.data_valid_time_dlla, self.data_valid_time_dllb, self.busy_offset, self.busy_bit_polarity)
        data += self.lookup_table + self.lut_custom_seq + self.reserved_padding1 + self.reserved_padding2

        dbg_info.append_binary_section(&#39;FCB&#39;, data)

        if self.padding_len &gt; 0:
            data += self._padding_export()
            dbg_info.append_section(f&#39;FCB-padding: {self.padding_len} bytes&#39;)

        return data

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the FlexSPIConfBlockFCB.&#34;&#34;&#34;
        return &#34;[FCB]\n&#34; + f&#39;{self.size} bytes\n&#39; if self.enabled else &#34;No FCB\n&#34;

    @classmethod
    def parse(cls, buffer: bytes) -&gt; &#39;FlexSPIConfBlockFCB&#39;:
        &#34;&#34;&#34;Parse binary data and creates instance of the class.

        :param buffer: data to be parsed
        :return: instance of the class representing the data
        :raise ValueError: if data are not valid Flex SPI configuration block
        &#34;&#34;&#34;
        if buffer[:4] != FlexSPIConfBlockFCB.TAG:
            raise ValueError(&#39;TAG does not match: &#39; + buffer[:4].hex())

        version = buffer[7:3:-1]
        if (version[0] != ord(&#39;V&#39;)) or (version[1] != 1) or (version[2] not in range(0, 9)) or \
                (version[3] not in range(0, 9)):
            raise ValueError(&#39;Invalid version number format&#39;)

        result = FlexSPIConfBlockFCB()
        if len(buffer) &lt; result.size:
            raise ValueError(&#39;Insufficient data length&#39;)

        offset = len(result.export_header())
        result.version = version
        (  # B
            result.read_sample_clk_src, result.cs_hold_time, result.cs_setup_time, result.column_address_width,
            result.device_mode_cfg_enable, result.device_mode_type,
            # H
            result.wait_time_cfg_commands,
            # I
            result.device_mode_seq, result.device_mode_arg, result.config_cmd_enable,
            result.config_cmd_0, result.config_cmd_1, result.config_cmd_2, _reserved1,
            # I
            result.cfg_cmd_arg_0, result.cfg_cmd_arg_1, result.cfg_cmd_arg_2, _reserved2,
            result.controller_misc_option,
            # B
            result.device_type, result.sflash_pad_type, result.serial_clk_freq, result.lut_custom_seq_enable,
            # I
            _reserved3, _reserved4,
            # I
            result.sflash_a1_size, result.sflash_a2_size, result.sflash_b1_size, result.sflash_b2_size,
            # I
            result.cs_pad_setting_override, result.sclk_pad_setting_override, result.data_pad_setting_override,
            result.dqs_pad_setting_override, result.timeout_in_ms, result.command_interval,
            # H
            result.data_valid_time_dlla, result.data_valid_time_dllb, result.busy_offset, result.busy_bit_polarity
        ) = unpack_from(FlexSPIConfBlockFCB.FORMAT, buffer, offset)
        offset += calcsize(FlexSPIConfBlockFCB.FORMAT)
        # lookup table
        result.lookup_table = buffer[offset:offset + len(result.lookup_table)]
        offset += len(result.lookup_table)
        # lookup table
        result.lut_custom_seq = buffer[offset:offset + len(result.lut_custom_seq)]
        offset += len(result.lut_custom_seq)
        # reserved padding
        result.reserved_padding1 = buffer[offset:offset + len(result.reserved_padding1)]
        offset += len(result.reserved_padding1)
        result.reserved_padding2 = buffer[offset:offset + len(result.reserved_padding2)]

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></li>
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.TAG"><code class="name">var <span class="ident">TAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>buffer: bytes) ‑> <a title="spsdk.image.segments.FlexSPIConfBlockFCB" href="#spsdk.image.segments.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse binary data and creates instance of the class.</p>
<p>:param buffer: data to be parsed
:return: instance of the class representing the data
:raise ValueError: if data are not valid Flex SPI configuration block</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, buffer: bytes) -&gt; &#39;FlexSPIConfBlockFCB&#39;:
    &#34;&#34;&#34;Parse binary data and creates instance of the class.

    :param buffer: data to be parsed
    :return: instance of the class representing the data
    :raise ValueError: if data are not valid Flex SPI configuration block
    &#34;&#34;&#34;
    if buffer[:4] != FlexSPIConfBlockFCB.TAG:
        raise ValueError(&#39;TAG does not match: &#39; + buffer[:4].hex())

    version = buffer[7:3:-1]
    if (version[0] != ord(&#39;V&#39;)) or (version[1] != 1) or (version[2] not in range(0, 9)) or \
            (version[3] not in range(0, 9)):
        raise ValueError(&#39;Invalid version number format&#39;)

    result = FlexSPIConfBlockFCB()
    if len(buffer) &lt; result.size:
        raise ValueError(&#39;Insufficient data length&#39;)

    offset = len(result.export_header())
    result.version = version
    (  # B
        result.read_sample_clk_src, result.cs_hold_time, result.cs_setup_time, result.column_address_width,
        result.device_mode_cfg_enable, result.device_mode_type,
        # H
        result.wait_time_cfg_commands,
        # I
        result.device_mode_seq, result.device_mode_arg, result.config_cmd_enable,
        result.config_cmd_0, result.config_cmd_1, result.config_cmd_2, _reserved1,
        # I
        result.cfg_cmd_arg_0, result.cfg_cmd_arg_1, result.cfg_cmd_arg_2, _reserved2,
        result.controller_misc_option,
        # B
        result.device_type, result.sflash_pad_type, result.serial_clk_freq, result.lut_custom_seq_enable,
        # I
        _reserved3, _reserved4,
        # I
        result.sflash_a1_size, result.sflash_a2_size, result.sflash_b1_size, result.sflash_b2_size,
        # I
        result.cs_pad_setting_override, result.sclk_pad_setting_override, result.data_pad_setting_override,
        result.dqs_pad_setting_override, result.timeout_in_ms, result.command_interval,
        # H
        result.data_valid_time_dlla, result.data_valid_time_dllb, result.busy_offset, result.busy_bit_polarity
    ) = unpack_from(FlexSPIConfBlockFCB.FORMAT, buffer, offset)
    offset += calcsize(FlexSPIConfBlockFCB.FORMAT)
    # lookup table
    result.lookup_table = buffer[offset:offset + len(result.lookup_table)]
    offset += len(result.lookup_table)
    # lookup table
    result.lut_custom_seq = buffer[offset:offset + len(result.lut_custom_seq)]
    offset += len(result.lut_custom_seq)
    # reserved padding
    result.reserved_padding1 = buffer[offset:offset + len(result.reserved_padding1)]
    offset += len(result.reserved_padding1)
    result.reserved_padding2 = buffer[offset:offset + len(result.reserved_padding2)]

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Length of the binary exported data without padding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Length of the binary exported data without padding.&#34;&#34;&#34;
    if not self.enabled:
        return 0

    return len(self.export_header()) + calcsize(self.FORMAT) + len(self.lookup_table) + len(self.lut_custom_seq) + \
           len(self.reserved_padding1) + len(self.reserved_padding2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export into binary form.</p>
<p>:param dbg_info: instance allowing to debug output
:return: binary representation used in the bootable image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export into binary form.

    :param dbg_info: instance allowing to debug output
    :return: binary representation used in the bootable image
    &#34;&#34;&#34;
    if not self.enabled:
        return b&#39;&#39;

    data = self.export_header()
    data += pack(self.FORMAT,
                 # B
                 self.read_sample_clk_src, self.cs_hold_time, self.cs_setup_time, self.column_address_width,
                 self.device_mode_cfg_enable, self.device_mode_type,
                 # H
                 self.wait_time_cfg_commands,
                 # I
                 self.device_mode_seq, self.device_mode_arg, self.config_cmd_enable,
                 self.config_cmd_0, self.config_cmd_1, self.config_cmd_2, 0,
                 # I
                 self.cfg_cmd_arg_0, self.cfg_cmd_arg_1, self.cfg_cmd_arg_2, 0,
                 self.controller_misc_option,
                 # B
                 self.device_type, self.sflash_pad_type, self.serial_clk_freq, self.lut_custom_seq_enable,
                 # I
                 0, 0,
                 # I
                 self.sflash_a1_size, self.sflash_a2_size, self.sflash_b1_size, self.sflash_b2_size,
                 # I
                 self.cs_pad_setting_override, self.sclk_pad_setting_override, self.data_pad_setting_override,
                 self.dqs_pad_setting_override, self.timeout_in_ms, self.command_interval,
                 # H
                 self.data_valid_time_dlla, self.data_valid_time_dllb, self.busy_offset, self.busy_bit_polarity)
    data += self.lookup_table + self.lut_custom_seq + self.reserved_padding1 + self.reserved_padding2

    dbg_info.append_binary_section(&#39;FCB&#39;, data)

    if self.padding_len &gt; 0:
        data += self._padding_export()
        dbg_info.append_section(f&#39;FCB-padding: {self.padding_len} bytes&#39;)

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.export_header"><code class="name flex">
<span>def <span class="ident">export_header</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export FCB header info binary form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_header(self) -&gt; bytes:
    &#34;&#34;&#34;Export FCB header info binary form.&#34;&#34;&#34;
    return self.TAG + self.version[::-1] + b&#39;\x00\x00\x00\x00&#39;</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.FlexSPIConfBlockFCB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the FlexSPIConfBlockFCB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the FlexSPIConfBlockFCB.&#34;&#34;&#34;
    return &#34;[FCB]\n&#34; + f&#39;{self.size} bytes\n&#39; if self.enabled else &#34;No FCB\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.AbstractFCB.enabled" href="#spsdk.image.segments.AbstractFCB.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.space" href="#spsdk.image.segments.AbstractFCB.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.PaddingFCB"><code class="flex name class">
<span>class <span class="ident">PaddingFCB</span></span>
<span>(</span><span>size: int, padding_value: int = 0, enabled: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Padding FCB.</p>
<p>Constructor.</p>
<p>:param size: of the exported padding
:param padding_value: byte value used as padding; 0 by default
:param enabled: whether enabled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PaddingFCB(AbstractFCB):
    &#34;&#34;&#34;Padding FCB.&#34;&#34;&#34;

    def __init__(self, size: int, padding_value: int = 0, enabled: bool = True):
        &#34;&#34;&#34;Constructor.

        :param size: of the exported padding
        :param padding_value: byte value used as padding; 0 by default
        :param enabled: whether enabled
        &#34;&#34;&#34;
        super().__init__()
        assert 0 &lt;= size &lt;= 0xFFFF
        assert 0 &lt;= padding_value &lt;= 0xFF
        self._size = size
        self._padding_byte = bytes([padding_value])
        self.enabled = enabled

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Return size of the exported data in bytes.&#34;&#34;&#34;
        return self._size if self.enabled else 0

    def info(self) -&gt; str:
        &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
        return f&#39;PaddingFCB: {self.size} bytes&#39;

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form (serialization).

        :param dbg_info: instance allowing to debug output format
        :return: binary representation
        &#34;&#34;&#34;
        if not self.enabled:
            return b&#39;&#39;

        result = self._padding_byte * self._size + self._padding_export()
        dbg_info.append_section(f&#39;FCB-padding: {len(result)} bytes&#39;)
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></li>
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.PaddingFCB.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Return size of the exported data in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Return size of the exported data in bytes.&#34;&#34;&#34;
    return self._size if self.enabled else 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.PaddingFCB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary form (serialization).</p>
<p>:param dbg_info: instance allowing to debug output format
:return: binary representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export to binary form (serialization).

    :param dbg_info: instance allowing to debug output format
    :return: binary representation
    &#34;&#34;&#34;
    if not self.enabled:
        return b&#39;&#39;

    result = self._padding_byte * self._size + self._padding_export()
    dbg_info.append_section(f&#39;FCB-padding: {len(result)} bytes&#39;)
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.PaddingFCB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;Return text description of the instance.&#34;&#34;&#34;
    return f&#39;PaddingFCB: {self.size} bytes&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.AbstractFCB.enabled" href="#spsdk.image.segments.AbstractFCB.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.parse" href="#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.space" href="#spsdk.image.segments.AbstractFCB.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegAPP"><code class="flex name class">
<span>class <span class="ident">SegAPP</span></span>
<span>(</span><span>data: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>APP segment.</p>
<p>Initialize APP segment.</p>
<p>:param data: application binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegAPP(BaseSegment):
    &#34;&#34;&#34;APP segment.&#34;&#34;&#34;

    def __init__(self, data: Optional[bytes] = None) -&gt; None:
        &#34;&#34;&#34;Initialize APP segment.

        :param data: application binary data
        &#34;&#34;&#34;
        super().__init__()
        self._data = data

    @property
    def data(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
        return self._data

    @data.setter
    def data(self, value: Union[bytearray, bytes]) -&gt; None:
        &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
        assert isinstance(value, (bytes, bytearray))
        self._data = bytes(value)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of APP segment.&#34;&#34;&#34;
        return 0 if (self._data is None) else len(self._data)

    def __repr__(self) -&gt; str:
        return &#34;APP &lt;LEN: {} Bytes&gt;&#34;.format(self.size)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegAPP.&#34;&#34;&#34;
        msg = &#34; Size: {0:d} Bytes\n&#34;.format(self.size)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self._data:
            data += bytes(self._data)
        data += self._padding_export()
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegAPP.data"><code class="name">var <span class="ident">data</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Application binary data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Application binary data.&#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegAPP.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of APP segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of APP segment.&#34;&#34;&#34;
    return 0 if (self._data is None) else len(self._data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegAPP.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = b&#39;&#39;
    if self._data:
        data += bytes(self._data)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegAPP.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegAPP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegAPP.&#34;&#34;&#34;
    msg = &#34; Size: {0:d} Bytes\n&#34;.format(self.size)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.parse" href="#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegBDS3a"><code class="flex name class">
<span>class <span class="ident">SegBDS3a</span></span>
</code></dt>
<dd>
<div class="desc"><p>BDS3a segment.</p>
<p>Initialize BDS3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBDS3a(BaseSegment):
    &#34;&#34;&#34;BDS3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;4L&#39;
    HEADER_SIZE = calcsize(FORMAT)
    IMAGES_MAX_COUNT = 6
    SIZE = HEADER_SIZE + SegIDS3a.SIZE * IMAGES_MAX_COUNT

    @property
    def header_size(self) -&gt; int:
        &#34;&#34;&#34;Header&#39;s size of BDS3a segment.&#34;&#34;&#34;
        return self.HEADER_SIZE

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of BDS3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize BDS3a segment.&#34;&#34;&#34;
        super().__init__()
        self.images_count = 0
        self.boot_data_size = 0
        self.boot_data_flag = 0
        self.images = [SegIDS3a() for _ in range(self.IMAGES_MAX_COUNT)]
        self.reserved = 0

    def __repr__(self) -&gt; str:
        return &#34;BDS3a &lt;IMAGES: {}, SIZE: {}B, FLAG: 0x{:X}&gt;&#34;.format(
            self.images_count, self.boot_data_size, self.boot_data_flag
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDS3a.&#34;&#34;&#34;
        msg = &#34; IMAGES: {}\n&#34;.format(self.images_count)
        # TODO: why the code commented-out?   msg += &#34; Data size: {}\n&#34;.format(self.boot_data_size)
        msg += &#34; DFLAGS: 0x{0:08X}\n&#34;.format(self.boot_data_flag)
        msg += &#34;\n&#34;
        for i in range(self.images_count):
            msg += &#34; IMAGE[{}] \n&#34;.format(i)
            msg += self.images[i].info()
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.images_count,
                    self.boot_data_size,
                    self.boot_data_flag,
                    self.reserved)

        for i in range(self.IMAGES_MAX_COUNT):
            data += self.images[i].export()

        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDS3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDS3a segment
        :return: SegBDS3a object
        &#34;&#34;&#34;
        obj = cls()
        (obj.images_count,
         obj.boot_data_size,
         obj.boot_data_flag,
         obj.reserved) = unpack_from(cls.FORMAT, data)

        for i in range(obj.images_count):
            obj.images[i] = SegIDS3a.parse(data[cls.HEADER_SIZE + i * SegIDS3a.SIZE:])

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3a.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDS3a.HEADER_SIZE"><code class="name">var <span class="ident">HEADER_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDS3a.IMAGES_MAX_COUNT"><code class="name">var <span class="ident">IMAGES_MAX_COUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDS3a.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3a.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegBDS3a" href="#spsdk.image.segments.SegBDS3a">SegBDS3a</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of BDS3a segment
:return: SegBDS3a object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegBDS3a&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of BDS3a segment
    :return: SegBDS3a object
    &#34;&#34;&#34;
    obj = cls()
    (obj.images_count,
     obj.boot_data_size,
     obj.boot_data_flag,
     obj.reserved) = unpack_from(cls.FORMAT, data)

    for i in range(obj.images_count):
        obj.images[i] = SegIDS3a.parse(data[cls.HEADER_SIZE + i * SegIDS3a.SIZE:])

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3a.header_size"><code class="name">var <span class="ident">header_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Header's size of BDS3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header_size(self) -&gt; int:
    &#34;&#34;&#34;Header&#39;s size of BDS3a segment.&#34;&#34;&#34;
    return self.HEADER_SIZE</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBDS3a.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of BDS3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of BDS3a segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3a.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT,
                self.images_count,
                self.boot_data_size,
                self.boot_data_flag,
                self.reserved)

    for i in range(self.IMAGES_MAX_COUNT):
        data += self.images[i].export()

    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBDS3a.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegBDS3a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegBDS3a.&#34;&#34;&#34;
    msg = &#34; IMAGES: {}\n&#34;.format(self.images_count)
    # TODO: why the code commented-out?   msg += &#34; Data size: {}\n&#34;.format(self.boot_data_size)
    msg += &#34; DFLAGS: 0x{0:08X}\n&#34;.format(self.boot_data_flag)
    msg += &#34;\n&#34;
    for i in range(self.images_count):
        msg += &#34; IMAGE[{}] \n&#34;.format(i)
        msg += self.images[i].info()
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegBDS3b"><code class="flex name class">
<span>class <span class="ident">SegBDS3b</span></span>
</code></dt>
<dd>
<div class="desc"><p>BDS3b segment.</p>
<p>Initialize BDS3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBDS3b(BaseSegment):
    &#34;&#34;&#34;BDS3b segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;4L&#39;
    HEADER_SIZE = calcsize(FORMAT)
    IMAGES_MAX_COUNT = 4
    SIZE = calcsize(FORMAT) + SegIDS3b.SIZE * (IMAGES_MAX_COUNT + 3)

    @property
    def header_size(self) -&gt; int:
        &#34;&#34;&#34;Size of header of BDS3b segment.&#34;&#34;&#34;
        return self.HEADER_SIZE

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of BDS3b segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize BDS3b segment.&#34;&#34;&#34;
        super().__init__()
        self.images_count = 0
        self.boot_data_size = 0
        self.boot_data_flag = 0
        self.reserved = 0

        self.images = [SegIDS3b() for _ in range(self.IMAGES_MAX_COUNT)]

        self.scd = SegIDS3b()
        self.csf = SegIDS3b()
        self.rs_img = SegIDS3b()

    def __repr__(self) -&gt; str:
        return &#34;BDS3b &lt;IMAGES: {}, SIZE: {}B, FLAG: 0x{:X}&gt;&#34;.format(
            self.images_count, self.boot_data_size, self.boot_data_flag
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDS3b.&#34;&#34;&#34;
        msg = &#34; IMAGES: {}\n&#34;.format(self.images_count)
        # TODO: why the code commented-out? msg += &#34; Data size: {}\n&#34;.format(self.boot_data_size)
        msg += &#34; DFLAGS: 0x{0:08X}\n&#34;.format(self.boot_data_flag)
        msg += &#34;\n&#34;
        for i in range(self.images_count):
            msg += &#34; IMAGE[{}] \n&#34;.format(i)
            msg += self.images[i].info()
        if self.scd.image_source != 0:
            msg += &#34; SCD:\n&#34;
            msg += self.scd.info()
        if self.csf.image_source != 0:
            msg += &#34; CSF:\n&#34;
            msg += self.csf.info()

        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.images_count,
                    self.boot_data_size,
                    self.boot_data_flag,
                    self.reserved)

        for i in range(self.IMAGES_MAX_COUNT):
            data += self.images[i].export()

        data += self.scd.export()
        data += self.csf.export()
        data += self.rs_img.export()

        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDS3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDS3b segment
        :return: SegBDS3b object
        &#34;&#34;&#34;
        obj = cls()
        (obj.images_count,
         obj.boot_data_size,
         obj.boot_data_flag,
         obj.reserved) = unpack_from(obj.FORMAT, data)

        offset = cls.HEADER_SIZE
        for i in range(obj.images_count):
            obj.images[i] = SegIDS3b.parse(data[offset:])
            offset += SegIDS3b.SIZE

        obj.scd = SegIDS3b.parse(data[offset:])
        offset += SegIDS3b.SIZE
        obj.csf = SegIDS3b.parse(data[offset:])
        offset += SegIDS3b.SIZE
        obj.rs_img = SegIDS3b.parse(data[offset:])

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3b.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDS3b.HEADER_SIZE"><code class="name">var <span class="ident">HEADER_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDS3b.IMAGES_MAX_COUNT"><code class="name">var <span class="ident">IMAGES_MAX_COUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDS3b.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3b.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegBDS3b" href="#spsdk.image.segments.SegBDS3b">SegBDS3b</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of BDS3b segment
:return: SegBDS3b object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegBDS3b&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of BDS3b segment
    :return: SegBDS3b object
    &#34;&#34;&#34;
    obj = cls()
    (obj.images_count,
     obj.boot_data_size,
     obj.boot_data_flag,
     obj.reserved) = unpack_from(obj.FORMAT, data)

    offset = cls.HEADER_SIZE
    for i in range(obj.images_count):
        obj.images[i] = SegIDS3b.parse(data[offset:])
        offset += SegIDS3b.SIZE

    obj.scd = SegIDS3b.parse(data[offset:])
    offset += SegIDS3b.SIZE
    obj.csf = SegIDS3b.parse(data[offset:])
    offset += SegIDS3b.SIZE
    obj.rs_img = SegIDS3b.parse(data[offset:])

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3b.header_size"><code class="name">var <span class="ident">header_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of header of BDS3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header_size(self) -&gt; int:
    &#34;&#34;&#34;Size of header of BDS3b segment.&#34;&#34;&#34;
    return self.HEADER_SIZE</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBDS3b.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of BDS3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of BDS3b segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBDS3b.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT,
                self.images_count,
                self.boot_data_size,
                self.boot_data_flag,
                self.reserved)

    for i in range(self.IMAGES_MAX_COUNT):
        data += self.images[i].export()

    data += self.scd.export()
    data += self.csf.export()
    data += self.rs_img.export()

    data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBDS3b.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegBDS3b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegBDS3b.&#34;&#34;&#34;
    msg = &#34; IMAGES: {}\n&#34;.format(self.images_count)
    # TODO: why the code commented-out? msg += &#34; Data size: {}\n&#34;.format(self.boot_data_size)
    msg += &#34; DFLAGS: 0x{0:08X}\n&#34;.format(self.boot_data_flag)
    msg += &#34;\n&#34;
    for i in range(self.images_count):
        msg += &#34; IMAGE[{}] \n&#34;.format(i)
        msg += self.images[i].info()
    if self.scd.image_source != 0:
        msg += &#34; SCD:\n&#34;
        msg += self.scd.info()
    if self.csf.image_source != 0:
        msg += &#34; CSF:\n&#34;
        msg += self.csf.info()

    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegBDT"><code class="flex name class">
<span>class <span class="ident">SegBDT</span></span>
<span>(</span><span>app_start: int = 0, app_length: int = 0, plugin: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Data Table segment.</p>
<p>Initialize BDT segment.</p>
<p>:param app_start: first address of the application
:param app_length: length of the application
:param plugin: 0 .. 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBDT(BaseSegment):
    &#34;&#34;&#34;Boot Data Table segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;3L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def plugin(self) -&gt; int:
        &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
        return self._plugin

    @plugin.setter
    def plugin(self, value: int) -&gt; None:
        assert value in (0, 1, 2), &#34;Plugin value must be 0 .. 2&#34;
        self._plugin = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the exported binary data (without padding).&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, app_start: int = 0, app_length: int = 0, plugin: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize BDT segment.

        :param app_start: first address of the application
        :param app_length: length of the application
        :param plugin: 0 .. 2
        &#34;&#34;&#34;
        super().__init__()
        self.app_start = app_start
        self.app_length = app_length
        self.plugin = plugin

    def __repr__(self) -&gt; str:
        return &#34;BDT &lt;ADDR: 0x{:X}, LEN: {} Bytes, Plugin: {}&gt;&#34;.format(self.app_start, self.app_length, self.plugin)

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBDT.&#34;&#34;&#34;
        msg = f&#34; Start      :  0x{self.app_start:08X}\n&#34;
        msg += f&#34; App Length : {size_fmt(self.app_length)} ({self.app_length} Bytes)\n&#34;
        msg += f&#34; Plugin     : {&#39;YES&#39; if self.plugin else &#39;NO&#39;}\n&#34;
        msg += &#34;\n&#34;

        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT, self.app_start, self.app_length, self.plugin)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBDT&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BDT segment
        :return: SegBDT object
        &#34;&#34;&#34;
        return cls(*unpack_from(cls.FORMAT, data))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBDT.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBDT.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBDT.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegBDT" href="#spsdk.image.segments.SegBDT">SegBDT</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of BDT segment
:return: SegBDT object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegBDT&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of BDT segment
    :return: SegBDT object
    &#34;&#34;&#34;
    return cls(*unpack_from(cls.FORMAT, data))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBDT.plugin"><code class="name">var <span class="ident">plugin</span> : int</code></dt>
<dd>
<div class="desc"><p>Plugin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plugin(self) -&gt; int:
    &#34;&#34;&#34;Plugin.&#34;&#34;&#34;
    return self._plugin</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBDT.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the exported binary data (without padding).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the exported binary data (without padding).&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBDT.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT, self.app_start, self.app_length, self.plugin)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBDT.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegBDT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegBDT.&#34;&#34;&#34;
    msg = f&#34; Start      :  0x{self.app_start:08X}\n&#34;
    msg += f&#34; App Length : {size_fmt(self.app_length)} ({self.app_length} Bytes)\n&#34;
    msg += f&#34; Plugin     : {&#39;YES&#39; if self.plugin else &#39;NO&#39;}\n&#34;
    msg += &#34;\n&#34;

    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegBEE"><code class="flex name class">
<span>class <span class="ident">SegBEE</span></span>
<span>(</span><span>regions: Sequence[<a title="spsdk.image.bee.BeeRegionHeader" href="bee.html#spsdk.image.bee.BeeRegionHeader">BeeRegionHeader</a>], max_facs: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE keys and regions segment.</p>
<p>Constructor.</p>
<p>:param regions: list of regions
:param max_facs: maximum total number of FAC in all regions, used for validation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBEE(BaseSegment):
    &#34;&#34;&#34;BEE keys and regions segment.&#34;&#34;&#34;

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        result = 0
        for region in self._regions:
            result += region.size
        return result

    def __init__(self, regions: Sequence[BeeRegionHeader], max_facs: int = 3):
        &#34;&#34;&#34;Constructor.

        :param regions: list of regions
        :param max_facs: maximum total number of FAC in all regions, used for validation
        &#34;&#34;&#34;
        super().__init__()
        self._regions = list(regions)
        self.max_facs = max_facs

    def add_region(self, region: BeeRegionHeader) -&gt; None:
        &#34;&#34;&#34;Add region.

        :param region: to be added
        &#34;&#34;&#34;
        self._regions.append(region)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = f&#39;BEE Segment, with {len(self._regions)} regions\n&#39;
        for region in self._regions:
            result += region.info()
        return result

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        for region in self._regions:
            region.update()

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        :raises ValueError: if number of FAC regions exceeds the limit
        &#34;&#34;&#34;
        total_facs = 0
        for region in self._regions:
            region.validate()
            total_facs += len(region.fac_regions)
        if total_facs &gt; self.max_facs:
            raise ValueError(f&#39;Totally {total_facs} FAC regions, but only {self.max_facs} supported&#39;)

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Serialization to binary representation.

        :param dbg_info: instance allowing to provide debug info about exported data
        :return:binary representation of the region (serialization).
        &#34;&#34;&#34;
        self.update()
        self.validate()
        result = b&#39;&#39;
        for index, region in enumerate(self._regions):
            dbg_info.append_section(f&#39;BEE Region {index}&#39;)
            result += region.export(dbg_info=dbg_info)
        if self.padding_len:
            result += self._padding_export()
            if self.size == 0:
                dbg_info.append_section(f&#39;BEE-padding {self.padding_len} bytes&#39;)

        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0, decrypt_keys: List[bytes] = list()) -&gt; &#39;SegBEE&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :param decrypt_keys: list of SW_GP keys used to decrypt EKIB
                The number of keys must match number of regions to be parsed
        :return: instance created from binary data
        &#34;&#34;&#34;
        regions: List[BeeRegionHeader] = list()
        for sw_gp_key in decrypt_keys:
            region = BeeRegionHeader.parse(data, offset, sw_gp_key)
            regions.append(region)
            offset += region.size
        return SegBEE(regions)

    def encrypt_data(self, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt image data located in any PRDB block.

        :param start_addr: start address of the data; must be aligned to block size
        :param data: to be encrypted
        :return: encrypted data, aligned to block size; blocks outside any FAC region kept untouched
        &#34;&#34;&#34;
        assert align(start_addr, BEE_ENCR_BLOCK_SIZE) == start_addr
        orig_len = len(data)
        data = align_block(data, BEE_ENCR_BLOCK_SIZE)
        result = bytes()
        offset = 0
        while offset &lt; len(data):
            blck = data[offset:offset + BEE_ENCR_BLOCK_SIZE]
            for region in self._regions:
                blck = region.encrypt_block(start_addr + offset, blck)
            result += blck
            offset += BEE_ENCR_BLOCK_SIZE
        return result[:orig_len]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBEE.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, decrypt_keys: List[bytes] = []) ‑> <a title="spsdk.image.segments.SegBEE" href="#spsdk.image.segments.SegBEE">SegBEE</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:param decrypt_keys: list of SW_GP keys used to decrypt EKIB
The number of keys must match number of regions to be parsed
:return: instance created from binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, decrypt_keys: List[bytes] = list()) -&gt; &#39;SegBEE&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :param decrypt_keys: list of SW_GP keys used to decrypt EKIB
            The number of keys must match number of regions to be parsed
    :return: instance created from binary data
    &#34;&#34;&#34;
    regions: List[BeeRegionHeader] = list()
    for sw_gp_key in decrypt_keys:
        region = BeeRegionHeader.parse(data, offset, sw_gp_key)
        regions.append(region)
        offset += region.size
    return SegBEE(regions)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBEE.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: size of the exported binary data in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
    result = 0
    for region in self._regions:
        result += region.size
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBEE.add_region"><code class="name flex">
<span>def <span class="ident">add_region</span></span>(<span>self, region: <a title="spsdk.image.bee.BeeRegionHeader" href="bee.html#spsdk.image.bee.BeeRegionHeader">BeeRegionHeader</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add region.</p>
<p>:param region: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_region(self, region: BeeRegionHeader) -&gt; None:
    &#34;&#34;&#34;Add region.

    :param region: to be added
    &#34;&#34;&#34;
    self._regions.append(region)</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBEE.encrypt_data"><code class="name flex">
<span>def <span class="ident">encrypt_data</span></span>(<span>self, start_addr: int, data: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt image data located in any PRDB block.</p>
<p>:param start_addr: start address of the data; must be aligned to block size
:param data: to be encrypted
:return: encrypted data, aligned to block size; blocks outside any FAC region kept untouched</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_data(self, start_addr: int, data: bytes) -&gt; bytes:
    &#34;&#34;&#34;Encrypt image data located in any PRDB block.

    :param start_addr: start address of the data; must be aligned to block size
    :param data: to be encrypted
    :return: encrypted data, aligned to block size; blocks outside any FAC region kept untouched
    &#34;&#34;&#34;
    assert align(start_addr, BEE_ENCR_BLOCK_SIZE) == start_addr
    orig_len = len(data)
    data = align_block(data, BEE_ENCR_BLOCK_SIZE)
    result = bytes()
    offset = 0
    while offset &lt; len(data):
        blck = data[offset:offset + BEE_ENCR_BLOCK_SIZE]
        for region in self._regions:
            blck = region.encrypt_block(start_addr + offset, blck)
        result += blck
        offset += BEE_ENCR_BLOCK_SIZE
    return result[:orig_len]</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBEE.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialization to binary representation.</p>
<p>:param dbg_info: instance allowing to provide debug info about exported data
:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Serialization to binary representation.

    :param dbg_info: instance allowing to provide debug info about exported data
    :return:binary representation of the region (serialization).
    &#34;&#34;&#34;
    self.update()
    self.validate()
    result = b&#39;&#39;
    for index, region in enumerate(self._regions):
        dbg_info.append_section(f&#39;BEE Region {index}&#39;)
        result += region.export(dbg_info=dbg_info)
    if self.padding_len:
        result += self._padding_export()
        if self.size == 0:
            dbg_info.append_section(f&#39;BEE-padding {self.padding_len} bytes&#39;)

    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBEE.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    result = f&#39;BEE Segment, with {len(self._regions)} regions\n&#39;
    for region in self._regions:
        result += region.info()
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBEE.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Updates internal fields of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
    for region in self._regions:
        region.update()</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBEE.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid
:raises ValueError: if number of FAC regions exceeds the limit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    :raises ValueError: if number of FAC regions exceeds the limit
    &#34;&#34;&#34;
    total_facs = 0
    for region in self._regions:
        region.validate()
        total_facs += len(region.fac_regions)
    if total_facs &gt; self.max_facs:
        raise ValueError(f&#39;Totally {total_facs} FAC regions, but only {self.max_facs} supported&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegBIC1"><code class="flex name class">
<span>class <span class="ident">SegBIC1</span></span>
<span>(</span><span>version: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Boot Images Container segment.</p>
<p>Initialize Boot Images Container segment.</p>
<p>:param version: The version of Header for Boot Images Container</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBIC1(BaseSegment):
    &#34;&#34;&#34;Boot Images Container segment.&#34;&#34;&#34;

    MAX_NUM_IMGS = 6

    FORMAT = &#39;&lt;LH2B2H&#39;
    SIZE = Header.SIZE + calcsize(FORMAT) + MAX_NUM_IMGS * SegBIM.SIZE + SegSIGB.SIZE + 8

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of Boot Images Container segment.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        &#34;&#34;&#34;Version of Boot Images Container segment.&#34;&#34;&#34;
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize Boot Images Container segment.

        :param version: The version of Header for Boot Images Container
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header2(SegTag.BIC1, version)
        self._header.length = self.SIZE
        self.flags = 0
        self.sw_version = 0
        self.fuse_version = 0
        self.images_count = 0
        self.sig_blk_offset = 0
        self.reserved = 0
        self.images = [SegBIM() for _ in range(self.MAX_NUM_IMGS)]
        self.sig_blk_hdr = SegSIGB()
        self.sig_blk_size = 0
        self.padding = 8

    def __repr__(self) -&gt; str:
        return &#34;BIC1 &lt;FLAGS:0x{:X}, SWV:0x{:X}, FUSEV:0x{:X}, COUNT:{}, SBO:0x{:X}&gt;&#34;.format(
            self.flags, self.sw_version, self.fuse_version, self.images_count, self.sig_blk_offset
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBIC1.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; Flags:        0x{:08X}\n&#34;.format(self.flags)
        msg += &#34; SW Version:   {}\n&#34;.format(self.sw_version)
        msg += &#34; Fuse Version: {}\n&#34;.format(self.fuse_version)
        msg += &#34; Images Count: {}\n&#34;.format(self.images_count)
        msg += &#34; SigBlkOffset: 0x{:08X}\n&#34;.format(self.sig_blk_offset)
        msg += &#34;\n&#34;
        for i in range(self.images_count):
            msg += &#34; IMAGE[{}] \n&#34;.format(i)
            msg += self.images[i].info()
        msg += &#34; [ Signature Block Header ]\n&#34;
        msg += self.sig_blk_hdr.info()
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validate segment.&#34;&#34;&#34;
        return None

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self._header.export()
        data += pack(self.FORMAT,
                     self.flags,
                     self.sw_version,
                     self.fuse_version,
                     self.images_count,
                     self.sig_blk_offset,
                     self.reserved)
        for image in self.images:
            data += image.export()
        data += self.sig_blk_hdr.export()
        data += pack(&#39;&lt;L&#39;, self.sig_blk_size)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBIC1&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BIC1 segment
        :return: SegBIC1 object
        &#34;&#34;&#34;
        header = Header2.parse(data, 0, SegTag.BIC1)
        offset = header.size
        obj = cls(header.param)

        (obj.flags,
         obj.sw_version,
         obj.fuse_version,
         obj.images_count,
         obj.sig_blk_offset,
         obj.reserved) = unpack_from(cls.FORMAT, data, offset)

        offset += calcsize(cls.FORMAT)
        for i in range(obj.images_count):
            obj.images[i] = SegBIM.parse(data[offset:])
            offset += SegBIM.SIZE

        obj.sig_blk_hdr = SegSIGB.parse(data[offset:])
        offset += SegSIGB.SIZE
        obj.sig_blk_size = unpack_from(&#39;&lt;L&#39;, data, offset)[0]

        obj.validate()

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBIC1.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBIC1.MAX_NUM_IMGS"><code class="name">var <span class="ident">MAX_NUM_IMGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBIC1.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBIC1.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegBIC1" href="#spsdk.image.segments.SegBIC1">SegBIC1</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of BIC1 segment
:return: SegBIC1 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegBIC1&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of BIC1 segment
    :return: SegBIC1 object
    &#34;&#34;&#34;
    header = Header2.parse(data, 0, SegTag.BIC1)
    offset = header.size
    obj = cls(header.param)

    (obj.flags,
     obj.sw_version,
     obj.fuse_version,
     obj.images_count,
     obj.sig_blk_offset,
     obj.reserved) = unpack_from(cls.FORMAT, data, offset)

    offset += calcsize(cls.FORMAT)
    for i in range(obj.images_count):
        obj.images[i] = SegBIM.parse(data[offset:])
        offset += SegBIM.SIZE

    obj.sig_blk_hdr = SegSIGB.parse(data[offset:])
    offset += SegSIGB.SIZE
    obj.sig_blk_size = unpack_from(&#39;&lt;L&#39;, data, offset)[0]

    obj.validate()

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBIC1.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBIC1.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Version of Boot Images Container segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of Boot Images Container segment.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBIC1.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self.validate()

    data = self._header.export()
    data += pack(self.FORMAT,
                 self.flags,
                 self.sw_version,
                 self.fuse_version,
                 self.images_count,
                 self.sig_blk_offset,
                 self.reserved)
    for image in self.images:
        data += image.export()
    data += self.sig_blk_hdr.export()
    data += pack(&#39;&lt;L&#39;, self.sig_blk_size)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBIC1.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegBIC1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegBIC1.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; Flags:        0x{:08X}\n&#34;.format(self.flags)
    msg += &#34; SW Version:   {}\n&#34;.format(self.sw_version)
    msg += &#34; Fuse Version: {}\n&#34;.format(self.fuse_version)
    msg += &#34; Images Count: {}\n&#34;.format(self.images_count)
    msg += &#34; SigBlkOffset: 0x{:08X}\n&#34;.format(self.sig_blk_offset)
    msg += &#34;\n&#34;
    for i in range(self.images_count):
        msg += &#34; IMAGE[{}] \n&#34;.format(i)
        msg += self.images[i].info()
    msg += &#34; [ Signature Block Header ]\n&#34;
    msg += self.sig_blk_hdr.info()
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBIC1.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validate segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validate segment.&#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegBIM"><code class="flex name class">
<span>class <span class="ident">SegBIM</span></span>
</code></dt>
<dd>
<div class="desc"><p>BootImage segment.</p>
<p>Initialize BootImage segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegBIM(BaseSegment):
    &#34;&#34;&#34;BootImage segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;2L2Q2L&#39;
    SIZE = calcsize(FORMAT) + 64 + 32

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of BootImage segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize BootImage segment.&#34;&#34;&#34;
        super().__init__()
        self.image_offset = 0
        self.image_size = 0
        self.load_address = 0
        self.entry_address = 0
        self.hab_flags = 0
        self.meta_data = 0
        self.image_hash: Optional[bytes] = None
        self.image_iv: Optional[bytes] = None

    def __repr__(self) -&gt; str:
        return &#34;BIM &lt;OFFSET:{}, SIZE:{}B, LOAD:0x{:X}, ENTRY:0x{:X}, FLAGS:0x{:X}&gt;&#34;.format(
            self.image_offset, self.image_size, self.load_address, self.entry_address, self.hab_flags
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegBIM.&#34;&#34;&#34;
        msg = &#34; Offset:     0x{:X}\n&#34;.format(self.image_offset)
        msg += &#34; Size:       {} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
        msg += &#34; Load:       0x{:X}\n&#34;.format(self.load_address)
        msg += &#34; Entry:      0x{:X}\n&#34;.format(self.entry_address)
        if self.image_hash:
            msg += &#34; HASH:       {}\n&#34;.format(&#39;&#39;.join([&#39;{:02X}&#39;.format(i) for i in self.image_hash]))
        if self.image_iv:
            msg += &#34; IV:         {}\n&#34;.format(&#39;&#39;.join([&#39;{:02X}&#39;.format(i) for i in self.image_iv]))
        msg += &#34; Hash Flags: 0x{:08X}\n&#34;.format(self.hab_flags)
        msg += &#34; Meta Data:  0x{:08X}\n&#34;.format(self.meta_data)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.image_offset,
                    self.image_size,
                    self.load_address,
                    self.entry_address,
                    self.hab_flags,
                    self.meta_data)

        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegBIM&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of BootImage segment
        :return: SegBootImage object
        &#34;&#34;&#34;
        obj = cls()
        (obj.image_offset,
         obj.image_size,
         obj.load_address,
         obj.entry_address,
         obj.hab_flags,
         obj.meta_data) = unpack_from(obj.FORMAT, data)

        offset = calcsize(cls.FORMAT)
        obj.image_hash = data[offset:offset + 64]
        offset += 64
        obj.image_iv = data[offset:offset + 32]

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBIM.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegBIM.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBIM.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegBIM" href="#spsdk.image.segments.SegBIM">SegBIM</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of BootImage segment
:return: SegBootImage object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegBIM&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of BootImage segment
    :return: SegBootImage object
    &#34;&#34;&#34;
    obj = cls()
    (obj.image_offset,
     obj.image_size,
     obj.load_address,
     obj.entry_address,
     obj.hab_flags,
     obj.meta_data) = unpack_from(obj.FORMAT, data)

    offset = calcsize(cls.FORMAT)
    obj.image_hash = data[offset:offset + 64]
    offset += 64
    obj.image_iv = data[offset:offset + 32]

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegBIM.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of BootImage segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of BootImage segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegBIM.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT,
                self.image_offset,
                self.image_size,
                self.load_address,
                self.entry_address,
                self.hab_flags,
                self.meta_data)

    data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegBIM.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegBIM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegBIM.&#34;&#34;&#34;
    msg = &#34; Offset:     0x{:X}\n&#34;.format(self.image_offset)
    msg += &#34; Size:       {} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
    msg += &#34; Load:       0x{:X}\n&#34;.format(self.load_address)
    msg += &#34; Entry:      0x{:X}\n&#34;.format(self.entry_address)
    if self.image_hash:
        msg += &#34; HASH:       {}\n&#34;.format(&#39;&#39;.join([&#39;{:02X}&#39;.format(i) for i in self.image_hash]))
    if self.image_iv:
        msg += &#34; IV:         {}\n&#34;.format(&#39;&#39;.join([&#39;{:02X}&#39;.format(i) for i in self.image_iv]))
    msg += &#34; Hash Flags: 0x{:08X}\n&#34;.format(self.hab_flags)
    msg += &#34; Meta Data:  0x{:08X}\n&#34;.format(self.meta_data)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegCSF"><code class="flex name class">
<span>class <span class="ident">SegCSF</span></span>
<span>(</span><span>version: int = 64, enabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Sequence File (CSF), signature block for Secure Boot.</p>
<p>A script of commands used to guide image authentication and device configuration operations.</p>
<p>Initialize CSF segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegCSF(BaseSegment):
    &#34;&#34;&#34;Command Sequence File (CSF), signature block for Secure Boot.

    A script of commands used to guide image authentication and device configuration operations.
    &#34;&#34;&#34;

    # list of supported CSF commands
    _COMMANDS: Tuple[CmdTag, ...] = (
        CmdTag.WRT_DAT, CmdTag.CHK_DAT, CmdTag.NOP, CmdTag.SET, CmdTag.INIT, CmdTag.UNLK, CmdTag.INS_KEY, CmdTag.AUT_DAT
    )

    @classmethod
    def _is_csf_command(cls, cmd: object) -&gt; bool:
        &#34;&#34;&#34;Test whether given class is instance of supported CSF command.

        :param cmd: instance to be tested
        :return: True if yes, False otherwise
        &#34;&#34;&#34;
        return isinstance(cmd, CmdBase) and (cmd.tag in cls._COMMANDS)

    def __init__(self, version: int = 0x40, enabled: bool = False):
        &#34;&#34;&#34;Initialize CSF segment.&#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.CSF, version)
        self.enabled = enabled
        self._commands: List[CmdBase] = []
        # additional command data: keys and certificates; these data are stored after the commands
        #   - key is an offset of the data section in segment
        #   - value is an instance of the data section
        self._cmd_data: Dict[int, BaseClass] = dict()
        # this allows to export segment, that was parsered, but certificate and private keys are not available
        self.no_signature_updates = False

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of CSF segment.&#34;&#34;&#34;
        return self._header.param

    @property
    def commands(self) -&gt; List[CmdBase]:
        &#34;&#34;&#34;List of CSF commands in the segment.&#34;&#34;&#34;
        return self._commands

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary representation of the segment; 0 is not enabled.&#34;&#34;&#34;
        if not self.enabled:
            return 0

        result = self._header.length
        for offset, cmd_data in self._cmd_data.items():
            result = max(result, offset + cmd_data.size)
        return result

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary representation of the segment including padding; 0 is not enabled.&#34;&#34;&#34;
        return self.size + self.padding_len if self.enabled else 0

    @property
    def macs(self) -&gt; Iterator[MAC]:
        &#34;&#34;&#34;Iterator of all MAC sections.&#34;&#34;&#34;
        # noinspection PyTypeChecker
        return filter(lambda m: isinstance(m, MAC), self._cmd_data.values())  # type: ignore

    def __repr__(self) -&gt; str:
        return &#34;CSF &lt;Commands: {}&gt;&#34;.format(len(self.commands))

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBase:
        return self.commands[key]

    def __setitem__(self, key: int, value: CmdBase) -&gt; None:
        assert SegCSF._is_csf_command(value)
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator[CmdBase]:
        return self.commands.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegCSF.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += f&#34;CSF Version        : {hex(self.version)}\n&#34;
        msg += f&#34;Number of commands : {len(self.commands)}\n&#34;
        for cmd in self.commands:
            msg += cmd.info()
            msg += &#34;\n&#34;

        # certificates and signatures
        msg += &#34;[CMD-DATA]\n&#34;
        for offset, cmd_data in self._cmd_data.items():
            msg += f&#34;- OFFSET : {offset}\n&#34;
            msg += cmd_data.info()

        return msg

    def append_command(self, cmd: CmdBase) -&gt; None:
        &#34;&#34;&#34;Append CSF command to the segment.

        :param cmd: to be added
        &#34;&#34;&#34;
        assert SegCSF._is_csf_command(cmd)
        self._commands.append(cmd)
        self._header.length += cmd.size
        self.update(False)

    def clear_commands(self) -&gt; None:
        &#34;&#34;&#34;Removes= all commands.&#34;&#34;&#34;
        self._commands.clear()
        self._header.length = self._header.size
        self.update(True)

    def update(self, reset_cmddata_offsets: bool) -&gt; None:
        &#34;&#34;&#34;Update the offsets for the export.

        :param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
                                    False to avoid any reset;
                                    Note: reset should be done during parsing process as the data are incomplete

        &#34;&#34;&#34;
        cur_ofs = self._header.length
        new_cmd_data: Dict[int, BaseClass] = dict()
        for cmd in filter(lambda c: c.needs_cmd_data_reference, self.commands):
            key = cmd.cmd_data_reference
            if key is not None:
                cmd.cmd_data_offset = cur_ofs
                new_cmd_data[cur_ofs] = key
                cur_ofs += align(key.size, 4)
            elif reset_cmddata_offsets and (cmd.cmd_data_offset &gt; 0):
                cmd.cmd_data_offset = 0

        self._cmd_data = new_cmd_data

    def _export_base(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export base part of the CSF section (header and commands) without keys and signatures.

        :param dbg_info: optional instance allowing to produce deung information about exported data
        :return: exported binary data
        &#34;&#34;&#34;
        self.update(True)
        data = self._header.export()
        dbg_info.append_binary_section(&#39;header&#39;, data)
        for command in self.commands:
            dbg_info.append_section(f&#39;COMMAND: {CmdTag.desc(command.tag)}&#39;)
            cmd_data = command.export(dbg_info)
            data += cmd_data
        return data

    def update_signatures(self, zulu: datetime, data: bytes, base_data_addr: int) -&gt; None:
        &#34;&#34;&#34;Update signatures in all CmdAuthData commands.

        :param zulu: current UTC time+date
        :param data: currently generated binary data; empty to create &#34;fake&#34; signature to update size of the segment
        :param base_data_addr: base address of the generated data
        &#34;&#34;&#34;
        if self.no_signature_updates:
            return

        for cmd in self.commands:
            if isinstance(cmd, CmdAuthData):
                if len(cmd) &gt; 0:  # any blocks defined? =&gt; sign image data
                    if not cmd.update_signature(zulu, data, base_data_addr):
                        assert len(data) == 0
                else:  # sign CSF section
                    if not cmd.update_signature(zulu, self._export_base()):
                        assert len(data) == 0

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array (serialization).

        :param dbg_info: optional list of strings to produce debug information about exported data
        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self.enabled:
            data = self._export_base(dbg_info)
            dbg_info.append_section(&#39;CSF-DATA: CERTIFICATES and SIGNATURES&#39;)
            cmd_data_by_offset = sorted(self._cmd_data.items(), key=lambda t: str(t[0]).zfill(8))
            for offset, cmd_data in cmd_data_by_offset:
                data = extend_block(data, offset)
                dbg_info.append_section(f&#39;CMD-DATA: {type(cmd_data).__name__}&#39;)
                data += cmd_data.export(dbg_info=dbg_info)
            # padding
            data += self._padding_export()

        return data

    def _parse_cmd_data(self, cmd: CmdBase, data: bytes) -&gt; None:
        &#34;&#34;&#34;Parse data for key installation or key authentication commands (certificate or signature).

        :param cmd: command with reference to a cmd-data
        :param data: binary data array to be parsed
        :return: parsed instance, either Certificate or Signature
        &#34;&#34;&#34;
        assert cmd.needs_cmd_data_reference
        assert self._cmd_data.get(cmd.cmd_data_offset) is None
        result = cmd.parse_cmd_data(data, cmd.cmd_data_offset)
        self._cmd_data[cmd.cmd_data_offset] = result

        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SegCSF&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of CSF segment
        :param offset: to start parsing the data
        :raises CorruptedException: When there is unknown command
        :raises CorruptedException: When command can not be parsed
        :return: SegCSF instance
        &#34;&#34;&#34;
        header = Header.parse(data, offset, SegTag.CSF)
        index = header.size
        obj = cls(header.param, True)
        obj.no_signature_updates = True
        while index &lt; header.length:
            try:
                cmd_obj = parse_command(data, offset + index)
                obj.append_command(cmd_obj)
            except ValueError:
                raise CorruptedException(&#34;Failed to parse command at position: &#34; + hex(offset + index))
            index += cmd_obj.size

        for cmd in obj.commands:
            if cmd.needs_cmd_data_reference:
                obj._parse_cmd_data(cmd, data)

        obj.update(True)
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegCSF.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.segments.SegCSF" href="#spsdk.image.segments.SegCSF">SegCSF</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of CSF segment
:param offset: to start parsing the data
:raises CorruptedException: When there is unknown command
:raises CorruptedException: When command can not be parsed
:return: SegCSF instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;SegCSF&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of CSF segment
    :param offset: to start parsing the data
    :raises CorruptedException: When there is unknown command
    :raises CorruptedException: When command can not be parsed
    :return: SegCSF instance
    &#34;&#34;&#34;
    header = Header.parse(data, offset, SegTag.CSF)
    index = header.size
    obj = cls(header.param, True)
    obj.no_signature_updates = True
    while index &lt; header.length:
        try:
            cmd_obj = parse_command(data, offset + index)
            obj.append_command(cmd_obj)
        except ValueError:
            raise CorruptedException(&#34;Failed to parse command at position: &#34; + hex(offset + index))
        index += cmd_obj.size

    for cmd in obj.commands:
        if cmd.needs_cmd_data_reference:
            obj._parse_cmd_data(cmd, data)

    obj.update(True)
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegCSF.commands"><code class="name">var <span class="ident">commands</span> : List[<a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>]</code></dt>
<dd>
<div class="desc"><p>List of CSF commands in the segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; List[CmdBase]:
    &#34;&#34;&#34;List of CSF commands in the segment.&#34;&#34;&#34;
    return self._commands</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.macs"><code class="name">var <span class="ident">macs</span> : Iterator[<a title="spsdk.image.secret.MAC" href="secret.html#spsdk.image.secret.MAC">MAC</a>]</code></dt>
<dd>
<div class="desc"><p>Iterator of all MAC sections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def macs(self) -&gt; Iterator[MAC]:
    &#34;&#34;&#34;Iterator of all MAC sections.&#34;&#34;&#34;
    # noinspection PyTypeChecker
    return filter(lambda m: isinstance(m, MAC), self._cmd_data.values())  # type: ignore</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the binary representation of the segment; 0 is not enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the binary representation of the segment; 0 is not enabled.&#34;&#34;&#34;
    if not self.enabled:
        return 0

    result = self._header.length
    for offset, cmd_data in self._cmd_data.items():
        result = max(result, offset + cmd_data.size)
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.space"><code class="name">var <span class="ident">space</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the binary representation of the segment including padding; 0 is not enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def space(self) -&gt; int:
    &#34;&#34;&#34;Size of the binary representation of the segment including padding; 0 is not enabled.&#34;&#34;&#34;
    return self.size + self.padding_len if self.enabled else 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Version of CSF segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of CSF segment.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegCSF.append_command"><code class="name flex">
<span>def <span class="ident">append_command</span></span>(<span>self, cmd: <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append CSF command to the segment.</p>
<p>:param cmd: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_command(self, cmd: CmdBase) -&gt; None:
    &#34;&#34;&#34;Append CSF command to the segment.

    :param cmd: to be added
    &#34;&#34;&#34;
    assert SegCSF._is_csf_command(cmd)
    self._commands.append(cmd)
    self._header.length += cmd.size
    self.update(False)</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.clear_commands"><code class="name flex">
<span>def <span class="ident">clear_commands</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Removes= all commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_commands(self) -&gt; None:
    &#34;&#34;&#34;Removes= all commands.&#34;&#34;&#34;
    self._commands.clear()
    self._header.length = self._header.size
    self.update(True)</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array (serialization).</p>
<p>:param dbg_info: optional list of strings to produce debug information about exported data
:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array (serialization).

    :param dbg_info: optional list of strings to produce debug information about exported data
    :return: bytes
    &#34;&#34;&#34;
    data = b&#39;&#39;
    if self.enabled:
        data = self._export_base(dbg_info)
        dbg_info.append_section(&#39;CSF-DATA: CERTIFICATES and SIGNATURES&#39;)
        cmd_data_by_offset = sorted(self._cmd_data.items(), key=lambda t: str(t[0]).zfill(8))
        for offset, cmd_data in cmd_data_by_offset:
            data = extend_block(data, offset)
            dbg_info.append_section(f&#39;CMD-DATA: {type(cmd_data).__name__}&#39;)
            data += cmd_data.export(dbg_info=dbg_info)
        # padding
        data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegCSF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegCSF.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += f&#34;CSF Version        : {hex(self.version)}\n&#34;
    msg += f&#34;Number of commands : {len(self.commands)}\n&#34;
    for cmd in self.commands:
        msg += cmd.info()
        msg += &#34;\n&#34;

    # certificates and signatures
    msg += &#34;[CMD-DATA]\n&#34;
    for offset, cmd_data in self._cmd_data.items():
        msg += f&#34;- OFFSET : {offset}\n&#34;
        msg += cmd_data.info()

    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, reset_cmddata_offsets: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update the offsets for the export.</p>
<p>:param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
False to avoid any reset;
Note: reset should be done during parsing process as the data are incomplete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, reset_cmddata_offsets: bool) -&gt; None:
    &#34;&#34;&#34;Update the offsets for the export.

    :param reset_cmddata_offsets: True to reset all cmd-data offsets, if cmd-data not specified in the command;
                                False to avoid any reset;
                                Note: reset should be done during parsing process as the data are incomplete

    &#34;&#34;&#34;
    cur_ofs = self._header.length
    new_cmd_data: Dict[int, BaseClass] = dict()
    for cmd in filter(lambda c: c.needs_cmd_data_reference, self.commands):
        key = cmd.cmd_data_reference
        if key is not None:
            cmd.cmd_data_offset = cur_ofs
            new_cmd_data[cur_ofs] = key
            cur_ofs += align(key.size, 4)
        elif reset_cmddata_offsets and (cmd.cmd_data_offset &gt; 0):
            cmd.cmd_data_offset = 0

    self._cmd_data = new_cmd_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegCSF.update_signatures"><code class="name flex">
<span>def <span class="ident">update_signatures</span></span>(<span>self, zulu: datetime.datetime, data: bytes, base_data_addr: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update signatures in all CmdAuthData commands.</p>
<p>:param zulu: current UTC time+date
:param data: currently generated binary data; empty to create "fake" signature to update size of the segment
:param base_data_addr: base address of the generated data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_signatures(self, zulu: datetime, data: bytes, base_data_addr: int) -&gt; None:
    &#34;&#34;&#34;Update signatures in all CmdAuthData commands.

    :param zulu: current UTC time+date
    :param data: currently generated binary data; empty to create &#34;fake&#34; signature to update size of the segment
    :param base_data_addr: base address of the generated data
    &#34;&#34;&#34;
    if self.no_signature_updates:
        return

    for cmd in self.commands:
        if isinstance(cmd, CmdAuthData):
            if len(cmd) &gt; 0:  # any blocks defined? =&gt; sign image data
                if not cmd.update_signature(zulu, data, base_data_addr):
                    assert len(data) == 0
            else:  # sign CSF section
                if not cmd.update_signature(zulu, self._export_base()):
                    assert len(data) == 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegDCD"><code class="flex name class">
<span>class <span class="ident">SegDCD</span></span>
<span>(</span><span>param: int = 65, enabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Device configuration data (DCD) segment.</p>
<p>IC configuration data, usually is used to configure DDR/SDRAM memory. Typically this is optional</p>
<p>Initialize DCD segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegDCD(BaseSegment):
    &#34;&#34;&#34;Device configuration data (DCD) segment.

    IC configuration data, usually is used to configure DDR/SDRAM memory. Typically this is optional
    &#34;&#34;&#34;

    # list of supported DCD commands
    _COMMANDS: Tuple[CmdTag, ...] = (CmdTag.WRT_DAT, CmdTag.CHK_DAT, CmdTag.NOP, CmdTag.UNLK)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._header

    @property
    def commands(self) -&gt; List[CmdBase]:
        &#34;&#34;&#34;Commands of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._commands

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Device configuration data (DCD) segment.&#34;&#34;&#34;
        return self._header.length if self.enabled else 0

    @property
    def space(self) -&gt; int:
        &#34;&#34;&#34;Add space.&#34;&#34;&#34;
        return self.size + self.padding if self.enabled else 0

    def __init__(self, param: int = 0x41, enabled: bool = False) -&gt; None:
        &#34;&#34;&#34;Initialize DCD segment.&#34;&#34;&#34;
        super().__init__()
        self.enabled = enabled
        self._header = Header(SegTag.DCD, param)
        self._header.length = self._header.size
        self._commands: List[CmdBase] = []

    def __repr__(self) -&gt; str:
        return &#34;DCD &lt;Commands: {}&gt;&#34;.format(len(self._commands))

    def __len__(self) -&gt; int:
        return len(self._commands)

    def __getitem__(self, key: int) -&gt; CmdBase:
        return self._commands[key]

    def __setitem__(self, key: int, value: CmdBase) -&gt; None:
        assert value.tag in self._COMMANDS
        self._commands[key] = value

    def __iter__(self) -&gt; Iterator:
        return self._commands.__iter__()

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegDCD.&#34;&#34;&#34;
        msg = &#34;&#34;
        for cmd in self._commands:
            msg += cmd.info()
            msg += &#34;\n&#34;
        return msg

    def append(self, cmd: CmdBase) -&gt; None:
        &#34;&#34;&#34;Appending of Device configuration data (DCD) segment.&#34;&#34;&#34;
        assert isinstance(cmd, CmdBase) and (cmd.tag in self._COMMANDS)
        self._commands.append(cmd)
        self._header.length += cmd.size

    def pop(self, index: int) -&gt; CmdBase:
        &#34;&#34;&#34;Popping of Device configuration data (DCD) segment.&#34;&#34;&#34;
        assert 0 &lt;= index &lt; len(self._commands)
        cmd = self._commands.pop(index)
        self._header.length -= cmd.size
        return cmd

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear of Device configuration data (DCD) segment.&#34;&#34;&#34;
        self._commands.clear()
        self._header.length = self._header.size

    def export_txt(self, txt_data: str = None) -&gt; str:
        &#34;&#34;&#34;Export txt of Device configuration data (DCD) segment.&#34;&#34;&#34;
        write_ops = (&#39;WriteValue&#39;, &#39;WriteClearBits&#39;, &#39;ClearBitMask&#39;, &#39;SetBitMask&#39;)
        check_ops = (&#39;CheckAllClear&#39;, &#39;CheckAllSet&#39;, &#39;CheckAnyClear&#39;, &#39;CheckAnySet&#39;)
        if txt_data is None:
            txt_data = &#34;&#34;

        for cmd in self._commands:
            if isinstance(cmd, CmdWriteData):
                for (address, value) in cmd:
                    txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}\n&#34;.format(write_ops[cmd.ops], cmd.num_bytes, address,
                                                                           value)
            elif isinstance(cmd, CmdCheckData):
                txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}&#34;.format(check_ops[cmd.ops], cmd.num_bytes, cmd.address,
                                                                     cmd.mask)
                txt_data += &#34; {0:d}\n&#34;.format(cmd.count) if cmd.count else &#34;\n&#34;

            elif isinstance(cmd, CmdUnlock):
                txt_data += &#34;Unlock {0:s}&#34;.format(EnumEngine[cmd.engine]) # type: ignore
                cnt = 1
                for value in cmd:
                    if cnt &gt; 6:
                        txt_data += &#34; \\\n&#34;
                        cnt = 0
                    txt_data += &#34; 0x{0:08X}&#34;.format(value)
                    cnt += 1

                txt_data += &#39;\n&#39;

            else:
                txt_data += &#34;Nop\n&#34;

            # Split with new line every group of commands
            txt_data += &#39;\n&#39;

        return txt_data

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = b&#39;&#39;
        if self.enabled:
            data = self._header.export()
            for command in self._commands:
                data += command.export()
            # padding
            data += self._padding_export()

        return data

    @classmethod
    def parse_txt(cls, text: str) -&gt; &#39;SegDCD&#39;:
        &#34;&#34;&#34;Parse segment from text file.

        :param text: The string with DCD commands
        :return: SegDCD object
        &#34;&#34;&#34;
        return SegDcdBuilder().build(text)

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegDCD&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of DCD segment
        :raises CorruptedException: Exception caused by corrupted data
        :return: SegDCD object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.DCD)
        index = header.size
        obj = cls(header.param, True)
        while index &lt; header.length:
            try:
                cmd_obj = parse_command(data, index)
            except ValueError:
                raise CorruptedException(&#34;Unknown command at position: &#34; + hex(index))

            obj.append(cmd_obj)
            index += cmd_obj.size
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegDCD.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegDCD" href="#spsdk.image.segments.SegDCD">SegDCD</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of DCD segment
:raises CorruptedException: Exception caused by corrupted data
:return: SegDCD object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegDCD&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of DCD segment
    :raises CorruptedException: Exception caused by corrupted data
    :return: SegDCD object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.DCD)
    index = header.size
    obj = cls(header.param, True)
    while index &lt; header.length:
        try:
            cmd_obj = parse_command(data, index)
        except ValueError:
            raise CorruptedException(&#34;Unknown command at position: &#34; + hex(index))

        obj.append(cmd_obj)
        index += cmd_obj.size
    return obj</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.parse_txt"><code class="name flex">
<span>def <span class="ident">parse_txt</span></span>(<span>text: str) ‑> <a title="spsdk.image.segments.SegDCD" href="#spsdk.image.segments.SegDCD">SegDCD</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from text file.</p>
<p>:param text: The string with DCD commands
:return: SegDCD object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_txt(cls, text: str) -&gt; &#39;SegDCD&#39;:
    &#34;&#34;&#34;Parse segment from text file.

    :param text: The string with DCD commands
    :return: SegDCD object
    &#34;&#34;&#34;
    return SegDcdBuilder().build(text)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegDCD.commands"><code class="name">var <span class="ident">commands</span> : List[<a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>]</code></dt>
<dd>
<div class="desc"><p>Commands of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; List[CmdBase]:
    &#34;&#34;&#34;Commands of Device configuration data (DCD) segment.&#34;&#34;&#34;
    return self._commands</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.image.header.Header" href="header.html#spsdk.image.header.Header">Header</a></code></dt>
<dd>
<div class="desc"><p>Header of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Header:
    &#34;&#34;&#34;Header of Device configuration data (DCD) segment.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of Device configuration data (DCD) segment.&#34;&#34;&#34;
    return self._header.length if self.enabled else 0</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.space"><code class="name">var <span class="ident">space</span> : int</code></dt>
<dd>
<div class="desc"><p>Add space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def space(self) -&gt; int:
    &#34;&#34;&#34;Add space.&#34;&#34;&#34;
    return self.size + self.padding if self.enabled else 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegDCD.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cmd: <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Appending of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, cmd: CmdBase) -&gt; None:
    &#34;&#34;&#34;Appending of Device configuration data (DCD) segment.&#34;&#34;&#34;
    assert isinstance(cmd, CmdBase) and (cmd.tag in self._COMMANDS)
    self._commands.append(cmd)
    self._header.length += cmd.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear of Device configuration data (DCD) segment.&#34;&#34;&#34;
    self._commands.clear()
    self._header.length = self._header.size</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = b&#39;&#39;
    if self.enabled:
        data = self._header.export()
        for command in self._commands:
            data += command.export()
        # padding
        data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.export_txt"><code class="name flex">
<span>def <span class="ident">export_txt</span></span>(<span>self, txt_data: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Export txt of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_txt(self, txt_data: str = None) -&gt; str:
    &#34;&#34;&#34;Export txt of Device configuration data (DCD) segment.&#34;&#34;&#34;
    write_ops = (&#39;WriteValue&#39;, &#39;WriteClearBits&#39;, &#39;ClearBitMask&#39;, &#39;SetBitMask&#39;)
    check_ops = (&#39;CheckAllClear&#39;, &#39;CheckAllSet&#39;, &#39;CheckAnyClear&#39;, &#39;CheckAnySet&#39;)
    if txt_data is None:
        txt_data = &#34;&#34;

    for cmd in self._commands:
        if isinstance(cmd, CmdWriteData):
            for (address, value) in cmd:
                txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}\n&#34;.format(write_ops[cmd.ops], cmd.num_bytes, address,
                                                                       value)
        elif isinstance(cmd, CmdCheckData):
            txt_data += &#34;{0:s} {1:d} 0x{2:08X} 0x{3:08X}&#34;.format(check_ops[cmd.ops], cmd.num_bytes, cmd.address,
                                                                 cmd.mask)
            txt_data += &#34; {0:d}\n&#34;.format(cmd.count) if cmd.count else &#34;\n&#34;

        elif isinstance(cmd, CmdUnlock):
            txt_data += &#34;Unlock {0:s}&#34;.format(EnumEngine[cmd.engine]) # type: ignore
            cnt = 1
            for value in cmd:
                if cnt &gt; 6:
                    txt_data += &#34; \\\n&#34;
                    cnt = 0
                txt_data += &#34; 0x{0:08X}&#34;.format(value)
                cnt += 1

            txt_data += &#39;\n&#39;

        else:
            txt_data += &#34;Nop\n&#34;

        # Split with new line every group of commands
        txt_data += &#39;\n&#39;

    return txt_data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegDCD.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegDCD.&#34;&#34;&#34;
    msg = &#34;&#34;
    for cmd in self._commands:
        msg += cmd.info()
        msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegDCD.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index: int) ‑> <a title="spsdk.image.commands.CmdBase" href="commands.html#spsdk.image.commands.CmdBase">CmdBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Popping of Device configuration data (DCD) segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index: int) -&gt; CmdBase:
    &#34;&#34;&#34;Popping of Device configuration data (DCD) segment.&#34;&#34;&#34;
    assert 0 &lt;= index &lt; len(self._commands)
    cmd = self._commands.pop(index)
    self._header.length -= cmd.size
    return cmd</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegDcdBuilder"><code class="flex name class">
<span>class <span class="ident">SegDcdBuilder</span></span>
</code></dt>
<dd>
<div class="desc"><p>Builder to create SegDCD from text input.</p>
<p>Initialize SegDcdBuilder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegDcdBuilder:
    &#34;&#34;&#34;Builder to create SegDCD from text input.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize SegDcdBuilder.&#34;&#34;&#34;
        self.line_cnt = 0  # current line number to be displayed in the error message
        self.cmd_write: Optional[CmdWriteData] = None  # this is cache to merge several write commands of same type

    def _parse_cmd(self, dcd_obj: SegDCD, cmd: List[str]) -&gt; None:
        &#34;&#34;&#34;Parse one command.

        :param dcd_obj: result of the builder
        :param cmd: command with arguments
        :raises SyntaxError: command is corrupted
        &#34;&#34;&#34;
        # ----------------------------
        # Parse command
        # ----------------------------
        cmd_tuple = _SEG_DCD_COMMANDS[cmd[0]]
        if cmd_tuple is None:
            if cmd[0] == &#39;Nop&#39;:
                if self.cmd_write is not None:
                    dcd_obj.append(self.cmd_write)
                    self.cmd_write = None

                dcd_obj.append(CmdNop())

            elif cmd[0] == &#39;Unlock&#39;:
                if self.cmd_write is not None:
                    dcd_obj.append(self.cmd_write)
                    self.cmd_write = None

                if cmd[1] not in EnumEngine:
                    raise SyntaxError(&#34;Unlock CMD: wrong engine parameter at line %d&#34; % (self.line_cnt - 1))

                engine = EnumEngine.from_int(EnumEngine[cmd[1]])
                args = [int(value, 0) for value in cmd[2:]]
                dcd_obj.append(CmdUnlock(engine, *args))
            else:
                assert False, &#34;unknown command&#34;

        elif cmd_tuple[0] == &#39;write&#39;:
            if len(cmd) &lt; 4:
                raise SyntaxError(&#34;Write CMD: not enough arguments at line %d&#34; % (self.line_cnt - 1))

            ops = cmd_tuple[1]
            numbytes = int(cmd[1])
            addr = int(cmd[2], 0)
            value = int(cmd[3], 0)

            if self.cmd_write is not None:
                if (self.cmd_write.ops != ops) or (self.cmd_write.num_bytes != numbytes):
                    dcd_obj.append(self.cmd_write)
                    self.cmd_write = None

            if self.cmd_write is None:
                self.cmd_write = CmdWriteData(numbytes, ops)

            self.cmd_write.append(addr, value)

        else:
            if len(cmd) &lt; 4:
                raise SyntaxError(&#34;Check CMD: not enough arguments at line %d&#34; % (self.line_cnt - 1))

            if self.cmd_write is not None:
                dcd_obj.append(self.cmd_write)
                self.cmd_write = None

            ops = cmd_tuple[1]
            numbytes = int(cmd[1])
            addr = int(cmd[2], 0)
            mask = int(cmd[3], 0)
            count = int(cmd[4], 0) if len(cmd) &gt; 4 else None
            dcd_obj.append(CmdCheckData(numbytes, ops, addr, mask, count))

    def build(self, text: str) -&gt; SegDCD:
        &#34;&#34;&#34;Parse segment from text file and build SegDCD.

        :param text: input text to import
        :return: SegDCD object
        :raise SyntaxError: if input format is not valid
        &#34;&#34;&#34;
        dcd_obj = SegDCD(enabled=True)
        cmd_mline = False
        cmd: List[str] = []
        for line in text.split(&#39;\n&#39;):
            line = line.rstrip(&#39;\0&#39;)
            line = line.lstrip()
            # increment line counter
            self.line_cnt += 1
            # ignore comments
            if not line or line.startswith(&#39;#&#39;):
                continue
            # check if multi-line command
            if cmd_mline:
                cmd += line.split()
                cmd_mline = False
            else:
                cmd = line.split()
                if cmd[0] not in _SEG_DCD_COMMANDS:
                    logger.error(f&#39;Unknown DCD command ignored: {cmd}&#39;)
                    continue
            #
            if cmd[-1] == &#39;\\&#39;:
                cmd = cmd[:-1]
                cmd_mline = True
                continue

            self._parse_cmd(dcd_obj, cmd)

        if self.cmd_write is not None:
            dcd_obj.append(self.cmd_write)

        return dcd_obj</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegDcdBuilder.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, text: str) ‑> <a title="spsdk.image.segments.SegDCD" href="#spsdk.image.segments.SegDCD">SegDCD</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from text file and build SegDCD.</p>
<p>:param text: input text to import
:return: SegDCD object
:raise SyntaxError: if input format is not valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, text: str) -&gt; SegDCD:
    &#34;&#34;&#34;Parse segment from text file and build SegDCD.

    :param text: input text to import
    :return: SegDCD object
    :raise SyntaxError: if input format is not valid
    &#34;&#34;&#34;
    dcd_obj = SegDCD(enabled=True)
    cmd_mline = False
    cmd: List[str] = []
    for line in text.split(&#39;\n&#39;):
        line = line.rstrip(&#39;\0&#39;)
        line = line.lstrip()
        # increment line counter
        self.line_cnt += 1
        # ignore comments
        if not line or line.startswith(&#39;#&#39;):
            continue
        # check if multi-line command
        if cmd_mline:
            cmd += line.split()
            cmd_mline = False
        else:
            cmd = line.split()
            if cmd[0] not in _SEG_DCD_COMMANDS:
                logger.error(f&#39;Unknown DCD command ignored: {cmd}&#39;)
                continue
        #
        if cmd[-1] == &#39;\\&#39;:
            cmd = cmd[:-1]
            cmd_mline = True
            continue

        self._parse_cmd(dcd_obj, cmd)

    if self.cmd_write is not None:
        dcd_obj.append(self.cmd_write)

    return dcd_obj</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.segments.SegFCB"><code class="flex name class">
<span>class <span class="ident">SegFCB</span></span>
</code></dt>
<dd>
<div class="desc"><p>FCB.</p>
<p>Initialize FCB segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegFCB(AbstractFCB, ABC):
    &#34;&#34;&#34;FCB.&#34;&#34;&#34;
    SIZE = 1024
    FINGERPRINT = b&#39;NFCB&#39;

    @property
    def crc(self) -&gt; int:
        &#34;&#34;&#34;Cyclic redundancy check.&#34;&#34;&#34;
        return 0

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize FCB segment.&#34;&#34;&#34;
        super().__init__()
        self.version = 1
        self.search_start_page = 0
        self.search_stride = 0
        self.search_count = 0
        self.firmware_copies = 0
        self.firmware_info_table = None
        self.config_block = None

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Export to binary form.&#34;&#34;&#34;
        data = pack(&#39;&lt;Is2I2HI&#39;, self.crc, self.FINGERPRINT, self.version, self.search_start_page, self.search_stride,
                    self.search_count, self.firmware_copies)
        # Reserved 40 bytes for future use, must be set to 0
        data += b&#39;\x00&#39; * 40
        if self.firmware_info_table:
            data += self.firmware_info_table
        # Reserved 128 bytes, must be set to 0
        data += b&#39;\x00&#39; * 128
        if self.config_block:
            data += self.config_block
        # Reserved 256 bytes, must be set to 0
        data += b&#39;\x00&#39; * 256
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></li>
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegFCB.FINGERPRINT"><code class="name">var <span class="ident">FINGERPRINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegFCB.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegFCB.crc"><code class="name">var <span class="ident">crc</span> : int</code></dt>
<dd>
<div class="desc"><p>Cyclic redundancy check.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def crc(self) -&gt; int:
    &#34;&#34;&#34;Cyclic redundancy check.&#34;&#34;&#34;
    return 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegFCB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Export to binary form.&#34;&#34;&#34;
    data = pack(&#39;&lt;Is2I2HI&#39;, self.crc, self.FINGERPRINT, self.version, self.search_start_page, self.search_stride,
                self.search_count, self.firmware_copies)
    # Reserved 40 bytes for future use, must be set to 0
    data += b&#39;\x00&#39; * 40
    if self.firmware_info_table:
        data += self.firmware_info_table
    # Reserved 128 bytes, must be set to 0
    data += b&#39;\x00&#39; * 128
    if self.config_block:
        data += self.config_block
    # Reserved 256 bytes, must be set to 0
    data += b&#39;\x00&#39; * 256
    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.AbstractFCB.enabled" href="#spsdk.image.segments.AbstractFCB.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.info" href="#spsdk.image.segments.BaseSegment.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.parse" href="#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.size" href="#spsdk.image.segments.BaseSegment.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.space" href="#spsdk.image.segments.AbstractFCB.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegIDS3a"><code class="flex name class">
<span>class <span class="ident">SegIDS3a</span></span>
</code></dt>
<dd>
<div class="desc"><p>IDS3a segment.</p>
<p>Initialize IDS3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIDS3a(BaseSegment):
    &#34;&#34;&#34;IDS3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;3Q4L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IDS3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize IDS3a segment.&#34;&#34;&#34;
        super().__init__()
        self.image_source = 0
        self.image_destination = 0
        self.image_entry = 0
        self.image_size = 0
        self.hab_flags = 0
        self.scfw_flags = 0
        self.rom_flags = 0

    def __repr__(self) -&gt; str:
        return &#34;IDS3a &lt;IN:0x{:X}, OUT:0x{:X}, ENTRY:0x{:X}, SIZE:{}B, HAB:0x{:X}, SCFW:0x{:X}, ROM:0x{:X}&gt;&#34;.format(
            self.image_source, self.image_destination, self.image_entry, self.image_size, self.hab_flags,
            self.scfw_flags, self.rom_flags
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIDS3a.&#34;&#34;&#34;
        msg = &#34; Source: 0x{:08X}\n&#34;.format(self.image_source)
        msg += &#34; Dest:   0x{:08X}\n&#34;.format(self.image_destination)
        msg += &#34; Entry:  0x{:08X}\n&#34;.format(self.image_entry)
        msg += &#34; Size:   {:s} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
        msg += &#34; &lt;Flags&gt;\n&#34;
        msg += &#34; SCFW:   0x{:08X}\n&#34;.format(self.scfw_flags)
        msg += &#34; HAB:    0x{:08X}\n&#34;.format(self.hab_flags)
        msg += &#34; ROM:    0x{:08X}\n&#34;.format(self.rom_flags)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.image_source,
                    self.image_destination,
                    self.image_entry,
                    self.image_size,
                    self.hab_flags,
                    self.scfw_flags,
                    self.rom_flags)
        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIDS3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IDS3a segment
        :return: SegIDS3a object
        &#34;&#34;&#34;
        obj = cls()
        (obj.image_source,
         obj.image_destination,
         obj.image_entry,
         obj.image_size,
         obj.hab_flags,
         obj.scfw_flags,
         obj.rom_flags) = unpack_from(obj.FORMAT, data)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3a.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegIDS3a.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3a.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIDS3a" href="#spsdk.image.segments.SegIDS3a">SegIDS3a</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IDS3a segment
:return: SegIDS3a object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIDS3a&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IDS3a segment
    :return: SegIDS3a object
    &#34;&#34;&#34;
    obj = cls()
    (obj.image_source,
     obj.image_destination,
     obj.image_entry,
     obj.image_size,
     obj.hab_flags,
     obj.scfw_flags,
     obj.rom_flags) = unpack_from(obj.FORMAT, data)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3a.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IDS3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IDS3a segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3a.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT,
                self.image_source,
                self.image_destination,
                self.image_entry,
                self.image_size,
                self.hab_flags,
                self.scfw_flags,
                self.rom_flags)
    data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIDS3a.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIDS3a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIDS3a.&#34;&#34;&#34;
    msg = &#34; Source: 0x{:08X}\n&#34;.format(self.image_source)
    msg += &#34; Dest:   0x{:08X}\n&#34;.format(self.image_destination)
    msg += &#34; Entry:  0x{:08X}\n&#34;.format(self.image_entry)
    msg += &#34; Size:   {:s} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
    msg += &#34; &lt;Flags&gt;\n&#34;
    msg += &#34; SCFW:   0x{:08X}\n&#34;.format(self.scfw_flags)
    msg += &#34; HAB:    0x{:08X}\n&#34;.format(self.hab_flags)
    msg += &#34; ROM:    0x{:08X}\n&#34;.format(self.rom_flags)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegIDS3b"><code class="flex name class">
<span>class <span class="ident">SegIDS3b</span></span>
</code></dt>
<dd>
<div class="desc"><p>IDS3b segment.</p>
<p>Initialize IDS3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIDS3b(BaseSegment):
    &#34;&#34;&#34;IDS3b segment.&#34;&#34;&#34;
    FORMAT = &#39;&lt;3Q2L&#39;
    SIZE = calcsize(FORMAT)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IDS3b segment.&#34;&#34;&#34;
        return calcsize(self.FORMAT)

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize IDS3b segment.&#34;&#34;&#34;
        super().__init__()
        self.image_source = 0
        self.image_destination = 0
        self.image_entry = 0
        self.image_size = 0
        self.flags = 0

    def __repr__(self) -&gt; str:
        return &#34;IDS3b &lt;IN:0x{:X}, OUT:0x{:X}, ENTRY:0x{:X}, SIZE:{}B, FLAGS:0x{:X}&gt;&#34;.format(
            self.image_source, self.image_destination, self.image_entry, self.image_size, self.flags
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIDS3b.&#34;&#34;&#34;
        msg = &#34; Source: 0x{:08X}\n&#34;.format(self.image_source)
        msg += &#34; Dest:   0x{:08X}\n&#34;.format(self.image_destination)
        msg += &#34; Entry:  0x{:08X}\n&#34;.format(self.image_entry)
        msg += &#34; Flags:  0x{:08X}\n&#34;.format(self.flags)
        msg += &#34; Size:   {:s} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = pack(self.FORMAT,
                    self.image_source, self.image_destination, self.image_entry, self.image_size, self.flags)
        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIDS3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IDS3b segment
        :return: SegIDS3b object
        &#34;&#34;&#34;
        ids = cls()
        (ids.image_source,
         ids.image_destination,
         ids.image_entry,
         ids.image_size,
         ids.flags) = unpack_from(cls.FORMAT, data)

        return ids</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3b.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegIDS3b.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3b.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIDS3b" href="#spsdk.image.segments.SegIDS3b">SegIDS3b</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IDS3b segment
:return: SegIDS3b object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIDS3b&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IDS3b segment
    :return: SegIDS3b object
    &#34;&#34;&#34;
    ids = cls()
    (ids.image_source,
     ids.image_destination,
     ids.image_entry,
     ids.image_size,
     ids.flags) = unpack_from(cls.FORMAT, data)

    return ids</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3b.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IDS3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IDS3b segment.&#34;&#34;&#34;
    return calcsize(self.FORMAT)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIDS3b.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = pack(self.FORMAT,
                self.image_source, self.image_destination, self.image_entry, self.image_size, self.flags)
    data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIDS3b.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIDS3b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIDS3b.&#34;&#34;&#34;
    msg = &#34; Source: 0x{:08X}\n&#34;.format(self.image_source)
    msg += &#34; Dest:   0x{:08X}\n&#34;.format(self.image_destination)
    msg += &#34; Entry:  0x{:08X}\n&#34;.format(self.image_entry)
    msg += &#34; Flags:  0x{:08X}\n&#34;.format(self.flags)
    msg += &#34; Size:   {:s} ({} Bytes)\n&#34;.format(size_fmt(self.image_size), self.image_size)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegIVT2"><code class="flex name class">
<span>class <span class="ident">SegIVT2</span></span>
<span>(</span><span>version: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Image Vector Table, IVT2 segment.</p>
<p>Initialize IVT2 segment.</p>
<p>:param version: The version of IVT and Image format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIVT2(BaseSegment):
    &#34;&#34;&#34;Image Vector Table, IVT2 segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;7L&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
        assert 0x40 &lt;= value &lt; 0x4F
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of the binary data.&#34;&#34;&#34;
        return self._header.length

    def __init__(self, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT2 segment.

        :param version: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT2, version)
        self._header.length = self.SIZE
        self.app_address = 0
        self.rs1 = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.rs2 = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT2 &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, APP:0x{:X}, CSF:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.app_address, self.csf_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT2.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; format version   : 0x{:02X}\n&#34;.format(self.version)
        msg += &#34; IVT start address: 0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT start address: 0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD start address: 0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; APP entry point  : 0x{:08X}\n&#34;.format(self.app_address)
        msg += &#34; CSF start address: 0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validate settings of the segment.

        :raises ValueError: if there is configuration problem
        &#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X} &lt; 0x{:X}&#34;.format(self.dcd_address, self.ivt_address))
        # TODO: resolve commented code: if self.app_address and self.app_address &lt; self.ivt_address:
        #  raise ValueError(&#34;Not valid APP address: 0x{:X} &lt; 0x{:X}&#34;.format(self.app_address, self.ivt_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X} &lt; 0x{:X}&#34;.format(self.csf_address, self.ivt_address))
        if self.padding &gt; 0:
            raise ValueError(&#34;IVT padding should be zero: {}&#34;.format(self.padding))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export to binary representation (serialization).

        :return: segment exported as binary data
        &#34;&#34;&#34;
        self.validate()

        data = self._header.export()
        data += pack(self.FORMAT, self.app_address, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address,
                     self.csf_address, self.rs2)

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT2&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT2 segment
        :return: SegIVT2 object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT2)
        obj = cls(header.param)
        # Parse IVT items
        (obj.app_address,
         obj.rs1,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.rs2) = unpack_from(cls.FORMAT, data, header.size)
        # Calculate IVT padding (should be zero)
        obj.padding = obj.bdt_address - obj.ivt_address - obj.size
        # Validate parsed values
        obj.validate()
        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT2.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegIVT2.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT2.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIVT2" href="#spsdk.image.segments.SegIVT2">SegIVT2</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IVT2 segment
:return: SegIVT2 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIVT2&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IVT2 segment
    :return: SegIVT2 object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.IVT2)
    obj = cls(header.param)
    # Parse IVT items
    (obj.app_address,
     obj.rs1,
     obj.dcd_address,
     obj.bdt_address,
     obj.ivt_address,
     obj.csf_address,
     obj.rs2) = unpack_from(cls.FORMAT, data, header.size)
    # Calculate IVT padding (should be zero)
    obj.padding = obj.bdt_address - obj.ivt_address - obj.size
    # Validate parsed values
    obj.validate()
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT2.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of the binary data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of the binary data.&#34;&#34;&#34;
    return self._header.length</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT2.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>The version of IVT and Image format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;The version of IVT and Image format.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT2.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export to binary representation (serialization).</p>
<p>:return: segment exported as binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export to binary representation (serialization).

    :return: segment exported as binary data
    &#34;&#34;&#34;
    self.validate()

    data = self._header.export()
    data += pack(self.FORMAT, self.app_address, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address,
                 self.csf_address, self.rs2)

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT2.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIVT2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIVT2.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; format version   : 0x{:02X}\n&#34;.format(self.version)
    msg += &#34; IVT start address: 0x{:08X}\n&#34;.format(self.ivt_address)
    msg += &#34; BDT start address: 0x{:08X}\n&#34;.format(self.bdt_address)
    msg += &#34; DCD start address: 0x{:08X}\n&#34;.format(self.dcd_address)
    msg += &#34; APP entry point  : 0x{:08X}\n&#34;.format(self.app_address)
    msg += &#34; CSF start address: 0x{:08X}\n&#34;.format(self.csf_address)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT2.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validate settings of the segment.</p>
<p>:raises ValueError: if there is configuration problem</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validate settings of the segment.

    :raises ValueError: if there is configuration problem
    &#34;&#34;&#34;
    if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid IVT/BDT address&#34;)
    if self.dcd_address and self.dcd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid DCD address: 0x{:X} &lt; 0x{:X}&#34;.format(self.dcd_address, self.ivt_address))
    # TODO: resolve commented code: if self.app_address and self.app_address &lt; self.ivt_address:
    #  raise ValueError(&#34;Not valid APP address: 0x{:X} &lt; 0x{:X}&#34;.format(self.app_address, self.ivt_address))
    if self.csf_address and self.csf_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid CSF address: 0x{:X} &lt; 0x{:X}&#34;.format(self.csf_address, self.ivt_address))
    if self.padding &gt; 0:
        raise ValueError(&#34;IVT padding should be zero: {}&#34;.format(self.padding))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegIVT3a"><code class="flex name class">
<span>class <span class="ident">SegIVT3a</span></span>
<span>(</span><span>param: int)</span>
</code></dt>
<dd>
<div class="desc"><p>IVT3a segment.</p>
<p>Initialize IVT segment.</p>
<p>:param param: The version of IVT and Image format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIVT3a(BaseSegment):
    &#34;&#34;&#34;IVT3a segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;1L5Q&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of IVT3a segment.&#34;&#34;&#34;
        return self._header

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IVT3a segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, param: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT segment.

        :param param: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT3, param)
        self._header.length = self.SIZE
        self.version = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.next = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT3a &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, CSF:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.csf_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT3a.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; VER:  {}\n&#34;.format(self.version)
        msg += &#34; IVT:  0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT:  0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD:  0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; CSF:  0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34; NEXT: 0x{:08X}\n&#34;.format(self.next)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validation of IVT3a segment.&#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self.header.export()
        data += pack(self.FORMAT, self.version, self.dcd_address, self.bdt_address, self.ivt_address,
                     self.csf_address, self.next)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT3a&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT3a segment
        :return: SegIVT3a object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT3)
        obj = cls(header.param)

        (obj.version,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.next) = unpack_from(cls.FORMAT, data, header.size)

        obj.validate()

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3a.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegIVT3a.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3a.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIVT3a" href="#spsdk.image.segments.SegIVT3a">SegIVT3a</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IVT3a segment
:return: SegIVT3a object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIVT3a&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IVT3a segment
    :return: SegIVT3a object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.IVT3)
    obj = cls(header.param)

    (obj.version,
     obj.dcd_address,
     obj.bdt_address,
     obj.ivt_address,
     obj.csf_address,
     obj.next) = unpack_from(cls.FORMAT, data, header.size)

    obj.validate()

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3a.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.image.header.Header" href="header.html#spsdk.image.header.Header">Header</a></code></dt>
<dd>
<div class="desc"><p>Header of IVT3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Header:
    &#34;&#34;&#34;Header of IVT3a segment.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT3a.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IVT3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IVT3a segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3a.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self.validate()

    data = self.header.export()
    data += pack(self.FORMAT, self.version, self.dcd_address, self.bdt_address, self.ivt_address,
                 self.csf_address, self.next)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT3a.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIVT3a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIVT3a.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; VER:  {}\n&#34;.format(self.version)
    msg += &#34; IVT:  0x{:08X}\n&#34;.format(self.ivt_address)
    msg += &#34; BDT:  0x{:08X}\n&#34;.format(self.bdt_address)
    msg += &#34; DCD:  0x{:08X}\n&#34;.format(self.dcd_address)
    msg += &#34; CSF:  0x{:08X}\n&#34;.format(self.csf_address)
    msg += &#34; NEXT: 0x{:08X}\n&#34;.format(self.next)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT3a.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of IVT3a segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validation of IVT3a segment.&#34;&#34;&#34;
    if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid IVT/BDT address&#34;)
    if self.dcd_address and self.dcd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
    if self.csf_address and self.csf_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegIVT3b"><code class="flex name class">
<span>class <span class="ident">SegIVT3b</span></span>
<span>(</span><span>version: int)</span>
</code></dt>
<dd>
<div class="desc"><p>IVT3b segment.</p>
<p>Initialize IVT segment.</p>
<p>:param version: The version of IVT and Image format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegIVT3b(BaseSegment):
    &#34;&#34;&#34;IVT3b segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;1L7Q&#39;
    SIZE = Header.SIZE + calcsize(FORMAT)

    @property
    def header(self) -&gt; Header:
        &#34;&#34;&#34;Header of IVT3b segment.&#34;&#34;&#34;
        return self._header

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of IVT3b segment.

        :return size
        &#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int) -&gt; None:
        &#34;&#34;&#34;Initialize IVT segment.

        :param version: The version of IVT and Image format
        &#34;&#34;&#34;
        super().__init__()
        self._header = Header(SegTag.IVT2, version)
        self._header.length = self.SIZE
        self.rs1 = 0
        self.dcd_address = 0
        self.bdt_address = 0
        self.ivt_address = 0
        self.csf_address = 0
        self.scd_address = 0
        self.rs2h = 0
        self.rs2l = 0

    def __repr__(self) -&gt; str:
        return &#34;IVT3b &lt;IVT:0x{:X}, BDT:0x{:X}, DCD:0x{:X}, CSF:0x{:X}, SCD:0x{:X}&gt;&#34;.format(
            self.ivt_address, self.bdt_address, self.dcd_address, self.csf_address, self.scd_address
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegIVT3b.&#34;&#34;&#34;
        msg = &#34;&#34;
        msg += &#34; IVT: 0x{:08X}\n&#34;.format(self.ivt_address)
        msg += &#34; BDT: 0x{:08X}\n&#34;.format(self.bdt_address)
        msg += &#34; DCD: 0x{:08X}\n&#34;.format(self.dcd_address)
        msg += &#34; SCD: 0x{:08X}\n&#34;.format(self.scd_address)
        msg += &#34; CSF: 0x{:08X}\n&#34;.format(self.csf_address)
        msg += &#34;\n&#34;
        return msg

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validation of IVT3b segment.&#34;&#34;&#34;
        if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid IVT/BDT address&#34;)
        if self.dcd_address and self.dcd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
        if self.csf_address and self.csf_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))
        if self.scd_address and self.scd_address &lt; self.ivt_address:
            raise ValueError(&#34;Not valid SCD address: 0x{:X}&#34;.format(self.scd_address))

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        self.validate()

        data = self.header.export()
        data += pack(self.FORMAT, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address, self.csf_address,
                     self.scd_address, self.rs2h, self.rs2l)
        data += self._padding_export()
        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegIVT3b&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of IVT3b segment
        :return: SegIVT3b object
        &#34;&#34;&#34;
        header = Header.parse(data, 0, SegTag.IVT2)
        obj = cls(header.param)

        (obj.rs1,
         obj.dcd_address,
         obj.bdt_address,
         obj.ivt_address,
         obj.csf_address,
         obj.scd_address,
         obj.rs2h,
         obj.rs2l) = unpack_from(cls.FORMAT, data, header.size)

        obj.validate()

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3b.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegIVT3b.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3b.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegIVT3b" href="#spsdk.image.segments.SegIVT3b">SegIVT3b</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of IVT3b segment
:return: SegIVT3b object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegIVT3b&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of IVT3b segment
    :return: SegIVT3b object
    &#34;&#34;&#34;
    header = Header.parse(data, 0, SegTag.IVT2)
    obj = cls(header.param)

    (obj.rs1,
     obj.dcd_address,
     obj.bdt_address,
     obj.ivt_address,
     obj.csf_address,
     obj.scd_address,
     obj.rs2h,
     obj.rs2l) = unpack_from(cls.FORMAT, data, header.size)

    obj.validate()

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3b.header"><code class="name">var <span class="ident">header</span> : <a title="spsdk.image.header.Header" href="header.html#spsdk.image.header.Header">Header</a></code></dt>
<dd>
<div class="desc"><p>Header of IVT3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Header:
    &#34;&#34;&#34;Header of IVT3b segment.&#34;&#34;&#34;
    return self._header</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT3b.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of IVT3b segment.</p>
<p>:return size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of IVT3b segment.

    :return size
    &#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegIVT3b.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    self.validate()

    data = self.header.export()
    data += pack(self.FORMAT, self.rs1, self.dcd_address, self.bdt_address, self.ivt_address, self.csf_address,
                 self.scd_address, self.rs2h, self.rs2l)
    data += self._padding_export()
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT3b.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegIVT3b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegIVT3b.&#34;&#34;&#34;
    msg = &#34;&#34;
    msg += &#34; IVT: 0x{:08X}\n&#34;.format(self.ivt_address)
    msg += &#34; BDT: 0x{:08X}\n&#34;.format(self.bdt_address)
    msg += &#34; DCD: 0x{:08X}\n&#34;.format(self.dcd_address)
    msg += &#34; SCD: 0x{:08X}\n&#34;.format(self.scd_address)
    msg += &#34; CSF: 0x{:08X}\n&#34;.format(self.csf_address)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegIVT3b.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of IVT3b segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validation of IVT3b segment.&#34;&#34;&#34;
    if self.ivt_address == 0 or self.bdt_address == 0 or self.bdt_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid IVT/BDT address&#34;)
    if self.dcd_address and self.dcd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid DCD address: 0x{:X}&#34;.format(self.dcd_address))
    if self.csf_address and self.csf_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid CSF address: 0x{:X}&#34;.format(self.csf_address))
    if self.scd_address and self.scd_address &lt; self.ivt_address:
        raise ValueError(&#34;Not valid SCD address: 0x{:X}&#34;.format(self.scd_address))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.segments.SegSIGB"><code class="flex name class">
<span>class <span class="ident">SegSIGB</span></span>
<span>(</span><span>version: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>SignatureBlock segment.</p>
<p>Initialize SignatureBlock segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegSIGB(BaseSegment):
    &#34;&#34;&#34;SignatureBlock segment.&#34;&#34;&#34;

    FORMAT = &#39;&lt;4HL&#39;
    SIZE = Header2.SIZE + calcsize(FORMAT)

    @property
    def version(self) -&gt; int:
        &#34;&#34;&#34;Version of Signature Block segment.&#34;&#34;&#34;
        return self._header.param

    @version.setter
    def version(self, value: int) -&gt; None:
        self._header.param = value

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Size of Signature Block segment.&#34;&#34;&#34;
        return self.SIZE

    def __init__(self, version: int = 0) -&gt; None:
        &#34;&#34;&#34;Initialize SignatureBlock segment.&#34;&#34;&#34;
        super().__init__()
        self._header = Header2(SegTag.SIGB, version)
        self._header.length = self.SIZE
        self.srk_table_offset = 0
        self.cert_offset = 0
        self.blob_offset = 0
        self.signature_offset = 0
        self.reserved = 0

    def __repr__(self) -&gt; str:
        return &#34;SIGB &lt;SRK:0x{:X}, CERT:0x{:X}, BLOB:0x{:X}, SIG:0x{:X}&gt;&#34;.format(
            self.srk_table_offset, self.cert_offset, self.blob_offset, self.signature_offset
        )

    def info(self) -&gt; str:
        &#34;&#34;&#34;String representation of the SegSIGB.&#34;&#34;&#34;
        msg = &#34; SRK Table Offset:   0x{:X}\n&#34;.format(self.srk_table_offset)
        msg += &#34; Certificate Offset: 0x{:X}\n&#34;.format(self.cert_offset)
        msg += &#34; Signature Offset:   0x{:X}\n&#34;.format(self.signature_offset)
        msg += &#34; Blob Offset:        0x{:X}\n&#34;.format(self.blob_offset)
        msg += &#34;\n&#34;
        return msg

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;Export segment as bytes array.

        :return: bytes
        &#34;&#34;&#34;
        data = self._header.export()
        data += pack(self.FORMAT,
                     self.srk_table_offset, self.cert_offset, self.blob_offset, self.signature_offset, self.reserved)
        data += self._padding_export()

        return data

    @classmethod
    def parse(cls, data: bytes) -&gt; &#39;SegSIGB&#39;:
        &#34;&#34;&#34;Parse segment from bytes array.

        :param data: The bytes array of SignatureBlock segment
        :return: SegSigBlk object
        &#34;&#34;&#34;
        header = Header2.parse(data, 0, SegTag.SIGB)
        obj = cls(header.param)

        (obj.srk_table_offset,
         obj.cert_offset,
         obj.blob_offset,
         obj.signature_offset,
         obj.reserved) = unpack_from(obj.FORMAT, data)

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.segments.SegSIGB.FORMAT"><code class="name">var <span class="ident">FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.segments.SegSIGB.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.segments.SegSIGB.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes) ‑> <a title="spsdk.image.segments.SegSIGB" href="#spsdk.image.segments.SegSIGB">SegSIGB</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse segment from bytes array.</p>
<p>:param data: The bytes array of SignatureBlock segment
:return: SegSigBlk object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes) -&gt; &#39;SegSIGB&#39;:
    &#34;&#34;&#34;Parse segment from bytes array.

    :param data: The bytes array of SignatureBlock segment
    :return: SegSigBlk object
    &#34;&#34;&#34;
    header = Header2.parse(data, 0, SegTag.SIGB)
    obj = cls(header.param)

    (obj.srk_table_offset,
     obj.cert_offset,
     obj.blob_offset,
     obj.signature_offset,
     obj.reserved) = unpack_from(obj.FORMAT, data)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.segments.SegSIGB.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Size of Signature Block segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Size of Signature Block segment.&#34;&#34;&#34;
    return self.SIZE</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegSIGB.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"><p>Version of Signature Block segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; int:
    &#34;&#34;&#34;Version of Signature Block segment.&#34;&#34;&#34;
    return self._header.param</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.segments.SegSIGB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export segment as bytes array.</p>
<p>:return: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;Export segment as bytes array.

    :return: bytes
    &#34;&#34;&#34;
    data = self._header.export()
    data += pack(self.FORMAT,
                 self.srk_table_offset, self.cert_offset, self.blob_offset, self.signature_offset, self.reserved)
    data += self._padding_export()

    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.segments.SegSIGB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of the SegSIGB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;String representation of the SegSIGB.&#34;&#34;&#34;
    msg = &#34; SRK Table Offset:   0x{:X}\n&#34;.format(self.srk_table_offset)
    msg += &#34; Certificate Offset: 0x{:X}\n&#34;.format(self.cert_offset)
    msg += &#34; Signature Offset:   0x{:X}\n&#34;.format(self.signature_offset)
    msg += &#34; Blob Offset:        0x{:X}\n&#34;.format(self.blob_offset)
    msg += &#34;\n&#34;
    return msg</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.image" href="index.html">spsdk.image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.image.segments.AbstractFCB" href="#spsdk.image.segments.AbstractFCB">AbstractFCB</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.segments.AbstractFCB.enabled" href="#spsdk.image.segments.AbstractFCB.enabled">enabled</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.export" href="#spsdk.image.segments.AbstractFCB.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.AbstractFCB.space" href="#spsdk.image.segments.AbstractFCB.space">space</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.BaseSegment" href="#spsdk.image.segments.BaseSegment">BaseSegment</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.BaseSegment.PADDING_VALUE" href="#spsdk.image.segments.BaseSegment.PADDING_VALUE">PADDING_VALUE</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.export" href="#spsdk.image.segments.BaseSegment.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.info" href="#spsdk.image.segments.BaseSegment.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.padding_len" href="#spsdk.image.segments.BaseSegment.padding_len">padding_len</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.parse" href="#spsdk.image.segments.BaseSegment.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.size" href="#spsdk.image.segments.BaseSegment.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.BaseSegment.space" href="#spsdk.image.segments.BaseSegment.space">space</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB" href="#spsdk.image.segments.FlexSPIConfBlockFCB">FlexSPIConfBlockFCB</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.FORMAT" href="#spsdk.image.segments.FlexSPIConfBlockFCB.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.TAG" href="#spsdk.image.segments.FlexSPIConfBlockFCB.TAG">TAG</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.VERSION" href="#spsdk.image.segments.FlexSPIConfBlockFCB.VERSION">VERSION</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.export" href="#spsdk.image.segments.FlexSPIConfBlockFCB.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.export_header" href="#spsdk.image.segments.FlexSPIConfBlockFCB.export_header">export_header</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.info" href="#spsdk.image.segments.FlexSPIConfBlockFCB.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.parse" href="#spsdk.image.segments.FlexSPIConfBlockFCB.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.FlexSPIConfBlockFCB.size" href="#spsdk.image.segments.FlexSPIConfBlockFCB.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.PaddingFCB" href="#spsdk.image.segments.PaddingFCB">PaddingFCB</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.segments.PaddingFCB.export" href="#spsdk.image.segments.PaddingFCB.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.PaddingFCB.info" href="#spsdk.image.segments.PaddingFCB.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.PaddingFCB.size" href="#spsdk.image.segments.PaddingFCB.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegAPP" href="#spsdk.image.segments.SegAPP">SegAPP</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.segments.SegAPP.data" href="#spsdk.image.segments.SegAPP.data">data</a></code></li>
<li><code><a title="spsdk.image.segments.SegAPP.export" href="#spsdk.image.segments.SegAPP.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegAPP.info" href="#spsdk.image.segments.SegAPP.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegAPP.size" href="#spsdk.image.segments.SegAPP.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegBDS3a" href="#spsdk.image.segments.SegBDS3a">SegBDS3a</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegBDS3a.FORMAT" href="#spsdk.image.segments.SegBDS3a.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.HEADER_SIZE" href="#spsdk.image.segments.SegBDS3a.HEADER_SIZE">HEADER_SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.IMAGES_MAX_COUNT" href="#spsdk.image.segments.SegBDS3a.IMAGES_MAX_COUNT">IMAGES_MAX_COUNT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.SIZE" href="#spsdk.image.segments.SegBDS3a.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.export" href="#spsdk.image.segments.SegBDS3a.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.header_size" href="#spsdk.image.segments.SegBDS3a.header_size">header_size</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.info" href="#spsdk.image.segments.SegBDS3a.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.parse" href="#spsdk.image.segments.SegBDS3a.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3a.size" href="#spsdk.image.segments.SegBDS3a.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegBDS3b" href="#spsdk.image.segments.SegBDS3b">SegBDS3b</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegBDS3b.FORMAT" href="#spsdk.image.segments.SegBDS3b.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.HEADER_SIZE" href="#spsdk.image.segments.SegBDS3b.HEADER_SIZE">HEADER_SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.IMAGES_MAX_COUNT" href="#spsdk.image.segments.SegBDS3b.IMAGES_MAX_COUNT">IMAGES_MAX_COUNT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.SIZE" href="#spsdk.image.segments.SegBDS3b.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.export" href="#spsdk.image.segments.SegBDS3b.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.header_size" href="#spsdk.image.segments.SegBDS3b.header_size">header_size</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.info" href="#spsdk.image.segments.SegBDS3b.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.parse" href="#spsdk.image.segments.SegBDS3b.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDS3b.size" href="#spsdk.image.segments.SegBDS3b.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegBDT" href="#spsdk.image.segments.SegBDT">SegBDT</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegBDT.FORMAT" href="#spsdk.image.segments.SegBDT.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDT.SIZE" href="#spsdk.image.segments.SegBDT.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDT.export" href="#spsdk.image.segments.SegBDT.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDT.info" href="#spsdk.image.segments.SegBDT.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDT.parse" href="#spsdk.image.segments.SegBDT.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDT.plugin" href="#spsdk.image.segments.SegBDT.plugin">plugin</a></code></li>
<li><code><a title="spsdk.image.segments.SegBDT.size" href="#spsdk.image.segments.SegBDT.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegBEE" href="#spsdk.image.segments.SegBEE">SegBEE</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegBEE.add_region" href="#spsdk.image.segments.SegBEE.add_region">add_region</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.encrypt_data" href="#spsdk.image.segments.SegBEE.encrypt_data">encrypt_data</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.export" href="#spsdk.image.segments.SegBEE.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.info" href="#spsdk.image.segments.SegBEE.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.parse" href="#spsdk.image.segments.SegBEE.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.size" href="#spsdk.image.segments.SegBEE.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.update" href="#spsdk.image.segments.SegBEE.update">update</a></code></li>
<li><code><a title="spsdk.image.segments.SegBEE.validate" href="#spsdk.image.segments.SegBEE.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegBIC1" href="#spsdk.image.segments.SegBIC1">SegBIC1</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegBIC1.FORMAT" href="#spsdk.image.segments.SegBIC1.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.MAX_NUM_IMGS" href="#spsdk.image.segments.SegBIC1.MAX_NUM_IMGS">MAX_NUM_IMGS</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.SIZE" href="#spsdk.image.segments.SegBIC1.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.export" href="#spsdk.image.segments.SegBIC1.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.info" href="#spsdk.image.segments.SegBIC1.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.parse" href="#spsdk.image.segments.SegBIC1.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.size" href="#spsdk.image.segments.SegBIC1.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.validate" href="#spsdk.image.segments.SegBIC1.validate">validate</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIC1.version" href="#spsdk.image.segments.SegBIC1.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegBIM" href="#spsdk.image.segments.SegBIM">SegBIM</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegBIM.FORMAT" href="#spsdk.image.segments.SegBIM.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIM.SIZE" href="#spsdk.image.segments.SegBIM.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIM.export" href="#spsdk.image.segments.SegBIM.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIM.info" href="#spsdk.image.segments.SegBIM.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIM.parse" href="#spsdk.image.segments.SegBIM.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegBIM.size" href="#spsdk.image.segments.SegBIM.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegCSF" href="#spsdk.image.segments.SegCSF">SegCSF</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegCSF.append_command" href="#spsdk.image.segments.SegCSF.append_command">append_command</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.clear_commands" href="#spsdk.image.segments.SegCSF.clear_commands">clear_commands</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.commands" href="#spsdk.image.segments.SegCSF.commands">commands</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.export" href="#spsdk.image.segments.SegCSF.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.info" href="#spsdk.image.segments.SegCSF.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.macs" href="#spsdk.image.segments.SegCSF.macs">macs</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.parse" href="#spsdk.image.segments.SegCSF.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.size" href="#spsdk.image.segments.SegCSF.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.space" href="#spsdk.image.segments.SegCSF.space">space</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.update" href="#spsdk.image.segments.SegCSF.update">update</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.update_signatures" href="#spsdk.image.segments.SegCSF.update_signatures">update_signatures</a></code></li>
<li><code><a title="spsdk.image.segments.SegCSF.version" href="#spsdk.image.segments.SegCSF.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegDCD" href="#spsdk.image.segments.SegDCD">SegDCD</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegDCD.append" href="#spsdk.image.segments.SegDCD.append">append</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.clear" href="#spsdk.image.segments.SegDCD.clear">clear</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.commands" href="#spsdk.image.segments.SegDCD.commands">commands</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.export" href="#spsdk.image.segments.SegDCD.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.export_txt" href="#spsdk.image.segments.SegDCD.export_txt">export_txt</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.header" href="#spsdk.image.segments.SegDCD.header">header</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.info" href="#spsdk.image.segments.SegDCD.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.parse" href="#spsdk.image.segments.SegDCD.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.parse_txt" href="#spsdk.image.segments.SegDCD.parse_txt">parse_txt</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.pop" href="#spsdk.image.segments.SegDCD.pop">pop</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.size" href="#spsdk.image.segments.SegDCD.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegDCD.space" href="#spsdk.image.segments.SegDCD.space">space</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegDcdBuilder" href="#spsdk.image.segments.SegDcdBuilder">SegDcdBuilder</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.segments.SegDcdBuilder.build" href="#spsdk.image.segments.SegDcdBuilder.build">build</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegFCB" href="#spsdk.image.segments.SegFCB">SegFCB</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.segments.SegFCB.FINGERPRINT" href="#spsdk.image.segments.SegFCB.FINGERPRINT">FINGERPRINT</a></code></li>
<li><code><a title="spsdk.image.segments.SegFCB.SIZE" href="#spsdk.image.segments.SegFCB.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegFCB.crc" href="#spsdk.image.segments.SegFCB.crc">crc</a></code></li>
<li><code><a title="spsdk.image.segments.SegFCB.export" href="#spsdk.image.segments.SegFCB.export">export</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegIDS3a" href="#spsdk.image.segments.SegIDS3a">SegIDS3a</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegIDS3a.FORMAT" href="#spsdk.image.segments.SegIDS3a.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3a.SIZE" href="#spsdk.image.segments.SegIDS3a.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3a.export" href="#spsdk.image.segments.SegIDS3a.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3a.info" href="#spsdk.image.segments.SegIDS3a.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3a.parse" href="#spsdk.image.segments.SegIDS3a.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3a.size" href="#spsdk.image.segments.SegIDS3a.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegIDS3b" href="#spsdk.image.segments.SegIDS3b">SegIDS3b</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegIDS3b.FORMAT" href="#spsdk.image.segments.SegIDS3b.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3b.SIZE" href="#spsdk.image.segments.SegIDS3b.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3b.export" href="#spsdk.image.segments.SegIDS3b.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3b.info" href="#spsdk.image.segments.SegIDS3b.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3b.parse" href="#spsdk.image.segments.SegIDS3b.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegIDS3b.size" href="#spsdk.image.segments.SegIDS3b.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegIVT2" href="#spsdk.image.segments.SegIVT2">SegIVT2</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegIVT2.FORMAT" href="#spsdk.image.segments.SegIVT2.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.SIZE" href="#spsdk.image.segments.SegIVT2.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.export" href="#spsdk.image.segments.SegIVT2.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.info" href="#spsdk.image.segments.SegIVT2.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.parse" href="#spsdk.image.segments.SegIVT2.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.size" href="#spsdk.image.segments.SegIVT2.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.validate" href="#spsdk.image.segments.SegIVT2.validate">validate</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT2.version" href="#spsdk.image.segments.SegIVT2.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegIVT3a" href="#spsdk.image.segments.SegIVT3a">SegIVT3a</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegIVT3a.FORMAT" href="#spsdk.image.segments.SegIVT3a.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.SIZE" href="#spsdk.image.segments.SegIVT3a.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.export" href="#spsdk.image.segments.SegIVT3a.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.header" href="#spsdk.image.segments.SegIVT3a.header">header</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.info" href="#spsdk.image.segments.SegIVT3a.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.parse" href="#spsdk.image.segments.SegIVT3a.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.size" href="#spsdk.image.segments.SegIVT3a.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3a.validate" href="#spsdk.image.segments.SegIVT3a.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegIVT3b" href="#spsdk.image.segments.SegIVT3b">SegIVT3b</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegIVT3b.FORMAT" href="#spsdk.image.segments.SegIVT3b.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.SIZE" href="#spsdk.image.segments.SegIVT3b.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.export" href="#spsdk.image.segments.SegIVT3b.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.header" href="#spsdk.image.segments.SegIVT3b.header">header</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.info" href="#spsdk.image.segments.SegIVT3b.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.parse" href="#spsdk.image.segments.SegIVT3b.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.size" href="#spsdk.image.segments.SegIVT3b.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegIVT3b.validate" href="#spsdk.image.segments.SegIVT3b.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.segments.SegSIGB" href="#spsdk.image.segments.SegSIGB">SegSIGB</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.segments.SegSIGB.FORMAT" href="#spsdk.image.segments.SegSIGB.FORMAT">FORMAT</a></code></li>
<li><code><a title="spsdk.image.segments.SegSIGB.SIZE" href="#spsdk.image.segments.SegSIGB.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.segments.SegSIGB.export" href="#spsdk.image.segments.SegSIGB.export">export</a></code></li>
<li><code><a title="spsdk.image.segments.SegSIGB.info" href="#spsdk.image.segments.SegSIGB.info">info</a></code></li>
<li><code><a title="spsdk.image.segments.SegSIGB.parse" href="#spsdk.image.segments.SegSIGB.parse">parse</a></code></li>
<li><code><a title="spsdk.image.segments.SegSIGB.size" href="#spsdk.image.segments.SegSIGB.size">size</a></code></li>
<li><code><a title="spsdk.image.segments.SegSIGB.version" href="#spsdk.image.segments.SegSIGB.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>