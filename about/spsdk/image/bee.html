<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spsdk.image.bee API documentation</title>
<meta name="description" content="Contains support for BEE encryption for RT10xx devices." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spsdk.image.bee</code></h1>
</header>
<section id="section-intro">
<p>Contains support for BEE encryption for RT10xx devices.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2020 NXP
#
# SPDX-License-Identifier: BSD-3-Clause
&#34;&#34;&#34;Contains support for BEE encryption for RT10xx devices.&#34;&#34;&#34;


import logging
from struct import pack, unpack_from, calcsize
from typing import Any, List, Optional, Sequence

from Crypto.Cipher import AES

from spsdk.utils.crypto import crypto_backend, Counter
from spsdk.utils.easy_enum import Enum
from spsdk.utils.misc import extend_block, DebugInfo

_LOGGER = logging.getLogger(__name__)


# size of minimal encrypted block in bytes
BEE_ENCR_BLOCK_SIZE = 0x400
# mask of the bits in the address, that must be zero
_ENCR_BLOCK_ADDR_MASK = BEE_ENCR_BLOCK_SIZE - 1  # 0x3FF


class BeeBaseClass:
    &#34;&#34;&#34;BEE base class.&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    # the format is class specific, and must be defined in child class
    _FORMAT = &#34;@_must_be_defined_in_child_class_@&#34;

    @classmethod
    def _struct_format(cls) -&gt; str:
        &#34;&#34;&#34;:return: format string for struct.pack/unpack function used for export/import from binary format.&#34;&#34;&#34;
        return cls._FORMAT  # _FORMAT class constant must be defined in child class

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return calcsize(cls._struct_format())

    def __eq__(self, other: Any) -&gt; bool:
        return isinstance(other, self.__class__) and (vars(other) == vars(self))

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return self.__class__._size()

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: text description of the instance.&#34;&#34;&#34;
        raise NotImplementedError(&#39;abstract method&#39;)

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        pass

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates the configuration of the instance.

        :raise AssertionError: if configuration is invalid.
        It is recommended to call the method before export and after parsing
        &#34;&#34;&#34;

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return: binary representation of the region (serialization).&#34;&#34;&#34;
        self.update()
        self.validate()
        return b&#39;&#39;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; Any:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data; this method returns just `0`
        :raise ValueError: if size of the data is not sufficient
        &#34;&#34;&#34;
        if len(data) - offset &lt; cls._size():
            raise ValueError(&#39;Insufficient size of the data&#39;)
        return 0


class BeeFacRegion(BeeBaseClass):
    &#34;&#34;&#34;BEE Factory Access Control (FAC) region.&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#34;&lt;3I20s&#34;

    def __init__(self, start: int = 0, length: int = 0, protected_level: int = 0):
        &#34;&#34;&#34;Constructor.

        :param start: Start address of one FAC region, align at 1KB boundary; 32-bit number
        :param length: Length of one FAC region, align at 1KB boundary; 32-bit number
        :param protected_level: Protected level: 0/1/2/3; 32-bit number
        &#34;&#34;&#34;
        self.start_addr = start
        self.length = length
        self.protected_level = protected_level
        # immediately validate all parameters
        self.validate()

    def __str__(self) -&gt; str:
        return f&#39;FAC: 0x{self.start_addr:08x}[0x{self.length:x}]&#39;

    @property
    def end_addr(self) -&gt; int:
        &#34;&#34;&#34;:return: end address of the region (which is last address of the region + 1).&#34;&#34;&#34;
        return self.start_addr + self.length

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        return f&#39;FAC(start={hex(self.start_addr)}, length={hex(self.length)}, protected_level={self.protected_level})&#39;

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates the configuration of the instance.

        :raise AssertionError: if configuration is invalid.
        &#34;&#34;&#34;
        assert (self.start_addr &amp; _ENCR_BLOCK_ADDR_MASK == 0) and (self.length &amp; _ENCR_BLOCK_ADDR_MASK == 0)
        assert 0 &lt;= self.protected_level &lt;= 3
        assert 0 &lt;= self.start_addr &lt; self.end_addr &lt;= 0xFFFFFFFF

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        return result + pack(self._struct_format(), self.start_addr, self.end_addr, self.protected_level, b&#39;\x00&#39; * 20)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeFacRegion&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        :raise ValueError: if reserved area is non-zero
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the data
        (start, end, protected_level, _reserved) = unpack_from(BeeFacRegion._struct_format(), data, offset)
        if _reserved != b&#39;\x00&#39; * 20:
            raise ValueError(&#39;Reserved area is non-zero&#39;)
        return BeeFacRegion(start, end - start, protected_level)


class BeeProtectRegionBlockAesMode(Enum):
    &#34;&#34;&#34;AES mode selection for BEE PRDB encryption.&#34;&#34;&#34;
    ECB = 0
    CTR = 1


class BeeProtectRegionBlock(BeeBaseClass):
    &#34;&#34;&#34;BEE protect region block (PRDB).&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#39;&lt;8I16s32s&#39;
    # low TAG used in the header
    TAGL = 0x5F474154  # &#34;TAG_&#34;
    # high TAG used in the header
    TAGH = 0x52444845  # &#34;EHDR&#34;
    # version of the format
    VERSION = 0x56010000
    # number of FAC regions included in the header; the real limit of FAC regions depends on the processor
    FAC_REGIONS = 4
    # total size
    SIZE = 0x100

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return cls.SIZE

    def __init__(self, encr_mode: BeeProtectRegionBlockAesMode = BeeProtectRegionBlockAesMode.CTR,
                 lock_options: int = 0, counter: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param encr_mode: AES encryption mode
        :param lock_options: Lock options; 32-bit number
        :param counter: Counter for AES-CTR mode; 16 bytes; by default, random value is used
        &#34;&#34;&#34;
        # - Encrypt region info:
        self._start_addr = 0  # this is calculated automatically based on FAC regions
        self._end_addr = 0xFFFFFFFF  # this is calculated automatically based on FAC regions
        self.mode = encr_mode
        self.lock_options = lock_options
        self.counter = counter if counter else crypto_backend().random_bytes(12) + b&#39;\x00\x00\x00\x00&#39;

        # - FAC regions, 1 - 4
        self.fac_regions: List[BeeFacRegion] = list()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates start and end address of the encryption region.&#34;&#34;&#34;
        super().update()
        # update FAC regions
        for fac in self.fac_regions:
            fac.update()
        # update start and end address
        min_addr = 0 if self.fac_count == 0 else 0xFFFFFFFF
        max_addr = 0
        for fac in self.fac_regions:
            min_addr = min(min_addr, fac.start_addr)
            max_addr = max(max_addr, fac.end_addr)
        self._start_addr = min_addr
        self._end_addr = max_addr

    def add_fac(self, fac: BeeFacRegion) -&gt; None:
        &#34;&#34;&#34;Append FAC region.

        :param fac: Factory Access Control to be added
        &#34;&#34;&#34;
        self.fac_regions.append(fac)
        self.update()

    @property
    def fac_count(self) -&gt; int:
        &#34;&#34;&#34;:return: number of Factory Access Control regions.&#34;&#34;&#34;
        return len(self.fac_regions)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = f&#39;BEE Region Header (start={hex(self._start_addr)}, end={hex(self._end_addr)})\n&#39;
        result += f&#39;AES Encryption mode: {BeeProtectRegionBlockAesMode.name(self.mode)}\n&#39;
        for fac in self.fac_regions:
            result += fac.info() + &#39;\n&#39;
        return result

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        assert 0 &lt;= self._start_addr &lt;= 0xFFFFFFFF
        assert self._start_addr &lt;= self._end_addr &lt;= 0xFFFFFFFF
        assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;  # TODO
        assert len(self.counter) == 16
        assert self.counter[-4:] == b&#39;\x00\x00\x00\x00&#39;, &#39;last four bytes must be zero&#39;
        assert 0 &lt; self.fac_count &lt;= self.FAC_REGIONS
        for fac in self.fac_regions:
            fac.validate()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return: binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        result += pack(self._struct_format(),
                       self.TAGL,
                       self.TAGH,
                       self.VERSION,
                       self.fac_count,
                       self._start_addr,
                       self._end_addr,
                       self.mode,
                       self.lock_options,
                       self.counter[::-1],  # bytes swapped: reversed order
                       b&#39;\x00&#39; * 32)
        for fac in self.fac_regions:
            result += fac.export()
        result = extend_block(result, self.SIZE)
        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeProtectRegionBlock&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        :raise ValueError: if format does not match
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        (
            tagl,
            tagh,
            version,
            fac_count,
            start_addr,
            end_addr,
            mode,
            lock_options,
            counter,
            _reserved_32
        ) = unpack_from(BeeProtectRegionBlock._struct_format(), data, offset)
        #
        if (tagl != BeeProtectRegionBlock.TAGL) or (tagh != BeeProtectRegionBlock.TAGH):
            raise ValueError(&#39;Invalid tag or unsupported version&#39;)
        if version != BeeProtectRegionBlock.VERSION:
            raise ValueError(&#39;Unsupported version&#39;)
        if _reserved_32 != b&#39;\x00&#39; * 32:
            raise ValueError(&#39;Reserved area is non-zero&#39;)
        #
        result = BeeProtectRegionBlock(mode, lock_options, counter[::-1])
        result._start_addr = start_addr
        result._end_addr = end_addr
        offset += calcsize(BeeProtectRegionBlock._struct_format())
        for _ in range(fac_count):
            fac = BeeFacRegion.parse(data, offset)
            result.add_fac(fac)
            offset += fac.size
        result.validate()
        return result

    def encrypt_block(self, key: bytes, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt block located in any FAC region.

        :param key: user for encryption
        :param start_addr: start address of the data
        :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
        :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
        &#34;&#34;&#34;
        assert len(data) == BEE_ENCR_BLOCK_SIZE
        if self._start_addr &lt;= start_addr &lt; self._end_addr:
            assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;
            assert len(key) == 16
            for fac in self.fac_regions:
                if fac.start_addr &lt;= start_addr &lt; fac.end_addr:
                    assert start_addr + len(data) &lt;= fac.end_addr
                    cntr_key = Counter(self.counter, ctr_value=start_addr &gt;&gt; 4, ctr_byteorder_encoding=&#39;big&#39;)
                    return crypto_backend().aes_ctr_encrypt(key, data, cntr_key.value)
        return data


class BeeKIB(BeeBaseClass):
    &#34;&#34;&#34;BEE Key block.

    Contains keys used to encrypt PRDB content.
    &#34;&#34;&#34;

    # key length in bytes
    _KEY_LEN = 16
    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#34;16s16s&#34;

    def __init__(self, kib_key: Optional[bytes] = None, kib_iv: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param kib_key: AES key
        :param kib_iv: AES initialization vector
        &#34;&#34;&#34;
        # Key Info Block (KIB)
        self.kib_key = kib_key if kib_key else crypto_backend().random_bytes(16)
        self.kib_iv = kib_iv if kib_iv else crypto_backend().random_bytes(16)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        return f&#34;BEE-KIB: {self.kib_key.hex()}, {self.kib_iv.hex()}&#34;

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        assert len(self.kib_key) == self._KEY_LEN
        assert len(self.kib_iv) == self._KEY_LEN

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        return result + pack(self._struct_format(), self.kib_key, self.kib_iv)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeKIB&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        (key, iv) = unpack_from(BeeKIB._struct_format(), data, offset)
        result = cls(key, iv)
        result.validate()
        return result


class BeeRegionHeader(BeeBaseClass):
    &#34;&#34;&#34;BEE keys and regions header.&#34;&#34;&#34;

    # offset of the Protected Region Block in the header
    PRDB_OFFSET = 0x80
    # total size including padding
    SIZE = 0x400

    @classmethod
    def _struct_format(cls) -&gt; str:
        &#34;&#34;&#34;:raise AssertionError: it is not expected to called for the class.&#34;&#34;&#34;
        raise AssertionError(&#39;This method is not expected to be used for this class, format depends on its fields&#39;)

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return cls.SIZE

    def __init__(self, prdb: Optional[BeeProtectRegionBlock] = None, sw_key: Optional[bytes] = None,
                 kib: Optional[BeeKIB] = None):
        &#34;&#34;&#34;Constructor.

        :param prdb: protect region block; None to use default
        :param sw_key: key used to encrypt KIB content
        :param kib: keys block; None to use default
        &#34;&#34;&#34;
        self._prdb = prdb if (prdb is not None) else BeeProtectRegionBlock()
        self._sw_key = sw_key if (sw_key is not None) else crypto_backend().random_bytes(16)
        self._kib = kib if (kib is not None) else BeeKIB()

    def add_fac(self, fac: BeeFacRegion) -&gt; None:
        &#34;&#34;&#34;Append FAC region.

        :param fac: to be added
        &#34;&#34;&#34;
        self._prdb.add_fac(fac)

    @property
    def fac_regions(self) -&gt; Sequence[BeeFacRegion]:
        &#34;&#34;&#34;:return: lift of Factory Access Control regions.&#34;&#34;&#34;
        return self._prdb.fac_regions

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = &#39;BEE Region Header\n&#39;
        result += f&#39;- KIB: {self._kib.info()}&#39;
        result += f&#39;- PRDB: {self._prdb.info()}&#39;
        return result

    def sw_key_fuses(self) -&gt; Sequence[int]:
        &#34;&#34;&#34;:return: sequence of fuse values for SW key to be burned into processor.

        The result is ordered, first value should be burned to the lowest address.
        &#34;&#34;&#34;
        result = list()
        for pos in range(16, 0, -4):
            result.append(unpack_from(&#34;&gt;I&#34;, self._sw_key[pos - 4:pos])[0])
        return result

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        super().update()
        self._kib.update()
        self._prdb.update()

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        self._kib.validate()
        self._prdb.validate()
        assert len(self._sw_key) == 16

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Serialization to binary representation.

        :param dbg_info: instance allowing to provide debug info about exported data
        :return:binary representation of the region (serialization).
        &#34;&#34;&#34;
        result = super().export()
        # KIB
        kib_data = self._kib.export()
        dbg_info.append_binary_section(&#39;BEE-KIB (non-crypted)&#39;, kib_data)
        aes = AES.new(self._sw_key, AES.MODE_ECB)
        result += aes.encrypt(kib_data)
        # padding
        result = extend_block(result, self.PRDB_OFFSET)
        # PRDB
        prdb_data = self._prdb.export()
        dbg_info.append_binary_section(&#39;BEE-PRDB (non-crypted)&#39;, prdb_data)
        aes = AES.new(self._kib.kib_key, AES.MODE_CBC, self._kib.kib_iv)
        result += aes.encrypt(prdb_data)
        # padding
        return extend_block(result, self.SIZE)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0, sw_key: bytes = b&#39;&#39;) -&gt; &#39;BeeRegionHeader&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
        :return: instance created from binary data
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        assert len(sw_key) == 16
        aes = AES.new(sw_key, AES.MODE_ECB)
        decr_data = aes.decrypt(data[offset:offset + BeeKIB._size()])
        kib = BeeKIB.parse(decr_data)
        aes = AES.new(kib.kib_key, AES.MODE_CBC, kib.kib_iv)
        decr_data = aes.decrypt(data[offset + cls.PRDB_OFFSET:offset + cls.PRDB_OFFSET + BeeProtectRegionBlock.SIZE])
        prdb = BeeProtectRegionBlock.parse(decr_data)
        result = cls(prdb, sw_key, kib)
        result.validate()
        return result

    def encrypt_block(self, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt block located in any FAC region.

        :param start_addr: start address of the data
        :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
        :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
        &#34;&#34;&#34;
        return self._prdb.encrypt_block(self._sw_key, start_addr, data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spsdk.image.bee.BeeBaseClass"><code class="flex name class">
<span>class <span class="ident">BeeBaseClass</span></span>
</code></dt>
<dd>
<div class="desc"><p>BEE base class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeBaseClass:
    &#34;&#34;&#34;BEE base class.&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    # the format is class specific, and must be defined in child class
    _FORMAT = &#34;@_must_be_defined_in_child_class_@&#34;

    @classmethod
    def _struct_format(cls) -&gt; str:
        &#34;&#34;&#34;:return: format string for struct.pack/unpack function used for export/import from binary format.&#34;&#34;&#34;
        return cls._FORMAT  # _FORMAT class constant must be defined in child class

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return calcsize(cls._struct_format())

    def __eq__(self, other: Any) -&gt; bool:
        return isinstance(other, self.__class__) and (vars(other) == vars(self))

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return self.__class__._size()

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: text description of the instance.&#34;&#34;&#34;
        raise NotImplementedError(&#39;abstract method&#39;)

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        pass

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates the configuration of the instance.

        :raise AssertionError: if configuration is invalid.
        It is recommended to call the method before export and after parsing
        &#34;&#34;&#34;

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return: binary representation of the region (serialization).&#34;&#34;&#34;
        self.update()
        self.validate()
        return b&#39;&#39;

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; Any:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data; this method returns just `0`
        :raise ValueError: if size of the data is not sufficient
        &#34;&#34;&#34;
        if len(data) - offset &lt; cls._size():
            raise ValueError(&#39;Insufficient size of the data&#39;)
        return 0</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeFacRegion" href="#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a></li>
<li><a title="spsdk.image.bee.BeeKIB" href="#spsdk.image.bee.BeeKIB">BeeKIB</a></li>
<li><a title="spsdk.image.bee.BeeProtectRegionBlock" href="#spsdk.image.bee.BeeProtectRegionBlock">BeeProtectRegionBlock</a></li>
<li><a title="spsdk.image.bee.BeeRegionHeader" href="#spsdk.image.bee.BeeRegionHeader">BeeRegionHeader</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeBaseClass.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data; this method returns just <code>0</code>
:raise ValueError: if size of the data is not sufficient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; Any:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data; this method returns just `0`
    :raise ValueError: if size of the data is not sufficient
    &#34;&#34;&#34;
    if len(data) - offset &lt; cls._size():
        raise ValueError(&#39;Insufficient size of the data&#39;)
    return 0</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeBaseClass.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: size of the exported binary data in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
    return self.__class__._size()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeBaseClass.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>:return: binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;:return: binary representation of the region (serialization).&#34;&#34;&#34;
    self.update()
    self.validate()
    return b&#39;&#39;</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeBaseClass.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: text description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: text description of the instance.&#34;&#34;&#34;
    raise NotImplementedError(&#39;abstract method&#39;)</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeBaseClass.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Updates internal fields of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeBaseClass.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the configuration of the instance.</p>
<p>:raise AssertionError: if configuration is invalid.
It is recommended to call the method before export and after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates the configuration of the instance.

    :raise AssertionError: if configuration is invalid.
    It is recommended to call the method before export and after parsing
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spsdk.image.bee.BeeFacRegion"><code class="flex name class">
<span>class <span class="ident">BeeFacRegion</span></span>
<span>(</span><span>start: int = 0, length: int = 0, protected_level: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE Factory Access Control (FAC) region.</p>
<p>Constructor.</p>
<p>:param start: Start address of one FAC region, align at 1KB boundary; 32-bit number
:param length: Length of one FAC region, align at 1KB boundary; 32-bit number
:param protected_level: Protected level: 0/1/2/3; 32-bit number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeFacRegion(BeeBaseClass):
    &#34;&#34;&#34;BEE Factory Access Control (FAC) region.&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#34;&lt;3I20s&#34;

    def __init__(self, start: int = 0, length: int = 0, protected_level: int = 0):
        &#34;&#34;&#34;Constructor.

        :param start: Start address of one FAC region, align at 1KB boundary; 32-bit number
        :param length: Length of one FAC region, align at 1KB boundary; 32-bit number
        :param protected_level: Protected level: 0/1/2/3; 32-bit number
        &#34;&#34;&#34;
        self.start_addr = start
        self.length = length
        self.protected_level = protected_level
        # immediately validate all parameters
        self.validate()

    def __str__(self) -&gt; str:
        return f&#39;FAC: 0x{self.start_addr:08x}[0x{self.length:x}]&#39;

    @property
    def end_addr(self) -&gt; int:
        &#34;&#34;&#34;:return: end address of the region (which is last address of the region + 1).&#34;&#34;&#34;
        return self.start_addr + self.length

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        return f&#39;FAC(start={hex(self.start_addr)}, length={hex(self.length)}, protected_level={self.protected_level})&#39;

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates the configuration of the instance.

        :raise AssertionError: if configuration is invalid.
        &#34;&#34;&#34;
        assert (self.start_addr &amp; _ENCR_BLOCK_ADDR_MASK == 0) and (self.length &amp; _ENCR_BLOCK_ADDR_MASK == 0)
        assert 0 &lt;= self.protected_level &lt;= 3
        assert 0 &lt;= self.start_addr &lt; self.end_addr &lt;= 0xFFFFFFFF

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        return result + pack(self._struct_format(), self.start_addr, self.end_addr, self.protected_level, b&#39;\x00&#39; * 20)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeFacRegion&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        :raise ValueError: if reserved area is non-zero
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the data
        (start, end, protected_level, _reserved) = unpack_from(BeeFacRegion._struct_format(), data, offset)
        if _reserved != b&#39;\x00&#39; * 20:
            raise ValueError(&#39;Reserved area is non-zero&#39;)
        return BeeFacRegion(start, end - start, protected_level)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeFacRegion.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.bee.BeeFacRegion" href="#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data
:raise ValueError: if reserved area is non-zero</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeFacRegion&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data
    :raise ValueError: if reserved area is non-zero
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the data
    (start, end, protected_level, _reserved) = unpack_from(BeeFacRegion._struct_format(), data, offset)
    if _reserved != b&#39;\x00&#39; * 20:
        raise ValueError(&#39;Reserved area is non-zero&#39;)
    return BeeFacRegion(start, end - start, protected_level)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeFacRegion.end_addr"><code class="name">var <span class="ident">end_addr</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: end address of the region (which is last address of the region + 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_addr(self) -&gt; int:
    &#34;&#34;&#34;:return: end address of the region (which is last address of the region + 1).&#34;&#34;&#34;
    return self.start_addr + self.length</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeFacRegion.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
    result = super().export()
    return result + pack(self._struct_format(), self.start_addr, self.end_addr, self.protected_level, b&#39;\x00&#39; * 20)</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeFacRegion.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    return f&#39;FAC(start={hex(self.start_addr)}, length={hex(self.length)}, protected_level={self.protected_level})&#39;</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeFacRegion.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the configuration of the instance.</p>
<p>:raise AssertionError: if configuration is invalid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates the configuration of the instance.

    :raise AssertionError: if configuration is invalid.
    &#34;&#34;&#34;
    assert (self.start_addr &amp; _ENCR_BLOCK_ADDR_MASK == 0) and (self.length &amp; _ENCR_BLOCK_ADDR_MASK == 0)
    assert 0 &lt;= self.protected_level &lt;= 3
    assert 0 &lt;= self.start_addr &lt; self.end_addr &lt;= 0xFFFFFFFF</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.bee.BeeKIB"><code class="flex name class">
<span>class <span class="ident">BeeKIB</span></span>
<span>(</span><span>kib_key: Union[bytes, NoneType] = None, kib_iv: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE Key block.</p>
<p>Contains keys used to encrypt PRDB content.</p>
<p>Constructor.</p>
<p>:param kib_key: AES key
:param kib_iv: AES initialization vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeKIB(BeeBaseClass):
    &#34;&#34;&#34;BEE Key block.

    Contains keys used to encrypt PRDB content.
    &#34;&#34;&#34;

    # key length in bytes
    _KEY_LEN = 16
    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#34;16s16s&#34;

    def __init__(self, kib_key: Optional[bytes] = None, kib_iv: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param kib_key: AES key
        :param kib_iv: AES initialization vector
        &#34;&#34;&#34;
        # Key Info Block (KIB)
        self.kib_key = kib_key if kib_key else crypto_backend().random_bytes(16)
        self.kib_iv = kib_iv if kib_iv else crypto_backend().random_bytes(16)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        return f&#34;BEE-KIB: {self.kib_key.hex()}, {self.kib_iv.hex()}&#34;

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        assert len(self.kib_key) == self._KEY_LEN
        assert len(self.kib_iv) == self._KEY_LEN

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        return result + pack(self._struct_format(), self.kib_key, self.kib_iv)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeKIB&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        (key, iv) = unpack_from(BeeKIB._struct_format(), data, offset)
        result = cls(key, iv)
        result.validate()
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeKIB.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.bee.BeeKIB" href="#spsdk.image.bee.BeeKIB">BeeKIB</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeKIB&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the input data
    (key, iv) = unpack_from(BeeKIB._struct_format(), data, offset)
    result = cls(key, iv)
    result.validate()
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeKIB.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; bytes:
    &#34;&#34;&#34;:return:binary representation of the region (serialization).&#34;&#34;&#34;
    result = super().export()
    return result + pack(self._struct_format(), self.kib_key, self.kib_iv)</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeKIB.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    return f&#34;BEE-KIB: {self.kib_key.hex()}, {self.kib_iv.hex()}&#34;</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeKIB.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    &#34;&#34;&#34;
    assert len(self.kib_key) == self._KEY_LEN
    assert len(self.kib_iv) == self._KEY_LEN</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock"><code class="flex name class">
<span>class <span class="ident">BeeProtectRegionBlock</span></span>
<span>(</span><span>encr_mode: <a title="spsdk.image.bee.BeeProtectRegionBlockAesMode" href="#spsdk.image.bee.BeeProtectRegionBlockAesMode">BeeProtectRegionBlockAesMode</a> = 1, lock_options: int = 0, counter: Union[bytes, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE protect region block (PRDB).</p>
<p>Constructor.</p>
<p>:param encr_mode: AES encryption mode
:param lock_options: Lock options; 32-bit number
:param counter: Counter for AES-CTR mode; 16 bytes; by default, random value is used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeProtectRegionBlock(BeeBaseClass):
    &#34;&#34;&#34;BEE protect region block (PRDB).&#34;&#34;&#34;

    # format of the binary representation of the class, used as parameter for struct.pack/unpack methods
    _FORMAT = &#39;&lt;8I16s32s&#39;
    # low TAG used in the header
    TAGL = 0x5F474154  # &#34;TAG_&#34;
    # high TAG used in the header
    TAGH = 0x52444845  # &#34;EHDR&#34;
    # version of the format
    VERSION = 0x56010000
    # number of FAC regions included in the header; the real limit of FAC regions depends on the processor
    FAC_REGIONS = 4
    # total size
    SIZE = 0x100

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return cls.SIZE

    def __init__(self, encr_mode: BeeProtectRegionBlockAesMode = BeeProtectRegionBlockAesMode.CTR,
                 lock_options: int = 0, counter: Optional[bytes] = None):
        &#34;&#34;&#34;Constructor.

        :param encr_mode: AES encryption mode
        :param lock_options: Lock options; 32-bit number
        :param counter: Counter for AES-CTR mode; 16 bytes; by default, random value is used
        &#34;&#34;&#34;
        # - Encrypt region info:
        self._start_addr = 0  # this is calculated automatically based on FAC regions
        self._end_addr = 0xFFFFFFFF  # this is calculated automatically based on FAC regions
        self.mode = encr_mode
        self.lock_options = lock_options
        self.counter = counter if counter else crypto_backend().random_bytes(12) + b&#39;\x00\x00\x00\x00&#39;

        # - FAC regions, 1 - 4
        self.fac_regions: List[BeeFacRegion] = list()

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates start and end address of the encryption region.&#34;&#34;&#34;
        super().update()
        # update FAC regions
        for fac in self.fac_regions:
            fac.update()
        # update start and end address
        min_addr = 0 if self.fac_count == 0 else 0xFFFFFFFF
        max_addr = 0
        for fac in self.fac_regions:
            min_addr = min(min_addr, fac.start_addr)
            max_addr = max(max_addr, fac.end_addr)
        self._start_addr = min_addr
        self._end_addr = max_addr

    def add_fac(self, fac: BeeFacRegion) -&gt; None:
        &#34;&#34;&#34;Append FAC region.

        :param fac: Factory Access Control to be added
        &#34;&#34;&#34;
        self.fac_regions.append(fac)
        self.update()

    @property
    def fac_count(self) -&gt; int:
        &#34;&#34;&#34;:return: number of Factory Access Control regions.&#34;&#34;&#34;
        return len(self.fac_regions)

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = f&#39;BEE Region Header (start={hex(self._start_addr)}, end={hex(self._end_addr)})\n&#39;
        result += f&#39;AES Encryption mode: {BeeProtectRegionBlockAesMode.name(self.mode)}\n&#39;
        for fac in self.fac_regions:
            result += fac.info() + &#39;\n&#39;
        return result

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        assert 0 &lt;= self._start_addr &lt;= 0xFFFFFFFF
        assert self._start_addr &lt;= self._end_addr &lt;= 0xFFFFFFFF
        assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;  # TODO
        assert len(self.counter) == 16
        assert self.counter[-4:] == b&#39;\x00\x00\x00\x00&#39;, &#39;last four bytes must be zero&#39;
        assert 0 &lt; self.fac_count &lt;= self.FAC_REGIONS
        for fac in self.fac_regions:
            fac.validate()

    def export(self) -&gt; bytes:
        &#34;&#34;&#34;:return: binary representation of the region (serialization).&#34;&#34;&#34;
        result = super().export()
        result += pack(self._struct_format(),
                       self.TAGL,
                       self.TAGH,
                       self.VERSION,
                       self.fac_count,
                       self._start_addr,
                       self._end_addr,
                       self.mode,
                       self.lock_options,
                       self.counter[::-1],  # bytes swapped: reversed order
                       b&#39;\x00&#39; * 32)
        for fac in self.fac_regions:
            result += fac.export()
        result = extend_block(result, self.SIZE)
        return result

    @classmethod
    def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeProtectRegionBlock&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :return: instance created from binary data
        :raise ValueError: if format does not match
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        (
            tagl,
            tagh,
            version,
            fac_count,
            start_addr,
            end_addr,
            mode,
            lock_options,
            counter,
            _reserved_32
        ) = unpack_from(BeeProtectRegionBlock._struct_format(), data, offset)
        #
        if (tagl != BeeProtectRegionBlock.TAGL) or (tagh != BeeProtectRegionBlock.TAGH):
            raise ValueError(&#39;Invalid tag or unsupported version&#39;)
        if version != BeeProtectRegionBlock.VERSION:
            raise ValueError(&#39;Unsupported version&#39;)
        if _reserved_32 != b&#39;\x00&#39; * 32:
            raise ValueError(&#39;Reserved area is non-zero&#39;)
        #
        result = BeeProtectRegionBlock(mode, lock_options, counter[::-1])
        result._start_addr = start_addr
        result._end_addr = end_addr
        offset += calcsize(BeeProtectRegionBlock._struct_format())
        for _ in range(fac_count):
            fac = BeeFacRegion.parse(data, offset)
            result.add_fac(fac)
            offset += fac.size
        result.validate()
        return result

    def encrypt_block(self, key: bytes, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt block located in any FAC region.

        :param key: user for encryption
        :param start_addr: start address of the data
        :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
        :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
        &#34;&#34;&#34;
        assert len(data) == BEE_ENCR_BLOCK_SIZE
        if self._start_addr &lt;= start_addr &lt; self._end_addr:
            assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;
            assert len(key) == 16
            for fac in self.fac_regions:
                if fac.start_addr &lt;= start_addr &lt; fac.end_addr:
                    assert start_addr + len(data) &lt;= fac.end_addr
                    cntr_key = Counter(self.counter, ctr_value=start_addr &gt;&gt; 4, ctr_byteorder_encoding=&#39;big&#39;)
                    return crypto_backend().aes_ctr_encrypt(key, data, cntr_key.value)
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.FAC_REGIONS"><code class="name">var <span class="ident">FAC_REGIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.TAGH"><code class="name">var <span class="ident">TAGH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.TAGL"><code class="name">var <span class="ident">TAGL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0) ‑> <a title="spsdk.image.bee.BeeProtectRegionBlock" href="#spsdk.image.bee.BeeProtectRegionBlock">BeeProtectRegionBlock</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:return: instance created from binary data
:raise ValueError: if format does not match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0) -&gt; &#39;BeeProtectRegionBlock&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :return: instance created from binary data
    :raise ValueError: if format does not match
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the input data
    (
        tagl,
        tagh,
        version,
        fac_count,
        start_addr,
        end_addr,
        mode,
        lock_options,
        counter,
        _reserved_32
    ) = unpack_from(BeeProtectRegionBlock._struct_format(), data, offset)
    #
    if (tagl != BeeProtectRegionBlock.TAGL) or (tagh != BeeProtectRegionBlock.TAGH):
        raise ValueError(&#39;Invalid tag or unsupported version&#39;)
    if version != BeeProtectRegionBlock.VERSION:
        raise ValueError(&#39;Unsupported version&#39;)
    if _reserved_32 != b&#39;\x00&#39; * 32:
        raise ValueError(&#39;Reserved area is non-zero&#39;)
    #
    result = BeeProtectRegionBlock(mode, lock_options, counter[::-1])
    result._start_addr = start_addr
    result._end_addr = end_addr
    offset += calcsize(BeeProtectRegionBlock._struct_format())
    for _ in range(fac_count):
        fac = BeeFacRegion.parse(data, offset)
        result.add_fac(fac)
        offset += fac.size
    result.validate()
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.fac_count"><code class="name">var <span class="ident">fac_count</span> : int</code></dt>
<dd>
<div class="desc"><p>:return: number of Factory Access Control regions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fac_count(self) -&gt; int:
    &#34;&#34;&#34;:return: number of Factory Access Control regions.&#34;&#34;&#34;
    return len(self.fac_regions)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.add_fac"><code class="name flex">
<span>def <span class="ident">add_fac</span></span>(<span>self, fac: <a title="spsdk.image.bee.BeeFacRegion" href="#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append FAC region.</p>
<p>:param fac: Factory Access Control to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fac(self, fac: BeeFacRegion) -&gt; None:
    &#34;&#34;&#34;Append FAC region.

    :param fac: Factory Access Control to be added
    &#34;&#34;&#34;
    self.fac_regions.append(fac)
    self.update()</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.encrypt_block"><code class="name flex">
<span>def <span class="ident">encrypt_block</span></span>(<span>self, key: bytes, start_addr: int, data: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt block located in any FAC region.</p>
<p>:param key: user for encryption
:param start_addr: start address of the data
:param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
:return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_block(self, key: bytes, start_addr: int, data: bytes) -&gt; bytes:
    &#34;&#34;&#34;Encrypt block located in any FAC region.

    :param key: user for encryption
    :param start_addr: start address of the data
    :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
    :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
    &#34;&#34;&#34;
    assert len(data) == BEE_ENCR_BLOCK_SIZE
    if self._start_addr &lt;= start_addr &lt; self._end_addr:
        assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;
        assert len(key) == 16
        for fac in self.fac_regions:
            if fac.start_addr &lt;= start_addr &lt; fac.end_addr:
                assert start_addr + len(data) &lt;= fac.end_addr
                cntr_key = Counter(self.counter, ctr_value=start_addr &gt;&gt; 4, ctr_byteorder_encoding=&#39;big&#39;)
                return crypto_backend().aes_ctr_encrypt(key, data, cntr_key.value)
    return data</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    result = f&#39;BEE Region Header (start={hex(self._start_addr)}, end={hex(self._end_addr)})\n&#39;
    result += f&#39;AES Encryption mode: {BeeProtectRegionBlockAesMode.name(self.mode)}\n&#39;
    for fac in self.fac_regions:
        result += fac.info() + &#39;\n&#39;
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Updates start and end address of the encryption region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; None:
    &#34;&#34;&#34;Updates start and end address of the encryption region.&#34;&#34;&#34;
    super().update()
    # update FAC regions
    for fac in self.fac_regions:
        fac.update()
    # update start and end address
    min_addr = 0 if self.fac_count == 0 else 0xFFFFFFFF
    max_addr = 0
    for fac in self.fac_regions:
        min_addr = min(min_addr, fac.start_addr)
        max_addr = max(max_addr, fac.end_addr)
    self._start_addr = min_addr
    self._end_addr = max_addr</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlock.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    &#34;&#34;&#34;
    assert 0 &lt;= self._start_addr &lt;= 0xFFFFFFFF
    assert self._start_addr &lt;= self._end_addr &lt;= 0xFFFFFFFF
    assert self.mode == BeeProtectRegionBlockAesMode.CTR, &#39;only AES/CTR encryption mode supported now&#39;  # TODO
    assert len(self.counter) == 16
    assert self.counter[-4:] == b&#39;\x00\x00\x00\x00&#39;, &#39;last four bytes must be zero&#39;
    assert 0 &lt; self.fac_count &lt;= self.FAC_REGIONS
    for fac in self.fac_regions:
        fac.validate()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.export" href="#spsdk.image.bee.BeeBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlockAesMode"><code class="flex name class">
<span>class <span class="ident">BeeProtectRegionBlockAesMode</span></span>
</code></dt>
<dd>
<div class="desc"><p>AES mode selection for BEE PRDB encryption.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeProtectRegionBlockAesMode(Enum):
    &#34;&#34;&#34;AES mode selection for BEE PRDB encryption.&#34;&#34;&#34;
    ECB = 0
    CTR = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeProtectRegionBlockAesMode.CTR"><code class="name">var <span class="ident">CTR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.bee.BeeProtectRegionBlockAesMode.ECB"><code class="name">var <span class="ident">ECB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.utils.easy_enum.Enum" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.utils.easy_enum.Enum.desc" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.desc">desc</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.from_int" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.from_int">from_int</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.get" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.get">get</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.name" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.name">name</a></code></li>
<li><code><a title="spsdk.utils.easy_enum.Enum.tags" href="../utils/easy_enum.html#spsdk.utils.easy_enum.Enum.tags">tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader"><code class="flex name class">
<span>class <span class="ident">BeeRegionHeader</span></span>
<span>(</span><span>prdb: Union[<a title="spsdk.image.bee.BeeProtectRegionBlock" href="#spsdk.image.bee.BeeProtectRegionBlock">BeeProtectRegionBlock</a>, NoneType] = None, sw_key: Union[bytes, NoneType] = None, kib: Union[<a title="spsdk.image.bee.BeeKIB" href="#spsdk.image.bee.BeeKIB">BeeKIB</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BEE keys and regions header.</p>
<p>Constructor.</p>
<p>:param prdb: protect region block; None to use default
:param sw_key: key used to encrypt KIB content
:param kib: keys block; None to use default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BeeRegionHeader(BeeBaseClass):
    &#34;&#34;&#34;BEE keys and regions header.&#34;&#34;&#34;

    # offset of the Protected Region Block in the header
    PRDB_OFFSET = 0x80
    # total size including padding
    SIZE = 0x400

    @classmethod
    def _struct_format(cls) -&gt; str:
        &#34;&#34;&#34;:raise AssertionError: it is not expected to called for the class.&#34;&#34;&#34;
        raise AssertionError(&#39;This method is not expected to be used for this class, format depends on its fields&#39;)

    @classmethod
    def _size(cls) -&gt; int:
        &#34;&#34;&#34;:return: size of the exported binary data in bytes.&#34;&#34;&#34;
        return cls.SIZE

    def __init__(self, prdb: Optional[BeeProtectRegionBlock] = None, sw_key: Optional[bytes] = None,
                 kib: Optional[BeeKIB] = None):
        &#34;&#34;&#34;Constructor.

        :param prdb: protect region block; None to use default
        :param sw_key: key used to encrypt KIB content
        :param kib: keys block; None to use default
        &#34;&#34;&#34;
        self._prdb = prdb if (prdb is not None) else BeeProtectRegionBlock()
        self._sw_key = sw_key if (sw_key is not None) else crypto_backend().random_bytes(16)
        self._kib = kib if (kib is not None) else BeeKIB()

    def add_fac(self, fac: BeeFacRegion) -&gt; None:
        &#34;&#34;&#34;Append FAC region.

        :param fac: to be added
        &#34;&#34;&#34;
        self._prdb.add_fac(fac)

    @property
    def fac_regions(self) -&gt; Sequence[BeeFacRegion]:
        &#34;&#34;&#34;:return: lift of Factory Access Control regions.&#34;&#34;&#34;
        return self._prdb.fac_regions

    def info(self) -&gt; str:
        &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
        result = &#39;BEE Region Header\n&#39;
        result += f&#39;- KIB: {self._kib.info()}&#39;
        result += f&#39;- PRDB: {self._prdb.info()}&#39;
        return result

    def sw_key_fuses(self) -&gt; Sequence[int]:
        &#34;&#34;&#34;:return: sequence of fuse values for SW key to be burned into processor.

        The result is ordered, first value should be burned to the lowest address.
        &#34;&#34;&#34;
        result = list()
        for pos in range(16, 0, -4):
            result.append(unpack_from(&#34;&gt;I&#34;, self._sw_key[pos - 4:pos])[0])
        return result

    def update(self) -&gt; None:
        &#34;&#34;&#34;Updates internal fields of the instance.&#34;&#34;&#34;
        super().update()
        self._kib.update()
        self._prdb.update()

    def validate(self) -&gt; None:
        &#34;&#34;&#34;Validates settings of the instance.

        :raises AssertionError: if settings invalid
        &#34;&#34;&#34;
        self._kib.validate()
        self._prdb.validate()
        assert len(self._sw_key) == 16

    def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
        &#34;&#34;&#34;Serialization to binary representation.

        :param dbg_info: instance allowing to provide debug info about exported data
        :return:binary representation of the region (serialization).
        &#34;&#34;&#34;
        result = super().export()
        # KIB
        kib_data = self._kib.export()
        dbg_info.append_binary_section(&#39;BEE-KIB (non-crypted)&#39;, kib_data)
        aes = AES.new(self._sw_key, AES.MODE_ECB)
        result += aes.encrypt(kib_data)
        # padding
        result = extend_block(result, self.PRDB_OFFSET)
        # PRDB
        prdb_data = self._prdb.export()
        dbg_info.append_binary_section(&#39;BEE-PRDB (non-crypted)&#39;, prdb_data)
        aes = AES.new(self._kib.kib_key, AES.MODE_CBC, self._kib.kib_iv)
        result += aes.encrypt(prdb_data)
        # padding
        return extend_block(result, self.SIZE)

    @classmethod
    def parse(cls, data: bytes, offset: int = 0, sw_key: bytes = b&#39;&#39;) -&gt; &#39;BeeRegionHeader&#39;:
        &#34;&#34;&#34;Deserialization.

        :param data: binary data to be parsed
        :param offset: to start parsing the data
        :param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
        :return: instance created from binary data
        &#34;&#34;&#34;
        super().parse(data, offset)  # check size of the input data
        assert len(sw_key) == 16
        aes = AES.new(sw_key, AES.MODE_ECB)
        decr_data = aes.decrypt(data[offset:offset + BeeKIB._size()])
        kib = BeeKIB.parse(decr_data)
        aes = AES.new(kib.kib_key, AES.MODE_CBC, kib.kib_iv)
        decr_data = aes.decrypt(data[offset + cls.PRDB_OFFSET:offset + cls.PRDB_OFFSET + BeeProtectRegionBlock.SIZE])
        prdb = BeeProtectRegionBlock.parse(decr_data)
        result = cls(prdb, sw_key, kib)
        result.validate()
        return result

    def encrypt_block(self, start_addr: int, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypt block located in any FAC region.

        :param start_addr: start address of the data
        :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
        :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
        &#34;&#34;&#34;
        return self._prdb.encrypt_block(self._sw_key, start_addr, data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeRegionHeader.PRDB_OFFSET"><code class="name">var <span class="ident">PRDB_OFFSET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader.SIZE"><code class="name">var <span class="ident">SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeRegionHeader.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>data: bytes, offset: int = 0, sw_key: bytes = b'') ‑> <a title="spsdk.image.bee.BeeRegionHeader" href="#spsdk.image.bee.BeeRegionHeader">BeeRegionHeader</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization.</p>
<p>:param data: binary data to be parsed
:param offset: to start parsing the data
:param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
:return: instance created from binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, data: bytes, offset: int = 0, sw_key: bytes = b&#39;&#39;) -&gt; &#39;BeeRegionHeader&#39;:
    &#34;&#34;&#34;Deserialization.

    :param data: binary data to be parsed
    :param offset: to start parsing the data
    :param sw_key: SW key used to decrypt the EKIB data (the key is marked as SW_GP2 on RT10xx)
    :return: instance created from binary data
    &#34;&#34;&#34;
    super().parse(data, offset)  # check size of the input data
    assert len(sw_key) == 16
    aes = AES.new(sw_key, AES.MODE_ECB)
    decr_data = aes.decrypt(data[offset:offset + BeeKIB._size()])
    kib = BeeKIB.parse(decr_data)
    aes = AES.new(kib.kib_key, AES.MODE_CBC, kib.kib_iv)
    decr_data = aes.decrypt(data[offset + cls.PRDB_OFFSET:offset + cls.PRDB_OFFSET + BeeProtectRegionBlock.SIZE])
    prdb = BeeProtectRegionBlock.parse(decr_data)
    result = cls(prdb, sw_key, kib)
    result.validate()
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spsdk.image.bee.BeeRegionHeader.fac_regions"><code class="name">var <span class="ident">fac_regions</span> : Sequence[<a title="spsdk.image.bee.BeeFacRegion" href="#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a>]</code></dt>
<dd>
<div class="desc"><p>:return: lift of Factory Access Control regions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fac_regions(self) -&gt; Sequence[BeeFacRegion]:
    &#34;&#34;&#34;:return: lift of Factory Access Control regions.&#34;&#34;&#34;
    return self._prdb.fac_regions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spsdk.image.bee.BeeRegionHeader.add_fac"><code class="name flex">
<span>def <span class="ident">add_fac</span></span>(<span>self, fac: <a title="spsdk.image.bee.BeeFacRegion" href="#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append FAC region.</p>
<p>:param fac: to be added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fac(self, fac: BeeFacRegion) -&gt; None:
    &#34;&#34;&#34;Append FAC region.

    :param fac: to be added
    &#34;&#34;&#34;
    self._prdb.add_fac(fac)</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader.encrypt_block"><code class="name flex">
<span>def <span class="ident">encrypt_block</span></span>(<span>self, start_addr: int, data: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt block located in any FAC region.</p>
<p>:param start_addr: start address of the data
:param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
:return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_block(self, start_addr: int, data: bytes) -&gt; bytes:
    &#34;&#34;&#34;Encrypt block located in any FAC region.

    :param start_addr: start address of the data
    :param data: binary block to be encrypted; the block size must be BEE_ENCR_BLOCK_SIZE
    :return: encrypted block if it is inside any FAC region; untouched block if it is not in any FAC region
    &#34;&#34;&#34;
    return self._prdb.encrypt_block(self._sw_key, start_addr, data)</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, dbg_info: <a title="spsdk.utils.misc.DebugInfo" href="../utils/misc.html#spsdk.utils.misc.DebugInfo">DebugInfo</a> = &lt;spsdk.utils.misc.DebugInfo object&gt;) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialization to binary representation.</p>
<p>:param dbg_info: instance allowing to provide debug info about exported data
:return:binary representation of the region (serialization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, dbg_info: DebugInfo = DebugInfo.disabled()) -&gt; bytes:
    &#34;&#34;&#34;Serialization to binary representation.

    :param dbg_info: instance allowing to provide debug info about exported data
    :return:binary representation of the region (serialization).
    &#34;&#34;&#34;
    result = super().export()
    # KIB
    kib_data = self._kib.export()
    dbg_info.append_binary_section(&#39;BEE-KIB (non-crypted)&#39;, kib_data)
    aes = AES.new(self._sw_key, AES.MODE_ECB)
    result += aes.encrypt(kib_data)
    # padding
    result = extend_block(result, self.PRDB_OFFSET)
    # PRDB
    prdb_data = self._prdb.export()
    dbg_info.append_binary_section(&#39;BEE-PRDB (non-crypted)&#39;, prdb_data)
    aes = AES.new(self._kib.kib_key, AES.MODE_CBC, self._kib.kib_iv)
    result += aes.encrypt(prdb_data)
    # padding
    return extend_block(result, self.SIZE)</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: test description of the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;:return: test description of the instance.&#34;&#34;&#34;
    result = &#39;BEE Region Header\n&#39;
    result += f&#39;- KIB: {self._kib.info()}&#39;
    result += f&#39;- PRDB: {self._prdb.info()}&#39;
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader.sw_key_fuses"><code class="name flex">
<span>def <span class="ident">sw_key_fuses</span></span>(<span>self) ‑> Sequence[int]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sequence of fuse values for SW key to be burned into processor.</p>
<p>The result is ordered, first value should be burned to the lowest address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sw_key_fuses(self) -&gt; Sequence[int]:
    &#34;&#34;&#34;:return: sequence of fuse values for SW key to be burned into processor.

    The result is ordered, first value should be burned to the lowest address.
    &#34;&#34;&#34;
    result = list()
    for pos in range(16, 0, -4):
        result.append(unpack_from(&#34;&gt;I&#34;, self._sw_key[pos - 4:pos])[0])
    return result</code></pre>
</details>
</dd>
<dt id="spsdk.image.bee.BeeRegionHeader.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates settings of the instance.</p>
<p>:raises AssertionError: if settings invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; None:
    &#34;&#34;&#34;Validates settings of the instance.

    :raises AssertionError: if settings invalid
    &#34;&#34;&#34;
    self._kib.validate()
    self._prdb.validate()
    assert len(self._sw_key) == 16</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></b></code>:
<ul class="hlist">
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spsdk.image" href="index.html">spsdk.image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spsdk.image.bee.BeeBaseClass" href="#spsdk.image.bee.BeeBaseClass">BeeBaseClass</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.bee.BeeBaseClass.export" href="#spsdk.image.bee.BeeBaseClass.export">export</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.info" href="#spsdk.image.bee.BeeBaseClass.info">info</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.parse" href="#spsdk.image.bee.BeeBaseClass.parse">parse</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.size" href="#spsdk.image.bee.BeeBaseClass.size">size</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.update" href="#spsdk.image.bee.BeeBaseClass.update">update</a></code></li>
<li><code><a title="spsdk.image.bee.BeeBaseClass.validate" href="#spsdk.image.bee.BeeBaseClass.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.bee.BeeFacRegion" href="#spsdk.image.bee.BeeFacRegion">BeeFacRegion</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.bee.BeeFacRegion.end_addr" href="#spsdk.image.bee.BeeFacRegion.end_addr">end_addr</a></code></li>
<li><code><a title="spsdk.image.bee.BeeFacRegion.export" href="#spsdk.image.bee.BeeFacRegion.export">export</a></code></li>
<li><code><a title="spsdk.image.bee.BeeFacRegion.info" href="#spsdk.image.bee.BeeFacRegion.info">info</a></code></li>
<li><code><a title="spsdk.image.bee.BeeFacRegion.parse" href="#spsdk.image.bee.BeeFacRegion.parse">parse</a></code></li>
<li><code><a title="spsdk.image.bee.BeeFacRegion.validate" href="#spsdk.image.bee.BeeFacRegion.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.bee.BeeKIB" href="#spsdk.image.bee.BeeKIB">BeeKIB</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.bee.BeeKIB.export" href="#spsdk.image.bee.BeeKIB.export">export</a></code></li>
<li><code><a title="spsdk.image.bee.BeeKIB.info" href="#spsdk.image.bee.BeeKIB.info">info</a></code></li>
<li><code><a title="spsdk.image.bee.BeeKIB.parse" href="#spsdk.image.bee.BeeKIB.parse">parse</a></code></li>
<li><code><a title="spsdk.image.bee.BeeKIB.validate" href="#spsdk.image.bee.BeeKIB.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.bee.BeeProtectRegionBlock" href="#spsdk.image.bee.BeeProtectRegionBlock">BeeProtectRegionBlock</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.FAC_REGIONS" href="#spsdk.image.bee.BeeProtectRegionBlock.FAC_REGIONS">FAC_REGIONS</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.SIZE" href="#spsdk.image.bee.BeeProtectRegionBlock.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.TAGH" href="#spsdk.image.bee.BeeProtectRegionBlock.TAGH">TAGH</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.TAGL" href="#spsdk.image.bee.BeeProtectRegionBlock.TAGL">TAGL</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.VERSION" href="#spsdk.image.bee.BeeProtectRegionBlock.VERSION">VERSION</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.add_fac" href="#spsdk.image.bee.BeeProtectRegionBlock.add_fac">add_fac</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.encrypt_block" href="#spsdk.image.bee.BeeProtectRegionBlock.encrypt_block">encrypt_block</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.fac_count" href="#spsdk.image.bee.BeeProtectRegionBlock.fac_count">fac_count</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.info" href="#spsdk.image.bee.BeeProtectRegionBlock.info">info</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.parse" href="#spsdk.image.bee.BeeProtectRegionBlock.parse">parse</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.update" href="#spsdk.image.bee.BeeProtectRegionBlock.update">update</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlock.validate" href="#spsdk.image.bee.BeeProtectRegionBlock.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.bee.BeeProtectRegionBlockAesMode" href="#spsdk.image.bee.BeeProtectRegionBlockAesMode">BeeProtectRegionBlockAesMode</a></code></h4>
<ul class="">
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlockAesMode.CTR" href="#spsdk.image.bee.BeeProtectRegionBlockAesMode.CTR">CTR</a></code></li>
<li><code><a title="spsdk.image.bee.BeeProtectRegionBlockAesMode.ECB" href="#spsdk.image.bee.BeeProtectRegionBlockAesMode.ECB">ECB</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spsdk.image.bee.BeeRegionHeader" href="#spsdk.image.bee.BeeRegionHeader">BeeRegionHeader</a></code></h4>
<ul class="two-column">
<li><code><a title="spsdk.image.bee.BeeRegionHeader.PRDB_OFFSET" href="#spsdk.image.bee.BeeRegionHeader.PRDB_OFFSET">PRDB_OFFSET</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.SIZE" href="#spsdk.image.bee.BeeRegionHeader.SIZE">SIZE</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.add_fac" href="#spsdk.image.bee.BeeRegionHeader.add_fac">add_fac</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.encrypt_block" href="#spsdk.image.bee.BeeRegionHeader.encrypt_block">encrypt_block</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.export" href="#spsdk.image.bee.BeeRegionHeader.export">export</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.fac_regions" href="#spsdk.image.bee.BeeRegionHeader.fac_regions">fac_regions</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.info" href="#spsdk.image.bee.BeeRegionHeader.info">info</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.parse" href="#spsdk.image.bee.BeeRegionHeader.parse">parse</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.sw_key_fuses" href="#spsdk.image.bee.BeeRegionHeader.sw_key_fuses">sw_key_fuses</a></code></li>
<li><code><a title="spsdk.image.bee.BeeRegionHeader.validate" href="#spsdk.image.bee.BeeRegionHeader.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>